<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SubPandaQA - Advanced Subtitle Quality Control</title>
    <!-- Google Fonts: Montserrat & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- jsPDF CDN for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root {
            --brand-color: #075BA2;
            --brand-color-light: #0a7ee5;
            --brand-color-dark: #05437a;
            --background-color: #f0f4f8;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --card-background: #ffffff;
            --success-color: #10b981;
            --error-color: #ef4444;
            --neutral-color: #373737;
            --neutral-color-dark: #2a2a2a;
        }
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--background-color);
            color: var(--text-primary);
        }
        .wow-header {
            background-color: var(--card-background);
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            border: 1px solid #e2e8f0;
        }
        .section-card {
            background-color: var(--card-background);
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            border: 1px solid #e2e8f0;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .section-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.15);
        }
        .section-title {
            display: flex;
            align-items: center;
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--brand-color);
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }
        .btn-primary {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background-color: var(--brand-color);
            color: white;
            font-weight: 600;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease;
        }
        .btn-primary:hover {
            background-color: var(--brand-color-dark);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            transform: translateY(-2px);
        }
        .lang-btn {
            background-color: #f3f4f6;
            color: var(--text-secondary);
            font-weight: 700;
            border-radius: 9999px;
            padding: 0.5rem 1rem;
            transition: all 0.3s ease;
        }
        .lang-btn.active, .lang-btn:hover {
            background-color: var(--brand-color);
            color: white;
        }
        .error-item {
            background-color: #fff1f2;
            border-left: 5px solid var(--error-color);
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.05);
            margin-bottom: 1rem;
            padding: 1rem;
        }
        .success-message {
            background-color: #f0fdf4;
            color: #166534;
            border: 2px solid #bbf7d0;
            border-radius: 0.75rem;
            padding: 1.5rem;
            text-align: center;
            font-weight: 600;
            font-size: 1.125rem;
        }
        #results-container {
            min-height: 400px;
        }
        #results {
            max-height: 500px;
            overflow-y: auto;
        }
    </style>
</head>
<body class="p-4 sm:p-6 lg:p-8">

    <div class="container mx-auto max-w-4xl">

        <!-- Main Content Layout -->
        <div class="flex flex-col gap-8">

            <!-- Header with white background -->
            <header class="wow-header p-8 relative">
                <div class="absolute top-4 right-4 flex space-x-2">
                    <button id="lang-en" class="lang-btn active">EN</button>
                    <button id="lang-es" class="lang-btn">ES</button>
                </div>
                <div class="flex flex-col items-center justify-center text-center">
                    <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/subpandaqa-logo.png" alt="SubPandaQA Logo" class="w-72 mb-4">
                    <p id="app-description" data-lang="app_description" class="text-xl font-light max-w-2xl text-gray-600">A powerful tool to detect errors in SRT subtitle files with style.</p>
                </div>
            </header>

            <!-- File Upload Section -->
            <section class="section-card">
                <h2 class="section-title"><span class="material-icons">upload_file</span><span data-lang="upload_title">1. Upload subtitle file (.srt)</span></h2>
                <input type="file" id="subtitleFile" accept=".srt" class="w-full text-gray-700 bg-gray-50 border-2 border-dashed border-gray-300 rounded-lg p-4 cursor-pointer hover:bg-gray-100 hover:border-brand-color transition-colors">
                <p id="fileName" class="mt-3 text-sm text-gray-500"></p>
            </section>

            <!-- Filter Configuration Section -->
            <section class="section-card">
                <h2 class="section-title"><span class="material-icons">filter_alt</span><span data-lang="filters_title">2. Configure filters</span></h2>
                <div class="flex items-center space-x-4 mb-6">
                    <button id="toggleAllFiltersButton" class="px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 transition-all duration-200" data-lang="toggle_filters">
                        Toggle All
                    </button>
                </div>
                <div id="filters-container" class="flex flex-col space-y-4 max-h-96 overflow-y-auto pr-2">
                    <!-- Filters will be populated by JS to support i18n -->
                </div>
            </section>
            
            <!-- Check Button -->
            <button id="checkButton" class="btn-primary w-full py-4 text-xl">
                <span class="material-icons">spellcheck</span>
                <span data-lang="check_button">CHECK SUBTITLES</span>
            </button>

            <!-- Results Section -->
            <section id="results-container" class="section-card flex-grow flex flex-col">
                <h2 class="section-title"><span class="material-icons">error</span><span data-lang="results_title">3. Review results</span></h2>
                <div id="results" class="bg-gray-50 p-4 rounded-lg border border-gray-200 text-sm flex-grow">
                    <p class="text-gray-500" data-lang="results_placeholder">Upload a subtitle file and press "CHECK SUBTITLES" to see the errors here.</p>
                </div>
                <div id="noErrorsMessage" class="hidden mt-4 success-message flex-grow flex items-center justify-center">
                    <span data-lang="no_errors">Congratulations! No errors were found with the selected filters.</span>
                </div>
            </section>

            <!-- Export Section -->
            <section class="section-card">
                 <h2 class="section-title"><span class="material-icons">save</span><span data-lang="export_title">Export error report</span></h2>
                <div class="flex flex-col sm:flex-row gap-4">
                    <button id="exportPdfButton" class="btn-primary flex-1 bg-[#373737] hover:bg-[#2a2a2a]">
                        <span class="material-icons">picture_as_pdf</span>
                        <span data-lang="export_pdf">Export to PDF</span>
                    </button>
                    <button id="exportTableButton" class="btn-primary flex-1 bg-[#373737] hover:bg-[#2a2a2a]">
                        <span class="material-icons">table_view</span>
                        <span data-lang="export_table">Export as HTML Table</span>
                    </button>
                </div>
            </section>
        </div>
    </div>

    <script>
        // --- LANGUAGE & TRANSLATION SETUP ---
        const translations = {
            en: {
                app_description: "A powerful tool to detect errors in SRT subtitle files with style.",
                upload_title: "1. Upload subtitle file (.srt)",
                filters_title: "2. Configure filters",
                toggle_filters: "Toggle all",
                check_button: "Check subtitles",
                results_title: "3. Review results",
                results_placeholder: 'Upload a subtitle file and press "Check subtitles" to see the errors here.',
                no_errors: "Congratulations! No errors were found with the selected filters.",
                export_title: "Export error report",
                export_pdf: "Export to PDF",
                export_table: "Export as HTML Table",
                selected_file: "Selected file: {fileName}",
                file_loaded: 'File loaded. Press "Check subtitles".',
                no_valid_subs: "Could not parse valid subtitles from the file.",
                file_process_error: "Error processing file: {errorMessage}. Make sure it is a valid SRT file.",
                upload_first: "Please upload a subtitle file first.",
                filter_cps: "Reading speed (CPS)",
                filter_wpm: "Reading speed (WPM)",
                filter_char_limit: "Character limit per line",
                filter_line_limit: "Line limit",
                filter_dash_space: "Space after dash",
                filter_duration: "Min/max duration",
                filter_min_gap: "Minimum gap between subtitles",
                filter_unclosed_tags: "Tag issues",
                filter_double_spaces: "Double/triple spaces",
                filter_question_marks: "Opening/closing question/exclamation marks",
                filter_lowercase_after_period: "Lowercase after period",
                filter_empty_subtitle: "Empty subtitle",
                filter_overlap: "Overlapping subtitles",
                filter_no_space_after_period: "No space after period",
                filter_unclosed_quotes: "Unclosed quotes",
                filter_ellipsis: "Ellipsis linking errors",
                filter_number_punctuation: "Number punctuation",
                filter_units_format: "Measurement unit format",
                filter_acronyms_format: "Acronym format",
                filter_ellipsis_char: "Incorrect ellipsis character",
                filter_dual_speaker_hyphen: "Dual speaker hyphen inconsistencies",
                filter_numbers_1_to_10: "Cardinal numbers as digits (1-10)",
                filter_four_digit_separator: "Thousand separator in 4-digit numbers",
                filter_semicolons: "Use of semicolons",
                filter_quote_period: "Quote punctuation",
                filter_ids_sfx_format: "SFX/description detection (brackets)",
                desc_cps: "Detects subtitles exceeding the configured CPS.",
                desc_wpm: "Detects subtitles exceeding the configured WPM.",
                desc_char_limit: "Detects lines exceeding the configured number of characters.",
                desc_line_limit: "Identifies subtitles with more than 2 lines.",
                desc_dash_space: 'Detects "-Hello" instead of "- Hello".',
                desc_duration: "Flags subtitles shorter than 1s or longer than 7s.",
                desc_min_gap: "Detects gaps smaller than 100ms or 4 frames between subtitles.",
                desc_unclosed_tags: "Identifies unclosed, unopened, or malformed tags.",
                desc_double_spaces: "Flags the presence of two or more consecutive spaces.",
                desc_question_marks: "Detects missing opening or closing marks for questions and exclamations.",
                desc_lowercase_after_period: 'Identifies "Text. next" instead of "Text. Next".',
                desc_empty_subtitle: "Detects subtitles that have been mistakenly left empty.",
                desc_overlap: "Detects subtitles that overlap with subsequent subtitles.",
                desc_no_space_after_period: "Detects a period followed immediately by a word or letter, without an intervening space.",
                desc_unclosed_quotes: "Identifies 'Unclosed single quote text' or \"Unclosed double quote text\".",
                desc_ellipsis: 'Flags subtitles ending with "..." suggesting a continuation.',
                desc_number_punctuation: 'Detects English-style punctuation "1,234.56" instead of "1.234,56".',
                desc_units_format: 'Detects measurement units (e.g., "km.", "cms") ending in a period or in plural form.',
                desc_acronyms_format: 'Detects acronyms (e.g., "F.B.I", "U N") that include periods or spaces.',
                desc_ellipsis_char: 'Detects the use of three consecutive dots (...) instead of the single ellipsis character (…).',
                desc_dual_speaker_hyphen: "Detects inconsistencies in the use of hyphens in dual speaker subtitles (e.g., one line with a hyphen and the other without).",
                desc_numbers_1_to_10: 'Detects if numbers from 1 to 10 are written in digits instead of letters (e.g., "5 dogs" instead of "five dogs").',
                desc_four_digit_separator: 'Detects if four-digit numbers have separators (e.g., "2,000" instead of "2000").',
                desc_semicolons: "Detects the presence of a semicolon (;).",
                desc_quote_period: 'Detects if the final period of a quoted sentence is inside the closing quotes (e.g., "Text." instead of "Text".).',
                desc_ids_sfx_format: "Detects the presence of text enclosed in square brackets (e.g., [Music], [Applause]).",
                errors: {
                    high_cps: "High reading speed: {cps} CPS (Max: {max})",
                    high_wpm: "High reading speed: {wpm} WPM (Max: {max})",
                    line_char_limit: "Line {lineIndex} exceeds character limit ({length} > {max})",
                    line_limit: "Exceeds line limit ({count} > {max})",
                    no_space_after_dash: "No space after a dash.",
                    duration_too_short: "Duration too short ({duration}ms < {min}ms)",
                    duration_too_long: "Duration too long ({duration}ms > {max}ms)",
                    gap_too_small: "Gap between subtitles is too small ({gap}ms)",
                    unclosed_tag: "Unclosed <{tag}> tag.",
                    unopened_tag: "Unopened </{tag}> tag.",
                    double_spaces: "Contains double or triple spaces.",
                    missing_closing_question: "Line {lineIndex}: Missing closing question mark (?).",
                    missing_opening_question: "Line {lineIndex}: Missing opening question mark (¿).",
                    missing_closing_exclamation: "Line {lineIndex}: Missing closing exclamation mark (!).",
                    missing_opening_exclamation: "Line {lineIndex}: Missing opening exclamation mark (¡).",
                    lowercase_after_period: "Starts with lowercase after a period.",
                    empty_subtitle: "Empty subtitle.",
                    overlap: "Overlaps with the next subtitle.",
                    no_space_after_period: "A period is followed by a letter without a space.",
                    unclosed_single_quote: "Unclosed single quote (').",
                    unclosed_double_quote: "Unclosed double quote (\").",
                    ellipsis_linking: "Contains ellipsis (...) at the end of a line (possible link).",
                    english_number_punctuation: "Uses English-style number punctuation (comma for thousands).",
                    incorrect_unit_format: "Incorrect unit format (period or plural).",
                    incorrect_acronym_format: "Incorrect acronym format (periods or spaces).",
                    incorrect_ellipsis_char: "Uses three dots (...) instead of the single ellipsis character (…).",
                    inconsistent_dialogue_hyphen: "Inconsistent use of hyphens in dual-speaker dialogue.",
                    number_as_digit: "Number from 1-10 is written as a digit instead of a word.",
                    four_digit_separator: "Four-digit number has a thousand separator.",
                    semicolon_present: "Contains a semicolon (;).",
                    quote_punctuation: "Final period is inside the closing quotes.",
                    sfx_brackets: "Contains SFX/description in brackets."
                }
            },
            es: {
                app_description: "Una potente herramienta para detectar errores en archivos de subtítulos SRT con estilo.",
                upload_title: "1. Subir archivo de subtítulos (.srt)",
                filters_title: "2. Configurar filtros",
                toggle_filters: "Marcar/Desmarcar todas",
                check_button: "REVISAR SUBTÍTULOS",
                results_title: "3. Resultados de la revisión",
                results_placeholder: 'Sube un archivo de subtítulos y presiona "REVISAR SUBTÍTULOS" para ver los errores aquí.',
                no_errors: "¡Felicidades! No se encontraron errores con los filtros seleccionados.",
                export_title: "Exportar informe de errores",
                export_pdf: "Exportar a PDF",
                export_table: "Exportar como Tabla HTML",
                selected_file: "Archivo seleccionado: {fileName}",
                file_loaded: 'Archivo cargado. Presiona "REVISAR SUBTÍTULOS".',
                no_valid_subs: "No se pudieron analizar subtítulos válidos del archivo.",
                file_process_error: "Error al procesar el archivo: {errorMessage}. Asegúrate de que es un archivo SRT válido.",
                upload_first: "Por favor, primero sube un archivo de subtítulos.",
                filter_cps: "Velocidad de lectura (CPS)",
                filter_wpm: "Velocidad de lectura (WPM)",
                filter_char_limit: "Límite de caracteres por línea",
                filter_line_limit: "Límite de líneas",
                filter_dash_space: "Espacio después de un guion",
                filter_duration: "Duración mínima/máxima",
                filter_min_gap: "Espacio mínimo entre subtítulos",
                filter_unclosed_tags: "Problemas con etiquetas",
                filter_double_spaces: "Espacios dobles o triples",
                filter_question_marks: "Signos de interrogación/admiración de apertura/cierre",
                filter_lowercase_after_period: "Minúscula después de punto",
                filter_empty_subtitle: "Subtítulo vacío",
                filter_overlap: "Subtítulos superpuestos (overlaps)",
                filter_no_space_after_period: "Ausencia de espacios después de un punto",
                filter_unclosed_quotes: "Comillas sin cerrar",
                filter_ellipsis: "Errores en puntos suspensivos de enlace",
                filter_number_punctuation: "Puntuación de cifras",
                filter_units_format: "Formato de unidades de medida",
                filter_acronyms_format: "Formato de siglas",
                filter_ellipsis_char: "Carácter de puntos suspensivos incorrecto",
                filter_dual_speaker_hyphen: "Guiones en diálogos de doble hablante",
                filter_numbers_1_to_10: "Números cardinales en cifras (1-10)",
                filter_four_digit_separator: "Separador de miles en 4 dígitos",
                filter_semicolons: "Uso de punto y coma",
                filter_quote_period: "Puntuación de comillas",
                filter_ids_sfx_format: "Detección de acotaciones o SFX (corchetes)",
                desc_cps: "Detecta subtítulos que excedan los CPS que configures.",
                desc_wpm: "Detecta subtítulos que excedan los WPM que configures.",
                desc_char_limit: "Detecta líneas que exceden el número de caracteres que configures.",
                desc_line_limit: "Identifica subtítulos con más de 2 líneas.",
                desc_dash_space: 'Detecta "-Hola" en lugar de "- Hola".',
                desc_duration: "Marca subtítulos con duración menor a 1 segundo o mayor a 7 segundos.",
                desc_min_gap: "Detecta gaps menores a 100ms o 4 frames entre subtítulos.",
                desc_unclosed_tags: "Identifica etiquetas HTML (ej: <i>, <b>) sin cerrar, sin abrir o mal formadas.",
                desc_double_spaces: 'Marca la presencia de dos ("  ") o tres ("   ") espacios consecutivos.',
                desc_question_marks: 'Detecta "¿Qué tal?" sin el signo de cierre o "Qué tal?" sin el de apertura, y de forma similar para "¡Hola!"',
                desc_lowercase_after_period: 'Identifica "Texto. siguiente" en lugar de "Texto. Siguiente".',
                desc_empty_subtitle: "Detecta subtítulos que se han quedado vacíos o sin texto por despiste.",
                desc_overlap: "Detecta subtítulos que pisan o se superponen con otros subtítulos.",
                desc_no_space_after_period: "Detecta un punto seguido directamente de una palabra o letra, sin espacio intermedio.",
                desc_unclosed_quotes: 'Identifica "Texto de comillas simples sin cerrar\' o "Texto de comillas dobles sin cerrar".',
                desc_ellipsis: 'Marca subtítulos que terminan con "..." sugiriendo una continuación.',
                desc_number_punctuation: 'Detecta la puntuación "1,234.56" típica del inglés en lugar de "1.234,56".',
                desc_units_format: 'Detecta unidades de medida (ej. "km.", "cms") que terminan en punto o están en plural.',
                desc_acronyms_format: 'Detecta siglas (ej. "F.B.I", "O N U") que incluyen puntos o espacios.',
                desc_ellipsis_char: 'Detecta el uso de tres puntos consecutivos (...) en lugar del carácter de elipsis único (…).',
                desc_dual_speaker_hyphen: "Detecta inconsistencias en el uso de guiones en subtítulos de doble hablante (ej. una línea con guion y otra sin él).",
                desc_numbers_1_to_10: 'Detecta si los números del 1 al 10 están escritos en cifras en lugar de letras (ej. "5 perros" en lugar de "cinco perros").',
                desc_four_digit_separator: 'Detecta si los números de cuatro dígitos tienen separadores (ej. "2.000" en lugar de "2000").',
                desc_semicolons: "Detecta la presencia de punto y coma (;).",
                desc_quote_period: 'Detecta si el punto final de una oración citada se encuentra dentro de las comillas de cierre (ej. "Texto." en lugar de "Texto".).',
                desc_ids_sfx_format: "Detecta la presencia de texto encerrado entre corchetes (ej. [Música], [Aplausos]).",
                errors: {
                    high_cps: "Velocidad de lectura alta: {cps} CPS (Máx: {max})",
                    high_wpm: "Velocidad de lectura alta: {wpm} WPM (Máx: {max})",
                    line_char_limit: "Línea {lineIndex} excede el límite de caracteres ({length} > {max})",
                    line_limit: "Excede el límite de líneas ({count} > {max})",
                    no_space_after_dash: "No hay espacio después de un guion.",
                    duration_too_short: "Duración demasiado corta ({duration}ms < {min}ms)",
                    duration_too_long: "Duración demasiado larga ({duration}ms > {max}ms)",
                    gap_too_small: "Espacio entre subtítulos demasiado pequeño ({gap}ms)",
                    unclosed_tag: "Etiqueta <{tag}> sin cerrar.",
                    unopened_tag: "Etiqueta </{tag}> sin abrir.",
                    double_spaces: "Contiene espacios dobles o triples.",
                    missing_closing_question: "Línea {lineIndex}: Falta signo de cierre de interrogación (?).",
                    missing_opening_question: "Línea {lineIndex}: Falta signo de apertura de interrogación (¿).",
                    missing_closing_exclamation: "Línea {lineIndex}: Falta signo de cierre de exclamación (!).",
                    missing_opening_exclamation: "Línea {lineIndex}: Falta signo de apertura de exclamación (¡).",
                    lowercase_after_period: "El subtítulo comienza con minúscula después de un punto.",
                    empty_subtitle: "Subtítulo vacío.",
                    overlap: "Overlap con el siguiente subtítulo.",
                    no_space_after_period: "Un punto seguido directamente de una palabra o letra, sin espacio intermedio.",
                    unclosed_single_quote: "Comilla simple (') sin cerrar.",
                    unclosed_double_quote: "Comilla doble (\") sin cerrar.",
                    ellipsis_linking: "Contiene elipsis (...) al final de una línea (posiblemente un enlace).",
                    english_number_punctuation: "Usa puntuación de miles estilo inglés (coma como separador de miles).",
                    incorrect_unit_format: "Unidad de medida con formato incorrecto (punto o plural).",
                    incorrect_acronym_format: "Sigla con puntuación o espacios internos incorrectos.",
                    incorrect_ellipsis_char: "Usa tres puntos (...) en lugar del carácter de elipsis único (…).",
                    inconsistent_dialogue_hyphen: "Inconsistencia en guiones de diálogo de doble hablante.",
                    number_as_digit: "Número del 1 al 10 escrito en cifra en lugar de letra.",
                    four_digit_separator: "Número de cuatro dígitos con separador de miles.",
                    semicolon_present: "Contiene punto y coma (;).",
                    quote_punctuation: "Punto final de cita se encuentra dentro de las comillas.",
                    sfx_brackets: "Contiene acotaciones o efectos de sonido entre corchetes."
                }
            }
        };

        let currentLang = 'en';

        function setLanguage(lang) {
            currentLang = lang;
            document.documentElement.lang = lang;
            document.querySelectorAll('[data-lang]').forEach(el => {
                const key = el.getAttribute('data-lang');
                if (translations[lang][key]) {
                    el.textContent = translations[lang][key];
                }
            });

            document.getElementById('lang-en').classList.toggle('active', lang === 'en');
            document.getElementById('lang-es').classList.toggle('active', lang === 'es');
            
            renderFilters();
        }

        // --- FILTER DEFINITIONS ---
        const filterDefinitions = [
            { id: 'filterCps', name: 'filter_cps', desc: 'desc_cps', inputs: [{type: 'number', id: 'maxCps', value: 20, title: 'Max CPS'}] },
            { id: 'filterWpm', name: 'filter_wpm', desc: 'desc_wpm', inputs: [{type: 'number', id: 'maxWpm', value: 150, title: 'Max WPM'}] },
            { id: 'filterCharLimit', name: 'filter_char_limit', desc: 'desc_char_limit', inputs: [{type: 'number', id: 'maxCharsPerLine', value: 42, title: 'Max chars per line'}] },
            { id: 'filterLineLimit', name: 'filter_line_limit', desc: 'desc_line_limit', inputs: [{type: 'number', id: 'maxLines', value: 2, title: 'Max lines'}] },
            { id: 'filterDashSpace', name: 'filter_dash_space', desc: 'desc_dash_space', inputs: [] },
            { id: 'filterDuration', name: 'filter_duration', desc: 'desc_duration', inputs: [{type: 'number', id: 'minDuration', value: 1000, title: 'Min duration (ms)'}, {type: 'number', id: 'maxDuration', value: 7000, title: 'Max duration (ms)'}] },
            { id: 'filterMinGap', name: 'filter_min_gap', desc: 'desc_min_gap', inputs: [
                {type: 'number', id: 'minGap', value: 100, title: 'Gap value'},
                {type: 'select', id: 'gapUnit', options: ['ms', 'frames']},
                {type: 'number', id: 'frameRate', value: 25, title: 'FPS', style: 'display:none;'}
            ] },
            { id: 'filterUnclosedTags', name: 'filter_unclosed_tags', desc: 'desc_unclosed_tags', inputs: [] },
            { id: 'filterDoubleSpaces', name: 'filter_double_spaces', desc: 'desc_double_spaces', inputs: [] },
            { id: 'filterQuestionMarks', name: 'filter_question_marks', desc: 'desc_question_marks', inputs: [] },
            { id: 'filterLowercaseAfterPeriod', name: 'filter_lowercase_after_period', desc: 'desc_lowercase_after_period', inputs: [] },
            { id: 'filterEmptySubtitle', name: 'filter_empty_subtitle', desc: 'desc_empty_subtitle', inputs: [] },
            { id: 'filterOverlap', name: 'filter_overlap', desc: 'desc_overlap', inputs: [] },
            { id: 'filterNoSpaceAfterPeriod', name: 'filter_no_space_after_period', desc: 'desc_no_space_after_period', inputs: [] },
            { id: 'filterUnclosedQuotes', name: 'filter_unclosed_quotes', desc: 'desc_unclosed_quotes', inputs: [] },
            { id: 'filterEllipsis', name: 'filter_ellipsis', desc: 'desc_ellipsis', inputs: [] },
            { id: 'filterNumberPunctuation', name: 'filter_number_punctuation', desc: 'desc_number_punctuation', inputs: [] },
            { id: 'filterUnitsFormat', name: 'filter_units_format', desc: 'desc_units_format', inputs: [] },
            { id: 'filterAcronymsFormat', name: 'filter_acronyms_format', desc: 'desc_acronyms_format', inputs: [] },
            { id: 'filterEllipsisChar', name: 'filter_ellipsis_char', desc: 'desc_ellipsis_char', inputs: [] },
            { id: 'filterDualSpeakerHyphen', name: 'filter_dual_speaker_hyphen', desc: 'desc_dual_speaker_hyphen', inputs: [] },
            { id: 'filterNumbers1to10', name: 'filter_numbers_1_to_10', desc: 'desc_numbers_1_to_10', inputs: [] },
            { id: 'filterFourDigitSeparator', name: 'filter_four_digit_separator', desc: 'desc_four_digit_separator', inputs: [] },
            { id: 'filterSemicolons', name: 'filter_semicolons', desc: 'desc_semicolons', inputs: [] },
            { id: 'filterQuotePeriod', name: 'filter_quote_period', desc: 'desc_quote_period', inputs: [] },
            { id: 'filterIdsSfxFormat', name: 'filter_ids_sfx_format', desc: 'desc_ids_sfx_format', inputs: [] }
        ];

        let filterStates = {};
        filterDefinitions.forEach(f => filterStates[f.id] = true);
        filterStates['filterWpm'] = false; // Unchecked by default

        function renderFilters() {
            const container = document.getElementById('filters-container');
            container.innerHTML = '';
            const langDict = translations[currentLang];

            filterDefinitions.forEach(filter => {
                const filterDiv = document.createElement('div');
                filterDiv.className = 'flex flex-col';
                
                let inputsHTML = '';
                filter.inputs.forEach(input => {
                    const value = document.getElementById(input.id) ? document.getElementById(input.id).value : input.value;
                    if(input.type === 'select') {
                        inputsHTML += `<select id="${input.id}" class="ml-2 px-2 py-1 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-green-500">${input.options.map(o => `<option value="${o}" ${value === o ? 'selected' : ''}>${o}</option>`).join('')}</select>`;
                    } else {
                        inputsHTML += `<input type="${input.type}" id="${input.id}" value="${value}" class="ml-2 w-20 px-2 py-1 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-green-500" title="${input.title}" style="${input.style || ''}">`;
                    }
                });

                filterDiv.innerHTML = `
                    <div class="flex items-center">
                        <input type="checkbox" id="${filter.id}" class="h-4 w-4 text-green-600 rounded focus:ring-green-500" ${filterStates[filter.id] ? 'checked' : ''}>
                        <label for="${filter.id}" class="ml-2 text-gray-700 font-semibold">${langDict[filter.name]}</label>
                        ${inputsHTML}
                    </div>
                    <p class="text-xs text-gray-500 mt-1 ml-6">${langDict[filter.desc]}</p>
                `;
                container.appendChild(filterDiv);

                document.getElementById(filter.id).addEventListener('change', (e) => {
                    filterStates[filter.id] = e.target.checked;
                });
            });
            
            document.getElementById('gapUnit').addEventListener('change', function() {
                document.getElementById('frameRate').style.display = this.value === 'frames' ? 'inline-block' : 'none';
            });
            document.getElementById('gapUnit').dispatchEvent(new Event('change'));
        }
        
        // Global variables
        let subtitles = [];
        let errorsFound = [];
        let allFiltersCheckedState = true;

        // DOM Elements
        const subtitleFile = document.getElementById('subtitleFile');
        const fileNameDisplay = document.getElementById('fileName');
        const checkButton = document.getElementById('checkButton');
        const resultsDiv = document.getElementById('results');
        const noErrorsMessage = document.getElementById('noErrorsMessage');
        const exportPdfButton = document.getElementById('exportPdfButton');
        const exportTableButton = document.getElementById('exportTableButton');
        const toggleAllFiltersButton = document.getElementById('toggleAllFiltersButton');

        // --- Core Functions (Original Logic Preserved) ---
        function formatTime(ms) {
            if (isNaN(ms) || ms < 0) return "00:00:00,000";
            const date = new Date(ms);
            return `${String(date.getUTCHours()).padStart(2, '0')}:${String(date.getUTCMinutes()).padStart(2, '0')}:${String(date.getUTCSeconds()).padStart(2, '0')},${String(date.getUTCMilliseconds()).padStart(3, '0')}`;
        }

        function timeToMs(timeString) {
            const parts = timeString.match(/(\d{2}):(\d{2}):(\d{2}),(\d{3})/);
            if (!parts) return 0;
            const [, h, m, s, ms] = parts.map(Number);
            return (h * 3600 + m * 60 + s) * 1000 + ms;
        }

        function calculateCps(text, durationMs) {
            if (durationMs <= 0) return 0;
            const cleanText = text.replace(/<[^>]*>/g, '');
            return cleanText.length / (durationMs / 1000);
        }
        
        function calculateWpm(text, durationMs) {
            if (durationMs <= 0) return 0;
            const cleanText = text.replace(/<[^>]*>/g, '');
            const words = cleanText.split(/\s+/).filter(word => word.length > 0).length;
            return words / (durationMs / 60000);
        }

        function parseSrt(srtText) {
            const entries = srtText.trim().split(/\r?\n\r?\n/);
            return entries.map((entry, index) => {
                const lines = entry.split(/\r?\n/);
                const timeMatch = lines[1] ? lines[1].match(/(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})/) : null;
                let startMs = 0, endMs = 0;
                if (timeMatch) {
                    [startMs, endMs] = [timeToMs(timeMatch[1]), timeToMs(timeMatch[2])];
                }
                const text = lines.slice(2).join('\n').trim();
                return {
                    index: parseInt(lines[0], 10) || (index + 1),
                    startMs, endMs, durationMs: endMs - startMs, text,
                    originalLines: text.split(/\r?\n/), errors: []
                };
            }).filter(sub => !isNaN(sub.index) && sub.text !== '');
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            const langDict = translations[currentLang];
            if (file) {
                fileNameDisplay.textContent = langDict.selected_file.replace('{fileName}', file.name);
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        subtitles = parseSrt(e.target.result);
                        resultsDiv.innerHTML = `<p class="text-gray-500">${subtitles.length > 0 ? langDict.file_loaded : langDict.no_valid_subs}</p>`;
                        noErrorsMessage.classList.add('hidden');
                        errorsFound = [];
                    } catch (error) {
                        resultsDiv.innerHTML = `<p class="text-red-600">${langDict.file_process_error.replace('{errorMessage}', error.message)}</p>`;
                        subtitles = [];
                    }
                };
                reader.readAsText(file);
            }
        }
        
        function getFilterValue(id) { return document.getElementById(id).value; }
        function isFilterChecked(id) { return document.getElementById(id).checked; }
        
        function getErrorMessage(key, params = {}) {
            let message = translations[currentLang].errors[key] || key;
            for (const p in params) {
                message = message.replace(`{${p}}`, params[p]);
            }
            return message;
        }

        function checkSubtitles() {
            const langDict = translations[currentLang];
            if (subtitles.length === 0) {
                resultsDiv.innerHTML = `<p class="text-red-600">${langDict.upload_first}</p>`;
                return;
            }

            errorsFound = [];
            subtitles.forEach((sub, i) => {
                sub.errors = [];
                
                if (isFilterChecked('filterCps')) {
                    const cps = calculateCps(sub.text, sub.durationMs);
                    if (cps > parseFloat(getFilterValue('maxCps'))) {
                        sub.errors.push(getErrorMessage('high_cps', { cps: cps.toFixed(2), max: getFilterValue('maxCps') }));
                    }
                }
                if (isFilterChecked('filterWpm')) {
                    const wpm = calculateWpm(sub.text, sub.durationMs);
                    if (wpm > parseFloat(getFilterValue('maxWpm'))) {
                        sub.errors.push(getErrorMessage('high_wpm', { wpm: wpm.toFixed(2), max: getFilterValue('maxWpm') }));
                    }
                }
                if (isFilterChecked('filterCharLimit')) {
                    sub.originalLines.forEach((line, lineIndex) => {
                        if (line.length > parseInt(getFilterValue('maxCharsPerLine'))) {
                            sub.errors.push(getErrorMessage('line_char_limit', { lineIndex: lineIndex + 1, length: line.length, max: getFilterValue('maxCharsPerLine') }));
                        }
                    });
                }
                if (isFilterChecked('filterLineLimit')) {
                    if (sub.originalLines.length > parseInt(getFilterValue('maxLines'))) {
                        sub.errors.push(getErrorMessage('line_limit', { count: sub.originalLines.length, max: getFilterValue('maxLines') }));
                    }
                }
                if (isFilterChecked('filterDashSpace')) {
                    if (sub.text.match(/-(?!\s)/) && !sub.text.match(/-\n/)) {
                        sub.errors.push(getErrorMessage('no_space_after_dash'));
                    }
                }
                if (isFilterChecked('filterDuration')) {
                    if (sub.durationMs < parseInt(getFilterValue('minDuration'))) {
                        sub.errors.push(getErrorMessage('duration_too_short', { duration: sub.durationMs, min: getFilterValue('minDuration') }));
                    }
                    if (sub.durationMs > parseInt(getFilterValue('maxDuration'))) {
                        sub.errors.push(getErrorMessage('duration_too_long', { duration: sub.durationMs, max: getFilterValue('maxDuration') }));
                    }
                }
                if (isFilterChecked('filterMinGap') && i < subtitles.length - 1) {
                    const nextSub = subtitles[i + 1];
                    let requiredGapMs;
                    const minGapValue = parseInt(getFilterValue('minGap'));
                    if (getFilterValue('gapUnit') === 'ms') {
                        requiredGapMs = minGapValue;
                    } else {
                        const frameRateValue = parseFloat(getFilterValue('frameRate'));
                        requiredGapMs = (minGapValue / frameRateValue) * 1000;
                    }
                    const actualGap = nextSub.startMs - sub.endMs;
                    if (actualGap < requiredGapMs && actualGap >= 0) {
                        sub.errors.push(getErrorMessage('gap_too_small', { gap: actualGap }));
                    }
                }
                if (isFilterChecked('filterUnclosedTags')) {
                    ['i', 'b', 'font'].forEach(tag => {
                        const openCount = (sub.text.match(new RegExp(`<${tag}>`, 'g')) || []).length;
                        const closeCount = (sub.text.match(new RegExp(`</${tag}>`, 'g')) || []).length;
                        if (openCount > closeCount) sub.errors.push(getErrorMessage('unclosed_tag', { tag: tag }));
                        if (closeCount > openCount) sub.errors.push(getErrorMessage('unopened_tag', { tag: tag }));
                    });
                }
                if (isFilterChecked('filterDoubleSpaces') && sub.text.match(/\s\s+/)) {
                    sub.errors.push(getErrorMessage('double_spaces'));
                }
                if (isFilterChecked('filterQuestionMarks')) {
                    sub.originalLines.forEach((line, lineIndex) => {
                        if (line.includes('¿') && !line.includes('?')) sub.errors.push(getErrorMessage('missing_closing_question', { lineIndex: lineIndex + 1 }));
                        if (!line.includes('¿') && line.includes('?')) sub.errors.push(getErrorMessage('missing_opening_question', { lineIndex: lineIndex + 1 }));
                        if (line.includes('¡') && !line.includes('!')) sub.errors.push(getErrorMessage('missing_closing_exclamation', { lineIndex: lineIndex + 1 }));
                        if (!line.includes('¡') && line.includes('!')) sub.errors.push(getErrorMessage('missing_opening_exclamation', { lineIndex: lineIndex + 1 }));
                    });
                }
                if (isFilterChecked('filterLowercaseAfterPeriod') && sub.text.match(/\.\s*([a-záéíóúüñ])/)) {
                    sub.errors.push(getErrorMessage('lowercase_after_period'));
                }
                if (isFilterChecked('filterEmptySubtitle') && sub.text.trim() === '') {
                    sub.errors.push(getErrorMessage('empty_subtitle'));
                }
                if (isFilterChecked('filterOverlap') && i < subtitles.length - 1) {
                    const nextSub = subtitles[i + 1];
                    if (sub.endMs > nextSub.startMs) {
                        sub.errors.push(getErrorMessage('overlap'));
                    }
                }
                if (isFilterChecked('filterNoSpaceAfterPeriod') && sub.text.match(/\.(?!\s|$)(?!\d)(?!\.)/g)) {
                    sub.errors.push(getErrorMessage('no_space_after_period'));
                }
                if (isFilterChecked('filterUnclosedQuotes')) {
                    if ((sub.text.match(/'/g) || []).length % 2 !== 0) sub.errors.push(getErrorMessage('unclosed_single_quote'));
                    if ((sub.text.match(/"/g) || []).length % 2 !== 0) sub.errors.push(getErrorMessage('unclosed_double_quote'));
                }
                if (isFilterChecked('filterEllipsis') && sub.originalLines.some(line => line.trim().endsWith('...'))) {
                    sub.errors.push(getErrorMessage('ellipsis_linking'));
                }
                if (isFilterChecked('filterNumberPunctuation') && sub.text.match(/\d{1,3}(,\d{3})+(\.\d+)?/)) {
                    sub.errors.push(getErrorMessage('english_number_punctuation'));
                }
                if (isFilterChecked('filterUnitsFormat') && sub.text.match(/\b(\d+(\.\d+)?\s*(km|cm|m|kg|g|L|ml|A|V|Hz)(s|\.))\b/gi)) {
                    sub.errors.push(getErrorMessage('incorrect_unit_format'));
                }
                if (isFilterChecked('filterAcronymsFormat') && sub.text.match(/\b[A-ZÑÁÉÍÓÚÄËÏÖÜ]\.([A-ZÑÁÉÍÓÚÄËÏÖÜ]\.)+\b|\b[A-ZÑÁÉÍÓÚÄËÏÖÜ]( [A-ZÑÁÉÍÓÚÄËÏÖÜ])+\b/g)) {
                    sub.errors.push(getErrorMessage('incorrect_acronym_format'));
                }
                if (isFilterChecked('filterEllipsisChar') && sub.text.includes('...') && !sub.text.includes('…')) {
                    sub.errors.push(getErrorMessage('incorrect_ellipsis_char'));
                }
                if (isFilterChecked('filterDualSpeakerHyphen') && sub.originalLines.length === 2) {
                    const line1HasHyphen = sub.originalLines[0].trim().startsWith('-');
                    const line2HasHyphen = sub.originalLines[1].trim().startsWith('-');
                    if (line1HasHyphen !== line2HasHyphen) sub.errors.push(getErrorMessage('inconsistent_dialogue_hyphen'));
                }
                if (isFilterChecked('filterNumbers1to10') && sub.text.match(/\b([1-9]|10)\b/g)) {
                    sub.errors.push(getErrorMessage('number_as_digit'));
                }
                if (isFilterChecked('filterFourDigitSeparator') && sub.text.match(/\b\d{1}[.,]\d{3}\b/g)) {
                    sub.errors.push(getErrorMessage('four_digit_separator'));
                }
                if (isFilterChecked('filterSemicolons') && sub.text.includes(';')) {
                    sub.errors.push(getErrorMessage('semicolon_present'));
                }
                if (isFilterChecked('filterQuotePeriod') && sub.text.match(/"\.[ \n\r]*$/)) {
                    sub.errors.push(getErrorMessage('quote_punctuation'));
                }
                if (isFilterChecked('filterIdsSfxFormat') && sub.text.match(/\[.*?\]/)) {
                    sub.errors.push(getErrorMessage('sfx_brackets'));
                }

                if (sub.errors.length > 0) errorsFound.push(sub);
            });
            displayResults();
        }

        function displayResults() {
            resultsDiv.innerHTML = '';
            if (errorsFound.length === 0) {
                noErrorsMessage.classList.remove('hidden');
                resultsDiv.classList.add('hidden');
                return;
            }
            noErrorsMessage.classList.add('hidden');
            resultsDiv.classList.remove('hidden');
            errorsFound.forEach(sub => {
                const subElement = document.createElement('div');
                subElement.className = 'error-item';
                subElement.innerHTML = `
                    <p class="font-bold text-lg text-red-700 mb-1">Subtitle ${sub.index} (${formatTime(sub.startMs)} --> ${formatTime(sub.endMs)})</p>
                    <pre class="bg-white p-2 rounded-md border border-red-200 text-gray-900 text-sm whitespace-pre-wrap mb-2">${escapeHtml(sub.text)}</pre>
                    <ul class="list-disc list-inside text-red-600 font-semibold">${sub.errors.map(e => `<li>${escapeHtml(e)}</li>`).join('')}</ul>`;
                resultsDiv.appendChild(subElement);
            });
        }
        
        function escapeHtml(text) {
            return text.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'})[m]);
        }
        
        function exportToPdf() {
            if (errorsFound.length === 0) return;
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            let y = 20;
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(18);
            doc.text("SubPandaQA Error Report", 105, y, { align: 'center' });
            y += 15;
            errorsFound.forEach(sub => {
                if (y > 270) { doc.addPage(); y = 20; }
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(12);
                doc.text(`Subtitle ${sub.index} (${formatTime(sub.startMs)} --> ${formatTime(sub.endMs)})`, 10, y);
                y += 7;
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(10);
                const textLines = doc.splitTextToSize(sub.text, 180);
                doc.text(textLines, 15, y);
                y += textLines.length * 5 + 2;
                doc.setTextColor(255, 0, 0);
                sub.errors.forEach(error => {
                    const errorLines = doc.splitTextToSize(`- ${error}`, 175);
                    doc.text(errorLines, 20, y);
                    y += errorLines.length * 5;
                });
                doc.setTextColor(0, 0, 0);
                y += 5;
            });
            doc.save('SubPandaQA_Report.pdf');
        }

        function exportToTable() {
            if (errorsFound.length === 0) return;
            let tableHtml = `<thead><tr><th>ID</th><th>Timestamps</th><th>Text</th><th>Errors</th></tr></thead><tbody>`;
            errorsFound.forEach(sub => {
                tableHtml += `<tr><td>${sub.index}</td><td>${formatTime(sub.startMs)} --> ${formatTime(sub.endMs)}</td><td><pre>${escapeHtml(sub.text)}</pre></td><td><ul>${sub.errors.map(e => `<li>${escapeHtml(e)}</li>`).join('')}</ul></td></tr>`;
            });
            const newWindow = window.open();
            newWindow.document.write(`<style>body{font-family:sans-serif}table{border-collapse:collapse;width:100%}th,td{border:1px solid #ddd;padding:8px}tr:nth-child(even){background-color:#f2f2f2}pre{white-space:pre-wrap}</style><h2>Error Report</h2><table>${tableHtml}</tbody></table>`);
            newWindow.document.close();
        }
        
        // --- Event Listeners ---
        subtitleFile.addEventListener('change', handleFileSelect);
        checkButton.addEventListener('click', checkSubtitles);
        exportPdfButton.addEventListener('click', exportToPdf);
        exportTableButton.addEventListener('click', exportToTable);
        document.getElementById('lang-en').addEventListener('click', () => setLanguage('en'));
        document.getElementById('lang-es').addEventListener('click', () => setLanguage('es'));
        
        toggleAllFiltersButton.addEventListener('click', () => {
            allFiltersCheckedState = !allFiltersCheckedState;
            Object.keys(filterStates).forEach(id => filterStates[id] = allFiltersCheckedState);
            renderFilters();
        });

        document.addEventListener('DOMContentLoaded', () => {
            setLanguage('en'); // Set default language on load
        });

    </script>
</body>
</html>
