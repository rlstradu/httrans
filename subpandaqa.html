<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SubPandaQA - Advanced Subtitle Quality Control</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root {
            --brand-color: #075BA2;
            --brand-color-light: #0a7ee5;
            --brand-color-dark: #05437a;
            --background-color: #f0f4f8;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --card-background: #ffffff;
            --success-color: #10b981;
            /* --- New category colors --- */
            --color-rules: #3498DB;      /* Blue */
            --color-timing: #2ECC71;    /* Green */
            --color-spelling: #E74C3C;   /* Red */
            --color-tags: #9B59B6;       /* Magenta/Purple */
        }
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--background-color);
            color: var(--text-primary);
        }
        .wow-header {
            background-color: var(--card-background);
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            border: 1px solid #e2e8f0;
        }
        .section-card {
            background-color: var(--card-background);
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            border: 1px solid #e2e8f0;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .section-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.15);
        }
        .section-title {
            display: flex;
            align-items: center;
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--brand-color);
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }
        .btn-primary {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background-color: var(--brand-color);
            color: white;
            font-weight: 600;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease;
        }
        .btn-primary:hover {
            background-color: var(--brand-color-dark);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            transform: translateY(-2px);
        }
        .lang-btn {
            background-color: #f3f4f6;
            color: var(--text-secondary);
            font-weight: 700;
            border-radius: 9999px;
            padding: 0.5rem 1rem;
            transition: all 0.3s ease;
        }
        .lang-btn.active, .lang-btn:hover {
            background-color: var(--brand-color);
            color: white;
        }
        .error-item {
            background-color: #fffafb;
            border-left: 5px solid #cbd5e1;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.05);
            margin-bottom: 1rem;
            padding: 1rem;
        }
        .success-message {
            background-color: #f0fdf4;
            color: #166534;
            border: 2px solid #bbf7d0;
            border-radius: 0.75rem;
            padding: 1.5rem;
            text-align: center;
            font-weight: 600;
            font-size: 1.125rem;
        }
        #results-container {
            min-height: 400px;
        }
        #results {
            max-height: 500px;
            overflow-y: auto;
        }
        /* --- New styles for categories --- */
        .category-title {
            font-size: 1.125rem;
            font-weight: 700;
            margin-top: 1rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.25rem;
            border-bottom: 2px solid;
        }
        .category-title.rules { border-color: var(--color-rules); color: var(--color-rules); }
        .category-title.timing { border-color: var(--color-timing); color: var(--color-timing); }
        .category-title.spelling { border-color: var(--color-spelling); color: var(--color-spelling); }
        .category-title.tags { border-color: var(--color-tags); color: var(--color-tags); }
        
        .error-category-rules { color: var(--color-rules); }
        .error-category-timing { color: var(--color-timing); }
        .error-category-spelling { color: var(--color-spelling); }
        .error-category-tags { color: var(--color-tags); }
        .error-category-default { color: var(--text-secondary); }
    </style>
</head>
<body class="p-4 sm:p-6 lg:p-8">

    <div class="container mx-auto max-w-4xl">

        <div class="flex flex-col gap-8">

            <header class="wow-header p-8 relative">
                <div class="absolute top-4 right-4 flex space-x-2">
                    <button id="lang-en" class="lang-btn active">EN</button>
                    <button id="lang-es" class="lang-btn">ES</button>
                </div>
                <div class="flex flex-col items-center justify-center text-center">
                    <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/subpandaqa-logo.png" alt="SubPandaQA Logo" class="w-72 mb-4">
                    <p id="app-description" data-lang="app_description" class="text-xl font-light max-w-2xl text-gray-600">A powerful tool to detect errors in SRT subtitle files with style.</p>
                </div>
            </header>

            <section class="section-card">
                <h2 class="section-title"><span class="material-icons">upload_file</span><span data-lang="upload_title">1. Upload subtitle file (.srt)</span></h2>
                <input type="file" id="subtitleFile" accept=".srt" class="w-full text-gray-700 bg-gray-50 border-2 border-dashed border-gray-300 rounded-lg p-4 cursor-pointer hover:bg-gray-100 hover:border-brand-color transition-colors">
                <p id="fileName" class="mt-3 text-sm text-gray-500"></p>
            </section>

            <section class="section-card">
                <h2 class="section-title"><span class="material-icons">filter_alt</span><span data-lang="filters_title">2. Configure filters</span></h2>
                <div class="flex items-center space-x-4 mb-6 flex-wrap gap-y-2">
                    <button id="toggleAllFiltersButton" class="px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 transition-all duration-200" data-lang="toggle_filters">
                        Toggle All
                    </button>
                    <button id="resetFiltersButton" class="px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 transition-all duration-200" data-lang="reset_filters">
                        Reset to default
                    </button>
                    <button id="saveFiltersButton" class="px-4 py-2 bg-blue-200 text-blue-800 font-semibold rounded-lg hover:bg-blue-300 focus:outline-none focus:ring-2 focus:ring-blue-400 transition-all duration-200" data-lang="save_filters">
                        Save Filters
                    </button>
                    <button id="importFiltersButton" class="px-4 py-2 bg-blue-200 text-blue-800 font-semibold rounded-lg hover:bg-blue-300 focus:outline-none focus:ring-2 focus:ring-blue-400 transition-all duration-200" data-lang="import_filters">
                        Import Filters
                    </button>
                    <input type="file" id="importFiltersInput" class="hidden" accept=".json">
                </div>
                <div id="filters-container" class="flex flex-col space-y-4 max-h-96 overflow-y-auto pr-2">
                    </div>
            </section>
            
            <button id="checkButton" class="btn-primary w-full py-4 text-xl">
                <span class="material-icons">spellcheck</span>
                <span data-lang="check_button">CHECK SUBTITLES</span>
            </button>

            <section id="results-container" class="section-card flex-grow flex flex-col">
                <h2 class="section-title"><span class="material-icons">error</span><span data-lang="results_title">3. Review results</span></h2>
                <div id="results" class="bg-gray-50 p-4 rounded-lg border border-gray-200 text-sm flex-grow">
                    <p class="text-gray-500" data-lang="results_placeholder">Upload a subtitle file and press "CHECK SUBTITLES" to see the errors here.</p>
                </div>
                <div id="noErrorsMessage" class="hidden mt-4 success-message flex-grow flex items-center justify-center">
                    <span data-lang="no_errors">Congratulations! No errors were found with the selected filters.</span>
                </div>
            </section>

            <section class="section-card">
                 <h2 class="section-title"><span class="material-icons">save</span><span data-lang="export_title">Export error report</span></h2>
                <div class="flex flex-col sm:flex-row gap-4">
                    <button id="exportPdfButton" class="btn-primary flex-1 bg-[#373737] hover:bg-[#2a2a2a]">
                        <span class="material-icons">picture_as_pdf</span>
                        <span data-lang="export_pdf">Export to PDF</span>
                    </button>
                    <button id="exportTableButton" class="btn-primary flex-1 bg-[#373737] hover:bg-[#2a2a2a]">
                        <span class="material-icons">table_view</span>
                        <span data-lang="export_table">Export as HTML Table</span>
                    </button>
                </div>
            </section>
        </div>
    </div>

    <div id="genericModal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
        <div class="relative top-20 mx-auto p-5 border w-full max-w-md shadow-lg rounded-xl bg-white">
            <div class="mt-3 text-center">
                <h3 id="modalTitle" class="text-lg leading-6 font-medium text-gray-900"></h3>
                <div class="mt-4 px-7 py-3">
                    <label id="modalFileNameLabel" for="modalFileName" class="block text-sm font-medium text-gray-700 text-left mb-1"></label>
                    <input type="text" id="modalFileName" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-brand-color focus:border-brand-color sm:text-sm">
                </div>
                <div class="items-center px-4 py-3 space-x-4">
                    <button id="confirmModalButton" class="px-4 py-2 bg-green-500 text-white text-base font-medium rounded-md w-auto shadow-sm hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-300" data-lang="export_modal_confirm">Confirm</button>
                    <button id="cancelModalButton" class="px-4 py-2 bg-gray-400 text-white text-base font-medium rounded-md w-auto shadow-sm hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-300" data-lang="export_modal_cancel">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- LANGUAGE & TRANSLATION SETUP ---
        const translations = {
            en: {
                app_description: "A powerful tool to detect errors in SRT subtitle files with style.",
                upload_title: "1. Upload subtitle file (.srt)",
                filters_title: "2. Configure filters",
                toggle_filters: "Toggle all",
                reset_filters: "Reset to default",
                save_filters: "Save Filters",
                import_filters: "Import Filters",
                check_button: "Check subtitles",
                results_title: "3. Review results",
                results_placeholder: 'Upload a subtitle file and press "Check subtitles" to see the errors here.',
                result_subtitle_header: "Subtitle {index}",
                no_errors: "Congratulations! No errors were found with the selected filters.",
                export_title: "Export error report",
                export_pdf: "Export to PDF",
                export_table: "Export as HTML Table",
                export_modal_title: "Export Report",
                save_modal_title: "Save Filter Configuration",
                export_modal_filename: "File name",
                export_modal_confirm: "Confirm",
                export_modal_cancel: "Cancel",
                default_report_name: "SRT-Report",
                default_filter_config_name: "filter-settings",
                selected_file: "Selected file: {fileName}",
                file_loaded: 'File loaded. Press "Check subtitles".',
                no_valid_subs: "Could not parse valid subtitles from the file.",
                file_process_error: "Error processing file: {errorMessage}. Make sure it is a valid SRT file.",
                upload_first: "Please upload a subtitle file first.",
                // Category translations
                category_rules: "Rules",
                category_timing: "Timing & Spotting",
                category_spelling: "Spelling & Punctuation",
                category_tags: "Tags & Code",
                // Filter names
                filter_cps: "Reading speed (CPS)",
                filter_wpm: "Reading speed (WPM)",
                filter_char_limit: "Character limit per line",
                filter_line_limit: "Line limit",
                filter_dash_space: "No space after dash",
                filter_space_after_dash: "Space after dash", // NEW
                filter_duration: "Min/max duration",
                filter_min_gap: "Minimum gap between subtitles",
                filter_unclosed_tags: "Tag issues",
                filter_double_spaces: "Double/triple spaces",
                filter_question_marks: "Opening/closing question/exclamation marks",
                filter_lowercase_after_period: "Lowercase after period",
                filter_empty_subtitle: "Empty subtitle",
                filter_overlap: "Overlapping subtitles",
                filter_no_space_after_period: "No space after period",
                filter_unclosed_quotes: "Unclosed quotes",
                filter_quote_period: "Quote punctuation",
                filter_no_period_after_quote: "No period after quote",
                filter_ellipsis: "Ellipsis linking errors",
                filter_number_punctuation: "Number punctuation",
                filter_units_format: "Measurement unit format",
                filter_acronyms_format: "Acronym format",
                filter_ellipsis_char: "Incorrect ellipsis character",
                filter_dual_speaker_hyphen: "Dual speaker hyphen inconsistencies",
                filter_numbers_1_to_10: "Cardinal numbers as digits (1-10)",
                filter_four_digit_separator: "Thousand separator in 4-digit numbers",
                filter_semicolons: "Use of semicolons",
                filter_ids_sfx_format: "SFX/description detection (brackets/parentheses)", // UPDATED
                filter_forbidden_sequences: "Forbidden sequences", // NEW
                // Filter descriptions
                desc_cps: "Detects subtitles exceeding the configured CPS (newlines are not counted).", // UPDATED
                desc_wpm: "Detects subtitles exceeding the configured WPM.",
                desc_char_limit: "Detects lines exceeding the configured number of characters (tags are not counted).", // UPDATED
                desc_line_limit: "Identifies subtitles with more than 2 lines.",
                desc_dash_space: 'Detects "-Hello" instead of "- Hello".',
                desc_space_after_dash: 'Detects "- Hello" instead of "-Hello". For styles that omit the space.', // NEW
                desc_duration: "Flags subtitles shorter than 1s or longer than 7s.",
                desc_min_gap: "Detects gaps smaller than the configured value (in ms or frames).", // UPDATED
                desc_unclosed_tags: "Identifies unclosed, unopened, or malformed tags.",
                desc_double_spaces: "Flags the presence of two or more consecutive spaces.",
                desc_question_marks: "Detects missing opening or closing marks for questions and exclamations.",
                desc_lowercase_after_period: 'Identifies "Text. next" instead of "Text. Next".',
                desc_empty_subtitle: "Detects subtitles that have been mistakenly left empty.",
                desc_overlap: "Detects subtitles that overlap with subsequent subtitles.",
                desc_no_space_after_period: "Detects a period followed immediately by a word or letter, without an intervening space.",
                desc_unclosed_quotes: "Identifies 'Unclosed single quote text' or \"Unclosed double quote text\" (apostrophe-safe).", // UPDATED
                desc_quote_period: 'Detects if the final period of a quoted sentence is inside the closing quotes (e.g., "Text." instead of "Text".).',
                desc_no_period_after_quote: 'Detects a closing quote (") at the end of a line that is not followed by a period (ignores `?"` and `!"`).', // UPDATED
                desc_ellipsis: 'Flags subtitles ending with "..." suggesting a continuation.',
                desc_number_punctuation: 'Detects English-style punctuation "1,234.56" instead of "1.234,56".',
                desc_units_format: 'Detects measurement units (e.g., "km.", "cms") ending in a period or in plural form.',
                desc_acronyms_format: 'Detects acronyms (e.g., "F.B.I", "U N") that include periods or spaces.',
                desc_ellipsis_char: 'Detects the use of three consecutive dots (...) instead of the single ellipsis character (…).',
                desc_dual_speaker_hyphen: "Detects inconsistencies in the use of hyphens in dual speaker subtitles (e.g., one line with a hyphen and the other without).",
                desc_numbers_1_to_10: 'Detects if numbers from 1 to 10 are written in digits instead of letters (e.g., "5 dogs" instead of "five dogs").',
                desc_four_digit_separator: 'Detects if four-digit numbers have separators (e.g., "2,000" instead of "2000").',
                desc_semicolons: "Detects the presence of a semicolon (;).",
                desc_ids_sfx_format: "Detects the presence of text enclosed in [square brackets] or (parentheses).", // UPDATED
                desc_forbidden_sequences: "Detects custom text sequences (e.g., '..', ',.'). Separate with spaces.", // NEW
                // Error messages
                errors: {
                    high_cps: "High reading speed: {cps} CPS (Max: {max})",
                    high_wpm: "High reading speed: {wpm} WPM (Max: {max})",
                    line_char_limit: "Line {lineIndex} exceeds character limit ({length} > {max})",
                    line_limit: "Exceeds line limit ({count} > {max})",
                    no_space_after_dash: "No space after a dash.",
                    space_after_dash: "Contains a space after a dash.", // NEW
                    duration_too_short: "Duration too short ({duration}ms < {min}ms)",
                    duration_too_long: "Duration too long ({duration}ms > {max}ms)",
                    // --- MODIFICADO ---
                    gap_too_small: "Gap too small ({gap}ms). Sub {currentIndex} ends: {endTime} / Sub {nextIndex} starts: {startTime}.",
                    unclosed_tag: "Unclosed <{tag}> tag.",
                    unopened_tag: "Unopened </{tag}> tag.",
                    double_spaces: "Contains double or triple spaces.",
                    missing_closing_question: "Missing closing question mark (?).",
                    missing_opening_question: "Missing opening question mark (¿).",
                    missing_closing_exclamation: "Missing closing exclamation mark (!).",
                    missing_opening_exclamation: "Missing opening exclamation mark (¡).",
                    lowercase_after_period: "Starts with lowercase after a period.",
                    empty_subtitle: "Empty subtitle.",
                    // --- MODIFICADO ---
                    overlap: "Overlaps with the next subtitle (subtitle {nextIndex}).",
                    no_space_after_period: "A period is followed by a letter without a space.",
                    unclosed_single_quote: "Unclosed single quote (').",
                    unclosed_double_quote: "Unclosed double quote (\").",
                    quote_punctuation: "Final period is inside the closing quotes.",
                    no_period_after_quote: "The line ends with a quote but is not followed by a period.",
                    ellipsis_linking: "Contains ellipsis (...) at the end of a line (possible link).",
                    english_number_punctuation: "Uses English-style number punctuation (comma for thousands).",
                    incorrect_unit_format: "Incorrect unit format (period or plural).",
                    incorrect_acronym_format: "Incorrect acronym format (periods or spaces).",
                    incorrect_ellipsis_char: "Uses three dots (...) instead of the single ellipsis character (…).",
                    inconsistent_dialogue_hyphen: "Inconsistent use of hyphens in dual-speaker dialogue.",
                    number_as_digit: "Number from 1-10 is written as a digit instead of a word.",
                    four_digit_separator: "Four-digit number has a thousand separator.",
                    semicolon_present: "Contains a semicolon (;).",
                    sfx_brackets: "Contains SFX/description in [brackets] or (parentheses).", // UPDATED
                    forbidden_sequence_found: "Forbidden sequence(s) found: {sequences}" // NEW
                }
            },
            es: {
                app_description: "Una potente herramienta para detectar errores en archivos de subtítulos SRT con estilo.",
                upload_title: "1. Subir archivo de subtítulos (.srt)",
                filters_title: "2. Configurar filtros",
                toggle_filters: "Marcar/Desmarcar todas",
                reset_filters: "Restablecer valores",
                save_filters: "Guardar filtros",
                import_filters: "Importar filtros",
                check_button: "REVISAR SUBTÍTULOS",
                results_title: "3. Resultados de la revisión",
                results_placeholder: 'Sube un archivo de subtítulos y presiona "REVISAR SUBTÍTULOS" para ver los errores aquí.',
                result_subtitle_header: "Subtítulo {index}",
                no_errors: "¡Felicidades! No se encontraron errores con los filtros seleccionados.",
                export_title: "Exportar informe de errores",
                export_pdf: "Exportar a PDF",
                export_table: "Exportar como Tabla HTML",
                export_modal_title: "Exportar Informe",
                save_modal_title: "Guardar Configuración de Filtros",
                export_modal_filename: "Nombre del archivo",
                export_modal_confirm: "Confirmar",
                export_modal_cancel: "Cancelar",
                default_report_name: "Informe-errores-SRT",
                default_filter_config_name: "configuracion-filtros",
                selected_file: "Archivo seleccionado: {fileName}",
                file_loaded: 'Archivo cargado. Presiona "REVISAR SUBTÍTULOS".',
                no_valid_subs: "No se pudieron analizar subtítulos válidos del archivo.",
                file_process_error: "Error al procesar el archivo: {errorMessage}. Asegúrate de que es un archivo SRT válido.",
                upload_first: "Por favor, primero sube un archivo de subtítulos.",
                // Category translations
                category_rules: "Convenciones",
                category_timing: "Sincronización",
                category_spelling: "Ortografía y ortotipografía",
                category_tags: "Etiquetas y código",
                // Filter names
                filter_cps: "Velocidad de lectura (CPS)",
                filter_wpm: "Velocidad de lectura (WPM)",
                filter_char_limit: "Límite de caracteres por línea",
                filter_line_limit: "Límite de líneas",
                filter_dash_space: "Sin espacio después de guion",
                filter_space_after_dash: "Espacio después de guion", // NEW
                filter_duration: "Duración mínima/máxima",
                filter_min_gap: "Espacio mínimo entre subtítulos",
                filter_unclosed_tags: "Problemas con etiquetas",
                filter_double_spaces: "Espacios dobles o triples",
                filter_question_marks: "Signos de interrogación/admiración de apertura/cierre",
                filter_lowercase_after_period: "Minúscula después de punto",
                filter_empty_subtitle: "Subtítulo vacío",
                filter_overlap: "Subtítulos superpuestos (overlaps)",
                filter_no_space_after_period: "Ausencia de espacios después de un punto",
                filter_unclosed_quotes: "Comillas sin cerrar",
                filter_quote_period: "Puntuación de comillas",
                filter_no_period_after_quote: "Sin punto después de comillas",
                filter_ellipsis: "Errores en puntos suspensivos de enlace",
                filter_number_punctuation: "Puntuación de cifras",
                filter_units_format: "Formato de unidades de medida",
                filter_acronyms_format: "Formato de siglas",
                filter_ellipsis_char: "Carácter de puntos suspensivos incorrecto",
                filter_dual_speaker_hyphen: "Guiones en diálogos de doble hablante",
                filter_numbers_1_to_10: "Números cardinales en cifras (1-10)",
                filter_four_digit_separator: "Separador de miles en 4 dígitos",
                filter_semicolons: "Uso de punto y coma",
                filter_ids_sfx_format: "Detección de acotaciones o SFX (corchetes/paréntesis)", // UPDATED
                filter_forbidden_sequences: "Secuencias prohibidas", // NEW
                // Filter descriptions
                desc_cps: "Detecta subtítulos que excedan los CPS (no se cuentan saltos de línea).", // UPDATED
                desc_wpm: "Detecta subtítulos que excedan los WPM que configures.",
                desc_char_limit: "Detecta líneas que exceden el número de caracteres (no se cuentan las etiquetas).", // UPDATED
                desc_line_limit: "Identifica subtítulos con más de 2 líneas.",
                desc_dash_space: 'Detecta "-Hola" en lugar de "- Hola".',
                desc_space_after_dash: 'Detecta "- Hola" en lugar de "-Hola". Para estilos que omiten el espacio.', // NEW
                desc_duration: "Marca subtítulos con duración menor a 1 segundo o mayor a 7 segundos.",
                desc_min_gap: "Detecta gaps menores al valor configurado (en ms o frames).", // UPDATED
                desc_unclosed_tags: "Identifica etiquetas HTML (ej: <i>, <b>) sin cerrar, sin abrir o mal formadas.",
                desc_double_spaces: 'Marca la presencia de dos ("  ") o tres ("   ") espacios consecutivos.',
                desc_question_marks: 'Detecta "¿Qué tal?" sin el signo de cierre o "Qué tal?" sin el de apertura, y de forma similar para "¡Hola!"',
                desc_lowercase_after_period: 'Identifica "Texto. siguiente" en lugar de "Texto. Siguiente".',
                desc_empty_subtitle: "Detecta subtítulos que se han quedado vacíos o sin texto por despiste.",
                desc_overlap: "Detecta subtítulos que pisan o se superponen con otros subtítulos.",
                desc_no_space_after_period: "Detecta un punto seguido directamente de una palabra o letra, sin espacio intermedio.",
                desc_unclosed_quotes: 'Identifica "comillas simples sin cerrar\' o "comillas dobles sin cerrar" (ignora apóstrofos).', // UPDATED
                desc_quote_period: 'Detecta si el punto final de una oración citada se encuentra dentro de las comillas de cierre (ej. "Texto." en lugar de "Texto".).',
                desc_no_period_after_quote: 'Detecta comillas de cierre (") al final de línea sin punto (ignora `?"` y `!"`).', // UPDATED
                desc_ellipsis: 'Marca subtítulos que terminan con "..." sugiriendo una continuación.',
                desc_number_punctuation: 'Detecta la puntuación "1,234.56" típica del inglés en lugar de "1.234,56".',
                desc_units_format: 'Detecta unidades de medida (ej. "km.", "cms") que terminan en punto o están en plural.',
                desc_acronyms_format: 'Detecta siglas (ej. "F.B.I", "O N U") que incluyen puntos o espacios.',
                desc_ellipsis_char: 'Detecta el uso de tres puntos consecutivos (...) en lugar del carácter de elipsis único (…).',
                desc_dual_speaker_hyphen: "Detecta inconsistencias en el uso de guiones en subtítulos de doble hablante (ej. una línea con guion y otra sin él).",
                desc_numbers_1_to_10: 'Detecta si los números del 1 al 10 están escritos en cifras en lugar de letras (ej. "5 perros" en lugar de "cinco perros").',
                desc_four_digit_separator: 'Detecta si los números de cuatro dígitos tienen separadores (ej. "2.000" en lugar de "2000").',
                desc_semicolons: "Detecta la presencia de punto y coma (;).",
                desc_ids_sfx_format: "Detecta la presencia de texto encerrado entre [corchetes] o (paréntesis).", // UPDATED
                desc_forbidden_sequences: "Detecta secuencias de texto personalizadas (ej. '..', ',.'). Separar con espacios.", // NEW
                // Error messages
                errors: {
                    high_cps: "Velocidad de lectura alta: {cps} CPS (Máx: {max})",
                    high_wpm: "Velocidad de lectura alta: {wpm} WPM (Máx: {max})",
                    line_char_limit: "Línea {lineIndex} excede el límite de caracteres ({length} > {max})",
                    line_limit: "Excede el límite de líneas ({count} > {max})",
                    no_space_after_dash: "No hay espacio después de un guion.",
                    space_after_dash: "Contiene un espacio después de un guion.", // NEW
                    duration_too_short: "Duración demasiado corta ({duration}ms < {min}ms)",
                    duration_too_long: "Duración demasiado larga ({duration}ms > {max}ms)",
                    // --- MODIFICADO ---
                    gap_too_small: "Gap demasiado pequeño ({gap}ms). Sub {currentIndex} acaba: {endTime} / Sub {nextIndex} empieza: {startTime}.",
                    unclosed_tag: "Etiqueta <{tag}> sin cerrar.",
                    unopened_tag: "Etiqueta </{tag}> sin abrir.",
                    double_spaces: "Contiene espacios dobles o triples.",
                    missing_closing_question: "Falta signo de cierre de interrogación (?).",
                    missing_opening_question: "Falta signo de apertura de interrogación (¿).",
                    missing_closing_exclamation: "Falta signo de cierre de exclamación (!).",
                    missing_opening_exclamation: "Falta signo de apertura de exclamación (¡).",
                    lowercase_after_period: "El subtítulo comienza con minúscula después de un punto.",
                    empty_subtitle: "Subtítulo vacío.",
                    // --- MODIFICADO ---
                    overlap: "Overlap con el siguiente subtítulo (subtítulo {nextIndex}).",
                    no_space_after_period: "Un punto seguido directamente de una palabra o letra, sin espacio intermedio.",
                    unclosed_single_quote: "Comilla simple (') sin cerrar.",
                    unclosed_double_quote: "Comilla doble (\") sin cerrar.",
                    quote_punctuation: "Punto final de cita se encuentra dentro de las comillas.",
                    no_period_after_quote: "La línea termina con comillas pero no le sigue un punto.",
                    ellipsis_linking: "Contiene elipsis (...) al final de una línea (posiblemente un enlace).",
                    english_number_punctuation: "Usa puntuación de miles estilo inglés (coma como separador de miles).",
                    incorrect_unit_format: "Unidad de medida con formato incorrecto (punto o plural).",
                    incorrect_acronym_format: "Sigla con puntuación o espacios internos incorrectos.",
                    incorrect_ellipsis_char: "Usa tres puntos (...) en lugar del carácter de elipsis único (…).",
                    inconsistent_dialogue_hyphen: "Inconsistencia en guiones de diálogo de doble hablante.",
                    number_as_digit: "Número del 1 al 10 escrito en cifra en lugar de letra.",
                    four_digit_separator: "Número de cuatro dígitos con separador de miles.",
                    semicolon_present: "Contiene punto y coma (;).",
                    sfx_brackets: "Contiene acotaciones o efectos de sonido entre [corchetes] o (paréntesis).", // UPDATED
                    forbidden_sequence_found: "Secuencia(s) prohibida(s) encontrada(s): {sequences}" // NEW
                }
            }
        };

        let currentLang = 'en';

        // --- NEW: ERROR CATEGORY MAPPING ---
        const errorCategories = {
            // Rules (Blue)
            'high_cps': 'rules', 'high_wpm': 'rules', 'line_char_limit': 'rules', 'line_limit': 'rules',
            'no_space_after_dash': 'rules', 'space_after_dash': 'rules', // NEW
            'ellipsis_linking': 'rules', 'inconsistent_dialogue_hyphen': 'rules', 'sfx_brackets': 'rules',
            // Timing (Green)
            'duration_too_short': 'timing', 'duration_too_long': 'timing', 'gap_too_small': 'timing',
            'overlap': 'timing', 'empty_subtitle': 'timing',
            // Spelling (Red)
            'double_spaces': 'spelling', 'missing_closing_question': 'spelling', 'missing_opening_question': 'spelling',
            'missing_closing_exclamation': 'spelling', 'missing_opening_exclamation': 'spelling', 'no_space_after_period': 'spelling',
            'unclosed_single_quote': 'spelling', 'unclosed_double_quote': 'spelling', 'quote_punctuation': 'spelling',
            'no_period_after_quote': 'spelling', 'english_number_punctuation': 'spelling', 'incorrect_unit_format': 'spelling',
            'incorrect_acronym_format': 'spelling', 'incorrect_ellipsis_char': 'spelling', 'number_as_digit': 'spelling',
            'four_digit_separator': 'spelling', 'semicolon_present': 'spelling', 'lowercase_after_period': 'spelling',
            'forbidden_sequence_found': 'spelling', // NEW
            // Tags (Magenta)
            'unclosed_tag': 'tags', 'unopened_tag': 'tags'
        };

        // --- UPDATED: FILTER DEFINITIONS WITH CATEGORIES ---
        const filterDefinitions = [
            // Category: Rules
            { id: 'filterCps', name: 'filter_cps', desc: 'desc_cps', category: 'rules', inputs: [{type: 'number', id: 'maxCps', value: 20, title: 'Max CPS'}] },
            { id: 'filterWpm', name: 'filter_wpm', desc: 'desc_wpm', category: 'rules', inputs: [{type: 'number', id: 'maxWpm', value: 150, title: 'Max WPM'}] },
            { id: 'filterCharLimit', name: 'filter_char_limit', desc: 'desc_char_limit', category: 'rules', inputs: [{type: 'number', id: 'maxCharsPerLine', value: 42, title: 'Max chars per line'}] },
            { id: 'filterLineLimit', name: 'filter_line_limit', desc: 'desc_line_limit', category: 'rules', inputs: [{type: 'number', id: 'maxLines', value: 2, title: 'Max lines'}] },
            { id: 'filterDashSpace', name: 'filter_dash_space', desc: 'desc_dash_space', category: 'rules', inputs: [] },
            { id: 'filterSpaceAfterDash', name: 'filter_space_after_dash', desc: 'desc_space_after_dash', category: 'rules', inputs: [] }, // NEW
            { id: 'filterEllipsis', name: 'filter_ellipsis', desc: 'desc_ellipsis', category: 'rules', inputs: [] },
            { id: 'filterDualSpeakerHyphen', name: 'filter_dual_speaker_hyphen', desc: 'desc_dual_speaker_hyphen', category: 'rules', inputs: [] },
            { id: 'filterIdsSfxFormat', name: 'filter_ids_sfx_format', desc: 'desc_ids_sfx_format', category: 'rules', inputs: [] },
            // Category: Timing
            { id: 'filterDuration', name: 'filter_duration', desc: 'desc_duration', category: 'timing', inputs: [{type: 'number', id: 'minDuration', value: 1000, title: 'Min duration (ms)'}, {type: 'number', id: 'maxDuration', value: 7000, title: 'Max duration (ms)'}] },
            { id: 'filterMinGap', name: 'filter_min_gap', desc: 'desc_min_gap', category: 'timing', inputs: [
                {type: 'number', id: 'minGap', value: 100, title: 'Gap value'},
                {type: 'select', id: 'gapUnit', options: ['ms', 'frames']},
                {type: 'number', id: 'frameRate', value: 25, title: 'FPS', style: 'display:none;'}
            ] },
            { id: 'filterOverlap', name: 'filter_overlap', desc: 'desc_overlap', category: 'timing', inputs: [] },
            { id: 'filterEmptySubtitle', name: 'filter_empty_subtitle', desc: 'desc_empty_subtitle', category: 'timing', inputs: [] },
            // Category: Spelling & Punctuation
            { id: 'filterDoubleSpaces', name: 'filter_double_spaces', desc: 'desc_double_spaces', category: 'spelling', inputs: [] },
            { id: 'filterQuestionMarks', name: 'filter_question_marks', desc: 'desc_question_marks', category: 'spelling', inputs: [] },
            { id: 'filterNoSpaceAfterPeriod', name: 'filter_no_space_after_period', desc: 'desc_no_space_after_period', category: 'spelling', inputs: [] },
            { id: 'filterUnclosedQuotes', name: 'filter_unclosed_quotes', desc: 'desc_unclosed_quotes', category: 'spelling', inputs: [] },
            { id: 'filterQuotePeriod', name: 'filter_quote_period', desc: 'desc_quote_period', category: 'spelling', inputs: [] },
            { id: 'filterNoPeriodAfterQuote', name: 'filter_no_period_after_quote', desc: 'desc_no_period_after_quote', category: 'spelling', inputs: [] },
            { id: 'filterNumberPunctuation', name: 'filter_number_punctuation', desc: 'desc_number_punctuation', category: 'spelling', inputs: [] },
            { id: 'filterUnitsFormat', name: 'filter_units_format', desc: 'desc_units_format', category: 'spelling', inputs: [] },
            { id: 'filterAcronymsFormat', name: 'filter_acronyms_format', desc: 'desc_acronyms_format', category: 'spelling', inputs: [] },
            { id: 'filterEllipsisChar', name: 'filter_ellipsis_char', desc: 'desc_ellipsis_char', category: 'spelling', inputs: [] },
            { id: 'filterNumbers1to10', name: 'filter_numbers_1_to_10', desc: 'desc_numbers_1_to_10', category: 'spelling', inputs: [] },
            { id: 'filterFourDigitSeparator', name: 'filter_four_digit_separator', desc: 'desc_four_digit_separator', category: 'spelling', inputs: [] },
            { id: 'filterSemicolons', name: 'filter_semicolons', desc: 'desc_semicolons', category: 'spelling', inputs: [] },
            // NEW
            { id: 'filterForbiddenSequences', name: 'filter_forbidden_sequences', desc: 'desc_forbidden_sequences', category: 'spelling', inputs: [{type: 'text', id: 'forbiddenSequences', value: '.. ,. .? .! ?, !?', title: 'Sequences (space separated)', style: 'width: 100%;'}] },
            { id: 'filterLowercaseAfterPeriod', name: 'filter_lowercase_after_period', desc: 'desc_lowercase_after_period', category: 'spelling', inputs: [] },
            // Category: Tags & Code
            { id: 'filterUnclosedTags', name: 'filter_unclosed_tags', desc: 'desc_unclosed_tags', category: 'tags', inputs: [] }
        ];

        // --- STATE MANAGEMENT ---
        let filterStates = {};
        let filterValues = {};
        let allFiltersCheckedState = true;
        let currentModalAction = { type: null };

        function initializeFilterDefaults() {
            filterDefinitions.forEach(filter => {
                // Set default checkbox state (all true except WPM, filterSpaceAfterDash, filterForbiddenSequences)
                filterStates[filter.id] = 
                    filter.id !== 'filterWpm' && 
                    filter.id !== 'filterSpaceAfterDash' && 
                    filter.id !== 'filterForbiddenSequences';

                // Set default input values
                filter.inputs.forEach(input => {
                    filterValues[input.id] = input.value;
                });
            });
            // Specific default values for new filters
            filterValues['forbiddenSequences'] = '.. ,. .? .! ?, !?';
            allFiltersCheckedState = true;
        }

        // --- UPDATED: renderFilters with categories ---
        function renderFilters() {
            const container = document.getElementById('filters-container');
            container.innerHTML = '';
            const langDict = translations[currentLang];
            
            const categories = [...new Set(filterDefinitions.map(f => f.category))];

            categories.forEach(category => {
                const categoryTitle = document.createElement('h3');
                categoryTitle.className = `category-title ${category}`;
                categoryTitle.textContent = langDict['category_' + category] || category;
                container.appendChild(categoryTitle);

                filterDefinitions.filter(f => f.category === category).forEach(filter => {
                    const filterDiv = document.createElement('div');
                    filterDiv.className = 'flex flex-col mb-2';
                    
                    let inputsHTML = '';
                    filter.inputs.forEach(input => {
                        const value = filterValues[input.id];
                        if(input.type === 'select') {
                            inputsHTML += `<select id="${input.id}" class="ml-2 px-2 py-1 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-green-500">${input.options.map(o => `<option value="${o}" ${value == o ? 'selected' : ''}>${o}</option>`).join('')}</select>`;
                        } else {
                            // UPDATED for full-width text input
                            const inputClass = input.type === 'text' ? 'w-full mt-1' : 'w-20 ml-2';
                            const title = input.title || '';
                            const style = input.style || '';
                            inputsHTML += `<input type="${input.type}" id="${input.id}" value="${value}" class="${inputClass} px-2 py-1 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-green-500" title="${title}" style="${style}">`;
                        }
                    });

                    // UPDATED: Handle text input layout differently
                    const isTextInput = filter.inputs.some(inp => inp.type === 'text');
                    if (isTextInput) {
                        filterDiv.innerHTML = `
                            <div class="flex items-center">
                                <input type="checkbox" id="${filter.id}" class="h-4 w-4 text-green-600 rounded focus:ring-green-500" ${filterStates[filter.id] ? 'checked' : ''}>
                                <label for="${filter.id}" class="ml-2 text-gray-700 font-semibold">${langDict[filter.name]}</label>
                            </div>
                            <div class="ml-6">
                                ${inputsHTML}
                                <p class="text-xs text-gray-500 mt-1">${langDict[filter.desc]}</p>
                            </div>
                        `;
                    } else {
                         filterDiv.innerHTML = `
                            <div class="flex items-center">
                                <input type="checkbox" id="${filter.id}" class="h-4 w-4 text-green-600 rounded focus:ring-green-500" ${filterStates[filter.id] ? 'checked' : ''}>
                                <label for="${filter.id}" class="ml-2 text-gray-700 font-semibold">${langDict[filter.name]}</label>
                                ${inputsHTML}
                            </div>
                            <p class="text-xs text-gray-500 mt-1 ml-6">${langDict[filter.desc]}</p>
                        `;
                    }
                    
                    container.appendChild(filterDiv);

                    document.getElementById(filter.id).addEventListener('change', (e) => {
                        filterStates[filter.id] = e.target.checked;
                    });

                    filter.inputs.forEach(input => {
                        const inputEl = document.getElementById(input.id);
                        if (inputEl) {
                            inputEl.addEventListener('change', (e) => {
                                filterValues[input.id] = (e.target.type === 'number') ? parseFloat(e.target.value) : e.target.value;
                            });
                        }
                    });
                });
            });
            
            const gapUnitEl = document.getElementById('gapUnit');
            if (gapUnitEl) {
                gapUnitEl.addEventListener('change', function() {
                    document.getElementById('frameRate').style.display = this.value === 'frames' ? 'inline-block' : 'none';
                });
                gapUnitEl.dispatchEvent(new Event('change'));
            }
        }
        
        // Global variables
        let subtitles = [];
        let errorsFound = [];

        // DOM Elements (unchanged)
        const subtitleFile = document.getElementById('subtitleFile');
        const fileNameDisplay = document.getElementById('fileName');
        const checkButton = document.getElementById('checkButton');
        const resultsDiv = document.getElementById('results');
        const noErrorsMessage = document.getElementById('noErrorsMessage');
        const exportPdfButton = document.getElementById('exportPdfButton');
        const exportTableButton = document.getElementById('exportTableButton');
        const toggleAllFiltersButton = document.getElementById('toggleAllFiltersButton');
        const resetFiltersButton = document.getElementById('resetFiltersButton');
        const saveFiltersButton = document.getElementById('saveFiltersButton');
        const importFiltersButton = document.getElementById('importFiltersButton');
        const importFiltersInput = document.getElementById('importFiltersInput');
        
        const genericModal = document.getElementById('genericModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalFileNameLabel = document.getElementById('modalFileNameLabel');
        const modalFileNameInput = document.getElementById('modalFileName');
        const confirmModalButton = document.getElementById('confirmModalButton');
        const cancelModalButton = document.getElementById('cancelModalButton');

        // --- Core Functions (Original Logic Preserved, error adding logic changed) ---
        function formatTime(ms) { if (isNaN(ms) || ms < 0) return "00:00:00,000"; const date = new Date(ms); return `${String(date.getUTCHours()).padStart(2, '0')}:${String(date.getUTCMinutes()).padStart(2, '0')}:${String(date.getUTCSeconds()).padStart(2, '0')},${String(date.getUTCMilliseconds()).padStart(3, '0')}`; }
        function timeToMs(timeString) { const parts = timeString.match(/(\d{2}):(\d{2}):(\d{2}),(\d{3})/); if (!parts) return 0; const [, h, m, s, ms] = parts.map(Number); return (h * 3600 + m * 60 + s) * 1000 + ms; }
        
        // --- MODIFICADO (No contar \n en CPS) ---
        function calculateCps(text, durationMs) { 
            if (durationMs <= 0) return 0; 
            const cleanText = text.replace(/<[^>]*>/g, '')
                                 .replace(/\.{3}/g, '…')
                                 .replace(/\n/g, ''); // <-- MODIFICADO: No contar saltos de línea
            return cleanText.length / (durationMs / 1000); 
        }
        
        // --- MODIFICADO (Contar \n como espacio en WPM) ---
        function calculateWpm(text, durationMs) { 
            if (durationMs <= 0) return 0; 
            const cleanText = text.replace(/<[^>]*>/g, '')
                                 .replace(/\.{3}/g, '…')
                                 .replace(/\n/g, ' '); // <-- MODIFICADO: Reemplazar \n por espacio
            const words = cleanText.split(/\s+/).filter(word => word.length > 0).length; 
            return words / (durationMs / 60000); 
        }
        
        function parseSrt(srtText) {
            const entries = srtText.trim().split(/\r?\n\r?\n/);
            return entries.map((entry, index) => {
                const lines = entry.split(/\r?\n/);
                const timeMatch = lines[1] ? lines[1].match(/(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})/) : null;
                let startMs = 0, endMs = 0; if (timeMatch) { [startMs, endMs] = [timeToMs(timeMatch[1]), timeToMs(timeMatch[2])]; }
                const text = lines.slice(2).join('\n').trim();
                return { index: parseInt(lines[0], 10) || (index + 1), startMs, endMs, durationMs: endMs - startMs, text, originalLines: text.split(/\r?\n/), errors: [] };
            }).filter(sub => !isNaN(sub.index)); // Allow empty subs for empty subtitle check
        }

        function handleFileSelect(event) {
            const file = event.target.files[0]; const langDict = translations[currentLang];
            if (file) {
                fileNameDisplay.textContent = langDict.selected_file.replace('{fileName}', file.name);
                const reader = new FileReader();
                reader.onload = (e) => {
                    try { subtitles = parseSrt(e.target.result); resultsDiv.innerHTML = `<p class="text-gray-500">${subtitles.length > 0 ? langDict.file_loaded : langDict.no_valid_subs}</p>`; noErrorsMessage.classList.add('hidden'); errorsFound = [];
                    } catch (error) { resultsDiv.innerHTML = `<p class="text-red-600">${langDict.file_process_error.replace('{errorMessage}', error.message)}</p>`; subtitles = []; }
                }; reader.readAsText(file);
            }
        }
        
        function getFilterValue(id) { return filterValues[id]; }
        function isFilterChecked(id) { return filterStates[id]; }
        
        function getErrorMessage(key, params = {}) {
            let message = translations[currentLang].errors[key] || key;
            for (const p in params) { message = message.replace(`{${p}}`, params[p]); }
            return message;
        }

        function addError(sub, key, params = {}) {
            sub.errors.push({
                message: getErrorMessage(key, params),
                category: errorCategories[key] || 'default'
            });
        }

        // --- UPDATED: checkSubtitles ---
        function checkSubtitles() {
            const langDict = translations[currentLang];
            if (subtitles.length === 0) { resultsDiv.innerHTML = `<p class="text-red-600">${langDict.upload_first}</p>`; return; }

            errorsFound = [];
            
            // --- Helper function for Question Mark check ---
            const getPunctuationCount = (text) => ({
                openQ: (text.match(/¿/g) || []).length,
                closeQ: (text.match(/\?/g) || []).length,
                openE: (text.match(/¡/g) || []).length,
                closeE: (text.match(/!/g) || []).length,
            });
            // --- End Helper ---
            
            subtitles.forEach((sub, i) => {
                sub.errors = [];
                const subTextClean = sub.text.replace(/<[^>]*>/g, ''); // Clean text (no tags) for relevant checks
                
                if (isFilterChecked('filterCps')) { const cps = calculateCps(sub.text, sub.durationMs); if (cps > parseFloat(getFilterValue('maxCps'))) { addError(sub, 'high_cps', { cps: cps.toFixed(2), max: getFilterValue('maxCps') }); } }
                if (isFilterChecked('filterWpm')) { const wpm = calculateWpm(sub.text, sub.durationMs); if (wpm > parseFloat(getFilterValue('maxWpm'))) { addError(sub, 'high_wpm', { wpm: wpm.toFixed(2), max: getFilterValue('maxWpm') }); } }
                
                // --- MODIFICADO (Punto 1: Tags no cuentan en CPL) ---
                if (isFilterChecked('filterCharLimit')) { 
                    sub.originalLines.forEach((line, lineIndex) => { 
                        const cleanLine = line.replace(/<[^>]*>/g, ''); // Strip tags
                        const effectiveLength = cleanLine.replace(/\.{3}/g, '…').length; // Count ellipsis
                        if (effectiveLength > parseInt(getFilterValue('maxCharsPerLine'))) { 
                            addError(sub, 'line_char_limit', { lineIndex: lineIndex + 1, length: effectiveLength, max: getFilterValue('maxCharsPerLine') }); 
                        } 
                    }); 
                }

                if (isFilterChecked('filterLineLimit')) { if (sub.originalLines.length > parseInt(getFilterValue('maxLines'))) { addError(sub, 'line_limit', { count: sub.originalLines.length, max: getFilterValue('maxLines') }); } }
                if (isFilterChecked('filterDashSpace')) { if (sub.text.match(/-(?!\s)/) && !sub.text.match(/-\n/)) { addError(sub, 'no_space_after_dash'); } }
                if (isFilterChecked('filterSpaceAfterDash')) { if (sub.text.match(/-\s/)) { addError(sub, 'space_after_dash'); } } // NEW
                if (isFilterChecked('filterDuration')) { if (sub.durationMs < parseInt(getFilterValue('minDuration'))) { addError(sub, 'duration_too_short', { duration: sub.durationMs, min: getFilterValue('minDuration') }); } if (sub.durationMs > parseInt(getFilterValue('maxDuration'))) { addError(sub, 'duration_too_long', { duration: sub.durationMs, max: getFilterValue('maxDuration') }); } }
                
                // --- MODIFICADO (Error de Gap más detallado) ---
                if (isFilterChecked('filterMinGap') && i < subtitles.length - 1) { 
                    const nextSub = subtitles[i + 1]; 
                    let requiredGapMs; 
                    const minGapValue = parseInt(getFilterValue('minGap')); 
                    if (getFilterValue('gapUnit') === 'ms') { 
                        requiredGapMs = minGapValue; 
                    } else { 
                        const frameRateValue = parseFloat(getFilterValue('frameRate')); 
                        requiredGapMs = (minGapValue / frameRateValue) * 1000; 
                    } 
                    const actualGap = nextSub.startMs - sub.endMs; 
                    if (actualGap < requiredGapMs && actualGap >= 0) { 
                        addError(sub, 'gap_too_small', { 
                            gap: actualGap,
                            currentIndex: sub.index,
                            nextIndex: nextSub.index,
                            endTime: formatTime(sub.endMs),
                            startTime: formatTime(nextSub.startMs)
                        }); 
                    } 
                }
                
                if (isFilterChecked('filterUnclosedTags')) { ['i', 'b', 'font'].forEach(tag => { const openCount = (sub.text.match(new RegExp(`<${tag}[^>]*>`, 'g')) || []).length; const closeCount = (sub.text.match(new RegExp(`</${tag}>`, 'g')) || []).length; if (openCount > closeCount) addError(sub, 'unclosed_tag', { tag: tag }); if (closeCount > openCount) addError(sub, 'unopened_tag', { tag: tag }); }); }
                if (isFilterChecked('filterDoubleSpaces') && subTextClean.match(/\s\s+/)) { addError(sub, 'double_spaces'); }
                
                // --- (Lógica de Guille 2 - sin cambios) ---
                if (isFilterChecked('filterQuestionMarks')) {
                    let counts = getPunctuationCount(sub.text);
                    const prevSub1 = subtitles[i-1] ? getPunctuationCount(subtitles[i-1].text) : null;
                    const prevSub2 = subtitles[i-2] ? getPunctuationCount(subtitles[i-2].text) : null;
                    const nextSub1 = subtitles[i+1] ? getPunctuationCount(subtitles[i+1].text) : null;
                    const nextSub2 = subtitles[i+2] ? getPunctuationCount(subtitles[i+2].text) : null;
                    
                    if (counts.closeQ > counts.openQ) { if (prevSub1 && prevSub1.openQ > prevSub1.closeQ) counts.openQ++; else if (prevSub2 && prevSub2.openQ > prevSub2.closeQ) counts.openQ++; }
                    if (counts.openQ > counts.closeQ) { if (nextSub1 && nextSub1.closeQ > nextSub1.openQ) counts.closeQ++; else if (nextSub2 && nextSub2.closeQ > nextSub2.openQ) counts.closeQ++; }
                    if (counts.closeE > counts.openE) { if (prevSub1 && prevSub1.openE > prevSub1.closeE) counts.openE++; else if (prevSub2 && prevSub2.openE > prevSub2.closeE) counts.openE++; }
                    if (counts.openE > counts.closeE) { if (nextSub1 && nextSub1.closeE > nextSub1.openE) counts.closeE++; else if (nextSub2 && nextSub2.closeE > nextSub2.openE) counts.closeE++; }
                    
                    if (counts.openQ > counts.closeQ) addError(sub, 'missing_closing_question');
                    if (counts.closeQ > counts.openQ) addError(sub, 'missing_opening_question');
                    if (counts.openE > counts.closeE) addError(sub, 'missing_closing_exclamation');
                    if (counts.closeE > counts.openE) addError(sub, 'missing_opening_exclamation');
                }

                if (isFilterChecked('filterLowercaseAfterPeriod') && subTextClean.match(/\.\s*([a-záéíóúüñ])/)) { addError(sub, 'lowercase_after_period'); }
                if (isFilterChecked('filterEmptySubtitle') && sub.text.trim() === '') { addError(sub, 'empty_subtitle'); }
                
                // --- MODIFICADO (Error de Overlap más detallado) ---
                if (isFilterChecked('filterOverlap') && i < subtitles.length - 1) { 
                    const nextSub = subtitles[i + 1]; 
                    if (sub.endMs > nextSub.startMs) { 
                        addError(sub, 'overlap', { nextIndex: nextSub.index }); 
                    } 
                }
                
                // --- MODIFICADO (Punto 1: Tags no afectan puntuación) ---
                if (isFilterChecked('filterNoSpaceAfterPeriod')) {
                    if (subTextClean.match(/\.(?!\s|$)(?!\d)(?!\.)/g)) { // Run regex on clean text
                        addError(sub, 'no_space_after_period');
                    }
                }
                
                // --- MODIFICADO (Punto 6: Apóstrofos) ---
                if (isFilterChecked('filterUnclosedQuotes')) { 
                    // Apostrophe-safe single quote check (uses negative lookbehind/ahead)
                    const singleQuotes = (sub.text.match(/(?<!\w)'(?!\w)/g) || []).length;
                    if (singleQuotes % 2 !== 0) addError(sub, 'unclosed_single_quote');
                    // Regular double quote check:
                    if ((sub.text.match(/"/g) || []).length % 2 !== 0) addError(sub, 'unclosed_double_quote'); 
                }

                if (isFilterChecked('filterQuotePeriod') && subTextClean.match(/"\.[ \n\r]*$/)) { addError(sub, 'quote_punctuation'); }

                // --- MODIFICADO (Punto 5: Excepciones ?"/!") ---
                if (isFilterChecked('filterNoPeriodAfterQuote')) { 
                    if (sub.originalLines.some(line => {
                        const trimmedLine = line.trim();
                        // Check if it ends with " but NOT ?" or !"
                        return trimmedLine.endsWith('"') && !trimmedLine.endsWith('?"') && !trimmedLine.endsWith('!"');
                    })) { 
                        addError(sub, 'no_period_after_quote'); 
                    } 
                }

                if (isFilterChecked('filterEllipsis') && sub.originalLines.some(line => line.trim().endsWith('...'))) { addError(sub, 'ellipsis_linking'); }
                if (isFilterChecked('filterNumberPunctuation') && subTextClean.match(/\d{1,3}(,\d{3})+(\.\d+)?/)) { addError(sub, 'english_number_punctuation'); }
                if (isFilterChecked('filterUnitsFormat') && subTextClean.match(/\b(\d+(\.\d+)?\s*(km|cm|m|kg|g|L|ml|A|V|Hz)(s|\.))\b/gi)) { addError(sub, 'incorrect_unit_format'); }
                if (isFilterChecked('filterAcronymsFormat') && subTextClean.match(/\b[A-ZÑÁÉÍÓÚÄËÏÖÜ]\.([A-ZÑÁÉÍÓÚÄËÏÖÜ]\.)+\b|\b[A-ZÑÁÉÍÓÚÄËÏÖÜ]( [A-ZÑÁÉÍÓÚÄËÏÖÜ])+\b/g)) { addError(sub, 'incorrect_acronym_format'); }
                if (isFilterChecked('filterEllipsisChar') && sub.text.includes('...') && !sub.text.includes('…')) { addError(sub, 'incorrect_ellipsis_char'); }
                if (isFilterChecked('filterDualSpeakerHyphen') && sub.originalLines.length === 2) { const line1HasHyphen = sub.originalLines[0].trim().startsWith('-'); const line2HasHyphen = sub.originalLines[1].trim().startsWith('-'); if (line1HasHyphen !== line2HasHyphen) addError(sub, 'inconsistent_dialogue_hyphen'); }
                if (isFilterChecked('filterNumbers1to10') && subTextClean.match(/\b([1-9]|10)\b/g)) { addError(sub, 'number_as_digit'); }
                if (isFilterChecked('filterFourDigitSeparator') && subTextClean.match(/\b\d{1}[.,]\d{3}\b/g)) { addError(sub, 'four_digit_separator'); }
                if (isFilterChecked('filterSemicolons') && subTextClean.includes(';')) { addError(sub, 'semicolon_present'); }

                // --- MODIFICADO (Punto 8: Paréntesis en SFX) ---
                if (isFilterChecked('filterIdsSfxFormat') && (sub.text.match(/\[.*?\]/) || sub.text.match(/\(.*?\)/))) { 
                    addError(sub, 'sfx_brackets'); 
                }
                
                // --- NEW (Punto 9: Secuencias prohibidas) ---
                if (isFilterChecked('filterForbiddenSequences')) {
                    const sequences = getFilterValue('forbiddenSequences').split(' ').filter(s => s.length > 0);
                    const found = [];
                    sequences.forEach(seq => {
                        if (subTextClean.includes(seq)) {
                            found.push(seq);
                        }
                    });
                    if (found.length > 0) {
                        addError(sub, 'forbidden_sequence_found', { sequences: found.join(', ') });
                    }
                }
                
                if (sub.errors.length > 0) errorsFound.push(sub);
            });
            displayResults();
        }

        // --- UPDATED: displayResults uses category classes ---
        function displayResults() {
            resultsDiv.innerHTML = '';
            if (errorsFound.length === 0) {
                noErrorsMessage.classList.remove('hidden');
                resultsDiv.classList.add('hidden');
                return;
            }
            noErrorsMessage.classList.add('hidden');
            resultsDiv.classList.remove('hidden');
            
            errorsFound.forEach(sub => {
                const subElement = document.createElement('div');
                subElement.className = 'error-item';
                const headerText = translations[currentLang].result_subtitle_header.replace('{index}', sub.index);
                
                const errorsHtml = sub.errors.map(e => 
                    `<li class="error-category-${e.category || 'default'}">${escapeHtml(e.message)}</li>`
                ).join('');
                
                subElement.innerHTML = `
                    <p class="font-bold text-lg text-slate-700 mb-1">${headerText} (${formatTime(sub.startMs)} --> ${formatTime(sub.endMs)})</p>
                    <pre class="bg-white p-2 rounded-md border border-slate-200 text-gray-900 text-sm whitespace-pre-wrap mb-2">${escapeHtml(sub.text)}</pre>
                    <ul class="list-disc list-inside font-semibold">${errorsHtml}</ul>`;
                resultsDiv.appendChild(subElement);
            });
        }
        
        function escapeHtml(text) { return text.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'})[m]); }
        
        // --- MODAL & EXPORT/IMPORT FUNCTIONS (unchanged) ---
        function showModal(type) {
            currentModalAction.type = type; const langDict = translations[currentLang];
            if (type === 'exportPdf' || type === 'exportTable') { if (errorsFound.length === 0) return; modalTitle.textContent = langDict.export_modal_title; modalFileNameLabel.textContent = langDict.export_modal_filename; modalFileNameInput.value = langDict.default_report_name; } 
            else if (type === 'saveFilters') { modalTitle.textContent = langDict.save_modal_title; modalFileNameLabel.textContent = langDict.export_modal_filename; modalFileNameInput.value = langDict.default_filter_config_name; }
            genericModal.classList.remove('hidden');
        }
        function hideModal() { genericModal.classList.add('hidden'); }

        function exportToPdf(fileName) {
            const { jsPDF } = window.jspdf; const doc = new jsPDF(); let y = 20;
            doc.setFont('helvetica', 'bold'); doc.setFontSize(18); doc.text("SubPandaQA Error Report", 105, y, { align: 'center' }); y += 15;
            errorsFound.forEach(sub => {
                if (y > 270) { doc.addPage(); y = 20; }
                const headerText = translations[currentLang].result_subtitle_header.replace('{index}', sub.index);
                doc.setFont('helvetica', 'bold'); doc.setFontSize(12); doc.text(`${headerText} (${formatTime(sub.startMs)} --> ${formatTime(sub.endMs)})`, 10, y); y += 7;
                doc.setFont('helvetica', 'normal'); doc.setFontSize(10); const textLines = doc.splitTextToSize(sub.text, 180); doc.text(textLines, 15, y); y += textLines.length * 5 + 2;
                sub.errors.forEach(error => {
                    const color = { rules: [52, 152, 219], timing: [46, 204, 113], spelling: [231, 76, 60], tags: [155, 89, 182], default: [0,0,0] }[error.category];
                    doc.setTextColor(color[0], color[1], color[2]);
                    const errorLines = doc.splitTextToSize(`- ${error.message}`, 175);
                    doc.text(errorLines, 20, y); y += errorLines.length * 5;
                });
                doc.setTextColor(0, 0, 0); y += 5;
            });
            doc.save(`${fileName || 'SubPandaQA_Report'}.pdf`);
        }

        function exportToTable(fileName) {
            let tableHtml = `<thead><tr><th>ID</th><th>Timestamps</th><th>Text</th><th>Errors</th></tr></thead><tbody>`;
            errorsFound.forEach(sub => {
                const headerText = translations[currentLang].result_subtitle_header.replace('{index}', sub.index);
                tableHtml += `<tr><td>${headerText}</td><td>${formatTime(sub.startMs)} --> ${formatTime(sub.endMs)}</td><td><pre>${escapeHtml(sub.text)}</pre></td><td><ul>${sub.errors.map(e => `<li style="color:var(--color-${e.category})">${escapeHtml(e.message)}</li>`).join('')}</ul></td></tr>`;
            });
            const newWindow = window.open();
            newWindow.document.write(`<style>:root{--color-rules:#3498DB;--color-timing:#2ECC71;--color-spelling:#E74C3C;--color-tags:#9B59B6;--color-default:#475569;}body{font-family:sans-serif}table{border-collapse:collapse;width:100%}th,td{border:1px solid #ddd;padding:8px}tr:nth-child(even){background-color:#f2f2f2}pre{white-space:pre-wrap}</style><h2>${fileName || 'Error Report'}</h2><table>${tableHtml}</tbody></table>`);
            newWindow.document.close();
        }

        function saveFiltersConfig(fileName) {
            const settings = { filterStates, filterValues }; const blob = new Blob([JSON.stringify(settings, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `${fileName || 'filter-settings'}.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function handleImportFilters(event) {
            const file = event.target.files[0]; if (!file) return; const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const settings = JSON.parse(e.target.result);
                    if (settings.filterStates && settings.filterValues) { filterStates = settings.filterStates; filterValues = settings.filterValues; renderFilters(); } 
                    else { alert('Invalid filter configuration file.'); }
                } catch (error) { alert('Error reading or parsing the file.'); }
            };
            reader.readAsText(file); event.target.value = '';
        }
        
        // --- EVENT LISTENERS ---
        function setLanguage(lang) {
            currentLang = lang; document.documentElement.lang = lang;
            document.querySelectorAll('[data-lang]').forEach(el => { const key = el.getAttribute('data-lang'); if (translations[lang][key]) { el.textContent = translations[lang][key]; } });
            document.getElementById('lang-en').classList.toggle('active', lang === 'en'); document.getElementById('lang-es').classList.toggle('active', lang === 'es');
            renderFilters();
        }

        subtitleFile.addEventListener('change', handleFileSelect);
        checkButton.addEventListener('click', checkSubtitles);
        exportPdfButton.addEventListener('click', () => showModal('exportPdf'));
        exportTableButton.addEventListener('click', () => showModal('exportTable'));
        saveFiltersButton.addEventListener('click', () => showModal('saveFilters'));
        importFiltersButton.addEventListener('click', () => importFiltersInput.click());
        importFiltersInput.addEventListener('change', handleImportFilters);
        document.getElementById('lang-en').addEventListener('click', () => setLanguage('en'));
        document.getElementById('lang-es').addEventListener('click', () => setLanguage('es'));
        toggleAllFiltersButton.addEventListener('click', () => { allFiltersCheckedState = !allFiltersCheckedState; Object.keys(filterStates).forEach(id => filterStates[id] = allFiltersCheckedState); renderFilters(); });
        resetFiltersButton.addEventListener('click', () => { initializeFilterDefaults(); renderFilters(); });
        cancelModalButton.addEventListener('click', hideModal);
        confirmModalButton.addEventListener('click', () => {
            const fileName = modalFileNameInput.value;
            switch (currentModalAction.type) { case 'exportPdf': exportToPdf(fileName); break; case 'exportTable': exportToTable(fileName); break; case 'saveFilters': saveFiltersConfig(fileName); break; }
            hideModal();
        });

        document.addEventListener('DOMContentLoaded', () => {
            initializeFilterDefaults();
            setLanguage('en'); // Set default language on load
        });

    </script>
</body>
</html>
