<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">subpandaTM</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    <!-- Dexie.js for IndexedDB management -->
    <script src="https://unpkg.com/dexie@latest/dist/dexie.js"></script>
    <!-- JSZip for project packaging -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* General styles for body and font */
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: #f3f4f6;
            color: #202020;
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow: hidden;
        }

        /* Ensures preformatted text respects line breaks and doesn't overflow */
        pre {
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Style for the check icon (SVG) */
        .check-icon {
            display: none;
            margin-left: 8px;
            vertical-align: middle;
            width: 20px;
            height: 20px;
            color: #22c55e;
        }

        /* --- UNIFIED BUTTON STYLES --- */
        .btn {
            padding: 0.25rem 0.75rem; /* Reduced padding */
            font-size: 0.875rem; /* Smaller font size */
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid transparent;
            white-space: nowrap;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Primary button style */
        .btn-primary {
            background-color: #075BA2;
            color: white;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #064f8a;
        }

        /* Secondary button style */
        .btn-secondary {
            background-color: #e5e7eb;
            color: #1f2937;
            border-color: #d1d5db;
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: #d1d5db;
        }

        /* Destructive button style */
        .btn-destructive {
            background-color: #ef4444;
            color: white;
        }
        .btn-destructive:hover:not(:disabled) {
            background-color: #dc2626;
        }
        
        /* Language button style */
        .btn-lang {
            background-color: #f3f4f6;
            color: #4b5563;
            padding: 0.25rem 0.75rem;
        }
        .btn-lang.active {
            background-color: #075BA2;
            color: white;
            font-weight: 700;
        }


        /* Specific styles for code display fields (original, translation) */
        .subtitle-display-code {
            background-color: #e3e3e3;
            border: 1px solid #000;
            color: #202020;
        }
        .subtitle-editor {
            background-color: #ffffff;
            color: #000000;
            min-height: 50px;
            border: 1px solid #d1d5db;
            padding: 0.5rem;
            border-radius: 0.375rem;
        }
        .subtitle-editor[contenteditable="false"] {
            background-color: #f3f4f6;
        }

        /* Background of translation units */
        .translation-unit-bg {
            background-color: #f8f8f8;
            border-color: #e5e7eb;
        }

        /* 2-column layout classes */
        .translation-row {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        @media (min-width: 768px) {
            .translation-row {
                flex-direction: row;
            }
            .original-col, .translation-col {
                flex: 1;
            }
        }

        /* Modal (pop-up) styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            width: 500px;
        }
        #shortcutsModal .modal-content,
        #findReplaceModal .modal-content {
            width: 650px;
            max-width: 95%;
        }
        .shortcut-icon {
            display: inline-block;
            width: 1em;
            height: 1em;
            vertical-align: middle;
            margin: 0 4px;
        }
        .shortcut-input {
            border: 1px solid #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: #f9f9f9;
            cursor: pointer;
            text-align: center;
            min-width: 120px;
            display: inline-block;
        }
        .shortcut-input.recording {
            background-color: #fffbe6;
            border-color: #facc15;
        }

        /* --- START: Floating Panel Styles --- */
        .floating-panel {
            position: fixed;
            width: 480px;
            min-width: 300px; /* Smaller min-width */
            max-width: 80vw;
            height: 400px; /* Default height */
            min-height: 250px; /* Smaller min-height */
            background-color: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 950;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Changed from resize: both */
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

        .floating-panel.is-visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        /* Default position classes */
        .panel-bottom-left { bottom: 20px; left: 20px; top: auto; right: auto; }
        .panel-bottom-right { bottom: 20px; right: 20px; top: auto; left: auto; }

        .floating-panel .sidebar-header {
            cursor: move;
            background-color: #f9fafb;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e5e7eb;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .floating-panel .sidebar-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        /* Resizer handles for floating panels */
        .resizer {
            position: absolute;
            background: transparent;
        }
        .resizer-t { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .resizer-b { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .resizer-l { left: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
        .resizer-r { right: -5px; top: 0; bottom: 0; width: 10px; cursor: ew-resize; }
        .resizer-tl { top: -5px; left: -5px; width: 10px; height: 10px; cursor: nwse-resize; }
        .resizer-tr { top: -5px; right: -5px; width: 10px; height: 10px; cursor: nesw-resize; }
        .resizer-bl { bottom: -5px; left: -5px; width: 10px; height: 10px; cursor: nesw-resize; }
        .resizer-br { bottom: -5px; right: -5px; width: 10px; height: 10px; cursor: nwse-resize; }
        /* --- END: Floating Panel Styles --- */


        /* Glossary/TM specific styles */
        .glossary-input-group input, .glossary-input-group select,
        .tm-input-group input, .tm-input-group select,
        .qa-input-group input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9rem;
            margin-top: 4px;
            color: #202020;
            background-color: #fff;
        }
        .glossary-info-box, .tm-info-box {
            background-color: #f0f8ff;
            border: 1px solid #d0e8f8;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            color: #333;
        }
        .glossary-highlight {
            background-color: #ffcc00;
            padding: 0 2px;
            border-radius: 3px;
        }
        .glossary-row-highlight {
            background-color: #ffcc00 !important;
            transition: background-color 0.3s ease;
        }

        /* Active translation unit highlight */
        .translation-unit-active {
            border: 2px solid #075BA2;
            box-shadow: 0 0 0 3px rgba(7, 91, 162, 0.25);
        }

        /* Loading Overlay Styles */
        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1001; font-size: 1.2rem; color: #333;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db;
            border-radius: 50%; width: 40px; height: 40px;
            animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Accordion styles */
        .accordion-item { border: 1px solid #e5e7eb; border-radius: 0.5rem; overflow: hidden; margin-bottom: 1rem; }
        .accordion-header { display: flex; align-items: center; justify-content: space-between; cursor: pointer; padding: 0.75rem 1rem; background-color: #f9fafb; border-bottom: 1px solid #e5e7eb; user-select: none; }
        .accordion-header:hover { background-color: #f3f4f6; color: #075BA2; }
        .accordion-icon { transition: transform 0.3s ease; }
        .accordion-icon.rotated { transform: rotate(180deg); }
        .accordion-content { overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; padding: 0 1rem; }
        .accordion-content.collapsed { max-height: 0; padding-top: 0; padding-bottom: 0; }
        .accordion-content.expanded { max-height: 500px; padding-top: 1rem; padding-bottom: 1rem; }

        /* TM Table styles */
        .tm-table {
            table-layout: fixed;
            width: 100%;
        }
        .tm-table th:nth-child(1), .tm-table td:nth-child(1) { width: 15%; text-align: center; }
        .tm-table th:nth-child(2), .tm-table td:nth-child(2),
        .tm-table th:nth-child(3), .tm-table td:nth-child(3) {
            width: 42.5%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        .tm-best-match-highlight { background-color: #d1fae5 !important; border-color: #10b981 !important; border-width: 2px; box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.25); }
        
        /* Diff styles */
        .diff-deletion { background-color: #fdd; text-decoration: line-through; }
        .diff-insertion { background-color: #dfd; }

        /* QA Error Styles */
        .qa-error { color: #ef4444; font-weight: 700; }
        .qa-success { color: #22c55e; font-weight: 700; }
        #qaErrorStats.clickable { cursor: pointer; text-decoration: underline; }
        .qa-error-item { padding: 0.5rem; border-bottom: 1px solid #e5e7eb; cursor: pointer; transition: background-color 0.2s; }
        .qa-error-item:hover { background-color: #f3f4f6; }
        #qaErrorListContainer { max-height: 60vh; overflow-y: auto; }

        /* Header styles */
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 900;
            flex-wrap: wrap;
        }
        .header-main-actions {
            display: flex;
            flex-grow: 1;
            justify-content: center;
            gap: 0.5rem; /* Reduced gap for smaller buttons */
            flex-wrap: wrap;
        }
        .header-lang-switcher {
            display: flex;
            gap: 0.5rem;
        }

        /* Main content area */
        .main-app-content { display: flex; flex-direction: column; flex-grow: 1; padding: 1rem; gap: 1rem; }
        .editor-and-sidebars-wrapper { display: flex; flex-direction: column; flex-grow: 1; gap: 1rem; position: relative; }
        #horizontal-resizer { width: 10px; height: auto; cursor: col-resize; background-color: #e5e7eb; border-left: 1px solid #d1d5db; border-right: 1px solid #d1d5db; }
        #horizontal-resizer:hover { background-color: #d1d5db; }

        /* Editor Scroll Arrow */
        #editorScrollIndicator {
            position: absolute;
            bottom: 15px;
            right: 5px; /* Adjust to not overlap with scrollbar */
            width: 32px;
            height: 32px;
            background-color: rgba(7, 91, 162, 0.6);
            color: white;
            border-radius: 50%;
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
            animation: bounce 2s infinite;
        }
        .editor-main-content.is-scrollable #editorScrollIndicator {
            display: flex;
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }


        @media (min-width: 1024px) {
            .main-app-content { flex-direction: row; align-items: stretch; gap: 0; }
            .video-player-section { flex-shrink: 0; flex-basis: 33%; position: sticky; top: 60px; align-self: flex-start; }
            .right-panel-content { flex-grow: 1; display: flex; flex-direction: column; gap: 0; }
            .editor-and-sidebars-wrapper { flex-direction: column; flex-grow: 1; display: flex; }
            /* Let the editor grow to fill the available space */
            .editor-main-content { flex-grow: 1; overflow-y: auto; }
            /* Hide the old sidebar container and its resizer */
            .sidebars-container, #vertical-resizer { display: none; }
        }

        /* Video player styles */
        #videoPlayerContainer { width: 100%; background-color: #000; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem; gap: 1rem; }
        #videoPlayerWrapper { position: relative; width: 100%; line-height: 0; background-color: #000; border-radius: 0.5rem; min-height: 250px; }
        #videoPlayer { width: 100%; height: auto; max-height: 60vh; border-radius: 0.5rem; }
        #subtitlePreviewOverlay { position: absolute; bottom: 5%; left: 0; right: 0; padding: 1rem; text-align: center; pointer-events: none; transition: opacity 0.3s ease; }
        #subtitlePreviewText { font-weight: bold; color: white; background-color: rgba(0, 0, 0, 0.6); padding: 0.25em 0.5em; border-radius: 0.25rem; line-height: 1.4; text-shadow: 1px 1px 3px rgba(0,0,0,0.8); white-space: pre-wrap; }
        #videoFileInput { display: none; }

        /* Animation for Restore button */
        @keyframes pulse-yellow { 0%, 100% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.7); } 50% { box-shadow: 0 0 0 8px rgba(250, 204, 21, 0); } }
        .animate-pulse-yellow { animation: pulse-yellow 2s infinite; }
    </style>
</head>
<body class="bg-gray-100">
    <!-- Header Section -->
    <header class="app-header">
        <div class="header-main-actions">
            <!-- Project Dropdown Menu -->
            <div class="relative group">
                <button class="btn btn-primary">
                    <span data-i18n="project_menu">Proyecto</span>
                    <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </button>
                <div class="absolute z-10 -left-2 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform-gpu group-hover:scale-100 scale-95">
                    <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="options-menu">
                        <button id="newProjectBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
                            <span data-i18n="new_project">Nuevo proyecto</span>
                        </button>
                        <label for="projectFile" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 cursor-pointer" role="menuitem">
                            <span data-i18n="load_project">Cargar proyecto</span>
                            <input type="file" id="projectFile" accept=".subpanda" class="hidden">
                        </label>
                        <button id="saveProjectBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 disabled:text-gray-400" role="menuitem" disabled>
                            <span data-i18n="save_project">Guardar proyecto</span>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Existing Buttons -->
            <label for="srtFile" class="btn btn-secondary">
                <span data-i18n="import_srt">Importar .srt</span>
                <input type="file" id="srtFile" accept=".srt" class="hidden">
            </label>
            <button id="saveSrt" class="btn btn-secondary" disabled>
                <span data-i18n="export_srt">Exportar .srt</span>
            </button>
            <button id="terminologyBtn" class="btn btn-secondary">
                <span data-i18n="terminology_btn">Terminología</span>
            </button>
            <button id="tmBtn" class="btn btn-secondary">
                <span data-i18n="tm_btn">Memoria de traducción</span>
            </button>
            <button id="findReplaceBtn" class="btn btn-secondary">
                <span data-i18n="find_replace_btn">Buscar y reemplazar</span>
            </button>
            <button id="qaBtn" class="btn btn-secondary">
                <span data-i18n="qa_btn">QA</span>
            </button>
            <button id="shortcutsBtn" class="btn btn-secondary">
                <span data-i18n="shortcuts_btn">Atajos</span>
            </button>
            <button id="resetPanelsBtn" class="btn btn-secondary" title="Restaurar paneles">
                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-counterclockwise" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2z"/>
                    <path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466"/>
                </svg>
            </button>
            <button id="backupBtn" class="btn btn-secondary">
                <span data-i18n="backup_btn">Copia de seguridad</span>
            </button>
        </div>
        <div class="header-lang-switcher">
            <button id="lang-es" class="btn btn-lang active">ES</button>
            <button id="lang-en" class="btn btn-lang">EN</button>
        </div>
    </header>

    <!-- Main Application Content Area -->
    <div class="main-app-content">
        <!-- Video Player Section -->
        <div class="video-player-section flex flex-col items-center justify-center p-4">
            <div id="videoPlayerContainer" class="w-full hidden">
                <div id="videoPlayerWrapper" class="relative bg-black rounded-lg">
                    <video id="videoPlayer" controls class="hidden w-full h-auto max-h-[60vh] rounded-lg"></video>
                    <div id="videoLogoPlaceholder" class="absolute inset-0 flex items-center justify-center pointer-events-none">
                         <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/subpandatm-logo.png" alt="subpandaTM Logo" class="h-24 w-auto opacity-75">
                    </div>
                    <div id="subtitlePreviewOverlay">
                        <span id="subtitlePreviewText"></span>
                    </div>
                </div>
                <div id="videoControls" class="w-full mt-4 flex flex-col items-center gap-4">
                    <label for="videoFileInput" id="loadVideoBtn" class="btn btn-primary">
                        <span data-i18n="load_video">Cargar vídeo</span>
                        <input type="file" id="videoFileInput" accept="video/*" class="hidden">
                    </label>
                    <div class="flex items-center gap-2 text-white">
                        <label for="subtitleFontSize" class="text-sm font-medium" data-i18n="preview_size">Tamaño:</label>
                        <input type="range" id="subtitleFontSize" min="12" max="48" value="24" class="w-24">
                    </div>
                    <div class="flex items-center gap-2 text-white">
                        <label for="subtitlePreviewSource" class="text-sm font-medium" data-i18n="preview_source">Mostrar:</label>
                        <select id="subtitlePreviewSource" class="bg-gray-700 text-white text-sm rounded-md p-1 border border-gray-500">
                            <option value="translation" data-i18n="translation_text_option">Traducción</option>
                            <option value="original" data-i18n="original_text_option">Original</option>
                        </select>
                    </div>
                </div>
            </div>
            <!-- Statistics Display -->
            <div id="statsContainer" class="bg-white p-4 rounded-lg shadow-xl w-full mt-4 relative hidden">
                <div class="accordion-item">
                    <div class="accordion-header" id="statsAccordionHeader">
                        <h3 class="text-lg font-bold" data-i18n="translation_stats_title">Estadísticas</h3>
                        <svg class="w-5 h-5 accordion-icon rotated" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </div>
                    <div class="accordion-content collapsed" id="statsAccordionContent">
                        <div class="bg-gray-100 p-3 rounded-md shadow-sm text-sm text-center space-y-1">
                            <p><span id="segmentsProgress"></span></p>
                            <p><span id="wordsTranslated"></span> / <span id="wordsTotal"></span></p>
                            <p><span id="wordsRemaining"></span></p>
                            <p id="qaErrorStats"></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="horizontal-resizer"></div>

        <!-- Right Panel Content -->
        <div class="right-panel-content">
            <div class="editor-and-sidebars-wrapper" id="editorAndSidebarsWrapper">
                <!-- Translation Content (Main Editor) -->
                <div class="editor-main-content space-y-4 pr-2" id="editorMainContent">
                    <div id="translationsContainer">
                        <div data-i18n="no_translations" id="initialMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md">
                           Importa un archivo .srt y un vídeo para empezar a trabajar. Si lo deseas, puedes trabajar con una memoria de traducción TMX y un glosario TBX, que puedes importar o crear desde cero.
                        </div>
                    </div>
                </div>
                <!-- Scroll Down Indicator -->
                <div id="editorScrollIndicator">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-arrow-down" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"/>
                    </svg>
                </div>

                <div id="vertical-resizer"></div>

                <!-- Sidebars Container (now empty, hidden by CSS) -->
                <div class="sidebars-container">
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Panels (moved outside the main layout) -->
    <!-- Terminology Panel -->
    <div id="terminologySidebar" class="floating-panel panel-bottom-left">
        <div class="resizer resizer-t"></div><div class="resizer resizer-r"></div><div class="resizer resizer-b"></div><div class="resizer resizer-l"></div>
        <div class="resizer resizer-tl"></div><div class="resizer resizer-tr"></div><div class="resizer resizer-bl"></div><div class="resizer resizer-br"></div>
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="terminology_sidebar_title">Terminología</h3>
            <button id="closeTerminologySidebarBtn" class="text-gray-500 hover:text-gray-700">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="sidebar-content">
            <div id="terminologyLanguageConfigSection" class="space-y-4">
                <h4 class="text-md font-semibold mb-2" data-i18n="config_lang_title">Configurar idiomas del glosario</h4>
                <div class="glossary-info-box mb-4">
                    <p data-i18n="config_lang_info"></p>
                </div>
                <div class="flex flex-col space-y-2 mb-4">
                    <div class="glossary-input-group">
                        <label for="configSrcLang" data-i18n="source_language">Idioma de origen:</label>
                        <input id="configSrcLang" list="isoLanguages" value="en-US" class="block w-full rounded-md" />
                    </div>
                    <div class="glossary-input-group">
                        <label for="configTgtLang" data-i18n="target_language">Idioma de destino:</label>
                        <input id="configTgtLang" list="isoLanguages" value="es-ES" class="block w-full rounded-md" />
                    </div>
                    <button onclick="confirmGlossaryLanguages()" data-i18n="confirm_languages" class="btn btn-primary w-full">Confirmar idiomas</button>
                </div>
            </div>

            <div id="terminologyEditorSection" style="display:none;">
                <div class="flex flex-col sm:flex-row gap-2 mb-4">
                    <button onclick="loadTBX()" data-i18n="import_tbx" class="btn btn-secondary flex-1 text-sm">Importar TBX</button>
                    <input type="file" id="tbxFileInput" accept=".xml,.tbx" class="hidden" />
                    <button onclick="downloadTBX()" data-i18n="download_tbx" class="btn btn-secondary flex-1 text-sm">Descargar TBX</button>
                    <button onclick="resetGlossary()" data-i18n="new_glossary" class="btn btn-secondary flex-1 text-sm">Nuevo glosario</button>
                </div>
                <h4 class="text-md font-semibold mb-2" data-i18n="current_lang_title">Idiomas actuales del glosario</h4>
                <div class="flex space-x-2 mb-4">
                    <div class="glossary-input-group flex-1">
                        <label data-i18n="source_language">Idioma de origen:</label>
                        <input id="displaySrcLang" disabled class="block w-full rounded-md" />
                    </div>
                    <div class="glossary-input-group flex-1">
                        <label data-i18n="target_language">Idioma de destino:</label>
                        <input id="displayTgtLang" disabled class="block w-full rounded-md" />
                    </div>
                </div>
                <div class="accordion-item">
                    <div class="accordion-header" id="addTermHeader">
                        <h4 class="text-md font-semibold m-0" data-i18n="add_term_title">Añadir término</h4>
                        <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </div>
                    <div class="accordion-content collapsed" id="addTermContent">
                        <div class="flex flex-col space-y-2 mb-4">
                            <div class="glossary-input-group">
                                <label for="srcTerm" data-i18n="term">Término:</label>
                                <input id="srcTerm" class="block w-full rounded-md" />
                            </div>
                            <div class="glossary-input-group">
                                <label for="tgtTerm" data-i18n="translation">Traducción:</label>
                                <input id="tgtTerm" class="block w-full rounded-md" />
                            </div>
                            <button onclick="addTerm()" data-i18n="add_button" class="btn btn-primary w-full">Añadir</button>
                        </div>
                    </div>
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="search_title">Buscar</h4>
                <div class="mb-4">
                    <input id="searchTerm" data-i18n-placeholder="search_placeholder" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white" oninput="renderGlossary()" />
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="glossary_list_title">Glosario</h4>
                <div class="overflow-x-auto">
                    <table class="w-full">
                        <thead>
                            <tr>
                                <th data-i18n="source_term_col">Término de origen</th>
                                <th data-i18n="target_term_col">Término de destino</th>
                                <th data-i18n="actions_col">Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="glossaryTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
        <datalist id="isoLanguages"></datalist>
    </div>

    <!-- Translation Memory Panel -->
    <div id="translationMemorySidebar" class="floating-panel panel-bottom-right">
        <div class="resizer resizer-t"></div><div class="resizer resizer-r"></div><div class="resizer resizer-b"></div><div class="resizer resizer-l"></div>
        <div class="resizer resizer-tl"></div><div class="resizer resizer-tr"></div><div class="resizer resizer-bl"></div><div class="resizer resizer-br"></div>
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="tm_sidebar_title">Memoria de traducción</h3>
            <button id="closeTranslationMemorySidebarBtn" class="text-gray-500 hover:text-gray-700">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="sidebar-content">
            <div id="tmInternalMessage" class="tm-info-box mb-4 hidden"></div>
            <div id="tmLanguageConfigSection" class="space-y-4">
                <h4 class="text-md font-semibold mb-2" data-i18n="tm_config_lang_title">Configurar idiomas de la TM</h4>
                <div class="tm-info-box mb-4">
                    <p data-i18n="tm_config_lang_info"></p>
                </div>
                <div class="flex flex-col space-y-2 mb-4">
                    <div class="tm-input-group">
                        <label for="tmConfigSrcLang" data-i18n="source_language">Idioma de origen:</label>
                        <input id="tmConfigSrcLang" list="isoLanguages" value="en-US" class="block w-full rounded-md" />
                    </div>
                    <div class="tm-input-group">
                        <label for="tmConfigTgtLang" data-i18n="target_language">Idioma de destino:</label>
                        <input id="tmConfigTgtLang" list="isoLanguages" value="es-ES" class="block w-full rounded-md" />
                    </div>
                    <button onclick="confirmTMLanguages()" data-i18n="confirm_languages" class="btn btn-primary w-full">Confirmar idiomas</button>
                </div>
            </div>

            <div id="tmEditorSection" style="display:none;">
                <div class="flex flex-col sm:flex-row gap-2 mb-4">
                    <button onclick="resetTM()" data-i18n="new_tm" class="btn btn-secondary flex-1 text-sm">Nueva TM</button>
                    <label for="tmFileInput" class="btn btn-secondary flex-1 text-sm text-center">
                        <span data-i18n="import_tmx">Importar TMX</span>
                        <input type="file" id="tmFileInput" accept=".xml,.tmx" class="hidden" />
                    </label>
                    <button onclick="downloadTMX()" data-i18n="download_tmx" class="btn btn-secondary flex-1 text-sm">Descargar TMX</button>
                </div>
                <h4 class="text-md font-semibold mb-2" data-i18n="current_tm_lang_title">Idiomas actuales de la TM</h4>
                <div class="flex space-x-2 mb-4">
                    <div class="tm-input-group flex-1">
                        <label data-i18n="source_language">Idioma de origen:</label>
                        <input id="displayTmSrcLang" disabled class="block w-full rounded-md" />
                    </div>
                    <div class="tm-input-group flex-1">
                        <label data-i18n="target_language">Idioma de destino:</label>
                        <input id="displayTmTgtLang" disabled class="block w-full rounded-md" />
                    </div>
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="tm_search_title">Buscar en TM</h4>
                <div class="mb-4">
                    <input id="tmSearchInput" data-i18n-placeholder="tm_search_placeholder" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white" oninput="tmSearch()" />
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="tm_search_results_title">Resultados de búsqueda en TM</h4>
                <div class="overflow-x-auto mb-4">
                    <table class="tm-table w-full">
                        <thead>
                            <tr>
                                <th data-i18n="tm_score_col">%</th>
                                <th data-i18n="tm_original_col">Original</th>
                                <th data-i18n="tm_translation_col">Traducción</th>
                            </tr>
                        </thead>
                        <tbody id="tmSearchResultsTableBody"></tbody>
                    </table>
                </div>
                <div data-i18n="tm_no_match_found" id="tmNoMatchFoundMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md hidden">
                    No se encontraron coincidencias en la TM.
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="messageBox" class="modal hidden">
        <div class="modal-content">
            <p id="messageText" class="text-lg font-semibold mb-4"></p>
            <button id="messageClose" class="btn btn-primary w-full" data-i18n="ok">OK</button>
        </div>
    </div>
    
    <!-- Shortcuts Modal -->
    <div id="shortcutsModal" class="modal hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 data-i18n="shortcuts_title" class="text-xl font-bold">Atajos de teclado</h2>
                <div class="flex gap-2">
                    <label for="importShortcutsInput" class="btn btn-secondary text-sm" data-i18n="import_shortcuts_btn">Importar</label>
                    <input type="file" id="importShortcutsInput" class="hidden" accept=".json">
                    <button id="exportShortcutsBtn" class="btn btn-secondary text-sm" data-i18n="export_shortcuts_btn">Exportar</button>
                </div>
            </div>
            <div id="shortcutsList" class="space-y-2 max-h-[60vh] overflow-y-auto pr-2">
                <!-- Shortcut items will be dynamically generated here -->
            </div>
            <div class="flex justify-between items-center mt-6">
                <button id="restoreShortcutsBtn" class="btn btn-destructive" data-i18n="restore_defaults_btn">Restaurar valores por defecto</button>
                <button id="shortcutsCloseBtn" class="btn btn-primary" data-i18n="close_btn">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="findReplaceModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="find_replace_title" class="text-xl font-bold mb-4">Buscar y reemplazar</h2>
            <div class="space-y-4">
                <div>
                    <label for="findInput" data-i18n="find_label" class="block text-sm font-medium mb-1">Buscar:</label>
                    <input type="text" id="findInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div>
                    <label for="replaceInput" data-i18n="replace_label" class="block text-sm font-medium mb-1">Reemplazar con:</label>
                    <input type="text" id="replaceInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex items-center space-x-4">
                    <label class="flex items-center">
                        <input type="checkbox" id="caseSensitiveCheckbox" class="mr-2 rounded">
                        <span data-i18n="case_sensitive">Distinguir mayúsculas y minúsculas</span>
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" id="regexCheckbox" class="mr-2 rounded">
                        <span data-i18n="regular_expression">Expresión regular</span>
                    </label>
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="findPrevBtn" class="btn btn-secondary" data-i18n="find_prev">Buscar anterior</button>
                    <button id="findNextBtn" class="btn btn-secondary" data-i18n="find_next">Buscar siguiente</button>
                    <button id="replaceBtn" class="btn btn-primary" data-i18n="replace">Reemplazar</button>
                    <button id="replaceAllBtn" class="btn btn-destructive" data-i18n="replace_all">Reemplazar todo</button>
                </div>
            </div>
            <button id="findReplaceCloseBtn" class="btn btn-secondary w-full mt-6" data-i18n="close_btn">Cerrar</button>
        </div>
    </div>
    <div id="saveSrtModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_srt_title" class="text-xl font-bold mb-4">Exportar Archivo SRT</h2>
            <div class="space-y-4">
                <div>
                    <label for="fileNameInput" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="fileNameInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>
    <!-- START: New Modals for TBX/TMX Download -->
    <div id="saveTbxModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_tbx_title" class="text-xl font-bold mb-4">Exportar Archivo TBX</h2>
            <div class="space-y-4">
                <div>
                    <label for="fileNameInputTbx" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="fileNameInputTbx" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveTbxBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveTbxBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>

    <div id="saveTmxModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_tmx_title" class="text-xl font-bold mb-4">Exportar Archivo TMX</h2>
            <div class="space-y-4">
                <div>
                    <label for="fileNameInputTmx" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="fileNameInputTmx" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveTmxBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveTmxBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>
    <!-- END: New Modals for TBX/TMX Download -->
    <div id="backupModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="backup_modal_title" class="text-xl font-bold mb-4">Copia de Seguridad</h2>
            <div id="backupFoundView">
                <div id="backupInfo" class="bg-gray-100 p-4 rounded-md mb-4">
                    <p data-i18n="restore_backup_info"></p>
                    <p><strong><span data-i18n="file_label"></span></strong> <span id="backupFileName"></span></p>
                    <p><strong><span data-i18n="last_modified_label"></span></strong> <span id="backupLastModified"></span></p>
                </div>
                <div class="flex justify-end space-x-2 flex-wrap gap-2">
                    <button data-i18n="export_srt_btn" id="exportSrtFromBackupBtn" class="btn btn-primary">Exportar SRT</button>
                    <button data-i18n="delete_backup_btn" id="deleteBackupBtn" class="btn btn-destructive">Borrar Backup</button>
                    <button data-i18n="restore_btn" id="confirmRestoreBtn" class="btn btn-primary">Restaurar</button>
                </div>
            </div>
            <div id="noBackupFoundView" class="hidden">
                 <p data-i18n="no_backup_found_info"></p>
            </div>
            <button data-i18n="close_btn" id="closeBackupModalBtn" class="btn btn-secondary w-full mt-6">Cerrar</button>
        </div>
    </div>
    <div id="qaModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="qa_modal_title" class="text-xl font-bold mb-4">Configuración de QA</h2>
            <div class="space-y-4">
                <div class="qa-input-group">
                    <label for="qaCpsLimit" data-i18n="cps_limit_label" class="block text-sm font-medium mb-1">Límite de CPS:</label>
                    <input type="number" id="qaCpsLimit" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="qa-input-group">
                    <label for="qaCharsPerLineLimit" data-i18n="chars_per_line_limit_label" class="block text-sm font-medium mb-1">Límite de caracteres por línea:</label>
                    <input type="number" id="qaCharsPerLineLimit" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
            </div>
            <div class="flex justify-end space-x-2 mt-6">
                 <button id="closeQaModalBtn" class="btn btn-secondary" data-i18n="close_btn">Cerrar</button>
                <button id="saveQaSettingsBtn" class="btn btn-primary" data-i18n="save_and_apply_btn">Guardar y aplicar</button>
            </div>
        </div>
    </div>
    <div id="qaErrorListModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="qa_error_list_title" class="text-xl font-bold mb-4">Lista de Errores de QA</h2>
            <div id="qaErrorListContainer"></div>
            <button id="closeQaErrorListModalBtn" class="btn btn-secondary w-full mt-6" data-i18n="close_btn">Cerrar</button>
        </div>
    </div>
    <!-- Project-related Modals -->
    <div id="reselectVideoModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="reselect_video_title" class="text-xl font-bold mb-4">Seleccionar vídeo</h2>
            <p data-i18n="reselect_video_info" id="reselectVideoInfo" class="mb-4"></p>
            <label for="reselectVideoInput" class="btn btn-primary w-full">
                <span data-i18n="load_video">Cargar vídeo</span>
                <input type="file" id="reselectVideoInput" accept="video/*" class="hidden">
            </label>
            <button id="skipReselectVideoBtn" class="btn btn-secondary w-full mt-2" data-i18n="skip_btn">Omitir</button>
        </div>
    </div>
    <div id="confirmNewProjectModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="confirm_new_project_title" class="text-xl font-bold mb-4">Crear nuevo proyecto</h2>
            <p data-i18n="confirm_new_project_message" class="mb-6">Tienes cambios sin guardar. ¿Quieres guardar el proyecto actual antes de continuar?</p>
            <div class="flex justify-end space-x-2">
                <button id="cancelNewProjectBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                <button id="continueWithoutSavingBtn" class="btn btn-destructive" data-i18n="continue_without_saving_btn">Continuar sin guardar</button>
                <button id="saveAndContinueBtn" class="btn btn-primary" data-i18n="save_and_continue_btn">Guardar y continuar</button>
            </div>
        </div>
    </div>


    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="loading-spinner"></div>
        <p id="loadingMessage"></p>
    </div>

    <script>
        // --- IndexedDB Setup (Dexie.js) ---
        const db = new Dexie("subpandaTM_v2");
        db.version(1).stores({
            projects: '++id, fileName',
            settings: 'key' // Using 'key' as the primary key for settings objects
        });

        // Global variables
        let srtEntries = [];
        let currentFileName = 'subtitles.srt';
        let videoFileName = null;
        let currentLanguage = 'es';
        let findState = { query: '', replace: '', caseSensitive: false, useRegex: false, lastFound: null };
        let previewSource = 'translation';
        let qaSettings = { cpsLimit: 20, charsPerLineLimit: 42 };
        let termsFoundInActiveSegment = new Set();
        let glossary = [];
        let glossarySourceLanguage = '';
        let glossaryTargetLanguage = '';
        let currentGlossaryLatestResults = [];
        let translationMemory = [];
        let tmSourceLanguage = '';
        let tmTargetLanguage = '';
        let tmBestMatchForActiveSegment = null;
        let currentTMLatestSearchResults = [];
        let timeUpdateListener = null;
        
        const DIFF_DELETE = -1;
        const DIFF_INSERT = 1;
        const DIFF_EQUAL = 0;

        // DOM elements
        const srtFile = document.getElementById('srtFile');
        const saveSrtButton = document.getElementById('saveSrt');
        const translationsContainer = document.getElementById('translationsContainer');
        const editorMainContent = document.getElementById('editorMainContent');
        const editorScrollIndicator = document.getElementById('editorScrollIndicator');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageClose = document.getElementById('messageClose');
        const dropArea = document.querySelector('.main-app-content');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const videoPlayerContainer = document.getElementById('videoPlayerContainer');
        const videoPlayer = document.getElementById('videoPlayer');
        const videoFileInput = document.getElementById('videoFileInput');
        const subtitlePreviewText = document.getElementById('subtitlePreviewText');
        const subtitleFontSize = document.getElementById('subtitleFontSize');
        const subtitlePreviewSource = document.getElementById('subtitlePreviewSource');
        const statsContainer = document.getElementById('statsContainer');
        const segmentsProgress = document.getElementById('segmentsProgress');
        const wordsTranslated = document.getElementById('wordsTranslated');
        const wordsTotal = document.getElementById('wordsTotal');
        const wordsRemaining = document.getElementById('wordsRemaining');
        const qaErrorStats = document.getElementById('qaErrorStats');
        const statsAccordionHeader = document.getElementById('statsAccordionHeader');
        const statsAccordionContent = document.getElementById('statsAccordionContent');
        const statsAccordionIcon = statsAccordionHeader.querySelector('.accordion-icon');
        const shortcutsBtn = document.getElementById('shortcutsBtn');
        const shortcutsModal = document.getElementById('shortcutsModal');
        const shortcutsCloseBtn = document.getElementById('shortcutsCloseBtn');
        const findReplaceBtn = document.getElementById('findReplaceBtn');
        const findReplaceModal = document.getElementById('findReplaceModal');
        const findInput = document.getElementById('findInput');
        const replaceInput = document.getElementById('replaceInput');
        const caseSensitiveCheckbox = document.getElementById('caseSensitiveCheckbox');
        const regexCheckbox = document.getElementById('regexCheckbox');
        const findPrevBtn = document.getElementById('findPrevBtn');
        const findNextBtn = document.getElementById('findNextBtn');
        const replaceBtn = document.getElementById('replaceBtn');
        const replaceAllBtn = document.getElementById('replaceAllBtn');
        const findReplaceCloseBtn = document.getElementById('findReplaceCloseBtn');
        const saveSrtModal = document.getElementById('saveSrtModal');
        const fileNameInput = document.getElementById('fileNameInput');
        const confirmSaveBtn = document.getElementById('confirmSaveBtn');
        const cancelSaveBtn = document.getElementById('cancelSaveBtn');
        const backupBtn = document.getElementById('backupBtn');
        const backupModal = document.getElementById('backupModal');
        const backupFoundView = document.getElementById('backupFoundView');
        const noBackupFoundView = document.getElementById('noBackupFoundView');
        const backupFileName = document.getElementById('backupFileName');
        const backupLastModified = document.getElementById('backupLastModified');
        const closeBackupModalBtn = document.getElementById('closeBackupModalBtn');
        const exportSrtFromBackupBtn = document.getElementById('exportSrtFromBackupBtn');
        const deleteBackupBtn = document.getElementById('deleteBackupBtn');
        const confirmRestoreBtn = document.getElementById('confirmRestoreBtn');
        const qaBtn = document.getElementById('qaBtn');
        const qaModal = document.getElementById('qaModal');
        const qaCpsLimitInput = document.getElementById('qaCpsLimit');
        const qaCharsPerLineLimitInput = document.getElementById('qaCharsPerLineLimit');
        const saveQaSettingsBtn = document.getElementById('saveQaSettingsBtn');
        const closeQaModalBtn = document.getElementById('closeQaModalBtn');
        const qaErrorListModal = document.getElementById('qaErrorListModal');
        const qaErrorListContainer = document.getElementById('qaErrorListContainer');
        const closeQaErrorListModalBtn = document.getElementById('closeQaErrorListModalBtn');
        const terminologyBtn = document.getElementById('terminologyBtn');
        const terminologySidebar = document.getElementById('terminologySidebar');
        const closeTerminologySidebarBtn = document.getElementById('closeTerminologySidebarBtn');
        const terminologyLanguageConfigSection = document.getElementById('terminologyLanguageConfigSection');
        const terminologyEditorSection = document.getElementById('terminologyEditorSection');
        const configSrcLang = document.getElementById('configSrcLang');
        const configTgtLang = document.getElementById('configTgtLang');
        const displaySrcLang = document.getElementById('displaySrcLang');
        const displayTgtLang = document.getElementById('displayTgtLang');
        const srcTermInput = document.getElementById('srcTerm');
        const tgtTermInput = document.getElementById('tgtTerm');
        const searchTermInput = document.getElementById('searchTerm');
        const glossaryTableBody = document.getElementById('glossaryTableBody');
        const tbxFileInput = document.getElementById('tbxFileInput');
        const isoLanguagesDatalist = document.getElementById('isoLanguages');
        const addTermHeader = document.getElementById('addTermHeader');
        const addTermContent = addTermHeader.nextElementSibling;
        const addTermAccordionIcon = addTermHeader.querySelector('.accordion-icon');
        const tmBtn = document.getElementById('tmBtn');
        const translationMemorySidebar = document.getElementById('translationMemorySidebar');
        const closeTranslationMemorySidebarBtn = document.getElementById('closeTranslationMemorySidebarBtn');
        const tmFileInput = document.getElementById('tmFileInput');
        const tmSearchInput = document.getElementById('tmSearchInput');
        const tmSearchResultsTableBody = document.getElementById('tmSearchResultsTableBody');
        const tmNoMatchFoundMessage = document.getElementById('tmNoMatchFoundMessage');
        const tmLanguageConfigSection = document.getElementById('tmLanguageConfigSection');
        const tmEditorSection = document.getElementById('tmEditorSection');
        const tmConfigSrcLang = document.getElementById('tmConfigSrcLang');
        const tmConfigTgtLang = document.getElementById('tmConfigTgtLang');
        const displayTmSrcLang = document.getElementById('displayTmSrcLang');
        const displayTmTgtLang = document.getElementById('displayTmTgtLang');
        const tmInternalMessage = document.getElementById('tmInternalMessage');
        const langEsBtn = document.getElementById('lang-es');
        const langEnBtn = document.getElementById('lang-en');
        const shortcutsList = document.getElementById('shortcutsList');
        const exportShortcutsBtn = document.getElementById('exportShortcutsBtn');
        const importShortcutsInput = document.getElementById('importShortcutsInput');
        const restoreShortcutsBtn = document.getElementById('restoreShortcutsBtn');
        const saveTbxModal = document.getElementById('saveTbxModal');
        const fileNameInputTbx = document.getElementById('fileNameInputTbx');
        const confirmSaveTbxBtn = document.getElementById('confirmSaveTbxBtn');
        const cancelSaveTbxBtn = document.getElementById('cancelSaveTbxBtn');
        const saveTmxModal = document.getElementById('saveTmxModal');
        const fileNameInputTmx = document.getElementById('fileNameInputTmx');
        const confirmSaveTmxBtn = document.getElementById('confirmSaveTmxBtn');
        const cancelSaveTmxBtn = document.getElementById('cancelSaveTmxBtn');
        const resetPanelsBtn = document.getElementById('resetPanelsBtn');
        // Project elements
        const newProjectBtn = document.getElementById('newProjectBtn');
        const saveProjectBtn = document.getElementById('saveProjectBtn');
        const projectFile = document.getElementById('projectFile');
        const reselectVideoModal = document.getElementById('reselectVideoModal');
        const reselectVideoInfo = document.getElementById('reselectVideoInfo');
        const reselectVideoInput = document.getElementById('reselectVideoInput');
        const skipReselectVideoBtn = document.getElementById('skipReselectVideoBtn');
        const confirmNewProjectModal = document.getElementById('confirmNewProjectModal');
        const cancelNewProjectBtn = document.getElementById('cancelNewProjectBtn');
        const continueWithoutSavingBtn = document.getElementById('continueWithoutSavingBtn');
        const saveAndContinueBtn = document.getElementById('saveAndContinueBtn');

        // --- I18N & SHORTCUTS SETUP ---

        const translations = {
            'es': {
                'title': 'subpandaTM', 'import_srt': 'Importar .srt', 'export_srt': 'Exportar .srt', 'backup_btn': 'Copia de seguridad', 'qa_btn': 'QA', 'shortcuts_btn': 'Atajos', 'find_replace_btn': 'Buscar y reemplazar', 'terminology_btn': 'Terminología', 'tm_btn': 'Memoria de traducción', 'load_video': 'Cargar vídeo', 'change_video': 'Cambiar vídeo', 'preview_size': 'Tamaño:', 'preview_source': 'Mostrar:', 'translation_text_option': 'Traducción', 'original_text_option': 'Original', 'translation_stats_title': 'Estadísticas', 'segments_progress_text': '{0}/{1} subtítulos traducidos ({2}%)', 'words_translated_text': '{0} palabras traducidas', 'words_total_text': '{0} palabras originales totales', 'words_remaining_text': '{0} palabras pendientes', 'no_translations': 'Importa un archivo .srt y un vídeo para empezar a trabajar. Si lo deseas, puedes trabajar con una memoria de traducción TMX y un glosario TBX, que puedes importar o crear desde cero.', 'time_codes': 'Códigos de tiempo:', 'original_text': 'Original:', 'translation_text': 'Traducción:', 'validate': 'Validar', 'edit': 'Editar', 'char_count_original': 'Original: ', 'char_count_translation': 'Traducción: ', 'char_units': ' caracteres', 'cps': ' CPS', 'ok': 'OK', 'close_btn': 'Cerrar', 'save_btn': 'Guardar', 'cancel_btn': 'Cancelar', 'shortcuts_title': 'Atajos de teclado',
                'shortcut_desc_validateAndNext': 'Validar traducción y pasar a la siguiente', 'shortcut_desc_goToNext': 'Ir al siguiente subtítulo', 'shortcut_desc_goToPrevious': 'Ir al subtítulo anterior', 'shortcut_desc_insertTM1': 'Insertar 1ª sugerencia de la MT', 'shortcut_desc_insertTM2': 'Insertar 2ª sugerencia de la MT', 'shortcut_desc_insertTM3': 'Insertar 3ª sugerencia de la MT', 'shortcut_desc_insertTM4': 'Insertar 4ª sugerencia de la MT', 'shortcut_desc_insertTM5': 'Insertar 5ª sugerencia de la MT', 'shortcut_desc_insertGloss1': 'Insertar 1er término del glosario', 'shortcut_desc_insertGloss2': 'Insertar 2º término del glosario', 'shortcut_desc_insertGloss3': 'Insertar 3er término del glosario', 'shortcut_desc_insertGloss4': 'Insertar 4º término del glosario', 'shortcut_desc_insertGloss5': 'Insertar 5º término del glosario', 'shortcut_desc_jumpToTime': 'Saltar al tiempo de inicio del subtítulo actual', 'shortcut_desc_playSegment': 'Reproducir el subtítulo actual', 'shortcut_desc_playPause': 'Reproducir/pausar vídeo', 'shortcut_desc_seekForward': 'Avanzar 3 segundos', 'shortcut_desc_seekBackward': 'Retroceder 3 segundos', 'shortcut_desc_seekForwardFast': 'Avanzar 5 segundos', 'shortcut_desc_seekBackwardFast': 'Retroceder 5 segundos', 'shortcut_desc_bold': 'Aplicar negrita', 'shortcut_desc_italic': 'Aplicar cursiva',
                'find_replace_title': 'Buscar y reemplazar', 'find_label': 'Buscar:', 'replace_label': 'Reemplazar con:', 'case_sensitive': 'Distinguir mayúsculas y minúsculas', 'regular_expression': 'Expresión regular', 'find_prev': 'Buscar anterior', 'find_next': 'Buscar siguiente', 'replace': 'Reemplazar', 'replace_all': 'Reemplazar todo', 'save_srt_title': 'Exportar Archivo SRT', 'save_tbx_title': 'Exportar Archivo TBX', 'save_tmx_title': 'Exportar Archivo TMX', 'file_name_label': 'Nombre del archivo:', 'backup_modal_title': 'Copia de Seguridad', 'restore_backup_info': 'Se ha encontrado una copia de seguridad de una sesión no guardada.', 'file_label': 'Archivo:', 'last_modified_label': 'Última modificación:', 'export_srt_btn': 'Exportar SRT', 'delete_backup_btn': 'Borrar Backup', 'restore_btn': 'Restaurar', 'no_backup_found_info': 'No se ha encontrado ninguna copia de seguridad automática.', 'qa_modal_title': 'Configuración de QA', 'cps_limit_label': 'Límite de CPS:', 'chars_per_line_limit_label': 'Límite de caracteres por línea:', 'save_and_apply_btn': 'Guardar y aplicar', 'qa_error_list_title': 'Lista de Errores de QA', 'qa_errors_found': '{0} errores de QA encontrados', 'qa_no_errors': 'No se han encontrado errores de QA.', 'terminology_sidebar_title': 'Terminología', 'config_lang_title': 'Configurar idiomas del glosario', 'config_lang_info': 'Define los idiomas de origen y destino de tu glosario. Es fundamental que el código ISO sea correcto. Tras configurar el idioma, podrás importar o crear un glosario desde cero.', 'source_language': 'Idioma de origen:', 'target_language': 'Idioma de destino:', 'confirm_languages': 'Confirmar idiomas', 'current_lang_title': 'Idiomas actuales del glosario', 'add_term_title': 'Añadir término', 'term': 'Término:', 'translation': 'Traducción:', 'add_button': 'Añadir', 'search_title': 'Buscar', 'search_placeholder': 'Buscar término...', 'import_tbx': 'Importar TBX', 'download_tbx': 'Descargar TBX', 'new_glossary': 'Nuevo glosario', 'glossary_list_title': 'Glosario', 'source_term_col': 'Término de origen', 'target_term_col': 'Término de destino', 'actions_col': 'Acciones', 'delete_button': 'Eliminar', 'tm_sidebar_title': 'Memoria de traducción', 'tm_config_lang_title': 'Configurar idiomas de la TM', 'tm_config_lang_info': 'Define los idiomas de origen y destino de tu memoria de traducción. Es fundamental que el código ISO sea correcto. Tras configurar el idioma, podrás importar o crear una memoria desde cero.', 'current_tm_lang_title': 'Idiomas actuales de la TM', 'new_tm': 'Nueva TM', 'import_tmx': 'Importar TMX', 'download_tmx': 'Descargar TMX', 'tm_search_title': 'Buscar en TM', 'tm_search_placeholder': 'Buscar en la memoria...', 'tm_search_results_title': 'Resultados de búsqueda en TM', 'tm_score_col': '%', 'tm_original_col': 'Original', 'tm_translation_col': 'Traducción', 'tm_no_match_found': 'No se encontraron coincidencias en la TM.',
                'import_shortcuts_btn': 'Importar', 'export_shortcuts_btn': 'Exportar', 'restore_defaults_btn': 'Restaurar valores por defecto', 'edit_shortcut_btn': 'Editar', 'recording_shortcut_text': 'Pulsar tecla...',
                'project_menu': 'Proyecto', 'load_project': 'Cargar proyecto', 'save_project': 'Guardar proyecto', 'new_project': 'Nuevo proyecto', 'reselect_video_title': 'Seleccionar vídeo', 'reselect_video_info': 'Proyecto cargado. Para sincronizar el vídeo, por favor, selecciona el archivo de vídeo original:', 'reselect_video_prompt': 'Proyecto cargado. Por favor, selecciona el archivo de vídeo original: {0}', 'skip_btn': 'Omitir', 'confirm_new_project_title': 'Crear nuevo proyecto', 'confirm_new_project_message': 'Tienes cambios sin guardar. ¿Quieres guardar el proyecto actual antes de continuar?', 'continue_without_saving_btn': 'Continuar sin guardar', 'save_and_continue_btn': 'Guardar y continuar'
            },
            'en': {
                'title': 'subpandaTM', 'import_srt': 'Import .srt', 'export_srt': 'Export .srt', 'backup_btn': 'Backup', 'qa_btn': 'QA', 'shortcuts_btn': 'Shortcuts', 'find_replace_btn': 'Find & Replace', 'terminology_btn': 'Terminology', 'tm_btn': 'Translation Memory', 'load_video': 'Load Video', 'change_video': 'Change Video', 'preview_size': 'Size:', 'preview_source': 'Show:', 'translation_text_option': 'Translation', 'original_text_option': 'Original', 'translation_stats_title': 'Statistics', 'segments_progress_text': '{0}/{1} subtitles translated ({2}%)', 'words_translated_text': '{0} words translated', 'words_total_text': '{0} total original words', 'words_remaining_text': '{0} words remaining', 'no_translations': 'Import an .srt file and a video to start working. If you wish, you can work with a TMX translation memory and a TBX glossary, which you can import or create from scratch.', 'time_codes': 'Time codes:', 'original_text': 'Original:', 'translation_text': 'Translation:', 'validate': 'Validate', 'edit': 'Edit', 'char_count_original': 'Original: ', 'char_count_translation': 'Translation: ', 'char_units': ' characters', 'cps': ' CPS', 'ok': 'OK', 'close_btn': 'Close', 'save_btn': 'Save', 'cancel_btn': 'Cancel', 'shortcuts_title': 'Keyboard Shortcuts',
                'shortcut_desc_validateAndNext': 'Validate translation and move to next', 'shortcut_desc_goToNext': 'Go to next subtitle', 'shortcut_desc_goToPrevious': 'Go to previous subtitle', 'shortcut_desc_insertTM1': 'Insert 1st TM suggestion', 'shortcut_desc_insertTM2': 'Insert 2nd TM suggestion', 'shortcut_desc_insertTM3': 'Insert 3rd TM suggestion', 'shortcut_desc_insertTM4': 'Insert 4th TM suggestion', 'shortcut_desc_insertTM5': 'Insert 5th TM suggestion', 'shortcut_desc_insertGloss1': 'Insert 1st glossary term', 'shortcut_desc_insertGloss2': 'Insert 2nd glossary term', 'shortcut_desc_insertGloss3': 'Insert 3rd glossary term', 'shortcut_desc_insertGloss4': 'Insert 4th glossary term', 'shortcut_desc_insertGloss5': 'Insert 5th glossary term', 'shortcut_desc_jumpToTime': 'Jump to current subtitle start time', 'shortcut_desc_playSegment': 'Play current subtitle', 'shortcut_desc_playPause': 'Play/pause video', 'shortcut_desc_seekForward': 'Seek forward 3 seconds', 'shortcut_desc_seekBackward': 'Seek backward 3 seconds', 'shortcut_desc_seekForwardFast': 'Seek forward 5 seconds', 'shortcut_desc_seekBackwardFast': 'Seek backward 5 seconds', 'shortcut_desc_bold': 'Apply bold', 'shortcut_desc_italic': 'Apply italics',
                'find_replace_title': 'Find and Replace', 'find_label': 'Find:', 'replace_label': 'Replace with:', 'case_sensitive': 'Case sensitive', 'regular_expression': 'Regular expression', 'find_prev': 'Find previous', 'find_next': 'Find next', 'replace': 'Replace', 'replace_all': 'Replace all', 'save_srt_title': 'Export SRT File', 'save_tbx_title': 'Export TBX File', 'save_tmx_title': 'Export TMX File', 'file_name_label': 'File name:', 'backup_modal_title': 'Backup', 'restore_backup_info': 'A backup of an unsaved session has been found.', 'file_label': 'File:', 'last_modified_label': 'Last modified:', 'export_srt_btn': 'Export SRT', 'delete_backup_btn': 'Delete Backup', 'restore_btn': 'Restore', 'no_backup_found_info': 'No automatic backup has been found.', 'qa_modal_title': 'QA Settings', 'cps_limit_label': 'CPS Limit:', 'chars_per_line_limit_label': 'Characters per line limit:', 'save_and_apply_btn': 'Save and apply', 'qa_error_list_title': 'QA Error List', 'qa_errors_found': '{0} QA errors found', 'qa_no_errors': 'No QA errors found.', 'terminology_sidebar_title': 'Terminology', 'config_lang_title': 'Set up glossary languages', 'config_lang_info': 'Define the source and target languages for your glossary. The ISO code must be correct. After setting the language, you can import or create a glossary from scratch.', 'source_language': 'Source language:', 'target_language': 'Target language:', 'confirm_languages': 'Confirm languages', 'current_lang_title': 'Current glossary languages', 'add_term_title': 'Add term', 'term': 'Term:', 'translation': 'Translation:', 'add_button': 'Add', 'search_title': 'Search', 'search_placeholder': 'Search term...', 'import_tbx': 'Import TBX', 'download_tbx': 'Download TBX', 'new_glossary': 'New glossary', 'glossary_list_title': 'Glossary', 'source_term_col': 'Source term', 'target_term_col': 'Target term', 'actions_col': 'Actions', 'delete_button': 'Delete', 'tm_sidebar_title': 'Translation Memory', 'tm_config_lang_title': 'Set up TM languages', 'tm_config_lang_info': 'Define the source and target languages for your translation memory. The ISO code must be correct. After setting the language, you can import or create a memory from scratch.', 'current_tm_lang_title': 'Current TM languages', 'new_tm': 'New TM', 'import_tmx': 'Import TMX', 'download_tmx': 'Download TMX', 'tm_search_title': 'Search TM', 'tm_search_placeholder': 'Search in memory...', 'tm_search_results_title': 'TM Search Results', 'tm_score_col': '%', 'tm_original_col': 'Original', 'tm_translation_col': 'Translation', 'tm_no_match_found': 'No matches found in the TM.',
                'import_shortcuts_btn': 'Import', 'export_shortcuts_btn': 'Export', 'restore_defaults_btn': 'Restore Defaults', 'edit_shortcut_btn': 'Edit', 'recording_shortcut_text': 'Press key...',
                'project_menu': 'Project', 'load_project': 'Load project', 'save_project': 'Save project', 'new_project': 'New project', 'reselect_video_title': 'Select Video', 'reselect_video_info': 'Project loaded. To sync the video, please select the original video file:', 'reselect_video_prompt': 'Project loaded. Please select the original video file: {0}', 'skip_btn': 'Skip', 'confirm_new_project_title': 'Create new project', 'confirm_new_project_message': 'You have unsaved changes. Do you want to save the current project before continuing?', 'continue_without_saving_btn': 'Continue without saving', 'save_and_continue_btn': 'Save and continue'
            }
        };

        const errorMessages = {
            'es': {
                'error_reading_file': 'Error al leer o analizar archivo .srt: ', 'error_saving_file': 'Error al guardar archivo: ', 'file_saved_successfully': 'Archivo .srt guardado con éxito.', 'file_saved_successfully_tbx': 'Archivo TBX guardado con éxito.', 'file_saved_successfully_tmx': 'Archivo TMX guardado con éxito.', 'please_enter_filename': 'Por favor, introduce un nombre de archivo.', 'no_translations_to_save': 'No hay subtítulos para guardar. Carga un archivo .srt primero.', 'reached_last': 'Has llegado al último subtítulo.', 'reached_first': 'Ya estás en el primer subtítulo.', 'file_processing_error': '¡Error! No se pudo procesar el archivo. Asegúrate de que es un archivo .srt válido.', 'no_match_found': 'No se encontró ninguna coincidencia.', 'replaced_all': 'Todas las ocurrencias reemplazadas.', 'no_find_query': 'Por favor, introduce el texto a buscar.', 'loading_file': 'Cargando archivo...', 'saving_file': 'Guardando archivo...', 'video_load_error': 'Error al cargar el vídeo. Asegúrate de que el formato es compatible.', 'both_terms_required': 'Ambos términos son requeridos.', 'lang_config_required': 'Por favor, configura los idiomas de origen y destino para el glosario.', 'cannot_download_empty_or_unconfigured_glossary': 'No se puede descargar un glosario vacío o sin configurar.', 'error_loading_tbx_file': 'Error al cargar el archivo TBX. Asegúrate de que sea un XML/TBX válido.', 'tmx_file_expected_tbx_found': 'Este archivo parece ser una memoria de traducción (TMX). Por favor, usa la opción "Importar TMX" en el panel de Memoria de Traducción.', 'tbx_file_expected_tmx_found': 'Este archivo parece ser un glosario (TBX). Por favor, usa la opción "Importar TBX" en el panel de Terminología.', 'error_loading_tmx_file': 'Error al cargar el archivo TMX. Asegúrate de que sea un XML/TMX válido.', 'cannot_download_empty_tm': 'No se puede descargar una memoria de traducción vacía.', 'backup_deleted_confirmation': '¿Estás seguro de que quieres borrar permanentemente este backup? Esta acción no se puede deshacer.', 'backup_deleted_message': 'El backup ha sido borrado.', 'project_restored_message': 'Proyecto restaurado con éxito.', 'no_backup_to_export': 'No hay datos de backup disponibles para exportar.', 'backup_export_error': 'Error al exportar el SRT del backup: ', 'backup_export_success': 'El archivo ha sido exportado con éxito.',
                'shortcut_import_error': 'Error al importar los atajos. Asegúrate de que es un archivo JSON válido.', 'shortcut_conflict': 'Este atajo ya está en uso. Por favor, elige otro.',
                'project_loaded_success': 'Proyecto cargado con éxito.', 'error_loading_project': 'Error al cargar el proyecto', 'no_project_to_save': 'No hay ningún proyecto activo para guardar.'
            },
            'en': {
                'error_reading_file': 'Error reading or parsing .srt file: ', 'error_saving_file': 'Error saving file: ', 'file_saved_successfully': '.srt file saved successfully.', 'file_saved_successfully_tbx': 'TBX file saved successfully.', 'file_saved_successfully_tmx': 'TMX file saved successfully.', 'please_enter_filename': 'Please enter a filename.', 'no_translations_to_save': 'No subtitles to save. Load an .srt file first.', 'reached_last': 'You have reached the last subtitle.', 'reached_first': 'You are already at the first subtitle.', 'file_processing_error': 'Error! Could not process the file. Make sure it is a valid .srt file.', 'no_match_found': 'No match found.', 'replaced_all': 'All occurrences replaced.', 'no_find_query': 'Please enter text to search for.', 'loading_file': 'Loading file...', 'saving_file': 'Saving file...', 'video_load_error': 'Error loading video. Make sure the format is supported.', 'both_terms_required': 'Both terms are required.', 'lang_config_required': 'Please set up the source and target languages for the glossary.', 'cannot_download_empty_or_unconfigured_glossary': 'Cannot download an empty or unconfigured glossary.', 'error_loading_tbx_file': 'Error loading TBX file. Make sure it is a valid XML/TBX.', 'tmx_file_expected_tbx_found': 'This file appears to be a Translation Memory (TMX). Please use the "Import TMX" option in the Translation Memory panel.', 'tbx_file_expected_tmx_found': 'This file appears to be a Glossary (TBX). Please use the "Import TBX" option in the Terminology panel.', 'error_loading_tmx_file': 'Error loading TMX file. Make sure it is a valid XML/TMX.', 'cannot_download_empty_tm': 'Cannot download an empty translation memory.', 'backup_deleted_confirmation': 'Are you sure you want to permanently delete this backup? This action cannot be undone.', 'backup_deleted_message': 'The backup has been deleted.', 'project_restored_message': 'Project restored successfully.', 'no_backup_to_export': 'No backup data available to export.', 'backup_export_error': 'Error exporting SRT from backup: ', 'backup_export_success': 'File exported successfully.',
                'shortcut_import_error': 'Error importing shortcuts. Please ensure it is a valid JSON file.', 'shortcut_conflict': 'This shortcut is already in use. Please choose another one.',
                'project_loaded_success': 'Project loaded successfully.', 'error_loading_project': 'Error loading project', 'no_project_to_save': 'There is no active project to save.'
            }
        };

        const defaultShortcuts = {
            validateAndNext: { ctrlKey: true, altKey: false, shiftKey: false, key: 'enter', descriptionKey: 'shortcut_desc_validateAndNext' },
            goToNext: { ctrlKey: true, altKey: false, shiftKey: false, key: 'arrowdown', descriptionKey: 'shortcut_desc_goToNext' },
            goToPrevious: { ctrlKey: true, altKey: false, shiftKey: false, key: 'arrowup', descriptionKey: 'shortcut_desc_goToPrevious' },
            insertTM1: { ctrlKey: false, altKey: true, shiftKey: false, key: '1', descriptionKey: 'shortcut_desc_insertTM1' },
            insertTM2: { ctrlKey: false, altKey: true, shiftKey: false, key: '2', descriptionKey: 'shortcut_desc_insertTM2' },
            insertTM3: { ctrlKey: false, altKey: true, shiftKey: false, key: '3', descriptionKey: 'shortcut_desc_insertTM3' },
            insertTM4: { ctrlKey: false, altKey: true, shiftKey: false, key: '4', descriptionKey: 'shortcut_desc_insertTM4' },
            insertTM5: { ctrlKey: false, altKey: true, shiftKey: false, key: '5', descriptionKey: 'shortcut_desc_insertTM5' },
            insertGloss1: { ctrlKey: true, altKey: true, shiftKey: false, key: '1', descriptionKey: 'shortcut_desc_insertGloss1' },
            insertGloss2: { ctrlKey: true, altKey: true, shiftKey: false, key: '2', descriptionKey: 'shortcut_desc_insertGloss2' },
            insertGloss3: { ctrlKey: true, altKey: true, shiftKey: false, key: '3', descriptionKey: 'shortcut_desc_insertGloss3' },
            insertGloss4: { ctrlKey: true, altKey: true, shiftKey: false, key: '4', descriptionKey: 'shortcut_desc_insertGloss4' },
            insertGloss5: { ctrlKey: true, altKey: true, shiftKey: false, key: '5', descriptionKey: 'shortcut_desc_insertGloss5' },
            jumpToTime: { ctrlKey: true, altKey: false, shiftKey: false, key: 'j', descriptionKey: 'shortcut_desc_jumpToTime' },
            playSegment: { ctrlKey: true, altKey: false, shiftKey: false, key: ' ', descriptionKey: 'shortcut_desc_playSegment' },
            playPause: { ctrlKey: false, altKey: true, shiftKey: false, key: 'p', descriptionKey: 'shortcut_desc_playPause' },
            seekForward: { ctrlKey: false, altKey: true, shiftKey: false, key: 'arrowright', descriptionKey: 'shortcut_desc_seekForward' },
            seekBackward: { ctrlKey: false, altKey: true, shiftKey: false, key: 'arrowleft', descriptionKey: 'shortcut_desc_seekBackward' },
            seekForwardFast: { ctrlKey: true, altKey: true, shiftKey: false, key: 'arrowright', descriptionKey: 'shortcut_desc_seekForwardFast' },
            seekBackwardFast: { ctrlKey: true, altKey: true, shiftKey: false, key: 'arrowleft', descriptionKey: 'shortcut_desc_seekBackwardFast' },
            bold: { ctrlKey: true, altKey: false, shiftKey: false, key: 'b', descriptionKey: 'shortcut_desc_bold' },
            italic: { ctrlKey: true, altKey: false, shiftKey: false, key: 'i', descriptionKey: 'shortcut_desc_italic' },
        };
        let shortcuts = { ...defaultShortcuts };

        // List of common ISO 639-1 language codes for the datalist
        const isoLanguagesData = [
          { code: "en", name: "English" }, { code: "en-US", name: "English (United States)" }, { code: "en-GB", name: "English (United Kingdom)" },
          { code: "es", name: "Español" }, { code: "es-AR", name: "Español (Argentina)" }, { code: "es-ES", name: "Español (España)" }, { code: "es-MX", name: "Español (México)" },
          { code: "fr", name: "Français" }, { code: "de", name: "Deutsch" }, { code: "it", name: "Italiano" }, { code: "pt", name: "Português" },
          { code: "ja", name: "日本語 (Japanese)" }, { code: "zh", name: "中文 (Chinese)" }, { code: "ar", name: "العربية (Arabic)" },
          { code: "ru", name: "Русский (Russian)" }, { code: "ko", name: "한국어 (Korean)" }, { code: "nl", name: "Nederlands" },
          { code: "sv", name: "Svenska" }, { code: "da", name: "Dansk" }, { code: "no", name: "Norsk" }, { code: "fi", "name": "Suomi" },
          { code: "tr", name: "Türkçe" }, { code: "pl", name: "Polski" }, { code: "cs", name: "Čeština" }, { code: "hu", name: "Magyar" },
          { code: "el", name: "Ελληνικά (Greek)" }, { code: "he", name: "עברית (Hebrew)" }, { code: "th", name: "ไทย (Thai)" },
          { code: "vi", name: "Tiếng Việt (Vietnamese)" }, { code: "id", name: "Bahasa Indonesia" }, { code: "ms", name: "Bahasa Melayu" },
          { code: "ca", name: "Català" }, { code: "eu", name: "Euskara" }, { code: "gl", name: "Galego" }, { code: "ro", name: "Română" },
          { code: "uk", name: "Українська (Ukrainian)" }, { code: "bg", name: "Български (Bulgarian)" }, { code: "hr", name: "Hrvatski" },
          { code: "sr", name: "Srpski" }, { code: "sk", name: "Slovenčina" }, { code: "sl", name: "Slovenščina" }, { code: "lt", name: "Lietuvių" },
          { code: "lv", name: "Latviešu" }, { code: "et", name: "Eesti" }, { code: "is", name: "Íslenska" }, { code: "ga", name: "Gaeilge" },
          { code: "mt", name: "Malti" },
        ];


        /**
         * Counts words in a given text string.
         * @param {string} text The text to count words from.
         * @returns {number} The number of words.
         */
        function countWords(text) {
            if (!text) return 0;
            // Trim leading/trailing whitespace and split by one or more whitespace characters
            const words = text.trim().split(/\s+/);
            // Filter out empty strings that might result from multiple spaces
            return words.filter(word => word.length > 0).length;
        }
        
        /**
         * Counts characters in a string, ignoring HTML tags.
         * @param {string} text The text to count.
         * @returns {number} The character count without tags.
         */
        function countCharactersWithoutTags(text) {
            if (!text) return 0;
            // Remove <b>, </b>, <i>, </i> tags using a regular expression
            const strippedText = text.replace(/<\/?(b|i)>/gi, '');
            return strippedText.length;
        }

        /**
         * Converts milliseconds to SRT time format (HH:MM:SS,ms).
         * @param {number} ms Milliseconds.
         * @returns {string} Formatted time string.
         */
        function formatTime(ms) {
            const hours = Math.floor(ms / 3600000);
            ms %= 3600000;
            const minutes = Math.floor(ms / 60000);
            ms %= 60000;
            const seconds = Math.floor(ms / 1000);
            const milliseconds = ms % 1000;

            return [
                hours.toString().padStart(2, '0'),
                minutes.toString().padStart(2, '0'),
                seconds.toString().padStart(2, '0')
            ].join(':') + ',' + milliseconds.toString().padStart(3, '0');
        }

        /**
         * Converts SRT time format (HH:MM:SS,ms) to milliseconds.
         * @param {string} timeStr Time string in SRT format.
         * @returns {number} Milliseconds.
         */
        function parseTime(timeStr) {
            const parts = timeStr.split(',');
            const [h, m, s] = parts[0].split(':').map(Number);
            const ms = Number(parts[1]);
            return (h * 3600 + m * 60 + s) * 1000 + ms;
        }

        /**
         * Calculates Characters Per Second (CPS) for a given text and duration.
         * @param {string} text The text of the subtitle.
         * @param {number} durationMs The duration of the subtitle in milliseconds.
         * @returns {number} CPS value.
         */
        function calculateCPS(text, durationMs) {
            if (durationMs <= 0) return 0;
            const textWithoutTags = text.replace(/<\/?(b|i)>/gi, '');
            return (textWithoutTags.length / (durationMs / 1000)).toFixed(2);
        }

        /**
         * Parses the content of an SRT file.
         * @param {string} content The full content of the SRT file.
         * @returns {Array<Object>} An array of SRT entry objects.
         */
        function parseSrtContent(content) {
            const entries = [];
            const blocks = content.split(/\r?\n\r?\n/); // Split by double newline (CRLF or LF)

            blocks.forEach(block => {
                const lines = block.trim().split(/\r?\n/);
                if (lines.length >= 3) {
                    const index = parseInt(lines[0]);
                    const timecodes = lines[1];
                    const text = lines.slice(2).join('\n'); // Join remaining lines as text

                    const [startTimeStr, endTimeStr] = timecodes.split(' --> ');
                    const startTimeMs = parseTime(startTimeStr);
                    const endTimeMs = parseTime(endTimeStr);
                    const durationMs = endTimeMs - startTimeMs;
                    const charCountOriginal = countCharactersWithoutTags(text);

                    entries.push({
                        index: index,
                        timecodes: timecodes,
                        startTimeMs: startTimeMs,
                        endTimeMs: endTimeMs,
                        durationMs: durationMs,
                        original: text,
                        translation: '', // Initialize translation as empty
                        wordCountOriginal: countWords(text),
                        wordCountTranslation: 0,
                        isTranslated: false,
                        charCountOriginal: charCountOriginal,
                        charCountTranslation: 0,
                        cpsOriginal: calculateCPS(text, durationMs),
                        cpsTranslation: 0
                    });
                }
            });
            return entries;
        }

        /**
         * Reconstructs the content of an SRT file from an array of entries.
         * @param {Array<Object>} entries The array of subtitle objects.
         * @returns {string} The reconstructed SRT file content.
         */
        function reconstructSrt(entries) {
            let srtContent = '';
            entries.forEach(entry => {
                srtContent += `${entry.index}\n`;
                srtContent += `${entry.timecodes}\n`;
                srtContent += `${entry.translation || entry.original}\n\n`; // Use translation if available, otherwise original
            });
            return srtContent.trim(); // Trim last double newline
        }

        /**
         * Adjusts the height of a textarea to fit its content.
         * If the translation textarea is empty, it matches the height of the original textarea.
         * @param {HTMLTextAreaElement} textarea The textarea element (translation).
         * @param {HTMLElement} [originalElement] The original element (original text pre) for height comparison.
         */
        function autoResizeTextarea(textarea, originalElement) {
            textarea.style.height = 'auto';
            if (textarea.innerHTML.trim() === '' && originalElement) {
                // If textarea is empty, set its height to match the original element's scroll height
                textarea.style.height = originalElement.scrollHeight + 'px';
            } else {
                // Otherwise, let it expand to its own content
                textarea.style.height = textarea.scrollHeight + 'px';
            }
        }

        /**
         * Updates the character count and CPS for a specific textarea, including QA checks.
         * @param {HTMLElement} editorDiv The contenteditable div element.
         * @param {number} originalLength The length of the original string segment.
         * @param {number} durationMs The duration of the subtitle in milliseconds.
         */
        function updateSubtitleStats(editorDiv, originalLength, durationMs) {
            const entryIndex = parseInt(editorDiv.dataset.entryIndex);
            const charCountSpan = document.getElementById(`charCount-${entryIndex}`);
            const cpsSpan = document.getElementById(`cps-${entryIndex}`);
            const lineCharCountsDiv = document.getElementById(`lineCharCounts-${entryIndex}`);
            const translationLength = countCharactersWithoutTags(editorDiv.innerHTML);
            const t = translations[currentLanguage];

            if (charCountSpan) {
                charCountSpan.textContent = `${t.char_count_original}${originalLength}${t.char_units} | ${t.char_count_translation}${translationLength}${t.char_units}`;
            }
            
            if (cpsSpan) {
                const currentCPS = calculateCPS(editorDiv.innerHTML, durationMs);
                cpsSpan.textContent = `${currentCPS}${t.cps}`;
                // QA Check for CPS
                if (currentCPS > qaSettings.cpsLimit) {
                    cpsSpan.classList.add('qa-error');
                } else {
                    cpsSpan.classList.remove('qa-error');
                }
            }

            if (lineCharCountsDiv) {
                const lines = editorDiv.innerText.split('\n');
                lineCharCountsDiv.innerHTML = ''; // Clear previous counts
                lines.forEach((line, i) => {
                    const lineLength = countCharactersWithoutTags(line);
                    const lineSpan = document.createElement('span');
                    lineSpan.textContent = `L${i + 1}: ${lineLength}`;
                    // QA Check for chars per line
                    if (lineLength > qaSettings.charsPerLineLimit) {
                        lineSpan.classList.add('qa-error');
                    }
                    if (i > 0) lineCharCountsDiv.append(document.createTextNode(', '));
                    lineCharCountsDiv.appendChild(lineSpan);
                });
            }
        }

        /**
         * Configures the editable state of a translation entry (editable/solo lectura).
         * @param {number} entryIndex The index of the SRT entry.
         * @param {boolean} isEditable True to make it editable, false for read-only.
         */
        function setTranslationEditableState(entryIndex, isEditable) {
            const translationEditor = document.getElementById(`translation-${entryIndex}`);
            const validateButton = document.getElementById(`validateBtn-${entryIndex}`);
            const editButton = document.getElementById(`editBtn-${entryIndex}`);
            const checkIcon = document.getElementById(`checkIcon-${entryIndex}`);
            const translationUnit = document.getElementById(`translation-unit-${entryIndex}`); // Get the parent unit

            if (!translationEditor || !validateButton || !editButton || !checkIcon || !translationUnit) {
                console.error(`Elements not found for index ${entryIndex}`);
                return;
            }

            translationEditor.contentEditable = isEditable;
            if (!isEditable) {
                translationUnit.classList.remove('translation-unit-active'); // Remove active highlight on validate

                // Update translation status and words when segment is validated
                const entry = srtEntries[entryIndex];
                entry.isTranslated = translationEditor.innerText.trim() !== '';
                entry.wordCountTranslation = countWords(translationEditor.innerText);
                entry.charCountTranslation = countCharactersWithoutTags(translationEditor.innerHTML);
                entry.cpsTranslation = calculateCPS(translationEditor.innerHTML, entry.durationMs);

                updateStatsDisplay(); // Update stats
                addOrUpdateTMEntry(entry.original, entry.translation); // Add/Update TM
            } else {
                translationUnit.classList.add('translation-unit-active'); // Add active highlight on edit/focus
            }

            validateButton.style.display = isEditable ? 'inline-block' : 'none';
            editButton.style.display = isEditable ? 'none' : 'inline-block';
            checkIcon.style.display = isEditable ? 'none' : 'inline-block';

            if (isEditable) {
                translationEditor.focus();
            }
        }

        /**
         * Applies a style command (like 'bold' or 'italic') to the current selection.
         * @param {string} command The command to execute.
         */
        function formatText(command) {
            document.execCommand(command, false, null);
        }

        /**
         * Applies glossary term highlighting to a given text segment.
         * Collects terms that were successfully highlighted.
         * @param {string} text The original text to highlight.
         * @returns {{html: string, foundTerms: Set<string>}} Object with HTML string and set of found terms.
         */
        function applyGlossaryHighlightToText(text) {
            let highlightedHtml = text;
            const currentFoundTerms = new Set(); // Terms found in *this specific* segment

            if (!glossarySourceLanguage) {
                return { html: text, foundTerms: currentFoundTerms };
            }

            const sortedGlossary = [...glossary].sort((a, b) => b.srcTerm.length - a.srcTerm.length);

            sortedGlossary.forEach(glossaryEntry => {
                if (glossarySourceLanguage && glossaryEntry.srcTerm) {
                    const term = glossaryEntry.srcTerm;
                    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b(${escapedTerm})\\b`, 'gi'); 

                    if (highlightedHtml.match(regex)) {
                        highlightedHtml = highlightedHtml.replace(regex, (match, p1) => {
                            currentFoundTerms.add(term);
                            return `<span class="glossary-highlight">${p1}</span>`;
                        });
                    }
                }
            });
            return { html: highlightedHtml, foundTerms: currentFoundTerms };
        }

        /**
         * Updates highlighting in the glossary table based on terms found in the editor.
         */
        function updateGlossaryTableHighlights() {
            renderGlossary();
        }

        /**
         * Checks if the editor is scrollable and updates the indicator arrow's visibility.
         */
        function checkEditorScroll() {
            if (editorMainContent.scrollHeight > editorMainContent.clientHeight) {
                editorMainContent.classList.add('is-scrollable');
            } else {
                editorMainContent.classList.remove('is-scrollable');
            }
        }


        /**
         * Renders subtitle entries in the user interface.
         * @param {Array<Object>} entries The array of subtitle objects to render.
         */
        function renderTranslations(entries) {
            translationsContainer.innerHTML = '';
            termsFoundInActiveSegment.clear();
            const t = translations[currentLanguage];

            if (entries.length === 0) {
                translationsContainer.innerHTML = `<div data-i18n="no_translations" id="initialMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md">${t.no_translations}</div>`;
                saveSrtButton.disabled = true;
                saveProjectBtn.disabled = true;
                statsContainer.classList.add('hidden');
                videoPlayerContainer.classList.add('hidden');
                checkEditorScroll();
                return;
            }

            entries.forEach((entry, entryIndex) => {
                const translationUnit = document.createElement('div');
                translationUnit.id = `translation-unit-${entryIndex}`;
                translationUnit.className = 'translation-unit-bg p-2 rounded-lg shadow-sm border border-gray-200 mb-4';

                translationUnit.innerHTML = `
                    <div class="text-md font-bold mb-1">Subtítulo ${entry.index}</div>
                    <div class="text-sm font-medium mb-1"><strong>${t.time_codes}</strong> ${entry.timecodes}</div>
                    <div class="translation-row mb-2">
                        <div class="original-col">
                            <label class="block text-sm font-medium mb-1">${t.original_text}</label>
                            <pre id="original-pre-${entryIndex}" class="subtitle-display-code p-1 rounded-md text-base overflow-auto max-h-24">${entry.original}</pre>
                        </div>
                        <div class="translation-col">
                            <label class="block text-sm font-medium mb-1">${t.translation_text}</label>
                            <div id="translation-${entryIndex}" class="subtitle-editor mt-1 block w-full focus:ring-blue-500 focus:border-blue-500 text-base" contenteditable="true" data-entry-index="${entryIndex}" data-original-length="${entry.charCountOriginal}" data-duration-ms="${entry.durationMs}">${entry.translation}</div>
                        </div>
                    </div>
                    <div class="flex items-center justify-between mt-1 w-full">
                        <span class="inline-block text-sm font-semibold">
                            <span id="charCount-${entryIndex}"></span> | <span id="cps-${entryIndex}"></span>
                        </span>
                        <div id="lineCharCounts-${entryIndex}" class="inline-block text-sm font-semibold ml-4"></div>
                        <div class="flex items-center space-x-2">
                            <button class="btn btn-secondary text-xs p-1" onclick="formatText('bold')"><b class="font-bold">B</b></button>
                            <button class="btn btn-secondary text-xs p-1" onclick="formatText('italic')"><i class="italic">I</i></button>
                            <svg id="checkIcon-${entryIndex}" class="check-icon text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                            <button id="validateBtn-${entryIndex}" class="btn btn-primary text-xs" data-entry-index="${entryIndex}">${t.validate}</button>
                            <button id="editBtn-${entryIndex}" class="btn btn-secondary text-xs" data-entry-index="${entryIndex}" style="display: none;">${t.edit}</button>
                        </div>
                    </div>
                `;
                
                const translationEditor = translationUnit.querySelector(`#translation-${entryIndex}`);
                const originalColPre = translationUnit.querySelector(`#original-pre-${entryIndex}`);
                const validateButton = translationUnit.querySelector(`#validateBtn-${entryIndex}`);
                const editButton = translationUnit.querySelector(`#editBtn-${entryIndex}`);

                translationEditor.addEventListener('input', (event) => {
                    const currentEntry = srtEntries[entryIndex];
                    currentEntry.translation = event.target.innerHTML;
                    currentEntry.wordCountTranslation = countWords(event.target.innerText);
                    currentEntry.isTranslated = event.target.innerText.trim() !== '';
                    currentEntry.charCountTranslation = countCharactersWithoutTags(event.target.innerHTML);
                    currentEntry.cpsTranslation = calculateCPS(event.target.innerHTML, currentEntry.durationMs);
                    autoResizeTextarea(event.target, originalColPre);
                    updateSubtitleStats(event.target, currentEntry.charCountOriginal, currentEntry.durationMs);
                    updateStatsDisplay();
                    updateSubtitlePreview();
                });

                translationEditor.addEventListener('focus', (event) => {
                    document.querySelectorAll('.translation-unit-active').forEach(unit => unit.classList.remove('translation-unit-active'));
                    translationUnit.classList.add('translation-unit-active');
                    termsFoundInActiveSegment.clear();
                    if (glossarySourceLanguage && glossary.length > 0) {
                        const highlightResult = applyGlossaryHighlightToText(entry.original);
                        originalColPre.innerHTML = highlightResult.html;
                        highlightResult.foundTerms.forEach(term => termsFoundInActiveSegment.add(term));
                    }
                    updateGlossaryTableHighlights();
                    autoResizeTextarea(event.target, originalColPre);
                    event.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    tmSearch(srtEntries[entryIndex].original);
                });

                translationEditor.addEventListener('blur', () => {
                    originalColPre.textContent = entry.original;
                    termsFoundInActiveSegment.clear();
                    updateGlossaryTableHighlights();
                    tmSearch();
                });

                validateButton.addEventListener('click', () => {
                    setTranslationEditableState(entryIndex, false);
                    goToNextTranslation(entryIndex);
                });

                editButton.addEventListener('click', () => setTranslationEditableState(entryIndex, true));

                translationsContainer.appendChild(translationUnit);
                updateSubtitleStats(translationEditor, entry.charCountOriginal, entry.durationMs);
            });
            
            saveSrtButton.disabled = false;
            saveProjectBtn.disabled = false;
            statsContainer.classList.remove('hidden');
            videoPlayerContainer.classList.remove('hidden');
            updateStatsDisplay();
            checkEditorScroll();

            const firstEditableSegment = getFirstEditableSegment();
            if (firstEditableSegment) {
                navigateToTranslation(firstEditableSegment.entryIndex);
            }
        }

        /**
         * Updates the display of translation progress and word counts.
         */
        function updateStatsDisplay() {
            const t = translations[currentLanguage];
            let totalSegments = srtEntries.length;
            let translatedSegments = srtEntries.filter(e => e.isTranslated).length;
            let totalWordsOriginal = srtEntries.reduce((acc, e) => acc + e.wordCountOriginal, 0);
            let totalWordsTranslated = srtEntries.reduce((acc, e) => acc + e.wordCountTranslation, 0);

            const percentage = totalSegments > 0 ? ((translatedSegments / totalSegments) * 100).toFixed(0) : 0;
            
            segmentsProgress.textContent = t.segments_progress_text.replace('{0}', translatedSegments).replace('{1}', totalSegments).replace('{2}', percentage);
            wordsTranslated.textContent = t.words_translated_text.replace('{0}', totalWordsTranslated);
            wordsTotal.textContent = t.words_total_text.replace('{0}', totalWordsOriginal);
            wordsRemaining.textContent = t.words_remaining_text.replace('{0}', totalWordsOriginal - totalWordsTranslated);

            const qaErrors = calculateAllQaErrors();
            if (qaErrors.length > 0) {
                qaErrorStats.textContent = t.qa_errors_found.replace('{0}', qaErrors.length);
                qaErrorStats.className = 'qa-error clickable';
            } else {
                qaErrorStats.textContent = t.qa_no_errors;
                qaErrorStats.className = 'qa-success';
            }
        }


        /**
         * Gets the index of the currently focused translation textarea.
         * @returns {{entryIndex: number} | null} The object with index, or null.
         */
        function getCurrentFocusedIndex() {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.classList.contains('subtitle-editor')) {
                return {
                    entryIndex: parseInt(activeElement.dataset.entryIndex)
                };
            }
            return null;
        }

        /**
         * Finds the first editable segment.
         * @returns {{entryIndex: number} | null} The object with index, or null.
         */
        function getFirstEditableSegment() {
            if (srtEntries.length > 0) {
                return { entryIndex: 0 };
            }
            return null;
        }


        /**
         * Navigates to and focuses a specific translation field.
         * @param {number} entryIndex The index of the SRT entry.
         */
        function navigateToTranslation(entryIndex) {
            const targetEditor = document.getElementById(`translation-${entryIndex}`);
            if (targetEditor) {
                const currentlyFocusedEditor = document.activeElement;
                if (currentlyFocusedEditor && currentlyFocusedEditor.classList.contains('subtitle-editor') && currentlyFocusedEditor !== targetEditor) {
                    currentlyFocusedEditor.blur();
                }
                setTranslationEditableState(entryIndex, true);
                targetEditor.scrollIntoView({ behavior: 'smooth', block: 'center' });
                jumpToCurrentSubtitleTime(entryIndex); // Autoplay video
            }
        }

        /**
         * Moves focus to the next translation field.
         * @param {number} currentEntryIndex The current index of the SRT entry.
         */
        function goToNextTranslation(currentEntryIndex) {
            if (srtEntries.length === 0) return;

            let nextEntryIndex = currentEntryIndex + 1;

            if (nextEntryIndex < srtEntries.length) {
                navigateToTranslation(nextEntryIndex);
            } else {
                showMessage(errorMessages[currentLanguage]['reached_last']);
            }
        }

        /**
         * Moves focus to the previous translation field.
         * @param {number} currentEntryIndex The current index of the SRT entry.
         */
        function goToPreviousTranslation(currentEntryIndex) {
            if (srtEntries.length === 0) return;

            let prevEntryIndex = currentEntryIndex - 1;

            if (prevEntryIndex >= 0) {
                navigateToTranslation(prevEntryIndex);
            } else {
                showMessage(errorMessages[currentLanguage]['reached_first']);
            }
        }

        // --- Event Handlers ---

        srtFile.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                await processFile(file);
            }
        });

        saveSrtButton.addEventListener('click', () => {
            if (srtEntries.length === 0) {
                showMessage(errorMessages[currentLanguage]['no_translations_to_save']);
                return;
            }
            fileNameInput.value = currentFileName.replace(/\.srt$/i, '') + '_trad.srt';
            saveSrtModal.classList.remove('hidden');
            fileNameInput.focus();
        });

        cancelSaveBtn.addEventListener('click', () => {
            saveSrtModal.classList.add('hidden');
        });

        confirmSaveBtn.addEventListener('click', () => {
            const filename = fileNameInput.value;
            if (!filename) {
                showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                return;
            }
            showLoadingOverlay(errorMessages[currentLanguage]['saving_file']);
            try {
                const updatedSrtContent = reconstructSrt(srtEntries);
                const blob = new Blob([updatedSrtContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename.endsWith('.srt') ? filename : filename + '.srt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showMessage(errorMessages[currentLanguage]['file_saved_successfully']);
            } catch (error) {
                showMessage(`${errorMessages[currentLanguage]['error_saving_file']} ${error.message}`);
                console.error("Error saving file:", error);
            } finally {
                hideLoadingOverlay();
                saveSrtModal.classList.add('hidden');
            }
        });


        async function processFile(file) {
            currentFileName = file.name;
            videoFileName = null; // Reset video file name when a new SRT is loaded
            showLoadingOverlay(errorMessages[currentLanguage]['loading_file']);

            videoPlayer.pause();
            videoPlayer.src = '';
            videoPlayer.classList.add('hidden');
            document.getElementById('videoLogoPlaceholder').classList.remove('hidden');
            
            const loadVideoBtnSpan = document.querySelector('#loadVideoBtn span');
            if (loadVideoBtnSpan) {
                loadVideoBtnSpan.textContent = translations[currentLanguage]['load_video'];
            }

            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        srtEntries = parseSrtContent(content);
                        renderTranslations(srtEntries);
                        runFullQaCheck();
                        updateStatsDisplay();
                        resolve();
                    } catch (error) {
                        showMessage(`${errorMessages[currentLanguage]['error_reading_file']} ${error.message}`);
                        console.error("Error parsing file:", error);
                        translationsContainer.innerHTML = `<div class="text-center text-red-500 p-4 border border-red-300 rounded-md">${errorMessages[currentLanguage]['file_processing_error']}</div>`;
                        saveSrtButton.disabled = true;
                        saveProjectBtn.disabled = true;
                        statsContainer.classList.add('hidden');
                        videoPlayerContainer.classList.add('hidden');
                        resolve();
                    } finally {
                        hideLoadingOverlay();
                    }
                };
                reader.onerror = () => {
                    showMessage(errorMessages[currentLanguage]['error_reading_file'] + (file.name || ''));
                    saveSrtButton.disabled = true;
                    saveProjectBtn.disabled = true;
                    statsContainer.classList.add('hidden');
                    videoPlayerContainer.classList.add('hidden');
                    hideLoadingOverlay();
                    resolve();
                };
                reader.readAsText(file);
            });
        }

        document.addEventListener('keydown', (event) => {
            // Do not trigger shortcuts if a modal is open or an input field is focused (except our editors)
            if (document.querySelector('.modal:not(.hidden)') || (document.activeElement.tagName === 'INPUT' && document.activeElement.type !== 'file')) {
                return;
            }

            const isEditorFocused = document.activeElement && document.activeElement.classList.contains('subtitle-editor');
            
            // Find which shortcut was triggered
            const triggeredAction = Object.keys(shortcuts).find(action => {
                const shortcut = shortcuts[action];
                // Handle space key correctly
                const keyMatch = (shortcut.key === ' ' && event.code === 'Space') || (shortcut.key.toLowerCase() === event.key.toLowerCase());
                return keyMatch &&
                       shortcut.ctrlKey === event.ctrlKey &&
                       shortcut.altKey === event.altKey &&
                       shortcut.shiftKey === event.shiftKey;
            });

            if (triggeredAction) {
                event.preventDefault();
                const currentFocused = getCurrentFocusedIndex();

                // Execute the action
                switch (triggeredAction) {
                    case 'validateAndNext':
                        if (isEditorFocused) {
                            setTranslationEditableState(currentFocused.entryIndex, false);
                            goToNextTranslation(currentFocused.entryIndex);
                        }
                        break;
                    case 'goToNext':
                        if (isEditorFocused) goToNextTranslation(currentFocused.entryIndex);
                        break;
                    case 'goToPrevious':
                        if (isEditorFocused) goToPreviousTranslation(currentFocused.entryIndex);
                        break;
                    case 'jumpToTime':
                        if (isEditorFocused) jumpToCurrentSubtitleTime(currentFocused.entryIndex);
                        break;
                    case 'playSegment':
                         if (isEditorFocused) jumpToCurrentSubtitleTime(currentFocused.entryIndex);
                        break;
                    case 'bold':
                        if (isEditorFocused) formatText('bold');
                        break;
                    case 'italic':
                        if (isEditorFocused) formatText('italic');
                        break;
                    case 'playPause':
                        if (videoPlayer.paused) videoPlayer.play(); else videoPlayer.pause();
                        break;
                    case 'seekForward':
                        videoPlayer.currentTime += 3;
                        break;
                    case 'seekBackward':
                        videoPlayer.currentTime -= 3;
                        break;
                    case 'seekForwardFast':
                        videoPlayer.currentTime += 5;
                        break;
                    case 'seekBackwardFast':
                        videoPlayer.currentTime -= 5;
                        break;
                    default:
                        // Handle TM and Glossary insertions
                        if (triggeredAction.startsWith('insertTM') && isEditorFocused) {
                            const index = parseInt(triggeredAction.replace('insertTM', '')) - 1;
                            if (currentTMLatestSearchResults.length > index) {
                                document.execCommand('insertHTML', false, currentTMLatestSearchResults[index].tgtText);
                            }
                        } else if (triggeredAction.startsWith('insertGloss') && isEditorFocused) {
                            const index = parseInt(triggeredAction.replace('insertGloss', '')) - 1;
                            if (currentGlossaryLatestResults.length > index) {
                                document.execCommand('insertHTML', false, currentGlossaryLatestResults[index].tgtTerm);
                            }
                        }
                        break;
                }
            }
        });

        // --- Message Box Functions ---
        function showMessage(msg) {
            messageText.textContent = msg;
            messageBox.classList.remove('hidden');
        }

        messageClose.addEventListener('click', () => {
            messageBox.classList.add('hidden');
        });

        // --- Keyboard Shortcuts Modal ---
        shortcutsBtn.addEventListener('click', () => {
            renderShortcutsModal();
            shortcutsModal.classList.remove('hidden');
        });

        shortcutsCloseBtn.addEventListener('click', () => {
            window.removeEventListener('keydown', recordShortcutHandler, true); // Use correct handler
            recordingAction = null;
            shortcutsModal.classList.add('hidden');
        });

        function formatShortcut(shortcut) {
            let parts = [];
            if (shortcut.ctrlKey) parts.push('Ctrl');
            if (shortcut.altKey) parts.push('Alt');
            if (shortcut.shiftKey) parts.push('Shift');
            
            let keyName = shortcut.key;
            if (keyName === ' ') keyName = 'Space';
            
            parts.push(keyName.charAt(0).toUpperCase() + keyName.slice(1));
            return parts.join(' + ');
        }

        function renderShortcutsModal() {
            shortcutsList.innerHTML = '';
            const t = translations[currentLanguage];
            for (const action in shortcuts) {
                const shortcut = shortcuts[action];
                const row = document.createElement('div');
                row.className = 'flex justify-between items-center p-2 border-b';
                
                const description = t[shortcut.descriptionKey] || shortcut.descriptionKey;
                
                row.innerHTML = `
                    <span>${description}</span>
                    <div class="flex items-center gap-2">
                        <span id="shortcut-display-${action}" class="shortcut-input font-mono">${formatShortcut(shortcut)}</span>
                        <button class="btn btn-secondary text-sm" data-action="${action}" data-i18n="edit_shortcut_btn">${t.edit_shortcut_btn}</button>
                    </div>
                `;
                shortcutsList.appendChild(row);
            }

            // Add event listeners to the new edit buttons
            shortcutsList.querySelectorAll('button[data-action]').forEach(button => {
                button.addEventListener('click', () => startRecording(button.dataset.action));
            });
        }
        
        let recordingAction = null;
        const recordShortcutHandler = (e) => {
            if (!recordingAction) return;
        
            e.preventDefault();
            e.stopPropagation();
        
            const modifierKeys = ['Control', 'Alt', 'Shift', 'Meta'];
            if (modifierKeys.includes(e.key)) {
                return; 
            }
        
            window.removeEventListener('keydown', recordShortcutHandler, true);
        
            const newShortcut = {
                key: e.key === ' ' ? ' ' : e.key.toLowerCase(),
                ctrlKey: e.ctrlKey,
                altKey: e.altKey,
                shiftKey: e.shiftKey
            };
        
            const conflict = Object.keys(shortcuts).find(action => 
                action !== recordingAction &&
                shortcuts[action].key === newShortcut.key &&
                shortcuts[action].ctrlKey === newShortcut.ctrlKey &&
                shortcuts[action].altKey === newShortcut.altKey &&
                shortcuts[action].shiftKey === newShortcut.shiftKey
            );
        
            if (conflict) {
                showMessage(errorMessages[currentLanguage].shortcut_conflict);
            } else {
                shortcuts[recordingAction] = { ...shortcuts[recordingAction], ...newShortcut };
                saveShortcuts();
            }
        
            recordingAction = null;
            renderShortcutsModal();
        };

        function startRecording(action) {
            window.removeEventListener('keydown', recordShortcutHandler, true);
            document.querySelectorAll('.shortcut-input.recording').forEach(el => {
                const prevAction = el.id.replace('shortcut-display-', '');
                el.classList.remove('recording');
                el.textContent = formatShortcut(shortcuts[prevAction]);
            });

            recordingAction = action;
            const displayEl = document.getElementById(`shortcut-display-${action}`);
            displayEl.classList.add('recording');
            displayEl.textContent = translations[currentLanguage].recording_shortcut_text;
            
            window.addEventListener('keydown', recordShortcutHandler, true);
        }

        async function saveShortcuts() {
            try {
                await db.settings.put({ key: 'shortcuts', value: shortcuts });
            } catch (error) {
                console.error("Failed to save shortcuts:", error);
            }
        }

        async function loadShortcuts() {
            try {
                const savedShortcuts = await db.settings.get('shortcuts');
                if (savedShortcuts && savedShortcuts.value) {
                    shortcuts = { ...defaultShortcuts, ...savedShortcuts.value };
                }
            } catch (error) {
                console.error("Failed to load shortcuts, using defaults:", error);
                shortcuts = { ...defaultShortcuts };
            }
        }
        
        restoreShortcutsBtn.addEventListener('click', async () => {
            shortcuts = { ...defaultShortcuts };
            await saveShortcuts();
            renderShortcutsModal();
        });

        exportShortcutsBtn.addEventListener('click', () => {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(shortcuts, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "subpanda_shortcuts.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        });

        importShortcutsInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedShortcuts = JSON.parse(e.target.result);
                    if (typeof importedShortcuts === 'object' && importedShortcuts !== null) {
                        shortcuts = { ...defaultShortcuts, ...importedShortcuts };
                        await saveShortcuts();
                        renderShortcutsModal();
                    } else {
                        throw new Error("Invalid format");
                    }
                } catch (err) {
                    showMessage(errorMessages[currentLanguage].shortcut_import_error);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        });


        // --- Find and Replace Modal ---
        findReplaceBtn.addEventListener('click', () => {
            findReplaceModal.classList.remove('hidden');
            findInput.focus();
        });

        findReplaceCloseBtn.addEventListener('click', () => {
            findReplaceModal.classList.add('hidden');
            findState.lastFound = null;
            const currentFocused = getCurrentFocusedIndex();
            if (currentFocused) {
                const targetEditor = document.getElementById(`translation-${currentFocused.entryIndex}`);
                if (targetEditor) {
                    targetEditor.focus();
                }
            }
        });

        findNextBtn.addEventListener('click', () => findAndNavigate(true));
        findPrevBtn.addEventListener('click', () => findAndNavigate(false));
        replaceBtn.addEventListener('click', replaceCurrentMatch);
        replaceAllBtn.addEventListener('click', replaceAllMatches);

        function findAndNavigate(forward = true) {
            const query = findInput.value;
            if (!query) {
                showMessage(errorMessages[currentLanguage]['no_find_query']);
                return;
            }

            findState.query = query;
            findState.caseSensitive = caseSensitiveCheckbox.checked;
            findState.useRegex = regexCheckbox.checked;

            let regex;
            try {
                regex = findState.useRegex ? new RegExp(findState.query, findState.caseSensitive ? '' : 'i') : null;
            } catch (e) {
                showMessage(`Error de expresión regular: ${e.message}`);
                return;
            }

            let startEntryIndex = 0;
            let startMatchIndex = 0;

            if (findState.lastFound) {
                startEntryIndex = findState.lastFound.entryIndex;
                startMatchIndex = forward ? findState.lastFound.matchEnd : findState.lastFound.matchStart - 1;
            } else {
                if (!forward) {
                    startEntryIndex = srtEntries.length - 1;
                    startMatchIndex = Infinity;
                }
            }

            let found = false;
            let currentEntryIndex = startEntryIndex;
            const totalEntries = srtEntries.length;

            for (let i = 0; i < totalEntries; i++) {
                const entry = srtEntries[currentEntryIndex];
                const text = entry.translation;
                let match;

                if (findState.useRegex) {
                    regex.lastIndex = 0;
                    if (forward) {
                        let searchFrom = (currentEntryIndex === startEntryIndex) ? startMatchIndex : 0;
                        const subText = text.substring(searchFrom);
                        match = regex.exec(subText);
                        if (match) {
                            match.index += searchFrom;
                        }
                    } else {
                        let allMatches = [];
                        let tempRegex = new RegExp(regex.source, regex.flags.includes('g') ? regex.flags : regex.flags + 'g');
                        let tempMatch;
                        while((tempMatch = tempRegex.exec(text)) !== null) {
                            allMatches.push(tempMatch);
                        }
                        let searchUntil = (currentEntryIndex === startEntryIndex) ? startMatchIndex : text.length;
                        match = allMatches.reverse().find(m => m.index < searchUntil);
                    }
                } else {
                    const searchText = findState.caseSensitive ? text : text.toLowerCase();
                    const queryLower = findState.caseSensitive ? findState.query : findState.query.toLowerCase();

                    if (forward) {
                        let searchFrom = (currentEntryIndex === startEntryIndex) ? startMatchIndex : 0;
                        const foundIndex = searchText.indexOf(queryLower, searchFrom);
                        if (foundIndex !== -1) {
                            match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                        }
                    } else {
                        let searchUntil = (currentEntryIndex === startEntryIndex) ? startMatchIndex : text.length;
                        const foundIndex = searchText.lastIndexOf(queryLower, searchUntil);
                        if (foundIndex !== -1) {
                            match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                        }
                    }
                }

                if (match) {
                    findState.lastFound = {
                        entryIndex: currentEntryIndex,
                        matchStart: match.index,
                        matchEnd: match.index + match[0].length,
                    };
                    navigateToTranslation(currentEntryIndex);
                    const targetEditor = document.getElementById(`translation-${currentEntryIndex}`);
                    if (targetEditor) {
                        const range = document.createRange();
                        const sel = window.getSelection();
                        range.setStart(targetEditor.firstChild, findState.lastFound.matchStart);
                        range.setEnd(targetEditor.firstChild, findState.lastFound.matchEnd);
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                    found = true;
                    return;
                }

                currentEntryIndex = (currentEntryIndex + (forward ? 1 : -1) + totalEntries) % totalEntries;
            }

            if (!found) {
                showMessage(errorMessages[currentLanguage]['no_match_found']);
                findState.lastFound = null;
            }
        }


        function replaceCurrentMatch() {
            if (!findState.lastFound || !findState.query) {
                showMessage(errorMessages[currentLanguage]['no_match_found']);
                return;
            }

            const { entryIndex, matchStart, matchEnd } = findState.lastFound;
            const entry = srtEntries[entryIndex];
            let originalText = entry.translation;
            let replacedText;

            if (findState.useRegex) {
                 const regex = new RegExp(findState.query, findState.caseSensitive ? '' : 'i');
                 replacedText = originalText.substring(0, matchStart) +
                                originalText.substring(matchStart, matchEnd).replace(regex, findState.replace) +
                                originalText.substring(Math.min(matchEnd, originalText.length));

            } else {
                replacedText = originalText.substring(0, matchStart) +
                               findState.replace +
                               originalText.substring(Math.min(matchEnd, originalText.length));
            }

            entry.translation = replacedText;
            entry.wordCountTranslation = countWords(replacedText);
            entry.isTranslated = replacedText.trim() !== '';
            entry.charCountTranslation = countCharactersWithoutTags(replacedText);
            entry.cpsTranslation = calculateCPS(replacedText, entry.durationMs);

            renderTranslations(srtEntries);
            navigateToTranslation(entryIndex);
            updateStatsDisplay();

            findState.lastFound = null;
        }

        function replaceAllMatches() {
            const query = findInput.value;
            const replaceWith = replaceInput.value;
            if (!query) {
                showMessage(errorMessages[currentLanguage]['no_find_query']);
                return;
            }

            let replacedCount = 0;
            let regex;
            try {
                regex = new RegExp(query, (caseSensitiveCheckbox.checked ? '' : 'i') + 'g' + (regexCheckbox.checked ? '' : ''));
            } catch (e) {
                showMessage(`Error de expresión regular: ${e.message}`);
                return;
            }

            srtEntries.forEach(entry => {
                let originalTranslation = entry.translation;
                let newTranslation;

                if (regexCheckbox.checked) {
                    newTranslation = originalTranslation.replace(regex, replaceWith);
                } else {
                    const searchStr = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const nonRegexRegex = new RegExp(searchStr, (caseSensitiveCheckbox.checked ? '' : 'i') + 'g');
                    newTranslation = originalTranslation.replace(nonRegexRegex, replaceWith);
                }

                if (originalTranslation !== newTranslation) {
                    entry.translation = newTranslation;
                    entry.wordCountTranslation = countWords(newTranslation);
                    entry.isTranslated = newTranslation.trim() !== '';
                    entry.charCountTranslation = countCharactersWithoutTags(newTranslation);
                    entry.cpsTranslation = calculateCPS(newTranslation, entry.durationMs);
                    replacedCount++;
                }
            });

            renderTranslations(srtEntries);
            showMessage(`${replacedCount} ${errorMessages[currentLanguage]['replaced_all']}`);
            findState.lastFound = null;
            updateStatsDisplay();
        }

        function setLanguage(lang) {
            currentLanguage = lang;
            
            langEsBtn.classList.toggle('active', lang === 'es');
            langEnBtn.classList.toggle('active', lang === 'en');

            const t = translations[lang];
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (t[key]) el.textContent = t[key];
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (t[key]) el.placeholder = t[key];
            });
            
            if (srtEntries.length > 0) {
                renderTranslations(srtEntries);
            } else {
                 const initialMessageElement = document.getElementById('initialMessage');
                if (initialMessageElement) initialMessageElement.textContent = t.no_translations;
            }
            renderGlossary();
            tmSearch();
        }

        // --- Terminology Sidebar Logic ---
        function setupPanel(panelId, buttonId, openCallback) {
            const panel = document.getElementById(panelId);
            const button = document.getElementById(buttonId);
            const closeButton = panel.querySelector('button[id^="close"]');

            button.addEventListener('click', () => {
                openFloatingPanel(panel, button, openCallback);
            });

            closeButton.addEventListener('click', () => {
                closeFloatingPanel(panel, button);
            });
        }

        function populateIsoLanguagesDatalist() {
            isoLanguagesDatalist.innerHTML = '';
            isoLanguagesData.forEach(lang => {
                const option = document.createElement('option');
                option.value = lang.code;
                option.textContent = lang.name;
                isoLanguagesDatalist.appendChild(option);
            });
        }

        function resetGlossary() {
            glossary = [];
            glossarySourceLanguage = '';
            glossaryTargetLanguage = '';
            if (configSrcLang) configSrcLang.value = 'en-US';
            if (configTgtLang) configTgtLang.value = 'es-ES';
            if (srcTermInput) srcTermInput.value = "";
            if (tgtTermInput) tgtTermInput.value = "";
            if (searchTermInput) searchTermInput.value = "";
            if (terminologyLanguageConfigSection && terminologyEditorSection) {
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }
            renderGlossary();
        }

        function showLanguageConfigSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection) {
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }
        }

        function showGlossaryEditorSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection && displaySrcLang && displayTgtLang) {
                terminologyLanguageConfigSection.style.display = 'none';
                terminologyEditorSection.style.display = 'block';
                displaySrcLang.value = glossarySourceLanguage;
                displayTgtLang.value = glossaryTargetLanguage;
                renderGlossary();
            }
        }

        function confirmGlossaryLanguages() {
            const srcLang = configSrcLang ? configSrcLang.value.trim() : '';
            const tgtLang = configTgtLang ? configTgtLang.value.trim() : '';
            if (!srcLang || !tgtLang) {
                showMessage(errorMessages[currentLanguage]['lang_config_required']);
                return;
            }
            glossarySourceLanguage = srcLang;
            glossaryTargetLanguage = tgtLang;
            showGlossaryEditorSection();
            renderTranslations(srtEntries);
        }

        function addTerm() {
            const srcTerm = srcTermInput ? srcTermInput.value.trim() : '';
            const tgtTerm = tgtTermInput ? tgtTermInput.value.trim() : '';
            if (!srcTerm || !tgtTerm) {
                showMessage(errorMessages[currentLanguage]['both_terms_required']);
                return;
            }
            glossary.push({
                srcLang: glossarySourceLanguage,
                srcTerm: srcTerm,
                tgtLang: glossaryTargetLanguage,
                tgtTerm: tgtTerm
            });
            if (srcTermInput) srcTermInput.value = "";
            if (tgtTermInput) tgtTermInput.value = "";
            renderGlossary();
            renderTranslations(srtEntries);
        }

        function deleteTerm(index) {
            glossary.splice(index, 1);
            renderGlossary();
            renderTranslations(srtEntries);
        }

        function renderGlossary() {
            if (!glossaryTableBody) return;
            const search = searchTermInput ? searchTermInput.value.toLowerCase() : '';
            glossaryTableBody.innerHTML = "";
            const t = translations[currentLanguage];
            const filteredGlossary = glossary.filter(entry =>
                (entry.srcTerm && entry.srcTerm.toLowerCase().includes(search)) ||
                (entry.tgtTerm && entry.tgtTerm.toLowerCase().includes(search))
            );
            const highlightedTerms = [];
            const otherTerms = [];
            filteredGlossary.forEach(entry => {
                if (entry.srcTerm && termsFoundInActiveSegment.has(entry.srcTerm)) {
                    highlightedTerms.push(entry);
                } else {
                    otherTerms.push(entry);
                }
            });
            currentGlossaryLatestResults = [...highlightedTerms, ...otherTerms.sort((a, b) => a.srcTerm.localeCompare(b.srcTerm))];
            
            const renderRow = (entry) => {
                 const row = document.createElement("tr");
                if (highlightedTerms.includes(entry)) {
                    row.classList.add('glossary-row-highlight');
                }
                row.innerHTML = `<td>${entry.srcTerm}</td><td>${entry.tgtTerm}</td><td><button class="btn btn-destructive text-xs" onclick="deleteTerm(${glossary.indexOf(entry)})">${t.delete_button}</button></td>`;
                glossaryTableBody.appendChild(row);
            };

            currentGlossaryLatestResults.forEach(renderRow);
        }

        function generateTBX() {
            const xml = [`<?xml version="1.0" encoding="UTF-8"?><martif type="TBX" xml:lang="${glossarySourceLanguage}"><text><body>`];
            glossary.forEach(entry => {
                xml.push(`<termEntry><LangSet xml:lang="${entry.srcLang}"><tig><term>${entry.srcTerm}</term></tig></LangSet><LangSet xml:lang="${entry.tgtLang}"><tig><term>${entry.tgtTerm}</term></tig></LangSet></termEntry>`);
            });
            xml.push(`</body></text></martif>`);
            return xml.join("\n");
        }

        /**
         * Opens a modal to ask for a filename before downloading the TBX file.
         */
        function downloadTBX() {
            if (glossary.length === 0 && (!glossarySourceLanguage || !glossaryTargetLanguage)) {
                showMessage(errorMessages[currentLanguage]['cannot_download_empty_or_unconfigured_glossary']);
                return;
            }
            fileNameInputTbx.value = 'glossary.tbx';
            saveTbxModal.classList.remove('hidden');
            fileNameInputTbx.focus();
        }

        function loadTBX() {
            if (!tbxFileInput) return;
            tbxFileInput.click();
            tbxFileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                showLoadingOverlay(errorMessages[currentLanguage]['loading_file']);
                try {
                    const reader = new FileReader();
                    await new Promise((resolve, reject) => {
                        reader.onload = () => {
                            try {
                                const parser = new DOMParser();
                                const xmlDoc = parser.parseFromString(reader.result, "application/xml");
                                if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                                    throw new Error("Invalid XML/TBX format: " + xmlDoc.getElementsByTagName("parsererror")[0].textContent);
                                }
                                if (xmlDoc.getElementsByTagName("tu").length > 0) {
                                    showTMInternalMessage(errorMessages[currentLanguage]['tbx_file_expected_tmx_found'], true);
                                    reject(new Error("Attempted to load TMX into Glossary."));
                                    return;
                                }
                                const entries = xmlDoc.getElementsByTagName("termEntry");
                                glossary = [];
                                let firstEntryLangs = { src: '', tgt: '' };
                                if (entries.length > 0) {
                                    const firstSets = entries[0].getElementsByTagName("LangSet");
                                    if (firstSets.length >= 2) {
                                        firstEntryLangs.src = firstSets[0].getAttribute("xml:lang");
                                        firstEntryLangs.tgt = firstSets[1].getAttribute("xml:lang");
                                    }
                                }
                                for (let entry of entries) {
                                    const sets = entry.getElementsByTagName("LangSet");
                                    if (sets.length >= 2) {
                                        const lang1 = sets[0].getAttribute("xml:lang");
                                        const term1 = sets[0].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                                        const lang2 = sets[1].getAttribute("xml:lang");
                                        const term2 = sets[1].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                                        glossary.push({ srcLang: lang1, srcTerm: term1, tgtLang: lang2, tgtTerm: term2 });
                                    }
                                }
                                if (glossary.length > 0 && firstEntryLangs.src && firstEntryLangs.tgt) {
                                    glossarySourceLanguage = firstEntryLangs.src;
                                    glossaryTargetLanguage = firstEntryLangs.tgt;
                                } else if (glossary.length === 0) {
                                    showMessage(errorMessages[currentLanguage]['error_loading_tbx_file']);
                                }
                                showGlossaryEditorSection();
                                renderTranslations(srtEntries);
                                resolve();
                            } catch (error) {
                                reject(error);
                            }
                        };
                        reader.onerror = reject;
                        reader.readAsText(file);
                    });
                } catch (error) {
                    console.error("Error loading TBX file:", error);
                    if (!error.message.includes("Attempted to load TMX")) {
                        showMessage(errorMessages[currentLanguage]['error_loading_tbx_file']);
                    }
                    resetGlossary();
                } finally {
                    hideLoadingOverlay();
                }
            };
        }

        // --- Translation Memory (TM) Logic ---
        function levenshteinDistance(a, b) {
            const an = a.length, bn = b.length;
            if (an === 0) return bn;
            if (bn === 0) return an;
            const matrix = Array(bn + 1).fill(null).map(() => Array(an + 1).fill(null));
            for (let i = 0; i <= an; i++) matrix[0][i] = i;
            for (let i = 0; i <= bn; i++) matrix[i][0] = i;
            for (let i = 1; i <= bn; i++) {
                for (let j = 1; j <= an; j++) {
                    const cost = a[j - 1] === b[i - 1] ? 0 : 1;
                    matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + cost);
                }
            }
            return matrix[bn][an];
        }

        function calculateSimilarity(s1, s2) {
            if (!s1 || !s2) return 0;
            const longerLength = Math.max(s1.length, s2.length);
            if (longerLength === 0) return 100;
            const distance = levenshteinDistance(s1, s2);
            return ((longerLength - distance) / longerLength) * 100;
        }
        
        function renderDiff(tmText, originalText) {
            const dmp = new diff_match_patch();
            const diffs = dmp.diff_main(tmText, originalText);
            dmp.diff_cleanupSemantic(diffs);

            return diffs.map(([op, text]) => {
                const safeText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '&para;<br>');
                switch (op) {
                    case DIFF_INSERT: return `<span class="diff-insertion">${safeText}</span>`;
                    case DIFF_DELETE: return `<span class="diff-deletion">${safeText}</span>`;
                    case DIFF_EQUAL: return safeText;
                }
            }).join('');
        }

        function showTMInternalMessage(msg, isError = false) {
            if (tmInternalMessage) {
                tmInternalMessage.textContent = msg;
                tmInternalMessage.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'border-red-500', 'bg-blue-100', 'text-blue-800', 'border-blue-500');
                tmInternalMessage.classList.add(isError ? 'bg-red-100' : 'bg-blue-100', isError ? 'text-red-800' : 'text-blue-800', isError ? 'border-red-500' : 'border-blue-500');
                tmInternalMessage.classList.remove('hidden');
            }
        }

        function hideTMInternalMessage() {
            if (tmInternalMessage) {
                tmInternalMessage.classList.add('hidden');
                tmInternalMessage.textContent = '';
            }
        }

        function resetTM() {
            translationMemory = [];
            tmSearchInput.value = '';
            renderTMSearchResults([]);
            showTMLanguageConfigSection();
            hideTMInternalMessage(); // Hide the message on reset
        }

        function showTMLanguageConfigSection() {
            if (tmLanguageConfigSection && tmEditorSection) {
                tmLanguageConfigSection.style.display = 'block';
                tmEditorSection.style.display = 'none';
                if (tmConfigSrcLang) tmConfigSrcLang.value = 'en-US';
                if (tmConfigTgtLang) tmConfigTgtLang.value = 'es-ES';
                hideTMInternalMessage();
            }
        }

        function showTMEditorSection() {
            if (tmLanguageConfigSection && tmEditorSection && displayTmSrcLang && displayTmTgtLang) {
                tmLanguageConfigSection.style.display = 'none';
                tmEditorSection.style.display = 'block';
                displayTmSrcLang.value = tmSourceLanguage;
                displayTmTgtLang.value = tmTargetLanguage;
                tmSearch();
                hideTMInternalMessage();
            }
        }

        function confirmTMLanguages() {
            const srcLang = tmConfigSrcLang ? tmConfigSrcLang.value.trim() : '';
            const tgtLang = tmConfigTgtLang ? tmConfigTgtLang.value.trim() : '';
            if (!srcLang || !tgtLang) {
                showTMInternalMessage(errorMessages[currentLanguage]['lang_config_required'], true);
                return;
            }
            tmSourceLanguage = srcLang;
            tmTargetLanguage = tgtLang;
            showTMEditorSection();
        }

        async function loadTMX(file) {
            showLoadingOverlay(errorMessages[currentLanguage]['loading_file']);
            hideTMInternalMessage();
            try {
                const reader = new FileReader();
                await new Promise((resolve, reject) => {
                    reader.onload = () => {
                        try {
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(reader.result, "application/xml");
                            if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                                throw new Error("Invalid XML/TMX format: " + xmlDoc.getElementsByTagName("parsererror")[0].textContent);
                            }
                            if (xmlDoc.getElementsByTagName("termEntry").length > 0) {
                                showTMInternalMessage(errorMessages[currentLanguage]['tmx_file_expected_tbx_found'], true);
                                reject(new Error("Attempted to load TBX into Translation Memory."));
                                return;
                            }
                            const tuElements = xmlDoc.getElementsByTagName("tu");
                            let newTM = [];
                            let detectedSrcLang = '', detectedTgtLang = '';
                            if (tuElements.length > 0) {
                                const tuvElements = tuElements[0].getElementsByTagName("tuv");
                                if (tuvElements.length >= 2) {
                                    detectedSrcLang = tuvElements[0].getAttribute("xml:lang");
                                    detectedTgtLang = tuvElements[1].getAttribute("xml:lang");
                                }
                            }
                            for (let tu of tuElements) {
                                const tuvElements = tu.getElementsByTagName("tuv");
                                if (tuvElements.length >= 2) {
                                    const srcTuv = tuvElements[0], tgtTuv = tuvElements[1];
                                    const srcLang = srcTuv.getAttribute("xml:lang"), tgtLang = tgtTuv.getAttribute("xml:lang");
                                    const srcSeg = srcTuv.getElementsByTagName("seg")[0]?.textContent || '', tgtSeg = tgtTuv.getElementsByTagName("seg")[0]?.textContent || '';
                                    newTM.push({ srcLang, srcText: srcSeg, tgtLang, tgtSeg, srcWordCount: countWords(srcSeg), tgtWordCount: countWords(tgtSeg) });
                                }
                            }
                            translationMemory = newTM;
                            tmSourceLanguage = detectedSrcLang || (tmConfigSrcLang ? tmConfigSrcLang.value : 'en-US');
                            tmTargetLanguage = detectedTgtLang || (tmConfigTgtLang ? tmConfigTgtLang.value : 'es-ES');
                            showTMInternalMessage(`TMX loaded with ${translationMemory.length} translation units.`);
                            showTMEditorSection();
                            tmSearch();
                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            } catch (error) {
                console.error("Error loading TMX file:", error);
                if (!error.message.includes("Attempted to load TBX")) {
                    showTMInternalMessage(errorMessages[currentLanguage]['error_loading_tmx_file'], true);
                }
                resetTM();
            } finally {
                hideLoadingOverlay();
            }
        }

        function generateTMX() {
            if (translationMemory.length === 0) {
                showTMInternalMessage(errorMessages[currentLanguage]['cannot_download_empty_tm'], true);
                return null;
            }
            const header = `<?xml version="1.0" encoding="UTF-8"?><tmx version="1.4"><header creationtool="subpandaTM" creationtoolversion="1.0" datatype="unknown" segtype="sentence" changeid="subpandaTMUser" srclang="${tmSourceLanguage || 'en-US'}" o-tmf="subpandaTM" adminlang="en-US" ${tmTargetLanguage ? `targetlang="${tmTargetLanguage}"` : ''}> </header><body>`;
            const xml = [header];
            translationMemory.forEach(entry => {
                xml.push(`    <tu><tuv xml:lang="${entry.srcLang}"><seg>${entry.srcText}</seg></tuv><tuv xml:lang="${entry.tgtLang}"><seg>${entry.tgtText}</seg></tuv></tu>`);
            });
            xml.push(`  </body></tmx>`);
            return xml.join("\n");
        }

        /**
         * Opens a modal to ask for a filename before downloading the TMX file.
         */
        function downloadTMX() {
            if (translationMemory.length === 0) {
                showMessage(errorMessages[currentLanguage]['cannot_download_empty_tm']);
                return;
            }
            fileNameInputTmx.value = 'translation_memory.tmx';
            saveTmxModal.classList.remove('hidden');
            fileNameInputTmx.focus();
        }

        function addOrUpdateTMEntry(original, translation) {
            if (!original || !translation || !tmSourceLanguage || !tmTargetLanguage) return;
            const existingIndex = translationMemory.findIndex(e => e.srcText === original && e.srcLang === tmSourceLanguage && e.tgtLang === tmTargetLanguage);
            if (existingIndex !== -1) {
                translationMemory[existingIndex].tgtText = translation;
                translationMemory[existingIndex].tgtWordCount = countWords(translation);
            } else {
                translationMemory.push({ srcLang: tmSourceLanguage, srcText: original, tgtLang: tmTargetLanguage, tgtText: translation, srcWordCount: countWords(original), tgtWordCount: countWords(translation) });
            }
            tmSearch();
        }

        function findBestTMMatch(sourceSegmentText) {
            if (translationMemory.length === 0 || !sourceSegmentText.trim() || !tmSourceLanguage || !tmTargetLanguage) return null;
            let bestMatch = null, highestScore = 0;
            const MIN_FUZZY_THRESHOLD = 70;
            translationMemory.forEach(entry => {
                if (entry.srcLang === tmSourceLanguage && entry.tgtLang === tmTargetLanguage && entry.srcText.trim()) {
                    const score = calculateSimilarity(sourceSegmentText, entry.srcText);
                    if (score >= MIN_FUZZY_THRESHOLD && score > highestScore) {
                        highestScore = score;
                        bestMatch = { ...entry, score: score.toFixed(0) };
                    }
                }
            });
            return bestMatch;
        }

        function tmSearch(activeSegmentOriginalText = null) {
            const query = tmSearchInput ? tmSearchInput.value.toLowerCase().trim() : '';
            if (!activeSegmentOriginalText) {
                const currentFocused = getCurrentFocusedIndex();
                if (currentFocused && srtEntries[currentFocused.entryIndex]) {
                    activeSegmentOriginalText = srtEntries[currentFocused.entryIndex].original;
                }
            }

            const filteredTM = translationMemory.filter(entry => {
                if (query) {
                    return (entry.srcText && entry.srcText.toLowerCase().includes(query)) || (entry.tgtText && entry.tgtText.toLowerCase().includes(query));
                }
                return true;
            });

            let resultsToRender = filteredTM.map(entry => {
                let score = 0;
                let diffHtml = entry.srcText;
                if (activeSegmentOriginalText) {
                    score = calculateSimilarity(activeSegmentOriginalText, entry.srcText);
                    diffHtml = renderDiff(entry.srcText, activeSegmentOriginalText);
                } else if (query) {
                    score = calculateSimilarity(query, entry.srcText);
                }
                return { ...entry, score: score.toFixed(0), diffHtml: diffHtml };
            });

            resultsToRender.sort((a, b) => b.score - a.score);

            const MIN_FUZZY_THRESHOLD = 70;
            resultsToRender.forEach((result, index) => {
                result.isBestMatch = index === 0 && result.score >= MIN_FUZZY_THRESHOLD;
            });

            currentTMLatestSearchResults = resultsToRender;
            renderTMSearchResults(resultsToRender);
        }

        function renderTMSearchResults(results) {
            if (!tmSearchResultsTableBody) return;
            const t = translations[currentLanguage];
            tmSearchResultsTableBody.innerHTML = '';
            if (results.length === 0) {
                if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.remove('hidden');
                return;
            } 
            if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.add('hidden');
            
            hideTMInternalMessage();
            results.forEach(entry => {
                const row = document.createElement('tr');
                if (entry.isBestMatch) row.classList.add('tm-best-match-highlight');
                
                const originalContent = (entry.diffHtml || entry.srcText).replace(/\n/g, '<br>');
                const translationContent = entry.tgtText.replace(/\n/g, '<br>');

                row.innerHTML = `<td>${entry.score}%</td><td class="align-top">${originalContent}</td><td class="align-top">${translationContent}</td>`;
                
                row.addEventListener('click', () => {
                    const currentFocused = getCurrentFocusedIndex();
                    if (currentFocused) {
                        const targetEditor = document.getElementById(`translation-${currentFocused.entryIndex}`);
                        if (targetEditor && targetEditor.contentEditable === 'true') {
                            targetEditor.innerHTML = entry.tgtText;
                            const event = new Event('input', { bubbles: true });
                            targetEditor.dispatchEvent(event);
                        }
                    }
                });
                tmSearchResultsTableBody.appendChild(row);
            });
        }

        function showLoadingOverlay(message) {
            if (loadingMessage && loadingOverlay) {
                loadingMessage.textContent = message;
                loadingOverlay.classList.remove('hidden');
            }
        }

        function hideLoadingOverlay() {
            if (loadingOverlay) {
                loadingOverlay.classList.add('hidden');
            }
        }

        if (dropArea) {
            dropArea.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.add('border-blue-500');
            });
            dropArea.addEventListener('dragleave', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-blue-500');
            });
            dropArea.addEventListener('drop', async (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-blue-500');
                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    const fileToProcess = Array.from(files).find(file => file.name.toLowerCase().endsWith('.srt') || file.name.toLowerCase().endsWith('.subpanda'));
                    if (fileToProcess.name.toLowerCase().endsWith('.srt')) {
                        await processFile(fileToProcess);
                    } else if (fileToProcess.name.toLowerCase().endsWith('.subpanda')) {
                        await loadProject({ target: { files: [fileToProcess] } });
                    } else {
                         showMessage('Por favor, suelta un archivo .srt o .subpanda válido.');
                    }
                }
            });
        }

        if (addTermHeader && addTermContent && addTermAccordionIcon) {
            addTermHeader.addEventListener('click', () => {
                const isCollapsed = addTermContent.classList.contains('collapsed');
                if (isCollapsed) {
                    addTermContent.classList.remove('collapsed');
                    addTermContent.classList.add('expanded');
                    addTermAccordionIcon.classList.remove('rotated');
                } else {
                    addTermContent.classList.remove('expanded');
                    addTermContent.classList.add('collapsed');
                    addTermAccordionIcon.classList.add('rotated');
                }
            });
        }

        if (statsAccordionHeader && statsAccordionContent && statsAccordionIcon) {
            statsAccordionHeader.addEventListener('click', () => {
                const isCollapsed = statsAccordionContent.classList.contains('collapsed');
                if (isCollapsed) {
                    statsAccordionContent.classList.remove('collapsed');
                    statsAccordionContent.classList.add('expanded');
                    statsAccordionIcon.classList.remove('rotated');
                } else {
                    statsAccordionContent.classList.remove('expanded');
                    statsAccordionContent.classList.add('collapsed');
                    statsAccordionIcon.classList.add('rotated');
                }
            });
        }

        videoFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                videoFileName = file.name; // Store video file name
                const videoURL = URL.createObjectURL(file);
                videoPlayer.src = videoURL;
                videoPlayer.load();
                videoPlayer.play();
        
                document.getElementById('videoLogoPlaceholder').classList.add('hidden');
                videoPlayer.classList.remove('hidden');
        
                const loadVideoBtnSpan = document.querySelector('#loadVideoBtn span');
                if (loadVideoBtnSpan) {
                    loadVideoBtnSpan.textContent = translations[currentLanguage]['change_video'];
                }
            } else {
                showMessage(errorMessages[currentLanguage]['video_load_error']);
            }
        });

        /**
         * Jumps the video player to the start time of the specified subtitle and plays until the end time.
         * @param {number} entryIndex The index of the SRT entry to play.
         */
        function jumpToCurrentSubtitleTime(entryIndex) {
            if (srtEntries[entryIndex] && videoPlayer.src) {
                const entry = srtEntries[entryIndex];
                const stopTime = entry.endTimeMs / 1000;
                videoPlayer.currentTime = entry.startTimeMs / 1000;
                videoPlayer.play();

                if (timeUpdateListener) {
                    videoPlayer.removeEventListener('timeupdate', timeUpdateListener);
                }

                timeUpdateListener = () => {
                    if (videoPlayer.currentTime >= stopTime) {
                        videoPlayer.pause();
                        videoPlayer.removeEventListener('timeupdate', timeUpdateListener);
                        timeUpdateListener = null;
                    }
                };
                
                videoPlayer.addEventListener('timeupdate', timeUpdateListener);
            }
        }
        
        /**
         * Updates the subtitle preview overlay based on the video's current time and user selection.
         */
        function updateSubtitlePreview() {
            if (!videoPlayer.src || srtEntries.length === 0) {
                subtitlePreviewText.innerHTML = '';
                return;
            }

            const currentTime = videoPlayer.currentTime;
            let activeSubtitle = null;

            for (const entry of srtEntries) {
                const startTime = entry.startTimeMs / 1000;
                const endTime = entry.endTimeMs / 1000;
                if (currentTime >= startTime && currentTime <= endTime) {
                    activeSubtitle = entry;
                    break;
                }
            }

            if (activeSubtitle) {
                let textToShow = '';
                if (previewSource === 'translation') {
                    textToShow = activeSubtitle.translation.trim() || activeSubtitle.original;
                } else {
                    textToShow = activeSubtitle.original;
                }
                subtitlePreviewText.innerHTML = textToShow;
            } else {
                subtitlePreviewText.innerHTML = '';
            }
        }
        
        // --- Backup and Restore Functions ---
        function getProjectState() {
            if (srtEntries.length === 0) return null;
            return {
                fileName: currentFileName, srtEntries: srtEntries,
                glossary: { data: glossary, sourceLang: glossarySourceLanguage, targetLang: glossaryTargetLanguage },
                translationMemory: { data: translationMemory, sourceLang: tmSourceLanguage, targetLang: tmTargetLanguage },
                qaSettings: qaSettings, lastModified: new Date()
            };
        }

        async function saveBackup() {
            const projectState = getProjectState();
            if (!projectState) {
                backupBtn.classList.remove('animate-pulse-yellow');
                return;
            }
            try {
                await db.projects.put({ id: 1, ...projectState });
                backupBtn.classList.add('animate-pulse-yellow');
            } catch (error) {
                console.error('Error saving backup to IndexedDB:', error);
            }
        }
        
        function restoreProject(backupData) {
            currentFileName = backupData.fileName;
            srtEntries = backupData.srtEntries;
            glossary = backupData.glossary.data || [];
            glossarySourceLanguage = backupData.glossary.sourceLang;
            glossaryTargetLanguage = backupData.glossary.targetLang;
            translationMemory = backupData.translationMemory.data || [];
            tmSourceLanguage = backupData.translationMemory.sourceLang;
            tmTargetLanguage = backupData.translationMemory.targetLang;
            qaSettings = backupData.qaSettings || { cpsLimit: 20, charsPerLineLimit: 42 };
            
            renderTranslations(srtEntries);
            showGlossaryEditorSection();
            showTMEditorSection();
            
            showMessage(errorMessages[currentLanguage]['project_restored_message']);
        }

        // --- QA Functions ---
        function runFullQaCheck() {
            srtEntries.forEach((entry, index) => {
                const editorDiv = document.getElementById(`translation-${index}`);
                if (editorDiv) {
                    updateSubtitleStats(editorDiv, entry.charCountOriginal, entry.durationMs);
                }
            });
            updateStatsDisplay();
        }

        function calculateAllQaErrors() {
            const errors = [];
            srtEntries.forEach((entry, index) => {
                const errorTypes = new Set();
                const currentCPS = calculateCPS(entry.translation, entry.durationMs);
                if (currentCPS > qaSettings.cpsLimit) {
                    errorTypes.add('CPS');
                }
                const lines = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '').split('\n');
                lines.forEach(line => {
                    if (countCharactersWithoutTags(line) > qaSettings.charsPerLineLimit) {
                        errorTypes.add('Line length');
                    }
                });

                if (errorTypes.size > 0) {
                    errors.push({
                        index: index,
                        subtitleIndex: entry.index,
                        text: entry.translation.replace(/<[^>]+>/g, ' ').substring(0, 50) + '...',
                        errors: Array.from(errorTypes)
                    });
                }
            });
            return errors;
        }

        function renderQaErrorList() {
            const errors = calculateAllQaErrors();
            qaErrorListContainer.innerHTML = '';
            const t = translations[currentLanguage];
            if (errors.length === 0) {
                qaErrorListContainer.textContent = t.qa_no_errors;
                return;
            }
            
            errors.forEach(error => {
                const errorItem = document.createElement('div');
                errorItem.className = 'qa-error-item';
                errorItem.dataset.entryIndex = error.index;
                errorItem.innerHTML = `
                    <div class="font-bold">Subtitle #${error.subtitleIndex} <span class="text-red-500">(${error.errors.join(', ')})</span></div>
                    <div class="text-sm text-gray-600">${error.text}</div>
                `;
                qaErrorListContainer.appendChild(errorItem);
            });
        }

        // --- Project Save/Load Functions ---
        async function saveProject() {
            if (srtEntries.length === 0) {
                showMessage(errorMessages[currentLanguage]['no_project_to_save']);
                return;
            }
            showLoadingOverlay(translations[currentLanguage]['saving_file']);

            const projectData = {
                version: '1.0',
                srtEntries,
                glossary,
                glossarySourceLanguage,
                glossaryTargetLanguage,
                translationMemory,
                tmSourceLanguage,
                tmTargetLanguage,
                qaSettings,
                videoFileName,
                currentLanguage
            };

            try {
                const zip = new JSZip();
                zip.file("project.json", JSON.stringify(projectData, null, 2)); // Pretty print JSON

                const content = await zip.generateAsync({ type: "blob" });
                
                const a = document.createElement("a");
                const url = URL.createObjectURL(content);
                a.href = url;
                a.download = currentFileName.replace(/\.[^/.]+$/, '') + '.subpanda';
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(url);
                a.remove();
                
                showMessage('Proyecto guardado con éxito.');

            } catch (error) {
                console.error("Error saving project:", error);
                showMessage('Error al guardar el proyecto.');
            } finally {
                hideLoadingOverlay();
            }
        }

        async function loadProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoadingOverlay(translations[currentLanguage]['loading_file']);
            try {
                const zip = await JSZip.loadAsync(file);
                const projectJsonFile = zip.file("project.json");

                if (!projectJsonFile) {
                    throw new Error("Archivo de proyecto inválido: no se encontró project.json.");
                }

                const projectData = JSON.parse(await projectJsonFile.async("string"));
                
                restoreProjectState(projectData);

                showMessage(errorMessages[currentLanguage]['project_loaded_success']);
                
                if (projectData.videoFileName) {
                    reselectVideoInfo.textContent = translations[currentLanguage]['reselect_video_prompt'].replace('{0}', projectData.videoFileName);
                    reselectVideoModal.classList.remove('hidden');
                }

            } catch (error) {
                console.error("Error loading project:", error);
                showMessage(`${errorMessages[currentLanguage]['error_loading_project']}: ${error.message}`);
            } finally {
                hideLoadingOverlay();
                event.target.value = ''; // Reset file input
            }
        }

        function restoreProjectState(data) {
            srtEntries = data.srtEntries || [];
            glossary = data.glossary || [];
            glossarySourceLanguage = data.glossarySourceLanguage || '';
            glossaryTargetLanguage = data.glossaryTargetLanguage || '';
            translationMemory = data.translationMemory || [];
            tmSourceLanguage = data.tmSourceLanguage || '';
            tmTargetLanguage = data.tmTargetLanguage || '';
            qaSettings = data.qaSettings || { cpsLimit: 20, charsPerLineLimit: 42 };
            videoFileName = data.videoFileName || null;
            currentFileName = data.srtEntries.length > 0 ? (data.videoFileName ? data.videoFileName.replace(/\.[^/.]+$/, ".srt") : 'project.srt') : 'subtitles.srt';

            setLanguage(data.currentLanguage || 'es');
            
            renderTranslations(srtEntries);
            
            if (glossarySourceLanguage) {
                showGlossaryEditorSection();
            } else {
                showLanguageConfigSection();
            }

            if (tmSourceLanguage) {
                showTMEditorSection();
            } else {
                showTMLanguageConfigSection();
            }
        }

        function resetApplicationState() {
            srtEntries = [];
            currentFileName = 'subtitles.srt';
            videoFileName = null;
            
            resetGlossary();
            resetTM();
            
            videoPlayer.pause();
            videoPlayer.src = '';
            videoPlayer.classList.add('hidden');
            document.getElementById('videoLogoPlaceholder').classList.remove('hidden');
            const loadVideoBtnSpan = document.querySelector('#loadVideoBtn span');
            if (loadVideoBtnSpan) {
                loadVideoBtnSpan.textContent = translations[currentLanguage]['load_video'];
            }
            
            renderTranslations([]);
            updateStatsDisplay();
            
            confirmNewProjectModal.classList.add('hidden');
        }

        // --- START: Floating Panel Logic (Drag, Resize, and Close) ---
        function closeFloatingPanel(panel, triggerButton) {
            panel.classList.remove('is-visible');
        
            if (triggerButton) {
                triggerButton.classList.remove('btn-primary');
                triggerButton.classList.add('btn-secondary');
            }
        }

        function openFloatingPanel(panelToOpen, triggerButton, callback) {
            if (panelToOpen.classList.contains('is-visible')) {
                closeFloatingPanel(panelToOpen, triggerButton);
                return;
            }

            if (!panelToOpen.dataset.moved) {
                // Reset to default position class if it hasn't been moved by the user
                panelToOpen.style.left = '';
                panelToOpen.style.top = '';
                panelToOpen.style.right = '';
                panelToOpen.style.bottom = '';
                panelToOpen.style.width = '';
                panelToOpen.style.height = '';
            }
            
            panelToOpen.classList.add('is-visible');
            
            if (triggerButton) {
                triggerButton.classList.remove('btn-secondary');
                triggerButton.classList.add('btn-primary');
            }

            if (callback) {
                callback();
            }
        }

        function makePanelDraggable(panel) {
            const header = panel.querySelector('.sidebar-header');
            let isDragging = false;
            let offsetX, offsetY;

            header.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
                
                isDragging = true;
                panel.dataset.moved = 'true'; 
                
                panel.style.right = 'auto';
                panel.style.bottom = 'auto';
                
                offsetX = e.clientX - panel.offsetLeft;
                offsetY = e.clientY - panel.offsetTop;
                
                panel.style.transition = 'none';
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'move';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                let newX = e.clientX - offsetX;
                let newY = e.clientY - offsetY;

                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const panelWidth = panel.offsetWidth;
                const panelHeight = panel.offsetHeight;
                const headerHeight = 60;

                if (newX < 0) newX = 0;
                if (newY < headerHeight) newY = headerHeight;
                if (newX + panelWidth > viewportWidth) newX = viewportWidth - panelWidth;
                if (newY + panelHeight > viewportHeight) newY = viewportHeight - panelHeight;

                panel.style.left = `${newX}px`;
                panel.style.top = `${newY}px`;
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    panel.style.transition = ''; 
                    document.body.style.userSelect = '';
                    document.body.style.cursor = '';
                }
            });
        }

        function makePanelResizable(panel) {
            const resizers = panel.querySelectorAll('.resizer');
            let currentResizer;
            let original_width = 0;
            let original_height = 0;
            let original_x = 0;
            let original_y = 0;
            let original_mouse_x = 0;
            let original_mouse_y = 0;

            resizers.forEach(resizer => {
                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    currentResizer = e.target;
                    original_width = parseFloat(getComputedStyle(panel, null).getPropertyValue('width').replace('px', ''));
                    original_height = parseFloat(getComputedStyle(panel, null).getPropertyValue('height').replace('px', ''));
                    original_x = panel.getBoundingClientRect().left;
                    original_y = panel.getBoundingClientRect().top;
                    original_mouse_x = e.pageX;
                    original_mouse_y = e.pageY;
                    panel.dataset.moved = 'true'; // Mark as moved/resized

                    window.addEventListener('mousemove', resize);
                    window.addEventListener('mouseup', stopResize);
                });
            });

            function resize(e) {
                if (currentResizer.classList.contains('resizer-br')) {
                    const width = original_width + (e.pageX - original_mouse_x);
                    const height = original_height + (e.pageY - original_mouse_y);
                    if (width > panel.minWidth) panel.style.width = width + 'px';
                    if (height > panel.minHeight) panel.style.height = height + 'px';
                } else if (currentResizer.classList.contains('resizer-bl')) {
                    const width = original_width - (e.pageX - original_mouse_x);
                    const height = original_height + (e.pageY - original_mouse_y);
                    if (width > panel.minWidth) {
                        panel.style.width = width + 'px';
                        panel.style.left = original_x + (e.pageX - original_mouse_x) + 'px';
                    }
                    if (height > panel.minHeight) panel.style.height = height + 'px';
                } else if (currentResizer.classList.contains('resizer-tr')) {
                    const width = original_width + (e.pageX - original_mouse_x);
                    const height = original_height - (e.pageY - original_mouse_y);
                    if (width > panel.minWidth) panel.style.width = width + 'px';
                    if (height > panel.minHeight) {
                        panel.style.height = height + 'px';
                        panel.style.top = original_y + (e.pageY - original_mouse_y) + 'px';
                    }
                } else if (currentResizer.classList.contains('resizer-tl')) {
                    const width = original_width - (e.pageX - original_mouse_x);
                    const height = original_height - (e.pageY - original_mouse_y);
                    if (width > panel.minWidth) {
                        panel.style.width = width + 'px';
                        panel.style.left = original_x + (e.pageX - original_mouse_x) + 'px';
                    }
                    if (height > panel.minHeight) {
                        panel.style.height = height + 'px';
                        panel.style.top = original_y + (e.pageY - original_mouse_y) + 'px';
                    }
                } else if (currentResizer.classList.contains('resizer-t')) {
                    const height = original_height - (e.pageY - original_mouse_y);
                    if (height > panel.minHeight) {
                        panel.style.height = height + 'px';
                        panel.style.top = original_y + (e.pageY - original_mouse_y) + 'px';
                    }
                } else if (currentResizer.classList.contains('resizer-b')) {
                    const height = original_height + (e.pageY - original_mouse_y);
                    if (height > panel.minHeight) panel.style.height = height + 'px';
                } else if (currentResizer.classList.contains('resizer-l')) {
                    const width = original_width - (e.pageX - original_mouse_x);
                    if (width > panel.minWidth) {
                        panel.style.width = width + 'px';
                        panel.style.left = original_x + (e.pageX - original_mouse_x) + 'px';
                    }
                } else { // resizer-r
                    const width = original_width + (e.pageX - original_mouse_x);
                    if (width > panel.minWidth) panel.style.width = width + 'px';
                }
            }

            function stopResize() {
                window.removeEventListener('mousemove', resize);
                window.removeEventListener('mouseup', stopResize);
            }
        }
        // --- END: Floating Panel Logic ---


        // --- Initialization on page load ---
        document.addEventListener('DOMContentLoaded', async () => {
            await loadShortcuts();
            populateIsoLanguagesDatalist();
            setLanguage('es'); 
            resetApplicationState();

            // Initialize floating panels
            makePanelDraggable(document.getElementById('terminologySidebar'));
            makePanelDraggable(document.getElementById('translationMemorySidebar'));
            makePanelResizable(document.getElementById('terminologySidebar'));
            makePanelResizable(document.getElementById('translationMemorySidebar'));
            
            // Setup panel buttons
            setupPanel('terminologySidebar', 'terminologyBtn', () => {
                 if (!glossarySourceLanguage || !glossaryTargetLanguage) {
                    showLanguageConfigSection();
                } else {
                    showGlossaryEditorSection();
                }
            });
            setupPanel('translationMemorySidebar', 'tmBtn', () => {
                if (!tmSourceLanguage || !tmTargetLanguage) {
                    showTMLanguageConfigSection();
                } else {
                    showTMEditorSection();
                    tmSearch();
                }
            });

            // Reset Panels Button
            resetPanelsBtn.addEventListener('click', () => {
                const panels = [terminologySidebar, translationMemorySidebar];
                const buttons = [terminologyBtn, tmBtn];
                panels.forEach((panel, index) => {
                    closeFloatingPanel(panel, buttons[index]);
                    // Clear custom styles and state
                    panel.removeAttribute('style');
                    panel.removeAttribute('data-moved');
                });
            });


            if (saveSrtButton) saveSrtButton.disabled = true;
            if (statsContainer) statsContainer.classList.add('hidden');
            if (videoPlayerContainer) videoPlayerContainer.classList.add('hidden');
            if (addTermContent) addTermContent.classList.add('collapsed');
            if (statsAccordionContent) statsAccordionContent.classList.add('collapsed');
            
            subtitleFontSize.addEventListener('input', (event) => {
                subtitlePreviewText.style.fontSize = `${event.target.value}px`;
            });
            subtitlePreviewText.style.fontSize = `${subtitleFontSize.value}px`;

            videoPlayer.addEventListener('timeupdate', updateSubtitlePreview);
            
            subtitlePreviewSource.addEventListener('change', (event) => {
                previewSource = event.target.value;
                updateSubtitlePreview();
            });

            // Language switcher events
            langEsBtn.addEventListener('click', () => setLanguage('es'));
            langEnBtn.addEventListener('click', () => setLanguage('en'));

            // Resizer logic
            const horizontalResizer = document.getElementById('horizontal-resizer');
            const videoSection = document.querySelector('.video-player-section');
            let isHorizontalResizing = false;
            horizontalResizer.addEventListener('mousedown', () => { isHorizontalResizing = true; document.body.style.cursor = 'col-resize'; });
            document.addEventListener('mousemove', (e) => { if (isHorizontalResizing) { const container = document.querySelector('.main-app-content'); const newVideoWidthPercent = ((e.clientX - container.getBoundingClientRect().left) / container.offsetWidth) * 100; if (newVideoWidthPercent > 20 && newVideoWidthPercent < 80) videoSection.style.flexBasis = `${newVideoWidthPercent}%`; } });
            document.addEventListener('mouseup', () => { isHorizontalResizing = false; document.body.style.cursor = ''; });
            
            // Editor scroll indicator logic
            editorMainContent.addEventListener('scroll', checkEditorScroll);
            new ResizeObserver(checkEditorScroll).observe(editorMainContent);


            // Backup Initialization
            try {
                const backup = await db.projects.get(1);
                if (backup) backupBtn.classList.add('animate-pulse-yellow');
            } catch (error) {
                console.error('Error checking initial backup:', error);
            }
            setInterval(saveBackup, 300000);

            backupBtn.addEventListener('click', async () => {
                const backup = await db.projects.get(1);
                if (backup) {
                    backupFileName.textContent = backup.fileName;
                    backupLastModified.textContent = new Date(backup.lastModified).toLocaleString();
                    backupFoundView.classList.remove('hidden');
                    noBackupFoundView.classList.add('hidden');
                } else {
                    backupFoundView.classList.add('hidden');
                    noBackupFoundView.classList.remove('hidden');
                }
                backupModal.classList.remove('hidden');
            });
            closeBackupModalBtn.addEventListener('click', () => backupModal.classList.add('hidden'));
            confirmRestoreBtn.addEventListener('click', async () => {
                const backup = await db.projects.get(1);
                if (backup) {
                    restoreProject(backup);
                    backupModal.classList.add('hidden');
                }
            });
            deleteBackupBtn.addEventListener('click', async () => {
                if (confirm(errorMessages[currentLanguage]['backup_deleted_confirmation'])) {
                    await db.projects.delete(1);
                    backupBtn.classList.remove('animate-pulse-yellow');
                    backupModal.classList.add('hidden');
                    showMessage(errorMessages[currentLanguage]['backup_deleted_message']);
                }
            });
            exportSrtFromBackupBtn.addEventListener('click', async () => {
                const backup = await db.projects.get(1);
                if (!backup) { showMessage(errorMessages[currentLanguage]['no_backup_to_export']); return; }
                try {
                    const srtContent = reconstructSrt(backup.srtEntries);
                    const newFileName = `${backup.fileName.replace(/\.srt$/i, '')}_recuperado_${new Date().toISOString().slice(0, 10)}.srt`;
                    const blob = new Blob([srtContent], { type: 'text/plain;charset=utf-8' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = newFileName;
                    a.click();
                    URL.revokeObjectURL(a.href);
                    showMessage(`${errorMessages[currentLanguage]['backup_export_success']}: "${newFileName}"`);
                } catch (error) {
                    showMessage(`${errorMessages[currentLanguage]['backup_export_error']}${error.message}`);
                }
            });

            // QA Modal Initialization
            qaBtn.addEventListener('click', () => {
                qaCpsLimitInput.value = qaSettings.cpsLimit;
                qaCharsPerLineLimitInput.value = qaSettings.charsPerLineLimit;
                qaModal.classList.remove('hidden');
            });
            closeQaModalBtn.addEventListener('click', () => qaModal.classList.add('hidden'));
            saveQaSettingsBtn.addEventListener('click', () => {
                qaSettings.cpsLimit = parseInt(qaCpsLimitInput.value, 10) || qaSettings.cpsLimit;
                qaSettings.charsPerLineLimit = parseInt(qaCharsPerLineLimitInput.value, 10) || qaSettings.charsPerLineLimit;
                runFullQaCheck();
                qaModal.classList.add('hidden');
            });

            // QA Error List Modal Initialization
            qaErrorStats.addEventListener('click', () => {
                if (calculateAllQaErrors().length > 0) {
                    renderQaErrorList();
                    qaErrorListModal.classList.remove('hidden');
                }
            });
            closeQaErrorListModalBtn.addEventListener('click', () => qaErrorListModal.classList.add('hidden'));
            qaErrorListContainer.addEventListener('click', (event) => {
                const errorItem = event.target.closest('.qa-error-item');
                if (errorItem) {
                    navigateToTranslation(parseInt(errorItem.dataset.entryIndex, 10));
                    qaErrorListModal.classList.add('hidden');
                }
            });

            // Event listeners for TBX/TMX modals
            cancelSaveTbxBtn.addEventListener('click', () => {
                saveTbxModal.classList.add('hidden');
            });

            confirmSaveTbxBtn.addEventListener('click', () => {
                const filename = fileNameInputTbx.value;
                if (!filename) {
                    showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                    return;
                }
                showLoadingOverlay(errorMessages[currentLanguage]['saving_file']);
                try {
                    const tbxContent = generateTBX();
                    const blob = new Blob([tbxContent], { type: "application/xml" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = filename.endsWith('.tbx') ? filename : filename + '.tbx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showMessage(errorMessages[currentLanguage]['file_saved_successfully_tbx']);
                } catch (error) {
                    showMessage(`${errorMessages[currentLanguage]['error_saving_file']} ${error.message}`);
                    console.error("Error downloading TBX:", error);
                } finally {
                    hideLoadingOverlay();
                    saveTbxModal.classList.add('hidden');
                }
            });

            cancelSaveTmxBtn.addEventListener('click', () => {
                saveTmxModal.classList.add('hidden');
            });

            confirmSaveTmxBtn.addEventListener('click', () => {
                const filename = fileNameInputTmx.value;
                if (!filename) {
                    showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                    return;
                }
                showLoadingOverlay(errorMessages[currentLanguage]['saving_file']);
                try {
                    const tmxContent = generateTMX();
                    if (!tmxContent) return;
                    const blob = new Blob([tmxContent], { type: "application/xml" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = filename.endsWith('.tmx') ? filename : filename + '.tmx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showMessage(errorMessages[currentLanguage]['file_saved_successfully_tmx']);
                } catch (error) {
                    showMessage(`${errorMessages[currentLanguage]['error_saving_file']} ${error.message}`);
                    console.error("Error downloading TMX:", error);
                } finally {
                    hideLoadingOverlay();
                    saveTmxModal.classList.add('hidden');
                }
            });

            // Project Save/Load Listeners
            newProjectBtn.addEventListener('click', () => {
                if (srtEntries.length > 0) {
                    confirmNewProjectModal.classList.remove('hidden');
                } else {
                    resetApplicationState();
                }
            });
            saveProjectBtn.addEventListener('click', saveProject);
            projectFile.addEventListener('change', loadProject);
            
            // TMX File Input Listener
            tmFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    loadTMX(file);
                }
                event.target.value = ''; // Reset input
            });

            // New Project Confirmation Modal Listeners
            cancelNewProjectBtn.addEventListener('click', () => {
                confirmNewProjectModal.classList.add('hidden');
            });
            continueWithoutSavingBtn.addEventListener('click', () => {
                resetApplicationState();
            });
            saveAndContinueBtn.addEventListener('click', async () => {
                await saveProject();
                resetApplicationState();
            });


            reselectVideoInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    videoFileName = file.name;
                    const videoURL = URL.createObjectURL(file);
                    videoPlayer.src = videoURL;
                    videoPlayer.load();
                    videoPlayer.play();
            
                    document.getElementById('videoLogoPlaceholder').classList.add('hidden');
                    videoPlayer.classList.remove('hidden');
            
                    const loadVideoBtnSpan = document.querySelector('#loadVideoBtn span');
                    if (loadVideoBtnSpan) {
                        loadVideoBtnSpan.textContent = translations[currentLanguage]['change_video'];
                    }
                    reselectVideoModal.classList.add('hidden');
                }
            });

            skipReselectVideoBtn.addEventListener('click', () => {
                reselectVideoModal.classList.add('hidden');
            });
        });
    </script>
</body>
</html>
