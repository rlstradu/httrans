<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">subpandaTM</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    <script src="https://unpkg.com/dexie@latest/dist/dexie.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/7.7.5/plugins/regions.min.js"></script>
    <style>
        /* General styles for body and font */
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: #f3f4f6;
            color: #202020;
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-y: auto;
        }

        /* Ensures preformatted text respects line breaks and doesn't overflow */
        pre {
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Style for the check icon (SVG) */
        .check-icon {
            display: none;
            margin-left: 8px;
            vertical-align: middle;
            width: 20px;
            height: 20px;
            color: #22c55e;
        }

#statsContainer {
            display: none !important; /* Oculta el div de estad√≠sticas permanentemente */
        }

        /* Estilo del contenedor principal de la barra */
.cps-bar-container {
    width: 100%;
    height: 6px; /* Altura fina */
    background-color: #e5e7eb; /* Fondo gris claro */
    border-radius: 3px;
    margin-top: 5px; /* Separaci√≥n del editor */
    position: relative;
    overflow: hidden; /* Asegura que la barra de llenado no se salga */
}

/* Estilo de la barra de llenado */
.cps-bar-fill {
    height: 100%;
    width: 0; /* Inicialmente a 0 */
    background-color: #22c55e; /* Verde por debajo del l√≠mite */
    transition: width 0.1s ease-out, background-color 0.3s ease; /* Transici√≥n suave */
}

/* Estilo del indicador de l√≠mite (la 'l√≠nea') */
.cps-bar-limit-marker {
    position: absolute;
    top: 0;
    width: 2px; /* Ancho de la l√≠nea de l√≠mite */
    height: 100%;
    background-color: #075BA2; /* Color de la l√≠nea de l√≠mite */
    z-index: 10; /* Asegura que est√© por encima del relleno */
    box-shadow: 0 0 2px rgba(0, 0, 0, 0.2);
    /* Se posicionar√° din√°micamente con JavaScript */
}

/* --- ESTILOS PARA LAS REGIONES DE WAVESURFER (MODIFICADO v2) --- */
        #waveform ::part(region) {
            z-index: 10;
            overflow: visible !important;
            background-color: rgba(7, 91, 162, 0.7);
            border-left: 1px solid rgba(7, 91, 162, 0.9);
            border-right: 1px solid rgba(7, 91, 162, 0.9);
            transition: background-color 0.15s ease;
font-size: small;
    color: #fff !important;
    padding: 10px;
        }
        #waveform ::part(region):hover {
            background-color: rgba(6, 78, 138, 0.8);
        }
        #waveform ::part(region-handle-left),
        #waveform ::part(region-handle-right) {
            background-color: rgba(7, 91, 162, 0.9);
            width: 5px;
            cursor: ew-resize;
        }
        .region-content {
            position: absolute;
            top: -65px; /* Ajustado para 4 l√≠neas */
            left: 0;
            width: 100%;
            font-size: 8px;
            line-height: 1.3; /* Espaciado entre l√≠neas */
            color: #fff;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 3px 6px; /* Padding reducido verticalmente */
            border-radius: 3px;
            pointer-events: none;
            box-sizing: border-box;
            overflow: hidden; /* Oculta el desbordamiento general */
        }
        .region-content .region-line {
            white-space: nowrap; /* Evita que el texto salte de l√≠nea */
            overflow: hidden; /* Oculta el texto que se sale */
            text-overflow: ellipsis; /* A√±ade puntos suspensivos (...) */
            margin-bottom: 1px; /* Peque√±o espacio entre l√≠neas */
        }
        .region-content .region-line:last-child {
            margin-bottom: 0; /* Sin margen inferior en la √∫ltima l√≠nea */
        }
        .region-content .region-line1 { /* N√∫mero */
            font-weight: bold;
            color: #E0E0E0; /* Blanco un poco m√°s tenue */
        }
        .region-content .region-line2 { /* Original */
            color: #A0A0A0; /* Gris√°ceo para diferenciar */
        }
        .region-content .region-line3 { /* Traducci√≥n */
            color: #FFFFFF; /* Blanco brillante */
            min-height: 1.3em; /* Asegura altura m√≠nima aunque est√© vac√≠o */
        }
        .region-content .region-line4 { /* Stats */
            color: #facc15; /* Amarillo para stats */
            font-family: monospace; /* Fuente monoespaciada para stats */
        }
        /* --- FIN ESTILOS REGIONES --- */

/* --- INICIO: ESTILOS PARA ONDA BLOQUEADA --- */
        #waveform.is-locked ::part(region) {
            opacity: 0.4 !important; /* M√°s transparente */
            transition: opacity 0.3s ease; /* Transici√≥n para la opacidad */
        }

        /* Oculta el icono de candado que no corresponda */
        #lockWaveformBtn .lock-icon-open.hidden,
        #lockWaveformBtn .lock-icon-closed.hidden {
            display: none;
        }
        /* --- FIN: ESTILOS PARA ONDA BLOQUEADA --- */

/* --- INICIO: ESTILO PARA REGI√ìN ACTIVA EN SEGUIMIENTO --- */
        #waveform ::part(region.region-playback-active) {
            background-color: rgba(255, 165, 0, 0.6) !important; /* Naranja semi-transparente */
            border-left: 2px solid rgba(255, 140, 0, 0.9);
            border-right: 2px solid rgba(255, 140, 0, 0.9);
            transition: background-color 0.1s ease-out, border-color 0.1s ease-out;
        }
        /* --- FIN: ESTILO PARA REGI√ìN ACTIVA --- */

/* --- INICIO: ESTILOS PARA SUBT√çTULO ACTIVO EN EDITOR --- */
        /* Estilo para el div editable cuando tiene el foco */
        .translation-editor-wrapper div[contenteditable="true"]:focus {
            border-color: #333 !important; /* Borde m√°s oscuro */
            box-shadow: 0 0 0 1px #333; /* Opcional: una sombra sutil para realzar */
        }

        /* Estilo para la unidad completa del subt√≠tulo cuando un editor interno tiene el foco */
        .translation-unit-active {
            background-color: #ffffff !important; 
            transition: background-color 0.2s ease-in-out; /* Transici√≥n suave */
        }
        /* --- FIN: ESTILOS PARA SUBT√çTULO ACTIVO EN EDITOR --- */

        /* --- UNIFIED BUTTON STYLES --- */
        .btn {
            padding: 0.25rem 0.75rem; /* Reduced padding */
            font-size: 0.875rem; /* Smaller font size */
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid transparent;
            white-space: nowrap;
        }
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Primary button style */
        .btn-primary {
            background-color: #075BA2;
            color: white;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #064f8a;
        }

        /* Secondary button style */
        .btn-secondary {
            background-color: #e5e7eb;
            color: #1f2937;
            border-color: #d1d5db;
        }

       .btn-secondary:hover:not(:disabled) {
            background-color: #d1d5db; /* Gris claro al pasar el rat√≥n */
        }

        /* A√ëADIR ESTA REGLA: Mantener azul en hover si est√° activo */
        .btn-secondary.active:hover:not(:disabled) {
            background-color: #064f8a; /* Un azul ligeramente m√°s oscuro que el activo, opcional */
            /* O si prefieres que NO cambie NADA al hacer hover cuando est√° activo: */
            /* background-color: #075BA2 !important; /* Mantiene el azul primario */
        }

/* Active style for toggle buttons */
.btn-secondary.active {
    background-color: #075BA2;
    color: white;
    font-weight: 700;
}

        /* Destructive button style */
        .btn-destructive {
            background-color: #ef4444;
            color: white;
        }
        .btn-destructive:hover:not(:disabled) {
            background-color: #dc2626;
        }
        
        /* Language button style */
        .btn-lang {
            background-color: #f3f4f6;
            color: #4b5563;
            padding: 0.25rem 0.75rem;
        }
        .btn-lang.active {
            background-color: #075BA2;
            color: white;
            font-weight: 700;
        }

.btn-active {
            background-color: #075BA2 !important; /* Mismo azul que el primario */
            color: white !important; /* Forzamos el color blanco */
            font-weight: 700 !important; /* Forzamos la negrita */
        }




        /* Specific styles for code display fields (original, translation) */
        .subtitle-display-code {
            background-color: #e3e3e3;
            border: 1px solid #000;
            color: #202020;
        }
        .subtitle-editor {
            background-color: #ffffff;
            color: #000000;
            min-height: 50px;
            border: 1px solid #d1d5db;
            padding: 0.5rem;
            border-radius: 0.375rem;
        }
        .subtitle-editor[contenteditable="false"] {
            background-color: #f3f4f6;
        }

        /* Background of translation units */
        .translation-unit-bg {
            background-color: #f8f8f8;
            border-color: #e5e7eb;
        }

        /* 2-column layout classes */
        .translation-row {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        @media (min-width: 768px) {
            .translation-row {
                flex-direction: row;
            }
            .original-col, .translation-col {
                flex: 1;
            }
        }

        /* Modal (pop-up) styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            width: 500px;
        }
        #shortcutsModal .modal-content,
        #findReplaceModal .modal-content {
            width: 650px;
            max-width: 95%;
        }
        .shortcut-icon {
            display: inline-block;
            width: 1em;
            height: 1em;
            vertical-align: middle;
            margin: 0 4px;
        }
        .shortcut-input {
            border: 1px solid #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: #f9f9f9;
            cursor: pointer;
            text-align: center;
            min-width: 120px;
            display: inline-block;
        }
        .shortcut-input.recording {
            background-color: #fffbe6;
            border-color: #facc15;
        }

        /* --- START: Floating Panel Styles --- */
        .floating-panel {
            position: fixed;
            width: 480px;
            min-width: 350px;
            max-width: 80vw;
            height: 75vh;
            min-height: 300px;
            background-color: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 950;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Changed from 'hidden' to allow resizers to be placed outside */
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

        #terminologySidebar {
            top: auto;
            right: auto;
            bottom: 20px;
            left: 20px;
            transform-origin: bottom left;
        }

        #translationMemorySidebar {
            top: auto;
            right: 20px;
            bottom: 20px;
            left: auto;
            transform-origin: bottom right;
        }

        .floating-panel.is-visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        
        .floating-panel .sidebar-header {
            cursor: move;
            background-color: #f9fafb;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e5e7eb;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .floating-panel .sidebar-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .panel-resizer {
            position: absolute;
            background: transparent;
        }
        .panel-resizer.top { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .panel-resizer.bottom { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .panel-resizer.left { top: 0; bottom: 0; left: -5px; width: 10px; cursor: ew-resize; }
        .panel-resizer.right { top: 0; bottom: 0; right: -5px; width: 10px; cursor: ew-resize; }
        .panel-resizer.top-left { top: -5px; left: -5px; width: 10px; height: 10px; cursor: nwse-resize; z-index: 1; }
        .panel-resizer.top-right { top: -5px; right: -5px; width: 10px; height: 10px; cursor: nesw-resize; z-index: 1; }
        .panel-resizer.bottom-left { bottom: -5px; left: -5px; width: 10px; height: 10px; cursor: nesw-resize; z-index: 1; }
        .panel-resizer.bottom-right { bottom: -5px; right: -5px; width: 10px; height: 10px; cursor: nwse-resize; z-index: 1; }
        
        /* --- END: Floating Panel Styles --- */


        /* Glossary/TM specific styles */
        .glossary-input-group input, .glossary-input-group select,
        .tm-input-group input, .tm-input-group select,
        .qa-input-group input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9rem;
            margin-top: 4px;
            color: #202020;
            background-color: #fff;
        }
        .glossary-info-box, .tm-info-box {
            background-color: #f0f8ff;
            border: 1px solid #d0e8f8;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            color: #333;
        }
        .glossary-highlight {
            background-color: #ffcc00;
            padding: 0 2px;
            border-radius: 3px;
        }
        .glossary-row-highlight {
            background-color: #ffcc00 !important;
            transition: background-color 0.3s ease;
        }

        /* Active translation unit highlight */
        .translation-unit-active {
            border: 2px solid #075BA2;
            box-shadow: 0 0 0 3px rgba(7, 91, 162, 0.25);
        }

        /* Loading Overlay Styles */
        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1001; font-size: 1.2rem; color: #333;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db;
            border-radius: 50%; width: 40px; height: 40px;
            animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Accordion styles */
        .accordion-item { border: 1px solid #e5e7eb; border-radius: 0.5rem; overflow: hidden; margin-bottom: 1rem; }
        .accordion-header { display: flex; align-items: center; justify-content: space-between; cursor: pointer; padding: 0.75rem 1rem; background-color: #f9fafb; border-bottom: 1px solid #e5e7eb; user-select: none; }
        .accordion-header:hover { background-color: #f3f4f6; color: #075BA2; }
        .accordion-icon { transition: transform 0.3s ease; }
        .accordion-icon.rotated { transform: rotate(180deg); }
        .accordion-content { overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; padding: 0 1rem; }
        .accordion-content.collapsed { max-height: 0; padding-top: 0; padding-bottom: 0; }
        .accordion-content.expanded { max-height: 500px; padding-top: 1rem; padding-bottom: 1rem; }

        /* TM Table styles */
        .tm-table {
            table-layout: fixed;
            width: 100%;
        }
        .tm-table th:nth-child(1), .tm-table td:nth-child(1) { width: 15%; text-align: center; }
        .tm-table th:nth-child(2), .tm-table td:nth-child(2),
        .tm-table th:nth-child(3), .tm-table td:nth-child(3) {
            width: 42.5%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        .tm-best-match-highlight { background-color: #d1fae5 !important; border-color: #10b981 !important; border-width: 2px; box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.25); }
        
        /* Diff styles */
        .diff-deletion { background-color: #fdd; text-decoration: line-through; }
        .diff-insertion { background-color: #dfd; }

        /* QA Error Styles */
        .qa-error { color: #ef4444; font-weight: 700; }
        .qa-success { color: #22c55e; font-weight: 700; }
        #qaErrorStats.clickable { cursor: pointer; text-decoration: underline; }
        .qa-error-item { padding: 0.5rem; border-bottom: 1px solid #e5e7eb; cursor: pointer; transition: background-color 0.2s; }
        .qa-error-item:hover { background-color: #f3f4f6; }
        #qaErrorListContainer { max-height: 60vh; overflow-y: auto; }

        /* Header styles */
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 900;
            flex-wrap: wrap;
        }
        .header-main-actions {
            display: flex;
            flex-grow: 1;
            justify-content: center;
            gap: 0.5rem; /* Reduced gap for smaller buttons */
            flex-wrap: wrap;
        }
        .header-lang-switcher {
            display: flex;
            gap: 0.5rem;
        }

        /* Main content area */
        .main-app-content { display: flex; flex-direction: column; flex-grow: 1; padding: 1rem; gap: 1rem; }
        .editor-and-sidebars-wrapper { display: flex; flex-direction: column; flex-grow: 1; gap: 1rem; min-height: 0;}
        #horizontal-resizer { width: 10px; height: auto; cursor: col-resize; background-color: #e5e7eb; border-left: 1px solid #d1d5db; border-right: 1px solid #d1d5db; }
        #horizontal-resizer:hover { background-color: #d1d5db; }

        @media (min-width: 1024px) {
            .main-app-content { flex-direction: row; align-items: stretch; gap: 0; }
            .video-player-section { flex-shrink: 0; flex-basis: 33%; position: sticky; top: 60px; align-self: flex-start; 
max-height: calc(100vh - 80px); /* Altura m√°xima = 100% de la pantalla menos el header y un margen */
    overflow-y: auto; /* Muestra la barra de scroll vertical solo si es necesario */
    padding-right: 0.5rem; /* Peque√±o espacio para que la barra no se pegue al contenido */
}
            .right-panel-content { 
                flex-grow: 1; 
                display: flex; 
                flex-direction: column; 
                gap: 0;
                overflow: hidden; /* ADDED to contain the scrolling child */
                min-height: 0;
            }
            .editor-and-sidebars-wrapper { flex-direction: column; flex-grow: 1; display: flex; }
            /* Let the editor grow to fill the available space */
            .editor-main-content { flex-grow: 1; overflow-y: auto; }
            /* Hide the old sidebar container and its resizer */
            .sidebars-container, #vertical-resizer { display: none; }
        }

        /* Video player styles */
        #videoPlayerContainer { width: 100%; background-color: #000; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem; gap: 1rem; }
        #videoPlayerWrapper { position: relative; width: 100%; line-height: 0; background-color: #000; border-radius: 0.5rem; min-height: 250px; }
        #videoPlayer { width: 100%; height: auto; max-height: calc(50vh - 105px); border-radius: 0.5rem; object-fit: contain; background-color: #000; }
        #subtitlePreviewOverlay { position: absolute; bottom: 10%; left: 0; right: 0; padding: 1rem; text-align: center; pointer-events: none; transition: opacity 0.3s ease; }
        #subtitlePreviewText { font-weight: 500; font-size: var(--user-font-size); color: white; padding: 0.10em 0.10em; background-color: rgba(0, 0, 0, 0.4); border-radius: 0.25rem; line-height: 1.4; text-shadow: 0px 0px 3px rgba(0,0,0,1); white-space: pre-wrap; }
        #videoFileInput { display: none; }

        /* Animation for Restore button */
        @keyframes pulse-yellow { 0%, 100% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.7); } 50% { box-shadow: 0 0 0 8px rgba(250, 204, 21, 0); } }
        .animate-pulse-yellow { animation: pulse-yellow 2s infinite; }

/* --- START: Fullscreen Video Controls & Subtitles --- */

/* Muestra la barra de controles en hover O en pantalla completa (con prefijos de compatibilidad) */
#videoPlayerWrapper:hover #videoControlsBar,
#videoPlayerWrapper:-webkit-full-screen #videoControlsBar,
#videoPlayerWrapper:-moz-full-screen #videoControlsBar,
#videoPlayerWrapper:fullscreen #videoControlsBar {
    opacity: 1;
}

/* Ajusta la posici√≥n de los subt√≠tulos en pantalla completa para que no choquen con los controles */
#videoPlayerWrapper:-webkit-full-screen #subtitlePreviewOverlay,
#videoPlayerWrapper:-moz-full-screen #subtitlePreviewOverlay,
#videoPlayerWrapper:fullscreen #subtitlePreviewOverlay {
    bottom: 8%; 
}

/* Anula la restricci√≥n de altura del v√≠deo S√ìLO en pantalla completa */
#videoPlayerWrapper.is-fullscreen #videoPlayer {
    width: 100% !important;
    height: 100% !important;
    max-height: 100% !important;
    object-fit: contain; 
}

/* --- END: Fullscreen Video Controls & Subtitles --- */

/* --- START: Custom Video Controls Styles --- */


        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #4a5568;
            border-radius: 5px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -4px; /* Center thumb on track */
        }
        input[type=range]:focus::-webkit-slider-runnable-track {
            background: #2d3748;
        }

          .volume-control {
            position: relative;
            /* A√±adimos padding para crear un "puente" para el hover */
            padding-bottom: 0.5rem;
            margin-bottom: -0.5rem; /* Compensamos el padding para no mover otros elementos */
        }

        .volume-slider-container {
            position: absolute;
            /* Ajustamos la posici√≥n para que quede justo encima del bot√≥n */
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(17, 24, 39, 0.75);
            padding: 1rem 0.75rem;
            border-radius: 0.75rem;
            display: none;
        }

        .volume-control:hover .volume-slider-container {
            display: block;
        }

        #volumeBar {
            -webkit-appearance: slider-vertical;
            writing-mode: bt-lr;
            background-color: transparent;
            width: 15px;
            height: 96px;
        }

video::-webkit-media-controls-fullscreen-button {
    display: none;
}
video::-moz-fullscreen-button {
    display: none !important; /* Mantenemos esto con !important por si acaso */
    opacity: 0 !important;    /* Lo hacemos totalmente transparente */
    width: 0 !important;     /* Forzamos a que no tenga anchura */
    pointer-events: none;    /* Desactivamos cualquier clic sobre √©l */
}

video::-ms-fullscreen-button {
    display: none;
}

        /* --- END: Custom Video Controls Styles --- */

#customFullscreenBtn span {
    font-size: 28px;      /* Tama√±o grande para el car√°cter */
    line-height: 1;       /* Centrado vertical perfecto */
}

/* --- START: Vertical Size Control Styles --- */
.size-control {
    position: relative;
    padding-bottom: 0.5rem;
    margin-bottom: -0.5rem;
}

.size-slider-container {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(17, 24, 39, 0.75);
    padding: 1rem 0.75rem;
    border-radius: 0.75rem;
    display: none;
}

.size-control:hover .size-slider-container {
    display: block;
}

#subtitleFontSize {
    -webkit-appearance: slider-vertical;
    writing-mode: bt-lr;
    background-color: transparent;
    width: 15px;
    height: 96px;
    cursor: pointer;
}

#subtitleFontSize::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 16px;
    width: 16px;
    border-radius: 50%;
    background: #ffffff;
    cursor: pointer;
    margin-top: 0;
    margin-left: -4px;
}

/* Estilos para el manejador en Firefox */
#volumeBar::-moz-range-thumb,
#subtitleFontSize::-moz-range-thumb {
    height: 16px;
    width: 16px;
    border-radius: 50%;
    background: #ffffff;
    cursor: pointer;
    border: none; /* Importante para evitar estilos por defecto */
}

/* Estilos para la pista en Firefox (opcional pero recomendado) */
#volumeBar::-moz-range-track,
#subtitleFontSize::-moz-range-track {
  background: #4a5568;
  border-radius: 5px;
  width: 8px;
}

/* --- START: Subtitle Source Control Styles --- */
.source-control {
    position: relative;
    padding-bottom: 0.5rem;
    margin-bottom: -0.5rem; /* Puente para el hover */
}

.source-options-container {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(17, 24, 39, 0.75);
    padding: 0.5rem;
    border-radius: 0.75rem;
    display: none; /* Oculto por defecto */
    flex-direction: column;
    gap: 0.25rem;
    width: 120px; /* Ancho fijo para el men√∫ */
}

.source-control:hover .source-options-container {
    display: flex; /* Se muestra al hacer hover */
}

.source-option {
    background-color: transparent;
    color: white;
    padding: 0.5rem;
    border-radius: 0.5rem;
    text-align: center;
    font-size: 0.875rem;
    width: 100%;
    transition: background-color 0.2s ease;
}

.source-option:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.source-option.active {
    background-color: #075BA2; /* Color primario para la opci√≥n activa */
    font-weight: 700;
}
/* --- END: Subtitle Source Control Styles --- */

/* --- Planner Styles --- */
.session-row {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.5rem;
    border-radius: 0.5rem;
    border: 1px solid #e5e7eb;
    transition: background-color 0.2s;
    cursor: pointer;
}
.session-row:hover {
    background-color: #f9fafb;
}
.session-row.completed {
    background-color: #f0fdf4; /* green-50 */
}
.session-row.completed .session-text {
    text-decoration: line-through;
    color: #6b7280;
}
.session-row.active {
    border-color: #075BA2;
    box-shadow: 0 0 0 2px rgba(7, 91, 162, 0.2);
}
.session-text {
    flex-grow: 1;
    font-size: 0.875rem;
}
.session-time {
    font-family: monospace;
    font-weight: 600;
    background-color: #e5e7eb;
    padding: 0.1rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.9rem;
}

#sessionResults {
    max-height: 250px; /* Altura m√°xima para la lista antes de que aparezca el scroll */
    overflow-y: auto; /* Muestra el scroll vertical solo si la lista es m√°s alta que max-height */
    padding-right: 0.25rem; /* Espacio para la barra de scroll */
}

#videoPlayerContainer {
    flex-shrink: 0;
}

/* --- END: Planner Styles --- */

/* --- Notificaciones (Toast) --- */
        #messageBox {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: auto;
            max-width: 350px;
            z-index: 2000;
            transition: opacity 0.3s ease-in-out; /* Solo transicionamos la opacidad */
            opacity: 0; /* Por defecto, es invisible */
            pointer-events: none; /* Evita que se pueda hacer clic cuando est√° invisible */
        }
        #messageBox.is-visible {
            opacity: 1;
            pointer-events: auto; /* Permite interacci√≥n cuando es visible */
        }
        #messageBox .modal-content {
            padding: 1rem 1.5rem;
            text-align: center;
        }
        #messageClose {
            display: none;
        }

/* --- INICIO: C√ìDIGO PARA LA BARRA DE CONTROLES ADAPTABLE (DEFINITIVO) --- */

#videoPlayerWrapper {
    container-type: inline-size;
    container-name: video-wrapper;
}

@container video-wrapper (max-width: 480px) {
    #videoControlsBar .btn {
        font-size: 0.75rem;
        padding: 0.2rem 0.5rem;
    }
    #videoControlsRight {
        gap: 0.5rem;
    }
    #fontSizeDisplay {
        width: 2.75rem;
    }
    #videoControlsLeft span {
        display: none;
    }
    #videoControlsLeft::after {
        content: 'üé•';
        font-size: 1.25rem;
        line-height: 1;
    }

    /* --- √öLTIMO AJUSTE DE ALINEACI√ìN --- */
    #setPreviewOriginal,
    #setPreviewTranslation {
        color: transparent;
        position: relative;
        width: 2rem;   /* Igualamos al ancho de los otros botones (w-8) */
        height: 2rem;  /* Igualamos a la altura de los otros botones (h-8) */
        padding-top: 0;
        padding-bottom: 0;
    }
    #setPreviewOriginal::after {
        content: 'O';
        font-size: 0.75rem;
        color: black;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
    #setPreviewTranslation::after {
        content: 'T';
        font-size: 0.75rem;
        color: white;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
}
/* --- FIN: C√ìDIGO PARA LA BARRA DE CONTROLES ADAPTABLE --- */

/* --- INICIO: A√ëADIR ESTE BLOQUE DE CSS --- */
        #statusBar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30px; /* Altura de la barra */
            background-color: #ffffff;
            border-top: 1px solid #d1d5db; /* Borde superior sutil */
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.05); /* Sombra ligera */
            z-index: 980; /* Encima del contenido, debajo de modales */
            padding: 0 1rem; /* Espaciado horizontal */
            display: flex;
            align-items: center;
            justify-content: center; /* Para contenido futuro */
            font-size: 0.875rem;
            color: #374151; /* Color de texto gris oscuro */
            transition: transform 0.3s ease-in-out;
            transform: translateY(100%); /* Oculto por defecto (movido hacia abajo) */
        }
        #statusBar.is-visible {
            transform: translateY(0); /* Visible (en su posici√≥n original) */
        }


/* --- FIN: A√ëADIR ESTE BLOQUE DE CSS --- */

    </style>
</head>
<body class="bg-gray-100">
    <header class="app-header">
        <div class="header-main-actions">
            <div class="relative group">
                <button class="btn btn-primary inline-flex items-center">
                    <span data-i18n="project_menu">Proyecto</span>
                    <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </button>
                <div class="absolute z-10 -left-2 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform-gpu group-hover:scale-100 scale-95">
                    <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="options-menu">
                        <button id="newProjectBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
                            <span data-i18n="new_project">Nuevo proyecto</span>
                        </button>
                        <label for="projectFile" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 cursor-pointer" role="menuitem">
                            <span data-i18n="load_project">Cargar proyecto</span>
                            <input type="file" id="projectFile" accept=".subpanda" class="hidden">
                        </label>
                        <button id="saveProjectBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 disabled:text-gray-400" role="menuitem" disabled>
                            <span data-i18n="save_project">Guardar proyecto</span>
                        </button>
<div class="border-t border-gray-100"></div>
 <button id="backupBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
        <span data-i18n="backup_btn">Copia de seguridad</span>
    </button>
<div class="border-t border-gray-100"></div>
<button id="resetAppBtn" class="block w-full text-left px-4 py-2 text-sm text-red-700 hover:bg-red-50 hover:text-red-900" role="menuitem">
    <span data-i18n="reset_app_btn">Resetear aplicaci√≥n</span>
</button>
                    </div>
                </div>
            </div>
            
            <label for="srtFile" class="btn btn-secondary">
                <span data-i18n="import_srt">Importar .srt</span>
                <input type="file" id="srtFile" accept=".srt" class="hidden">
            </label>
            <button id="saveSrt" class="btn btn-secondary" disabled>
                <span data-i18n="export_srt">Exportar .srt</span>
            </button>
<div class="relative group">
    <button class="btn btn-secondary inline-flex items-center">
        <span data-i18n="tools_menu">Herramientas</span>
        <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
    </button>
    <div class="absolute z-10 -left-2 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform-gpu group-hover:scale-100 scale-95">
        <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="options-menu">
 <button id="undoBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 disabled:text-gray-400" role="menuitem" disabled>
            <span data-i18n="undo_btn">Deshacer</span>
        </button>
        <button id="redoBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 disabled:text-gray-400" role="menuitem" disabled>
            <span data-i18n="redo_btn">Rehacer</span>
        </button>
        <div class="border-t border-gray-200"></div>
            <button id="findReplaceBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
                <span data-i18n="find_replace_btn">Buscar y reemplazar</span>
            </button>
            <button id="shortcutsBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
                <span data-i18n="shortcuts_btn">Atajos</span>
            </button>
<button id="goToSubtitleBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
        <span data-i18n="go_to_subtitle_menu">Ir a...</span>
    </button>
<button id="timecodeSettingsBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
    <span data-i18n="timecode_settings_btn">Ajustes de Timecode</span>
</button>
<button id="toggleStatusBarBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
                <span data-i18n="show_status_bar_btn">Mostrar barra de estado</span>
            </button>
        </div>
    </div>
</div>
                        <button id="qaBtn" class="btn btn-secondary">
                <span data-i18n="qa_btn">QA</span>
            </button>
            <button id="contextBtn" class="btn btn-secondary">
    <span data-i18n="context_btn">IA</span>
</button>

            <button id="terminologyBtn" class="btn btn-secondary">
                <span data-i18n="terminology_btn">Terminolog√≠a</span>
            </button>
            <button id="tmBtn" class="btn btn-secondary">
                <span data-i18n="tm_btn">Memoria de traducci√≥n</span>
            </button>
        </div>
        <div class="header-lang-switcher">
            <button id="lang-es" class="btn btn-lang active">ES</button>
            <button id="lang-en" class="btn btn-lang">EN</button>
        </div>
    </header>

    <div class="main-app-content">
       <div class="video-player-section flex flex-col items-center justify-center p-4">

    <div id="videoPlayerContainer" class="w-full">
        <div id="videoPlayerWrapper" class="relative bg-black rounded-lg group">
            <div id="videoControlsBar" class="absolute top-0 left-0 right-0 z-10 w-full flex justify-between items-center p-2 bg-black bg-opacity-50 transition-opacity duration-300 opacity-0 group-hover:opacity-100">
        
        <label for="videoFileInput" id="videoControlsLeft" class="btn btn-primary py-2">
            <span data-i18n="load_video">Cargar v√≠deo</span>
            <input type="file" id="videoFileInput" accept="video/*" class="hidden">
        </label>
    
        <div id="videoControlsRight" class="flex items-center gap-4">
            <div class="flex items-center gap-1 p-1 bg-gray-700 rounded-md">
                <button id="setPreviewOriginal" class="btn py-2 btn-secondary" data-i18n="original_text_option">Original</button>
                <button id="setPreviewTranslation" class="btn py-2 btn-secondary" data-i18n="translation_text_option">Traducci√≥n</button>
            </div>
            <div class="flex items-center gap-2 text-white">
                <button id="decreaseFontSize" class="btn btn-secondary w-8 h-8 flex items-center justify-center text-lg">-</button>
                <span id="fontSizeDisplay" class="font-semibold text-sm w-12 text-center">22px</span>
                <button id="increaseFontSize" class="btn btn-secondary w-8 h-8 flex items-center justify-center text-lg">+</button>
                <button id="customFullscreenBtn" class="btn btn-secondary w-8 h-8 flex items-center justify-center">
                    <span id="fullscreen-enter-char">‚õ∂</span>
                    <span id="fullscreen-exit-char" class="hidden">‚§°</span>
                </button>
            </div>
        </div>
    </div>
    <video id="videoPlayer" class="w-full h-auto rounded-lg"></video>
    
            <div id="videoLogoPlaceholder" class="absolute inset-0 flex items-center justify-center pointer-events-none">
                <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/subpandatm-logo.png" alt="subpandaTM Logo" class="h-24 w-auto opacity-75">
            </div>
    
            <div id="subtitlePreviewOverlay">
                <span id="subtitlePreviewText"></span>
            </div>
        </div>
    </div>
    
    <div id="waveform" class="bg-white p-4 rounded-lg shadow-xl w-full mt-4 hidden">
        </div>
        <div id="waveformControls" class="w-full bg-gray-50 p-2 rounded-b-lg shadow-lg flex justify-center items-center gap-3 -mt-1 hidden">
            <button id="lockWaveformBtn" class="btn btn-secondary" title="Bloquear/Desbloquear onda">
                <svg class="lock-icon-open w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5V6.75a4.5 4.5 0 1 0-9 0v3.75m.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" />
                </svg>
                <svg class="lock-icon-closed hidden w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 10.5V6.75a4.5 4.5 0 1 0-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" />
                </svg>
            </button>
<button id="followPlaybackBtn" class="btn btn-secondary">
        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M2.036 12.322a1.012 1.012 0 0 1 0-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178Z" />
          <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
        </svg>
    </button>
            <button id="zoomOutBtn" class="btn btn-secondary" data-i18n-title="zoom_out">
                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607ZM7.5 10.5h6" /> </svg>
            </button>
            <button id="zoomInBtn" class="btn btn-secondary" data-i18n-title="zoom_in">
                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607ZM10.5 7.5v3m0 0v3m0-3h3m-3 0h-3" />
                </svg>
            </button>
        </div>
                <div id="statsContainer" class="bg-white p-4 rounded-lg shadow-xl w-full mt-4 hidden">
                    <div class="accordion-item">
                        <div class="accordion-header" id="statsAccordionHeader">
                            <h3 class="text-lg font-bold" data-i18n="translation_stats_title">Estad√≠sticas</h3>
                            <svg class="w-5 h-5 accordion-icon rotated" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </div>
                        <div class="accordion-content collapsed" id="statsAccordionContent">
                            <div class="bg-gray-100 p-3 rounded-md shadow-sm text-sm text-center space-y-1">
                                <p><span id="segmentsProgress"></span></p>
                                <p><span id="wordsTranslated"></span> / <span id="wordsTotal"></span></p>
                                <p><span id="wordsRemaining"></span></p>
                                <p id="qaErrorStats"></p>
                            </div>
                        </div>
                    </div>
                </div>
    <div id="plannerContainer" class="bg-white p-4 rounded-lg shadow-xl w-full mt-4 hidden">
        <div class="accordion-item">
            <div class="accordion-header" id="plannerAccordionHeader">
                <h3 class="text-lg font-bold" data-i18n="planner_title">Planificador</h3>
                <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </div>
            <div class="accordion-content collapsed" id="plannerAccordionContent">
                <div class="flex flex-col sm:flex-row items-center gap-2 p-2 bg-gray-50 rounded-lg">
        <div class="flex items-center gap-2 flex-shrink-0">
            <label for="sessionCount" class="text-sm font-medium" data-i18n="planner_divide_in">Dividir en:</label>
            <input type="number" id="sessionCount" value="3" min="1" class="w-16 p-1 border border-gray-300 rounded-md text-center">
            <label for="sessionCount" class="text-sm font-medium" data-i18n="planner_sessions">sesiones</label>
        </div>
        <div class="flex-grow w-full">
            <select id="divisionMethod" class="w-full p-1.5 border border-gray-300 rounded-md text-sm">
                <option value="subtitles" data-i18n="planner_method_subs">Por n√∫mero de subt√≠tulos</option>
                <option value="words" data-i18n="planner_method_words">Por n√∫mero de palabras</option>
                <option value="time" data-i18n="planner_method_time">Por tiempo</option>
            </select>
        </div>
        <button id="calculateSessionsBtn" class="btn btn-primary w-full sm:w-auto" data-i1admin="planner_calculate">Calcular</button>
    </div>
                <div id="sessionResults" class="mt-4 space-y-2">
                    </div>
            </div>
        </div>
    </div>

</div> <div id="horizontal-resizer"></div>

        <div class="right-panel-content">
            <div class="editor-and-sidebars-wrapper" id="editorAndSidebarsWrapper">
                <div class="editor-main-content space-y-4 pr-2" id="editorMainContent">
                    <div id="translationsContainer">
                        <div data-i18n="no_translations" id="initialMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md">
                           Importa un archivo .srt y un v√≠deo para empezar a trabajar. Si lo deseas, puedes trabajar con una memoria de traducci√≥n TMX y un glosario TBX, que puedes importar o crear desde cero.
                        </div>
                    </div>
                </div>

                <div id="vertical-resizer"></div>

                <div class="sidebars-container">
                </div>
            </div>
        </div>
    </div>

    <div id="terminologySidebar" class="floating-panel">
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="terminology_sidebar_title">Terminolog√≠a</h3>
            <div class="flex items-center">
                <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posici√≥n y tama√±o">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
                </button>
                <button id="closeTerminologySidebarBtn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>
        <div class="sidebar-content">
            <div id="terminologyLanguageConfigSection" class="space-y-4">
                <h4 class="text-md font-semibold mb-2" data-i18n="config_lang_title">Configurar idiomas del glosario</h4>
                <div class="glossary-info-box mb-4">
                    <p data-i18n="config_lang_info"></p>
                </div>
                <div class="flex flex-col space-y-2 mb-4">
                    <div class="glossary-input-group">
                        <label for="configSrcLang" data-i18n="source_language">Idioma de origen:</label>
                        <input id="configSrcLang" list="isoLanguages" value="en-US" class="block w-full rounded-md" />
                    </div>
                    <div class="glossary-input-group">
                        <label for="configTgtLang" data-i18n="target_language">Idioma de destino:</label>
                        <input id="configTgtLang" list="isoLanguages" value="es-ES" class="block w-full rounded-md" />
                    </div>
                    <button onclick="confirmGlossaryLanguages()" data-i18n="confirm_languages" class="btn btn-primary w-full">Confirmar idiomas</button>
                </div>
            </div>

            <div id="terminologyEditorSection" style="display:none;">
                <div class="flex flex-col sm:flex-row gap-2 mb-4">
                    <button onclick="loadTBX()" data-i18n="import_tbx" class="btn btn-secondary flex-1 text-sm">Importar TBX</button>
                    <input type="file" id="tbxFileInput" accept=".xml,.tbx" class="hidden" />
                    <button onclick="downloadTBX()" data-i18n="download_tbx" class="btn btn-secondary flex-1 text-sm">Descargar TBX</button>
                    <button onclick="showConfirmResetGlossary()" data-i18n="new_glossary" class="btn btn-secondary flex-1 text-sm">Nuevo glosario</button>
                </div>
                <h4 class="text-md font-semibold mb-2" data-i18n="current_lang_title">Idiomas actuales del glosario</h4>
                <div class="flex space-x-2 mb-4">
                    <div class="glossary-input-group flex-1">
                        <label data-i18n="source_language">Idioma de origen:</label>
                        <input id="displaySrcLang" disabled class="block w-full rounded-md" />
                    </div>
                    <div class="glossary-input-group flex-1">
                        <label data-i18n="target_language">Idioma de destino:</label>
                        <input id="displayTgtLang" disabled class="block w-full rounded-md" />
                    </div>
                </div>
                <div class="accordion-item">
                    <div class="accordion-header" id="addTermHeader">
                        <h4 class="text-md font-semibold m-0" data-i18n="add_term_title">A√±adir t√©rmino</h4>
                        <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </div>
                    <div class="accordion-content collapsed" id="addTermContent">
                        <div class="flex flex-col space-y-2 mb-4">
                            <div class="glossary-input-group">
                                <label for="srcTerm" data-i18n="term">T√©rmino:</label>
                                <input id="srcTerm" class="block w-full rounded-md" />
                            </div>
                            <div class="glossary-input-group">
                                <label for="tgtTerm" data-i18n="translation">Traducci√≥n:</label>
                                <input id="tgtTerm" class="block w-full rounded-md" />
                            </div>
                            <button onclick="addTerm()" data-i18n="add_button" class="btn btn-primary w-full">A√±adir</button>
                        </div>
                    </div>
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="search_title">Buscar</h4>
                <div class="mb-4">
                    <input id="searchTerm" data-i18n-placeholder="search_placeholder" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white" oninput="renderGlossary()" />
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="glossary_list_title">Glosario</h4>
                <div class="overflow-x-auto">
                    <table class="w-full">
                        <thead>
                            <tr>
                                <th data-i18n="source_term_col">T√©rmino de origen</th>
                                <th data-i18n="target_term_col">T√©rmino de destino</th>
                                <th data-i18n="actions_col">Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="glossaryTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
        <datalist id="isoLanguages"></datalist>
    </div>

    <div id="translationMemorySidebar" class="floating-panel">
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="tm_sidebar_title">Memoria de traducci√≥n</h3>
            <div class="flex items-center">
                <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posici√≥n y tama√±o">
                   <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
                </button>
                <button id="closeTranslationMemorySidebarBtn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>
        <div class="sidebar-content">
            <div id="tmInternalMessage" class="tm-info-box mb-4 hidden"></div>
            <div id="tmLanguageConfigSection" class="space-y-4">
                <h4 class="text-md font-semibold mb-2" data-i18n="tm_config_lang_title">Configurar idiomas de la TM</h4>
                <div class="tm-info-box mb-4">
                    <p data-i18n="tm_config_lang_info"></p>
                </div>
                <div class="flex flex-col space-y-2 mb-4">
                    <div class="tm-input-group">
                        <label for="tmConfigSrcLang" data-i18n="source_language">Idioma de origen:</label>
                        <input id="tmConfigSrcLang" list="isoLanguages" value="en-US" class="block w-full rounded-md" />
                    </div>
                    <div class="tm-input-group">
                        <label for="tmConfigTgtLang" data-i18n="target_language">Idioma de destino:</label>
                        <input id="tmConfigTgtLang" list="isoLanguages" value="es-ES" class="block w-full rounded-md" />
                    </div>
                    <button onclick="confirmTMLanguages()" data-i18n="confirm_languages" class="btn btn-primary w-full">Confirmar idiomas</button>
                </div>
            </div>

            <div id="tmEditorSection" style="display:none;">
                <div class="flex flex-col sm:flex-row gap-2 mb-4">
                    <button onclick="showConfirmResetTm()" data-i18n="new_tm" class="btn btn-secondary flex-1 text-sm">Nueva TM</button>
                    <label for="tmFileInput" class="btn btn-secondary flex-1 text-sm text-center">
                        <span data-i18n="import_tmx">Importar TMX</span>
                        <input type="file" id="tmFileInput" accept=".xml,.tmx" class="hidden" />
                    </label>
                    <button onclick="downloadTMX()" data-i18n="download_tmx" class="btn btn-secondary flex-1 text-sm">Descargar TMX</button>
                </div>
                <h4 class="text-md font-semibold mb-2" data-i18n="current_tm_lang_title">Idiomas actuales de la TM</h4>
                <div class="flex space-x-2 mb-4">
                    <div class="tm-input-group flex-1">
                        <label data-i18n="source_language">Idioma de origen:</label>
                        <input id="displayTmSrcLang" disabled class="block w-full rounded-md" />
                    </div>
                    <div class="tm-input-group flex-1">
                        <label data-i18n="target_language">Idioma de destino:</label>
                        <input id="displayTmTgtLang" disabled class="block w-full rounded-md" />
                    </div>
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="tm_search_title">Buscar en TM</h4>
                <div class="mb-4">
                    <input id="tmSearchInput" data-i18n-placeholder="tm_search_placeholder" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white" oninput="tmSearch()" />
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="tm_search_results_title">Resultados de b√∫squeda en TM</h4>
                <div class="overflow-x-auto mb-4">
                    <table class="tm-table w-full">
                        <thead>
                            <tr>
                                <th data-i18n="tm_score_col">%</th>
                                <th data-i18n="tm_original_col">Original</th>
                                <th data-i18n="tm_translation_col">Traducci√≥n</th>
                            </tr>
                        </thead>
                        <tbody id="tmSearchResultsTableBody"></tbody>
                    </table>
                </div>
                <div data-i18n="tm_no_match_found" id="tmNoMatchFoundMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md hidden">
                    No se encontraron coincidencias en la TM.
                </div>
            </div>
        </div>
    </div>

    <div id="messageBox" class="modal hidden">
        <div class="modal-content">
            <p id="messageText" class="text-lg font-semibold mb-4"></p>
            <button id="messageClose" class="btn btn-primary w-full" data-i18n="ok">OK</button>
        </div>
    </div>
    
    <div id="shortcutsModal" class="modal hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 data-i18n="shortcuts_title" class="text-xl font-bold">Atajos de teclado</h2>
                <div class="flex gap-2">
                    <label for="importShortcutsInput" class="btn btn-secondary text-sm" data-i18n="import_shortcuts_btn">Importar</label>
                    <input type="file" id="importShortcutsInput" class="hidden" accept=".json">
                    <button id="exportShortcutsBtn" class="btn btn-secondary text-sm" data-i18n="export_shortcuts_btn">Exportar</button>
                </div>
<div class="flex items-center gap-2">
                    <label for="shortcutProfileSelector" class="text-sm font-medium">Perfil:</label>
                    <select id="shortcutProfileSelector" class="text-sm rounded-md border-gray-300 shadow-sm">
                        <option value="windows">Windows / Linux</option>
                        <option value="mac">macOS</option>
                    </select>
                </div>
            </div>
            <div id="shortcutsList" class="space-y-2 max-h-[60vh] overflow-y-auto pr-2">
                </div>
            <div class="flex justify-between items-center mt-6">
                <button id="restoreShortcutsBtn" class="btn btn-destructive" data-i18n="restore_defaults_btn">Restaurar valores por defecto</button>
                <button id="shortcutsCloseBtn" class="btn btn-primary" data-i18n="close_btn">Cerrar</button>
            </div>
        </div>
    </div>

<div id="findReplacePanel" class="floating-panel" style="width: 600px; height: auto;">
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="find_replace_title">Buscar y reemplazar</h3>
            <div class="flex items-center">
                <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posici√≥n y tama√±o">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
                </button>
                <button id="closeFindReplacePanelBtn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>
        <div class="sidebar-content p-4">
            <div class="space-y-4">
                <div>
                    <label for="findInput" data-i18n="find_label" class="block text-sm font-medium mb-1">Buscar:</label>
                    <input type="text" id="findInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div>
                    <label for="replaceInput" data-i18n="replace_label" class="block text-sm font-medium mb-1">Reemplazar con:</label>
                    <input type="text" id="replaceInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex items-center space-x-4">
                    <label class="flex items-center">
                        <input type="checkbox" id="caseSensitiveCheckbox" class="mr-2 rounded">
                        <span data-i18n="case_sensitive">Distinguir may√∫sculas y min√∫sculas</span>
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" id="regexCheckbox" class="mr-2 rounded">
                        <span data-i18n="regular_expression">Expresi√≥n regular</span>
                    </label>
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="findPrevBtn" class="btn btn-secondary" data-i18n="find_prev">Buscar anterior</button>
                    <button id="findNextBtn" class="btn btn-secondary" data-i18n="find_next">Buscar siguiente</button>
                    <button id="replaceBtn" class="btn btn-primary" data-i18n="replace">Reemplazar</button>
                    <button id="replaceAllBtn" class="btn btn-destructive" data-i18n="replace_all">Reemplazar todo</button>
                </div>
            </div>
        </div>
    </div>

    <div id="saveSrtModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_srt_title" class="text-xl font-bold mb-4">Exportar Archivo SRT</h2>
            <div class="space-y-4">
                <div>
                    <label for="fileNameInput" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="fileNameInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>
    <div id="saveTbxModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_tbx_title" class="text-xl font-bold mb-4">Exportar Archivo TBX</h2>
            <div class="space-y-4">
                <div>
                    <label for="fileNameInputTbx" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="fileNameInputTbx" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveTbxBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveTbxBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>

    <div id="saveTmxModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_tmx_title" class="text-xl font-bold mb-4">Exportar Archivo TMX</h2>
            <div class="space-y-4">
                <div>
                    <label for="fileNameInputTmx" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="fileNameInputTmx" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveTmxBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveTmxBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>
    <div id="backupModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="backup_modal_title" class="text-xl font-bold mb-4">Copia de Seguridad</h2>
            <div id="backupFoundView">
                <div id="backupInfo" class="bg-gray-100 p-4 rounded-md mb-4">
                    <p data-i18n="restore_backup_info"></p>
                    <p><strong><span data-i18n="file_label"></span></strong> <span id="backupFileName"></span></p>
                    <p><strong><span data-i18n="last_modified_label"></span></strong> <span id="backupLastModified"></span></p>
                </div>
                <div class="flex justify-end space-x-2 flex-wrap gap-2">
                    <button data-i18n="export_srt_btn" id="exportSrtFromBackupBtn" class="btn btn-primary">Exportar SRT</button>
                    <button data-i18n="delete_backup_btn" id="deleteBackupBtn" class="btn btn-destructive">Borrar Backup</button>
                    <button data-i18n="restore_btn" id="confirmRestoreBtn" class="btn btn-primary">Restaurar</button>
                </div>
            </div>
            <div id="noBackupFoundView" class="hidden">
                 <p data-i18n="no_backup_found_info"></p>
            </div>
            <button data-i18n="close_btn" id="closeBackupModalBtn" class="btn btn-secondary w-full mt-6">Cerrar</button>
        </div>
    </div>
    <div id="qaModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="qa_modal_title" class="text-xl font-bold mb-4">Configuraci√≥n de QA</h2>
            <div class="space-y-4">
                <div class="qa-input-group">
                    <label for="qaCpsLimit" data-i18n="cps_limit_label" class="block text-sm font-medium mb-1">L√≠mite de CPS:</label>
                    <input type="number" id="qaCpsLimit" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="qa-input-group">
                    <label for="qaCharsPerLineLimit" data-i18n="chars_per_line_limit_label" class="block text-sm font-medium mb-1">L√≠mite de caracteres por l√≠nea:</label>
                    <input type="number" id="qaCharsPerLineLimit" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
            </div>
            <div class="flex justify-end space-x-2 mt-6">
                 <button id="closeQaModalBtn" class="btn btn-secondary" data-i18n="close_btn">Cerrar</button>
                <button id="saveQaSettingsBtn" class="btn btn-primary" data-i18n="save_and_apply_btn">Guardar y aplicar</button>
            </div>
        </div>
    </div>
    <div id="qaErrorListModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="qa_error_list_title" class="text-xl font-bold mb-4">Lista de Errores de QA</h2>
            <div id="qaErrorListContainer"></div>
            <button id="closeQaErrorListModalBtn" class="btn btn-secondary w-full mt-6" data-i18n="close_btn">Cerrar</button>
        </div>
    </div>
    <div id="reselectVideoModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="reselect_video_title" class="text-xl font-bold mb-4">Seleccionar v√≠deo</h2>
            <p data-i18n="reselect_video_info" id="reselectVideoInfo" class="mb-4"></p>
            <label for="reselectVideoInput" class="btn btn-primary w-full">
                <span data-i18n="load_video">Cargar v√≠deo</span>
                <input type="file" id="reselectVideoInput" accept="video/*" class="hidden">
            </label>
            <button id="skipReselectVideoBtn" class="btn btn-secondary w-full mt-2" data-i18n="skip_btn">Omitir</button>
        </div>
    </div>
<div id="saveProjectModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_project_title" class="text-xl font-bold mb-4">Guardar Proyecto</h2>
            <div class="space-y-4">
                <div>
                    <label for="projectFileNameInput" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="projectFileNameInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveProjectBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveProjectBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>
    <div id="confirmNewProjectModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="confirm_new_project_title" class="text-xl font-bold mb-4">Crear nuevo proyecto</h2>
            <p data-i18n="confirm_new_project_message" class="mb-6">Tienes cambios sin guardar. ¬øQuieres guardar el proyecto actual antes de continuar?</p>
            <div class="flex justify-end space-x-2">
                <button id="cancelNewProjectBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                <button id="continueWithoutSavingBtn" class="btn btn-destructive" data-i18n="continue_without_saving_btn">Continuar sin guardar</button>
                <button id="saveAndContinueBtn" class="btn btn-primary" data-i18n="save_and_continue_btn">Guardar y continuar</button>
            </div>
        </div>
    </div>

    <div id="confirmResetGlossaryModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="confirm_new_glossary_title" class="text-xl font-bold mb-4">Confirmar nuevo glosario</h2>
            <p data-i18n="confirm_new_glossary_message" class="mb-6">Solo puedes tener un glosario activo. Si contin√∫as, se borrar√°n todos los datos del glosario actual. Para evitar perder tu trabajo, aseg√∫rate de exportarlo primero como un archivo TBX.</p>
            <div class="flex justify-end space-x-2">
                <button id="cancelResetGlossaryBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                <button id="confirmResetGlossaryBtn" class="btn btn-destructive" data-i18n="continue_btn">Continuar</button>
            </div>
        </div>
    </div>

    <div id="confirmResetTmModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="confirm_new_tm_title" class="text-xl font-bold mb-4">Confirmar nueva TM</h2>
            <p data-i18n="confirm_new_tm_message" class="mb-6">Solo puedes tener una memoria de traducci√≥n (TM) activa. Si contin√∫as, se borrar√°n todos los datos de la TM actual. Para evitar perder tu trabajo, aseg√∫rate de exportarla primero como un archivo TMX.</p>
            <div class="flex justify-end space-x-2">
                <button id="cancelResetTmBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                <button id="confirmResetTmBtn" class="btn btn-destructive" data-i18n="continue_btn">Continuar</button>
            </div>
        </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="loading-spinner"></div>
        <p id="loadingMessage"></p>
    </div>

    <div id="contextSidebar" class="floating-panel">
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="context_sidebar_title">Contexto IA</h3>
            <div class="flex items-center">
                <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posici√≥n y tama√±o">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
                </button>
                <button id="closeContextSidebarBtn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>
        <div class="sidebar-content p-4" id="contextSidebarContent">
            <div id="contextImportView">
                <h4 class="font-bold text-md mb-2" data-i18n="load_context_title">Cargar Contexto</h4>
                <div class="accordion-item mb-4">
    <div class="accordion-header" id="contextHelpHeader">
        <h4 class="text-md font-semibold m-0" data-i18n="context_help_title">¬øC√≥mo funciona?</h4>
        <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
    </div>
    <div class="accordion-content collapsed" id="contextHelpContent">
        <div class="space-y-2 text-sm">
            <p data-i18n="context_help_intro"></p>
            <p data-i18n="context_help_format"></p>
        </div>
    </div>
</div>
                
                <div class="flex items-center gap-2 mb-1">
    <button id="copyPromptBtn" class="btn btn-primary flex-1" data-i18n="copy_prompt_btn"></button>
    <button id="pasteJsonBtn" class="btn btn-secondary" data-i18n="paste_json_btn"></button>
    <button id="aiSettingsBtn" class="btn btn-secondary p-2" title="Personalizar Prompt">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
    </button>
</div>
                <div id="jsonValidationStatus" class="text-xs h-5 mb-2"></div>
                
                <textarea id="contextPasteArea" class="w-full h-32 p-2 border rounded-md mb-2" data-i18n-placeholder="paste_json_placeholder"></textarea>
                <button id="importFromPasteBtn" class="btn btn-primary w-full mb-4" data-i18n="import_from_paste_btn"></button>
                
                <div class="text-center my-2 text-gray-500 font-semibold" data-i18n="or_divider"></div>
                
<label for="contextFileInput" class="btn btn-secondary w-full text-center cursor-pointer block">
                    <span data-i18n="import_from_file_btn"></span>
                    <input type="file" id="contextFileInput" accept=".json" class="hidden">
                </label>
            </div>

            <div id="contextDisplayView" class="hidden"></div>
        </div>
    </div>

<div id="aiSettingsModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="ai_settings_title" class="text-xl font-bold mb-4">Personalizar prompt de IA</h2>
            <p data-i18n="ai_settings_intro" class="text-sm text-gray-600 mb-4">
                A√±ade hasta tres instrucciones para la IA. La primera es obligatoria y viene con un texto por defecto que puedes modificar. Las pautas de QA se a√±adir√°n autom√°ticamente.
            </p>
            <div class="space-y-3">
                <div>
                    <label for="aiInstruction1" class="block text-sm font-medium mb-1" data-i18n="ai_instruction_1_label">Instrucci√≥n 1 (Obligatoria):</label>
                    <textarea id="aiInstruction1" rows="3" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></textarea>
                </div>
                <div>
                    <label for="aiInstruction2" class="block text-sm font-medium mb-1" data-i18n="ai_instruction_2_label">Instrucci√≥n 2 (Opcional):</label>
                    <textarea id="aiInstruction2" rows="2" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></textarea>
                </div>
                <div>
                    <label for="aiInstruction3" class="block text-sm font-medium mb-1" data-i18n="ai_instruction_3_label">Instrucci√≥n 3 (Opcional):</label>
                    <textarea id="aiInstruction3" rows="2" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></textarea>
                </div>
            </div>
            <div class="flex justify-end space-x-2 mt-6">
                 <button id="closeAiSettingsModalBtn" class="btn btn-secondary" data-i18n="close_btn">Cerrar</button>
                <button id="saveAiSettingsBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
            </div>
        </div>
    </div>

<div id="timecodeModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="timecode_modal_title" class="text-xl font-bold mb-4">Ajustes de Timecode</h2>
            <div class="space-y-4">
                
                <div class="qa-input-group">
                    <label for="projectFpsInput" data-i18n="project_fps_label" class="block text-sm font-medium mb-1">FPS del Proyecto:</label>
                    <select id="projectFpsInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                        <option value="23.976">23.976</option>
                        <option value="24">24</option>
                        <option value="25" selected>25</option>
                        <option value="29.97">29.97</option>
                        <option value="30">30</option>
                        <option value="50">50</option>
                        <option value="59.94">59.94</option>
                        <option value="60">60</option>
                        <option value="custom">Otro...</option>
                    </select>
                    <input type="number" id="projectFpsCustomInput" step="0.001" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white mt-2 hidden" placeholder="Escribe FPS personalizado">
                </div>
                
                <div class="glossary-info-box bg-blue-50 border-blue-200">
                    <p data-i18n="fps_recommendation_note" class="text-blue-700"></p>
                </div>
                <div class="flex items-center">
                    <input type="checkbox" id="useFrameTimecodeToggle" class="mr-2 rounded">
                    <label for="useFrameTimecodeToggle" data-i18n="show_frames_label" class="text-sm font-medium">Mostrar timecode en frames (ej. 00:00:10:05)</label>
                </div>
                <div class="glossary-info-box">
                    <p data-i18n="timecode_warning">Aviso: La exportaci√≥n SRT siempre usar√° milisegundos por compatibilidad.</p>
                </div>
            </div>
            <div class="flex justify-end space-x-2 mt-6">
                 <button id="closeTimecodeModalBtn" class="btn btn-secondary" data-i18n="close_btn">Cerrar</button>
                <button id="saveTimecodeSettingsBtn" class="btn btn-primary" data-i18n="save_and_apply_btn">Guardar y aplicar</button>
            </div>
        </div>
    </div>

<div id="goToSubtitlePanel" class="floating-panel" style="width: 320px; height: auto;">
    <div class="sidebar-header">
        <h3 class="text-lg font-bold" data-i18n="go_to_subtitle_title">Ir a Subt√≠tulo / TC</h3>
        <div class="flex items-center">
            <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posici√≥n y tama√±o">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
            </button>
            <button id="closeGoToSubtitlePanelBtn" class="text-gray-500 hover:text-gray-700">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>
    <div class="sidebar-content p-4 space-y-4">
        <div>
            <label for="goToSubtitleInput" class="block text-sm font-medium mb-1" data-i18n="go_to_subtitle_label">Ir al subt√≠tulo N¬∫:</label>
            <div class="flex gap-2">
                <input type="number" id="goToSubtitleInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white" min="1">
                <button id="goToSubtitleActionBtn" class="btn btn-primary" data-i18n="go_btn">Ir</button>
            </div>
        </div>
        <div>
            <label for="goToTimecodeInput" class="block text-sm font-medium mb-1" data-i18n="go_to_timecode_label">Ir al timecode:</label>
            <div class="flex gap-2">
                <input type="text" id="goToTimecodeInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 font-mono text-black bg-white" value="00:00:00,000" onfocus="this.select()">
                <button id="goToTimecodeActionBtn" class="btn btn-primary" data-i18n="go_btn">Ir</button>
            </div>
        </div>
    </div>
</div>


    <script>
        // --- IndexedDB Setup (Dexie.js) ---
        const db = new Dexie("subpandaTM_v2");
        db.version(1).stores({
            projects: '++id, fileName',
            settings: 'key' // Using 'key' as the primary key for settings objects
        });

        // Global variables
        let srtEntries = [];
        let currentFileName = 'subtitles.srt';
        let videoFileName = null;
let wavesurfer = null;
let wsRegions = null;
        let currentLanguage = 'es';
        let findState = { query: '', replace: '', caseSensitive: false, useRegex: false, lastFound: null };
        let previewSource = 'translation';
let subtitleFontSize = 20; // Tama√±o de fuente inicial en p√≠xeles
        let qaSettings = { cpsLimit: 20, charsPerLineLimit: 42 };
        let termsFoundInActiveSegment = new Set();
        let glossary = [];
        let glossarySourceLanguage = '';
        let glossaryTargetLanguage = '';
        let currentGlossaryLatestResults = [];
        let translationMemory = [];
        let tmSourceLanguage = '';
        let tmTargetLanguage = '';
        let tmBestMatchForActiveSegment = null;
        let currentTMLatestSearchResults = [];
        let editingTermIndex = -1; 
        let timeUpdateListener = null;
let contextData = [];
let lastActiveSubtitleIndex = 0;
let afterSaveAction = null;
let messageTimeout = null;
let projectFPS = 25;
let useFrameTimecode = false;
let historyStack = [];
let redoStack = [];
let debounceTimeout = null;
let isApplyingState = false; 
let isWaveformLocked = false;
let currentWaveformZoom = 100; // Valor inicial (minPxPerSec)
const ZOOM_STEP = 20; // Cu√°nto zoom a√±adir/quitar cada vez
let isFollowPlaybackActive = false;
let currentlyTrackedRegionId = null;
let currentlyTrackedEditorIndex = -1;
let lastFocusedEditorUnitIndex = -1;
        
        const DIFF_DELETE = -1;
        const DIFF_INSERT = 1;
        const DIFF_EQUAL = 0;

        // DOM elements
        const srtFile = document.getElementById('srtFile');
        const saveSrtButton = document.getElementById('saveSrt');
        const translationsContainer = document.getElementById('translationsContainer');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageClose = document.getElementById('messageClose');
        const dropArea = document.querySelector('.main-app-content');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const videoPlayerContainer = document.getElementById('videoPlayerContainer');
        const videoPlayer = document.getElementById('videoPlayer');
        const videoFileInput = document.getElementById('videoFileInput');
        const subtitlePreviewText = document.getElementById('subtitlePreviewText');
const setPreviewOriginal = document.getElementById('setPreviewOriginal');
const setPreviewTranslation = document.getElementById('setPreviewTranslation');
const decreaseFontSize = document.getElementById('decreaseFontSize');
const increaseFontSize = document.getElementById('increaseFontSize');
const fontSizeDisplay = document.getElementById('fontSizeDisplay');
const videoPlayerWrapper = document.getElementById('videoPlayerWrapper');
const customFullscreenBtn = document.getElementById('customFullscreenBtn');
const fullscreenEnterChar = document.getElementById('fullscreen-enter-char');
const fullscreenExitChar = document.getElementById('fullscreen-exit-char');
                const statsContainer = document.getElementById('statsContainer');
        const segmentsProgress = document.getElementById('segmentsProgress');
        const wordsTranslated = document.getElementById('wordsTranslated');
        const wordsTotal = document.getElementById('wordsTotal');
        const wordsRemaining = document.getElementById('wordsRemaining');
        const qaErrorStats = document.getElementById('qaErrorStats');
        const statsAccordionHeader = document.getElementById('statsAccordionHeader');
        const statsAccordionContent = document.getElementById('statsAccordionContent');
        const statsAccordionIcon = statsAccordionHeader.querySelector('.accordion-icon');
        const shortcutsBtn = document.getElementById('shortcutsBtn');
        const shortcutsModal = document.getElementById('shortcutsModal');
        const shortcutsCloseBtn = document.getElementById('shortcutsCloseBtn');
        const findReplaceBtn = document.getElementById('findReplaceBtn');
        const findReplacePanel = document.getElementById('findReplacePanel');
        const closeFindReplacePanelBtn = document.getElementById('closeFindReplacePanelBtn');
        const findInput = document.getElementById('findInput');
        const replaceInput = document.getElementById('replaceInput');
        const caseSensitiveCheckbox = document.getElementById('caseSensitiveCheckbox');
        const regexCheckbox = document.getElementById('regexCheckbox');
        const findPrevBtn = document.getElementById('findPrevBtn');
        const findNextBtn = document.getElementById('findNextBtn');
        const replaceBtn = document.getElementById('replaceBtn');
        const replaceAllBtn = document.getElementById('replaceAllBtn');
        const findReplaceCloseBtn = document.getElementById('findReplaceCloseBtn');
        const saveSrtModal = document.getElementById('saveSrtModal');
        const fileNameInput = document.getElementById('fileNameInput');
        const confirmSaveBtn = document.getElementById('confirmSaveBtn');
        const cancelSaveBtn = document.getElementById('cancelSaveBtn');
        const backupBtn = document.getElementById('backupBtn');
        const backupModal = document.getElementById('backupModal');
        const backupFoundView = document.getElementById('backupFoundView');
        const noBackupFoundView = document.getElementById('noBackupFoundView');
        const backupFileName = document.getElementById('backupFileName');
        const backupLastModified = document.getElementById('backupLastModified');
        const closeBackupModalBtn = document.getElementById('closeBackupModalBtn');
        const exportSrtFromBackupBtn = document.getElementById('exportSrtFromBackupBtn');
        const deleteBackupBtn = document.getElementById('deleteBackupBtn');
        const confirmRestoreBtn = document.getElementById('confirmRestoreBtn');
        const qaBtn = document.getElementById('qaBtn');
        const qaModal = document.getElementById('qaModal');
        const qaCpsLimitInput = document.getElementById('qaCpsLimit');
        const qaCharsPerLineLimitInput = document.getElementById('qaCharsPerLineLimit');
        const saveQaSettingsBtn = document.getElementById('saveQaSettingsBtn');
        const closeQaModalBtn = document.getElementById('closeQaModalBtn');
        const qaErrorListModal = document.getElementById('qaErrorListModal');
        const qaErrorListContainer = document.getElementById('qaErrorListContainer');
        const closeQaErrorListModalBtn = document.getElementById('closeQaErrorListModalBtn');
        const terminologyBtn = document.getElementById('terminologyBtn');
        const terminologySidebar = document.getElementById('terminologySidebar');
        const closeTerminologySidebarBtn = document.getElementById('closeTerminologySidebarBtn');
        const terminologyLanguageConfigSection = document.getElementById('terminologyLanguageConfigSection');
        const terminologyEditorSection = document.getElementById('terminologyEditorSection');
        const configSrcLang = document.getElementById('configSrcLang');
        const configTgtLang = document.getElementById('configTgtLang');
        const displaySrcLang = document.getElementById('displaySrcLang');
        const displayTgtLang = document.getElementById('displayTgtLang');
        const srcTermInput = document.getElementById('srcTerm');
        const tgtTermInput = document.getElementById('tgtTerm');
        const searchTermInput = document.getElementById('searchTerm');
        const glossaryTableBody = document.getElementById('glossaryTableBody');
        const tbxFileInput = document.getElementById('tbxFileInput');
        const isoLanguagesDatalist = document.getElementById('isoLanguages');
        const addTermHeader = document.getElementById('addTermHeader');
        const addTermContent = addTermHeader.nextElementSibling;
        const addTermAccordionIcon = addTermHeader.querySelector('.accordion-icon');
        const tmBtn = document.getElementById('tmBtn');
        const translationMemorySidebar = document.getElementById('translationMemorySidebar');
        const closeTranslationMemorySidebarBtn = document.getElementById('closeTranslationMemorySidebarBtn');
        const tmFileInput = document.getElementById('tmFileInput');
        const tmSearchInput = document.getElementById('tmSearchInput');
        const tmSearchResultsTableBody = document.getElementById('tmSearchResultsTableBody');
        const tmNoMatchFoundMessage = document.getElementById('tmNoMatchFoundMessage');
        const tmLanguageConfigSection = document.getElementById('tmLanguageConfigSection');
        const tmEditorSection = document.getElementById('tmEditorSection');
        const tmConfigSrcLang = document.getElementById('tmConfigSrcLang');
        const tmConfigTgtLang = document.getElementById('tmConfigTgtLang');
        const displayTmSrcLang = document.getElementById('displayTmSrcLang');
        const displayTmTgtLang = document.getElementById('displayTmTgtLang');
        const tmInternalMessage = document.getElementById('tmInternalMessage');
        const langEsBtn = document.getElementById('lang-es');
        const langEnBtn = document.getElementById('lang-en');
        const shortcutsList = document.getElementById('shortcutsList');
        const exportShortcutsBtn = document.getElementById('exportShortcutsBtn');
        const importShortcutsInput = document.getElementById('importShortcutsInput');
        const restoreShortcutsBtn = document.getElementById('restoreShortcutsBtn');
        const saveTbxModal = document.getElementById('saveTbxModal');
        const fileNameInputTbx = document.getElementById('fileNameInputTbx');
        const confirmSaveTbxBtn = document.getElementById('confirmSaveTbxBtn');
        const cancelSaveTbxBtn = document.getElementById('cancelSaveTbxBtn');
        const saveTmxModal = document.getElementById('saveTmxModal');
        const fileNameInputTmx = document.getElementById('fileNameInputTmx');
        const confirmSaveTmxBtn = document.getElementById('confirmSaveTmxBtn');
        const cancelSaveTmxBtn = document.getElementById('cancelSaveTmxBtn');
        // Project elements
        const newProjectBtn = document.getElementById('newProjectBtn');
        const saveProjectBtn = document.getElementById('saveProjectBtn');
        const projectFile = document.getElementById('projectFile');
const resetAppBtn = document.getElementById('resetAppBtn');
        const reselectVideoModal = document.getElementById('reselectVideoModal');
        const reselectVideoInfo = document.getElementById('reselectVideoInfo');
        const reselectVideoInput = document.getElementById('reselectVideoInput');
        const skipReselectVideoBtn = document.getElementById('skipReselectVideoBtn');
        const confirmNewProjectModal = document.getElementById('confirmNewProjectModal');
        const cancelNewProjectBtn = document.getElementById('cancelNewProjectBtn');
        const continueWithoutSavingBtn = document.getElementById('continueWithoutSavingBtn');
        const saveAndContinueBtn = document.getElementById('saveAndContinueBtn');
        const saveProjectModal = document.getElementById('saveProjectModal');
const projectFileNameInput = document.getElementById('projectFileNameInput');
const confirmSaveProjectBtn = document.getElementById('confirmSaveProjectBtn');
const cancelSaveProjectBtn = document.getElementById('cancelSaveProjectBtn');
        const confirmResetGlossaryModal = document.getElementById('confirmResetGlossaryModal');
        const confirmResetGlossaryBtn = document.getElementById('confirmResetGlossaryBtn');
        const cancelResetGlossaryBtn = document.getElementById('cancelResetGlossaryBtn');
        const confirmResetTmModal = document.getElementById('confirmResetTmModal');
        const confirmResetTmBtn = document.getElementById('confirmResetTmBtn');
        const cancelResetTmBtn = document.getElementById('cancelResetTmBtn');

const contextBtn = document.getElementById('contextBtn');
const contextSidebar = document.getElementById('contextSidebar');
const closeContextSidebarBtn = document.getElementById('closeContextSidebarBtn');
const contextFile = document.getElementById('contextFile');
const goToSubtitleBtn = document.getElementById('goToSubtitleBtn');
const goToSubtitlePanel = document.getElementById('goToSubtitlePanel');
const closeGoToSubtitlePanelBtn = document.getElementById('closeGoToSubtitlePanelBtn');
const goToSubtitleInput = document.getElementById('goToSubtitleInput');
const goToSubtitleActionBtn = document.getElementById('goToSubtitleActionBtn');
const goToTimecodeInput = document.getElementById('goToTimecodeInput');
const goToTimecodeActionBtn = document.getElementById('goToTimecodeActionBtn');
const contextHelpHeader = document.getElementById('contextHelpHeader');
const contextHelpContent = document.getElementById('contextHelpContent');
// --- INICIO: Nuevos elementos DOM de la botonera ---
const waveformControls = document.getElementById('waveformControls');
const lockWaveformBtn = document.getElementById('lockWaveformBtn');
const zoomInBtn = document.getElementById('zoomInBtn');
const zoomOutBtn = document.getElementById('zoomOutBtn');
const lockIconOpen = document.querySelector('.lock-icon-open');
const lockIconClosed = document.querySelector('.lock-icon-closed');
const followPlaybackBtn = document.getElementById('followPlaybackBtn'); 
// --- FIN: Nuevos elementos DOM de la botonera ---

        // --- I18N & SHORTCUTS SETUP ---

        const translations = {
            'es': {
                'title': 'subpandaTM', 'import_srt': 'Importar .srt', 'export_srt': 'Exportar .srt', 'backup_btn': 'Copia de seguridad', 'qa_btn': 'QA', 'shortcuts_btn': 'Atajos', 'find_replace_btn': 'Buscar y reemplazar', 'terminology_btn': 'Terminolog√≠a', 'tm_btn': 'Memoria de traducci√≥n', 'load_video': 'Cargar v√≠deo', 'change_video': 'Cambiar v√≠deo', 'preview_size': 'Tama√±o:', 'preview_source': 'Mostrar:', 'translation_text_option': 'Traducci√≥n', 'original_text_option': 'Original', 'translation_stats_title': 'Estad√≠sticas', 'segments_progress_text': '{0}/{1} subt√≠tulos traducidos ({2}%)', 'words_translated_text': '{0} palabras traducidas', 'words_total_text': '{0} palabras originales totales', 'words_remaining_text': '{0} palabras pendientes', 'no_translations': 'Importa un archivo .srt y un v√≠deo para empezar a trabajar. Si lo deseas, puedes trabajar con una memoria de traducci√≥n TMX y un glosario TBX, que puedes importar o crear desde cero.', 'time_codes': 'C√≥digos de tiempo:', 'original_text': 'Original:', 'translation_text': 'Traducci√≥n:', 'validate': 'Validar', 'edit': 'Editar', 'char_count_original': 'Original: ', 'char_count_translation': 'Traducci√≥n: ', 'char_units': ' c', 'cps': ' CPS', 'ok': 'OK', 'close_btn': 'Cerrar', 'save_btn': 'Guardar', 'cancel_btn': 'Cancelar', 'shortcuts_title': 'Atajos de teclado',
                'shortcut_desc_validateAndNext': 'Validar traducci√≥n y pasar a la siguiente', 'shortcut_desc_goToNext': 'Ir al siguiente subt√≠tulo', 'shortcut_desc_goToPrevious': 'Ir al subt√≠tulo anterior', 'shortcut_desc_insertTM1': 'Insertar 1¬™ sugerencia de la MT', 'shortcut_desc_insertTM2': 'Insertar 2¬™ sugerencia de la MT', 'shortcut_desc_insertTM3': 'Insertar 3¬™ sugerencia de la MT', 'shortcut_desc_insertTM4': 'Insertar 4¬™ sugerencia de la MT', 'shortcut_desc_insertTM5': 'Insertar 5¬™ sugerencia de la MT', 'shortcut_desc_insertGloss1': 'Insertar 1er t√©rmino del glosario', 'shortcut_desc_insertGloss2': 'Insertar 2¬∫ t√©rmino del glosario', 'shortcut_desc_insertGloss3': 'Insertar 3er t√©rmino del glosario', 'shortcut_desc_insertGloss4': 'Insertar 4¬∫ t√©rmino del glosario', 'shortcut_desc_insertGloss5': 'Insertar 5¬∫ t√©rmino del glosario', 'shortcut_desc_jumpToTime': 'Saltar al tiempo de inicio del subt√≠tulo actual', 'shortcut_desc_playSegment': 'Reproducir el subt√≠tulo actual', 'shortcut_desc_playPause': 'Reproducir/pausar v√≠deo', 'shortcut_desc_seekForward': 'Avanzar 3 segundos', 'shortcut_desc_seekBackward': 'Retroceder 3 segundos', 'shortcut_desc_seekForwardFast': 'Avanzar 5 segundos', 'shortcut_desc_seekBackwardFast': 'Retroceder 5 segundos', 'shortcut_desc_bold': 'Aplicar negrita', 'shortcut_desc_italic': 'Aplicar cursiva',
                'find_replace_title': 'Buscar y reemplazar', 'find_label': 'Buscar:', 'replace_label': 'Reemplazar con:', 'case_sensitive': 'Distinguir may√∫sculas y min√∫sculas', 'regular_expression': 'Expresi√≥n regular', 'find_prev': 'Buscar anterior', 'find_next': 'Buscar siguiente', 'replace': 'Reemplazar', 'replace_all': 'Reemplazar todo', 'save_srt_title': 'Exportar Archivo SRT', 'save_tbx_title': 'Exportar Archivo TBX', 'save_tmx_title': 'Exportar Archivo TMX', 'file_name_label': 'Nombre del archivo:', 'backup_modal_title': 'Copia de Seguridad', 'restore_backup_info': 'Se ha encontrado una copia de seguridad de una sesi√≥n no guardada.', 'file_label': 'Archivo:', 'last_modified_label': '√öltima modificaci√≥n:', 'export_srt_btn': 'Exportar SRT', 'delete_backup_btn': 'Borrar Backup', 'restore_btn': 'Restaurar', 'no_backup_found_info': 'No se ha encontrado ninguna copia de seguridad autom√°tica.', 'qa_modal_title': 'Configuraci√≥n de QA', 'cps_limit_label': 'L√≠mite de CPS:', 'chars_per_line_limit_label': 'L√≠mite de caracteres por l√≠nea:', 'save_and_apply_btn': 'Guardar y aplicar', 'qa_error_list_title': 'Lista de Errores de QA', 'qa_errors_found': '{0} errores de QA encontrados', 'qa_no_errors': 'No se han encontrado errores de QA.', 'terminology_sidebar_title': 'Terminolog√≠a', 'config_lang_title': 'Configurar idiomas del glosario', 'config_lang_info': 'Define los idiomas de origen y destino de tu glosario. Es fundamental que el c√≥digo ISO sea correcto. Tras configurar el idioma, podr√°s importar o crear un glosario desde cero.', 'source_language': 'Idioma de origen:', 'target_language': 'Idioma de destino:', 'confirm_languages': 'Confirmar idiomas', 'current_lang_title': 'Idiomas actuales del glosario', 'add_term_title': 'A√±adir t√©rmino', 'term': 'T√©rmino:', 'translation': 'Traducci√≥n:', 'add_button': 'A√±adir', 'search_title': 'Buscar', 'search_placeholder': 'Buscar t√©rmino...', 'import_tbx': 'Importar TBX', 'download_tbx': 'Descargar TBX', 'new_glossary': 'Nuevo glosario', 'glossary_list_title': 'Glosario', 'source_term_col': 'T√©rmino de origen', 'target_term_col': 'T√©rmino de destino', 'actions_col': 'Acciones', 'edit_button': 'Editar', 'delete_button': 'Eliminar', 'save_changes_btn': 'Guardar cambios', 'tm_sidebar_title': 'Memoria de traducci√≥n', 'tm_config_lang_title': 'Configurar idiomas de la TM', 'tm_config_lang_info': 'Define los idiomas de origen y destino de tu memoria de traducci√≥n. Es fundamental que el c√≥digo ISO sea correcto. Tras configurar el idioma, podr√°s importar o crear una memoria desde cero.', 'current_tm_lang_title': 'Idiomas actuales de la TM', 'new_tm': 'Nueva TM', 'import_tmx': 'Importar TMX', 'download_tmx': 'Descargar TMX', 'tm_search_title': 'Buscar en TM', 'tm_search_placeholder': 'Buscar en la memoria...', 'tm_search_results_title': 'Resultados de b√∫squeda en TM', 'tm_score_col': '%', 'tm_original_col': 'Original', 'tm_translation_col': 'Traducci√≥n', 'tm_no_match_found': 'No se encontraron coincidencias en la TM.',
                'import_shortcuts_btn': 'Importar', 'export_shortcuts_btn': 'Exportar', 'restore_defaults_btn': 'Restaurar valores por defecto', 'edit_shortcut_btn': 'Editar', 'recording_shortcut_text': 'Pulsar tecla...', 'project_menu': 'Proyecto', 'load_project': 'Cargar proyecto', 'save_project': 'Guardar proyecto', 'new_project': 'Nuevo proyecto', 'reselect_video_title': 'Seleccionar v√≠deo', 'reselect_video_info': 'Proyecto cargado. Para sincronizar el v√≠deo, por favor, selecciona el archivo de v√≠deo original:', 'reselect_video_prompt': 'Proyecto cargado. Por favor, selecciona el archivo de v√≠deo original: {0}', 'skip_btn': 'Omitir', 'confirm_new_project_title': 'Crear nuevo proyecto', 'confirm_new_project_message': 'Tienes cambios sin guardar. ¬øQuieres guardar el proyecto actual antes de continuar?', 'continue_without_saving_btn': 'Continuar sin guardar',  'save_and_continue_btn': 'Guardar y continuar',
                'confirm_new_glossary_title': 'Confirmar nuevo glosario', 'confirm_new_glossary_message': 'Solo puedes tener un glosario activo. Si contin√∫as, se borrar√°n todos los datos del glosario actual. Para evitar perder tu trabajo, aseg√∫rate de exportarlo primero como un archivo TBX.','confirm_new_tm_title': 'Confirmar nueva TM','confirm_new_tm_message': 'Solo puedes tener una memoria de traducci√≥n (TM) activa. Si contin√∫as, se borrar√°n todos los datos de la TM actual. Para evitar perder tu trabajo, aseg√∫rate de exportarla primero como un archivo TMX.', 'continue_btn': 'Continuar',
                'productive_documentation': 'Documentaci√≥n productiva', 'doc_resource_placeholder': 'Ej: https://dle.rae.es/{word}', 
'entry_time': 'Entrada:',
                'exit_time': 'Salida:',
                'duration_label': 'Duraci√≥n:',
                'rewind_frame_tooltip': 'Retroceder 1 fotograma (40ms)',
                'play_segment_tooltip': 'Reproducir subt√≠tulo',
                'forward_frame_tooltip': 'Avanzar 1 fotograma (40ms)',
'shortcut_desc_playSegmentLoop': 'Reproducir subt√≠tulo actual en bucle',
'validate_all_previous': 'Validar ant.',
'validate_all_previous_tooltip': 'Validar este y todos los subt√≠tulos anteriores',
'context_sidebar_title': 'Asistente de IA',
'context_btn': 'IA',
'import_context': 'Importar contexto',
'ai_translation_title': 'Sugerencia de la IA:',
'context_notes_title': 'Consultas:',
'pretranslate_all_btn': 'Pretraducir todo',
        'pretranslate_all_title': 'Rellena todos los subt√≠tulos con la sugerencia principal de la IA',
        'instruction_1': 'Instrucci√≥n 1',
        'instruction_2': 'Instrucci√≥n 2',
        'instruction_3': 'Instrucci√≥n 3',
'no_context_available': 'No hay contexto disponible para este subt√≠tulo.',
'load_context_title': 'Importar sugerencias de la IA',
'context_help_title': '¬øC√≥mo funciona?',
'context_help_intro': 'Este asistente sirve para a√±adir propuestas o sugerencias de la IA que ir√°n apareciendo en cada subt√≠tulo a medida que vayas traduciendo. Puedes personalizar hasta 3 consultas que se ir√°n mostrando a la vez, junto con aclaraciones sobre el contexto o problemas de traducci√≥n que detecte la IA que uses. ',
'context_help_format': 'Para usar esta caracter√≠stica, primero debes asegurarte de haber importado un archivo SRT. Si ya lo has importado, el siguiente paso es personalizar tus prompts en el icono de la rueda mec√°nica. Cuando hayas terminado de redactar tus prompts, solo tendr√°s que darle a "Copiar prompt" y pegar y enviar el texto copiado a la IA que hayas elegido (recomendamos Gemini Pro). La respuesta que obtendr√°s ser√° un c√≥digo JSON que debes copiar y pegar en el siguiente recuadro haciendo clic en "Pegar c√≥digo". Si el c√≥digo que hayas pegado est√° correcto, ver√°s un aviso en color verde. En ese caso, haz clic en "Importar desde texto" y en adelante podr√°s usar las sugerencias de la IA para cada subt√≠tulo en esta misma ventana.',
'paste_json_placeholder': 'Pega aqu√≠ el c√≥digo JSON...',
'import_from_paste_btn': 'Importar desde texto',
'or_divider': 'o',
'import_from_file_btn': 'Importar desde archivo .json',
'reset_context': 'Cargar nuevo',
'copy_prompt_btn': 'Copiar prompt',
'paste_json_btn': 'Pegar c√≥digo',
'json_valid': 'El c√≥digo JSON es v√°lido.',
'json_invalid': 'El c√≥digo JSON es incorrecto.',
'prompt_copied_success': 'Prompt copiado al portapapeles.',
'clipboard_paste_error': 'No se ha podido pegar desde el portapapeles.',
'load_srt_first': 'Primero debes cargar un archivo SRT.',
'suggestion_primary': 'Traducci√≥n literal',
'suggestion_natural': 'Natural y fluida',
'suggestion_technical': 'Ajustada a CPS y CPL',
'tools_menu': 'Herramientas',
'go_to_subtitle_menu': 'Ir a...',
'go_to_subtitle_title': 'Ir a...',
'go_to_subtitle_label': 'Ir al subt√≠tulo n¬∫:',
'go_to_timecode_label': 'Ir al c√≥digo de tiempo:',
'go_btn': 'Ir',
'ai_default_instruction_1': 'Traduce los subt√≠tulos a espa√±ol de Espa√±a. Separa en dos l√≠neas los subt√≠tulos que tengan m√°s de {0} caracteres. Procura que todos los subt√≠tulos tengan menos de {1} caracteres por segundo.',
'reset_app_btn': 'Resetear aplicaci√≥n',
'reset_app_confirm': '¬øEst√°s seguro de que quieres resetear la aplicaci√≥n? Se borrar√°n todos los proyectos, backups y ajustes guardados en este navegador. Esta acci√≥n no se puede deshacer.',
'reset_app_success': 'Aplicaci√≥n reseteada. Recargando...',
'reset_db_error': 'Error al resetear la aplicaci√≥n. Por favor, borra la cach√© del navegador manualmente.',
'reset_storage_error': 'Ha ocurrido un error durante el reseteo.',
'planner_title': 'Planificador',
'planner_divide_in': 'Dividir en:',
'planner_sessions': 'sesiones',
'planner_method_subs': 'Por n√∫mero de subt√≠tulos',
'planner_method_words': 'Por n√∫mero de palabras',
'planner_method_time': 'Por tiempo',
'planner_calculate': 'Calcular',
'planner_load_srt_warning': 'Carga un archivo SRT para poder usar el planificador.',
'planner_session_subs': 'Subt√≠tulos #{0} - #{1}',
'planner_session_time': 'Tiempo {0} - {1} (hasta Sub. #{2})',
'planner_session_words': 'Subt√≠tulos #{0} - #{1} (~{2} palabras)',
'planner_words_label': 'palabras',
'planner_session_qa': 'Revisi√≥n / QA',
'save_project_title': 'Guardar proyecto',
                'confirm_restore_message': '¬øEst√°s seguro de que quieres restaurar la copia de seguridad? Se perder√° todo el trabajo no guardado en la sesi√≥n actual.',
'replacements_made': 'Se han hecho {0} reemplazos.',
'undo_btn': 'Deshacer',
'redo_btn': 'Rehacer',
'linebreak_tooltip_text': 'Salto de l√≠nea = Mayus + Enter',
'delete_subtitle_confirm': '¬øSeguro que quieres eliminar este subt√≠tulo? ', 
'merge_next_tooltip': 'Fusionar con el subt√≠tulo siguiente',
    'split_tooltip': 'Separar subt√≠tulo en la posici√≥n del cursor',
    'delete_tooltip': 'Eliminar subt√≠tulo',
'lock_waveform': 'Bloquear onda',
'unlock_waveform': 'Desbloquear onda',
'zoom_out': 'Alejar zoom',
'zoom_in': 'Aumentar zoom',
'follow_playback_on': 'Activar seguimiento de reproducci√≥n',
'follow_playback_off': 'Desactivar seguimiento de reproducci√≥n',
'show_status_bar_btn': 'Mostrar estad√≠sticas',
            'hide_status_bar_btn': 'Ocultar estad√≠sticas',
'timecode_settings_btn': 'Ajustes de tiempo',
'timecode_modal_title': 'Ajustes de tiempo',
'project_fps_label': 'FPS del proyecto:',
'fps_recommendation_note': 'Sugerencia: Para una sincronizaci√≥n precisa, comprueba los FPS de tu archivo de v√≠deo en las propiedades y selecciona el mismo valor aqu√≠.', 
'show_frames_label': 'Mostrar c√≥digo de tiempo en frames (ej. 00:00:10:05)',
'timecode_warning': 'Aviso: La exportaci√≥n SRT siempre usar√° milisegundos por compatibilidad.',
'timecode_format_error': 'El formato del c√≥digo de tiempo noes v√°lido. Usa HH:MM:SS:FF.',

            },
            'en': {
                'title': 'subpandaTM', 'import_srt': 'Import .srt', 'export_srt': 'Export .srt', 'backup_btn': 'Backup', 'qa_btn': 'QA', 'shortcuts_btn': 'Shortcuts', 'find_replace_btn': 'Find & Replace', 'terminology_btn': 'Terminology', 'tm_btn': 'Translation Memory', 'load_video': 'Load Video', 'change_video': 'Change Video', 'preview_size': 'Size:', 'preview_source': 'Show:', 'translation_text_option': 'Translation', 'original_text_option': 'Original', 'translation_stats_title': 'Statistics', 'segments_progress_text': '{0}/{1} subtitles translated ({2}%)', 'words_translated_text': '{0} words translated', 'words_total_text': '{0} total original words', 'words_remaining_text': '{0} words remaining', 'no_translations': 'Import an .srt file and a video to start working. If you wish, you can work with a TMX translation memory and a TBX glossary, which you can import or create from scratch.', 'time_codes': 'Time codes:', 'original_text': 'Original:', 'translation_text': 'Translation:', 'validate': 'Validate', 'edit': 'Edit', 'char_count_original': 'Original: ', 'char_count_translation': 'Translation: ', 'char_units': ' c', 'cps': ' CPS', 'ok': 'OK', 'close_btn': 'Close', 'save_btn': 'Save', 'cancel_btn': 'Cancel', 'shortcuts_title': 'Keyboard Shortcuts',
                'shortcut_desc_validateAndNext': 'Validate translation and move to next', 'shortcut_desc_goToNext': 'Go to next subtitle', 'shortcut_desc_goToPrevious': 'Go to previous subtitle', 'shortcut_desc_insertTM1': 'Insert 1st TM suggestion', 'shortcut_desc_insertTM2': 'Insert 2nd TM suggestion', 'shortcut_desc_insertTM3': 'Insert 3rd TM suggestion', 'shortcut_desc_insertTM4': 'Insert 4th TM suggestion', 'shortcut_desc_insertTM5': 'Insert 5th TM suggestion', 'shortcut_desc_insertGloss1': 'Insert 1st glossary term', 'shortcut_desc_insertGloss2': 'Insert 2nd glossary term', 'shortcut_desc_insertGloss3': 'Insert 3rd glossary term', 'shortcut_desc_insertGloss4': 'Insert 4th glossary term', 'shortcut_desc_insertGloss5': 'Insert 5th glossary term', 'shortcut_desc_jumpToTime': 'Jump to current subtitle start time', 'shortcut_desc_playSegment': 'Play current subtitle', 'shortcut_desc_playPause': 'Play/pause video', 'shortcut_desc_seekForward': 'Seek forward 3 seconds', 'shortcut_desc_seekBackward': 'Seek backward 3 seconds', 'shortcut_desc_seekForwardFast': 'Seek forward 5 seconds', 'shortcut_desc_seekBackwardFast': 'Seek backward 5 seconds', 'shortcut_desc_bold': 'Apply bold', 'shortcut_desc_italic': 'Apply italics',
                'find_replace_title': 'Find and Replace', 'find_label': 'Find:', 'replace_label': 'Replace with:', 'case_sensitive': 'Case sensitive', 'regular_expression': 'Regular expression', 'find_prev': 'Find previous', 'find_next': 'Find next', 'replace': 'Replace', 'replace_all': 'Replace all', 'save_srt_title': 'Export SRT File', 'save_tbx_title': 'Export TBX File', 'save_tmx_title': 'Export TMX File', 'file_name_label': 'File name:', 'backup_modal_title': 'Backup', 'restore_backup_info': 'A backup of an unsaved session has been found.', 'file_label': 'File:', 'last_modified_label': 'Last modified:', 'export_srt_btn': 'Export SRT', 'delete_backup_btn': 'Delete Backup', 'restore_btn': 'Restore', 'no_backup_found_info': 'No automatic backup has been found.', 'qa_modal_title': 'QA Settings', 'cps_limit_label': 'CPS Limit:', 'chars_per_line_limit_label': 'Characters per line limit:', 'save_and_apply_btn': 'Save and apply', 'qa_error_list_title': 'QA Error List', 'qa_errors_found': '{0} QA errors found', 'qa_no_errors': 'No QA errors found.', 'terminology_sidebar_title': 'Terminology', 'config_lang_title': 'Set up glossary languages', 'config_lang_info': 'Define the source and target languages for your glossary. The ISO code must be correct. After setting the language, you can import or create a glossary from scratch.', 'source_language': 'Source language:', 'target_language': 'Target language:', 'confirm_languages': 'Confirm languages', 'current_lang_title': 'Current glossary languages', 'add_term_title': 'Add term', 'term': 'Term:', 'translation': 'Translation:', 'add_button': 'Add', 'search_title': 'Search', 'search_placeholder': 'Search term...', 'import_tbx': 'Import TBX', 'download_tbx': 'Download TBX', 'new_glossary': 'New glossary', 'glossary_list_title': 'Glossary', 'source_term_col': 'Source term', 'target_term_col': 'Target term', 'actions_col': 'Actions', 'delete_button': 'Delete', 'edit_button': 'Edit', 'save_changes_btn': 'Save Changes', 'tm_sidebar_title': 'Translation Memory', 'tm_config_lang_title': 'Set up TM languages', 'tm_config_lang_info': 'Define the source and target languages for your translation memory. The ISO code must be correct. After setting the language, you can import or create a memory from scratch.', 'current_tm_lang_title': 'Current TM languages', 'new_tm': 'New TM', 'import_tmx': 'Import TMX', 'download_tmx': 'Download TMX', 'tm_search_title': 'Search TM', 'tm_search_placeholder': 'Search in memory...', 'tm_search_results_title': 'TM Search Results', 'tm_score_col': '%', 'tm_original_col': 'Original', 'tm_translation_col': 'Translation', 'tm_no_match_found': 'No matches found in the TM.',
                'import_shortcuts_btn': 'Import', 'export_shortcuts_btn': 'Export', 'restore_defaults_btn': 'Restore Defaults', 'edit_shortcut_btn': 'Edit', 'recording_shortcut_text': 'Press key...',
                'project_menu': 'Project', 'load_project': 'Load project', 'save_project': 'Save project', 'new_project': 'New project', 'reselect_video_title': 'Select Video', 'reselect_video_info': 'Project loaded. To sync the video, please select the original video file:', 'reselect_video_prompt': 'Project loaded. Please select the original video file: {0}', 'skip_btn': 'Skip', 'confirm_new_project_title': 'Create new project', 'confirm_new_project_message': 'You have unsaved changes. Do you want to save the current project before continuing?',
                'continue_without_saving_btn': 'Continue without saving', 
                'save_and_continue_btn': 'Save and continue',
                'confirm_new_glossary_title': 'Confirm New Glossary',
                'confirm_new_glossary_message': 'You can only have one active glossary. If you continue, all data from the current glossary will be deleted. To avoid losing your work, make sure to export it as a TBX file first.',
                'confirm_new_tm_title': 'Confirm New TM',
                'confirm_new_tm_message': 'You can only have one active Translation Memory (TM). If you continue, all data from the current TM will be deleted. To avoid losing your work, make sure to export it as a TMX file first.',
                'continue_btn': 'Continue', 
                'productive_documentation': 'Productivity Documentation',
                'doc_resource_placeholder': 'E.g., https://www.wordreference.com/es/en/{word}',
'entry_time': 'Start:',
                'exit_time': 'End:',
                'duration_label': 'Duration:',
                'rewind_frame_tooltip': 'Rewind 1 frame (40ms)',
                'play_segment_tooltip': 'Play current subtitle',
                'forward_frame_tooltip': 'Forward 1 frame (40ms)',
'shortcut_desc_playSegmentLoop': 'Play current subtitle in a loop',
'validate_all_previous': 'Validate prev.',
'validate_all_previous_tooltip': 'Validate this and all previous subtitles',
'context_sidebar_title': 'AI Assistant',
'context_btn': 'AI',
'import_context': 'Import Context',
'ai_translation_title': 'AI Suggestion:',
'context_notes_title': 'Prompts:',
'pretranslate_all_btn': 'Pre-translate all',
        'pretranslate_all_title': 'Fill all subtitles with the main AI suggestion',
        'instruction_1': 'Prompt  1',
        'instruction_2': 'Prompt  2',
        'instruction_3': 'Prompt  3',
'no_context_available': 'No context available for this subtitle.',
'load_context_title': 'Import AI Suggestions',
'context_help_title': 'How does it work?',
'context_help_intro': 'This assistant helps you add AI-powered suggestions that appear alongside each subtitle as you translate. You can set up to three custom prompts to show at once, along with notes the AI detects about context or possible translation issues.',
'context_help_format': 'To get started, make sure you‚Äôve imported an SRT file. If you have, click the gear icon to set up your prompts. When you‚Äôre happy with them, hit ‚ÄúCopy prompt‚Äù, then paste and send that text to your preferred AI (we recommend Gemini Pro). The AI will return a JSON code ‚Äî just copy it, click ‚ÄúPaste code‚Äù below, and drop it in. If everything looks good, you‚Äôll see a green confirmation. From there, click ‚ÄúImport from text‚Äù, and you‚Äôll start seeing the AI‚Äôs suggestions for each subtitle right here in this window.',
'paste_json_placeholder': 'Paste the JSON code here...',
'import_from_paste_btn': 'Import from text',
'or_divider': 'or',
'import_from_file_btn': 'Import from .json file',
'reset_context': 'Load New',
'copy_prompt_btn': 'Copy prompt',
'paste_json_btn': 'Paste code',
'json_valid': 'Valid JSON code.',
'json_invalid': 'Incorrect JSON code.',
'prompt_copied_success': 'Prompt copied to clipboard.',
'clipboard_paste_error': 'Could not paste from clipboard.',
'load_srt_first': 'You must load an SRT file first.',
'suggestion_primary': 'Literal translation',
'suggestion_natural': 'Natural and fluent',
'suggestion_technical': 'Within the CPS and CPL guidelines',
'tools_menu': 'Tools',
'go_to_subtitle_menu': 'Go to...',
'go_to_subtitle_title': 'Go to...',
'go_to_subtitle_label': 'Go to subtitle #:',
'go_to_timecode_label': 'Go to timecode:',
'go_btn': 'Go',
'ai_default_instruction_1': 'Translate the subtitles to Spanish (Spain). Split subtitles longer than {0} characters into two lines. Try to keep all subtitles under {1} characters per second.',
'reset_app_btn': 'Reset Application',
'reset_app_confirm': 'Are you sure you want to reset the application? All saved projects, backups, and settings in this browser will be deleted. This action cannot be undone.',
'reset_app_success': 'Application reset. Reloading...',
'reset_db_error': 'Error resetting the database. Please clear your browser cache manually.',
'reset_storage_error': 'An error occurred during the reset.',
'planner_title': 'Planner',
'planner_divide_in': 'Divide into:',
'planner_sessions': 'sessions',
'planner_method_subs': 'By number of subtitles',
'planner_method_words': 'By number of words',
'planner_method_time': 'By time',
'planner_calculate': 'Calculate',
'planner_load_srt_warning': 'Load an SRT file to use the planner.',
'planner_session_subs': 'Subtitles #{0} - #{1}',
'planner_session_time': 'Time {0} - {1} (up to Sub #{2})',
'planner_session_words': 'Subtitles #{0} - #{1} (~{2} words)',
'planner_words_label': 'words',
'planner_session_qa': 'Review / QA',
'save_project_title': 'Save Project',
                'confirm_restore_message': 'Are you sure you want to restore the backup? All unsaved work in the current session will be lost.',
'replacements_made': '{0} replacements have been made.',
'undo_btn': 'Undo',
'redo_btn': 'Redo',
'linebreak_tooltip_text': 'Linebreak = Shift + Enter',
'ai_settings_title': 'Customize AI Prompt',
'ai_settings_intro': 'Add up to three instructions for the AI. The first is mandatory and comes with default text that you can modify. QA guidelines will be added automatically.',
'ai_instruction_1_label': 'Instruction 1 (Required):',
'ai_instruction_2_label': 'Instruction 2 (Optional):',
'ai_instruction_3_label': 'Instruction 3 (Optional):',
'delete_subtitle_confirm': 'Are you sure you want to delete this subtitle?',
'merge_next_tooltip': 'Merge with next subtitle',
    'split_tooltip': 'Split subtitle at cursor position',
    'delete_tooltip': 'Delete subtitle',
'lock_waveform': 'Lock waveform',
'unlock_waveform': 'Unlock waveform',
'zoom_out': 'Zoom out',
'zoom_in': 'Zoom in',
'follow_playback_on': 'Enable playback tracking',
'follow_playback_off': 'Disable playback tracking',
'show_status_bar_btn': 'Show statss bar',
            'hide_status_bar_btn': 'Hide stats bar',
'timecode_settings_btn': 'Timecode Settings',
'timecode_modal_title': 'Timecode Settings',
'project_fps_label': 'Project FPS:',
'fps_recommendation_note': "Tip: For accurate timing, check your video file's FPS (Right-click > Properties > Details) and select the same value here.", 
'show_frames_label': 'Show timecode in frames (e.g. 00:00:10:05)',
'timecode_warning': 'Note: SRT export will always use milliseconds for compatibility.',
'timecode_format_error': 'Invalid timecode format. Use HH:MM:SS:FF.',
            }
        };

        const errorMessages = {
            'es': {
                'error_reading_file': 'Error al leer o analizar archivo .srt: ', 'error_saving_file': 'Error al guardar archivo: ', 'file_saved_successfully': 'Archivo .srt guardado con √©xito.', 'file_saved_successfully_tbx': 'Archivo TBX guardado con √©xito.', 'file_saved_successfully_tmx': 'Archivo TMX guardado con √©xito.', 'please_enter_filename': 'Por favor, introduce un nombre de archivo.', 'no_translations_to_save': 'No hay subt√≠tulos para guardar. Carga un archivo .srt primero.', 'reached_last': 'Has llegado al √∫ltimo subt√≠tulo.', 'reached_first': 'Ya est√°s en el primer subt√≠tulo.', 'file_processing_error': '¬°Error! No se pudo procesar el archivo. Aseg√∫rate de que es un archivo .srt v√°lido.', 'no_match_found': 'No se encontr√≥ ninguna coincidencia.', 'replaced_all': 'Todas las ocurrencias reemplazadas.', 'no_find_query': 'Por favor, introduce el texto a buscar.', 'loading_file': 'Cargando archivo...', 'saving_file': 'Guardando archivo...', 'video_load_error': 'Error al cargar el v√≠deo. Aseg√∫rate de que el formato es compatible.', 'both_terms_required': 'Ambos t√©rminos son requeridos.', 'lang_config_required': 'Por favor, configura los idiomas de origen y destino para el glosario.', 'cannot_download_empty_or_unconfigured_glossary': 'No se puede descargar un glosario vac√≠o o sin configurar.', 'error_loading_tbx_file': 'Error al cargar el archivo TBX. Aseg√∫rate de que sea un XML/TBX v√°lido.', 'tmx_file_expected_tbx_found': 'Este archivo parece ser una memoria de traducci√≥n (TMX). Por favor, usa la opci√≥n "Importar TMX" en el panel de Memoria de Traducci√≥n.', 'tbx_file_expected_tmx_found': 'Este archivo parece ser un glosario (TBX). Por favor, usa la opci√≥n "Importar TBX" en el panel de Terminolog√≠a.', 'error_loading_tmx_file': 'Error al cargar el archivo TMX. Aseg√∫rate de que sea un XML/TMX v√°lido.', 'cannot_download_empty_tm': 'No se puede descargar una memoria de traducci√≥n vac√≠a.', 'backup_deleted_confirmation': '¬øEst√°s seguro de que quieres borrar permanentemente este backup? Esta acci√≥n no se puede deshacer.', 'backup_deleted_message': 'El backup ha sido borrado.', 'project_restored_message': 'Proyecto restaurado con √©xito.', 'no_backup_to_export': 'No hay datos de backup disponibles para exportar.', 'backup_export_error': 'Error al exportar el SRT del backup: ', 'backup_export_success': 'El archivo ha sido exportado con √©xito.',
                'shortcut_import_error': 'Error al importar los atajos. Aseg√∫rate de que es un archivo JSON v√°lido.', 'shortcut_conflict': 'Este atajo ya est√° en uso. Por favor, elige otro.',
                'project_loaded_success': 'Proyecto cargado con √©xito.', 'error_loading_project': 'Error al cargar el proyecto', 'no_project_to_save': 'No hay ning√∫n proyecto activo para guardar.'
            },
            'en': {
                'error_reading_file': 'Error reading or parsing .srt file: ', 'error_saving_file': 'Error saving file: ', 'file_saved_successfully': '.srt file saved successfully.', 'file_saved_successfully_tbx': 'TBX file saved successfully.', 'file_saved_successfully_tmx': 'TMX file saved successfully.', 'please_enter_filename': 'Please enter a filename.', 'no_translations_to_save': 'No subtitles to save. Load an .srt file first.', 'reached_last': 'You have reached the last subtitle.', 'reached_first': 'You are already at the first subtitle.', 'file_processing_error': 'Error! Could not process the file. Make sure it is a valid .srt file.', 'no_match_found': 'No match found.', 'replaced_all': 'All occurrences replaced.', 'no_find_query': 'Please enter text to search for.', 'loading_file': 'Loading file...', 'saving_file': 'Saving file...', 'video_load_error': 'Error loading video. Make sure the format is supported.', 'both_terms_required': 'Both terms are required.', 'lang_config_required': 'Please set up the source and target languages for the glossary.', 'cannot_download_empty_or_unconfigured_glossary': 'Cannot download an empty or unconfigured glossary.', 'error_loading_tbx_file': 'Error loading TBX file. Make sure it is a valid XML/TBX.', 'tmx_file_expected_tbx_found': 'This file appears to be a Translation Memory (TMX). Please use the "Import TMX" option in the Translation Memory panel.', 'tbx_file_expected_tmx_found': 'This file appears to be a Glossary (TBX). Please use the "Import TBX" option in the Terminology panel.', 'error_loading_tmx_file': 'Error loading TMX file. Make sure it is a valid XML/TMX.', 'cannot_download_empty_tm': 'Cannot download an empty translation memory.', 'backup_deleted_confirmation': 'Are you sure you want to permanently delete this backup? This action cannot be undone.', 'backup_deleted_message': 'The backup has been deleted.', 'project_restored_message': 'Project restored successfully.', 'no_backup_to_export': 'No backup data available to export.', 'backup_export_error': 'Error exporting SRT from backup: ', 'backup_export_success': 'File exported successfully.',
                'shortcut_import_error': 'Error importing shortcuts. Please ensure it is a valid JSON file.', 'shortcut_conflict': 'This shortcut is already in use. Please choose another one.',
                'project_loaded_success': 'Project loaded successfully.', 'error_loading_project': 'Error loading project', 'no_project_to_save': 'There is no active project to save.'
            }
        };

const AI_PROMPT_TEMPLATE = `Act√∫a como un asistente experto en traducci√≥n audiovisual para subtitulaci√≥n. Te proporcionar√© el contenido de un archivo SRT.

Tu √∫nica salida debe ser un archivo de c√≥digo en formato JSON, sin ninguna explicaci√≥n antes o despu√©s del bloque de c√≥digo.

El JSON debe ser un array de objetos. Cada objeto debe corresponder a un subt√≠tulo y tener la siguiente estructura exacta:

1.  Una clave '"index"' (n√∫mero).
2.  Una clave '"ai_suggestions"' (objeto). Dentro de este objeto, debe haber tres claves:
    * '"primary"': Tu mejor traducci√≥n al espa√±ol de Espa√±a.
    * '"natural"': Una versi√≥n m√°s coloquial o fluida.
    * '"technical"': Una versi√≥n optimizada para subtitulaci√≥n (m√°x. 42 caracteres por l√≠nea, CPS < 20), usando '\\n' para los saltos de l√≠nea.
3.  Una clave '"context_notes"' (texto). Aqu√≠ debes explicar modismos, referencias culturales, etc., y a√±adir un enlace a una fuente fiable que respalde tus decisiones.

Aseg√∫rate de que la clave '"context_notes"' est√© al mismo nivel que '"index"' y '"ai_suggestions"', y NO dentro de '"ai_suggestions"'.

**Ejemplo de la estructura requerida para un objeto:**
{
  "index": 1,
  "ai_suggestions": {
    "primary": "Traducci√≥n principal aqu√≠.",
    "natural": "Traducci√≥n natural aqu√≠.",
    "technical": "Traducci√≥n t√©cnica aqu√≠."
  },
  "context_notes": "<b>Explicaci√≥n:</b> Notas y enlace aqu√≠. Fuente: https://www.ejemplo.com"
}

Ahora, analiza el siguiente contenido SRT y genera el JSON completo:

[SRT_CONTENT_PLACEHOLDER]`;

 let shortcutProfiles = {}; // contendr√° los perfiles 'windows' y 'mac'
        let activeProfile = 'windows'; // perfil por defecto
        let shortcuts = {}; // se rellenar√° con el perfil activo
     
   // List of common ISO 639-1 language codes for the datalist
        const isoLanguagesData = [
          { code: "en", name: "English" }, { code: "en-US", name: "English (United States)" }, { code: "en-GB", name: "English (United Kingdom)" },
          { code: "es", name: "Espa√±ol" }, { code: "es-AR", name: "Espa√±ol (Argentina)" }, { code: "es-ES", name: "Espa√±ol (Espa√±a)" }, { code: "es-MX", name: "Espa√±ol (M√©xico)" },
          { code: "fr", name: "Fran√ßais" }, { code: "de", name: "Deutsch" }, { code: "it", name: "Italiano" }, { code: "pt", name: "Portugu√™s" },
          { code: "ja", name: "Êó•Êú¨Ë™û (Japanese)" }, { code: "zh", name: "‰∏≠Êñá (Chinese)" }, { code: "ar", name: "ÿßŸÑÿπÿ±ÿ®Ÿäÿ© (Arabic)" },
          { code: "ru", name: "–†—É—Å—Å–∫–∏–π (Russian)" }, { code: "ko", name: "ÌïúÍµ≠Ïñ¥ (Korean)" }, { code: "nl", name: "Nederlands" },
          { code: "sv", name: "Svenska" }, { code: "da", name: "Dansk" }, { code: "no", name: "Norsk" }, { code: "fi", "name": "Suomi" },
          { code: "tr", name: "T√ºrk√ße" }, { code: "pl", name: "Polski" }, { code: "cs", name: "ƒåe≈°tina" }, { code: "hu", name: "Magyar" },
          { code: "el", name: "ŒïŒªŒªŒ∑ŒΩŒπŒ∫Œ¨ (Greek)" }, { code: "he", name: "◊¢◊ë◊®◊ô◊™ (Hebrew)" }, { code: "th", name: "‡πÑ‡∏ó‡∏¢ (Thai)" },
          { code: "vi", name: "Ti·∫øng Vi·ªát (Vietnamese)" }, { code: "id", name: "Bahasa Indonesia" }, { code: "ms", name: "Bahasa Melayu" },
          { code: "ca", name: "Catal√†" }, { code: "eu", name: "Euskara" }, { code: "gl", name: "Galego" }, { code: "ro", name: "Rom√¢nƒÉ" },
          { code: "uk", name: "–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞ (Ukrainian)" }, { code: "bg", name: "–ë—ä–ª–≥–∞—Ä—Å–∫–∏ (Bulgarian)" }, { code: "hr", name: "Hrvatski" },
          { code: "sr", name: "Srpski" }, { code: "sk", name: "Slovenƒçina" }, { code: "sl", name: "Sloven≈°ƒçina" }, { code: "lt", name: "Lietuvi≈≥" },
          { code: "lv", name: "Latvie≈°u" }, { code: "et", name: "Eesti" }, { code: "is", name: "√çslenska" }, { code: "ga", name: "Gaeilge" },
          { code: "mt", name: "Malti" },
        ];


        /**
         * Counts words in a given text string.
         * @param {string} text The text to count words from.
         * @returns {number} The number of words.
         */
        function countWords(text) {
            if (!text) return 0;
            // Trim leading/trailing whitespace and split by one or more whitespace characters
            const words = text.trim().split(/\s+/);
            // Filter out empty strings that might result from multiple spaces
            return words.filter(word => word.length > 0).length;
        }
        
        /**
         * Counts characters in a string, ignoring HTML tags.
         * @param {string} text The text to count.
         * @returns {number} The character count without tags.
         */
        function countCharactersWithoutTags(text) {
            if (!text) return 0;
            // Remove all HTML tags
            const noTags = text.replace(/<[^>]+>/g, '');
            // Convert entities like &nbsp; to space
            const cleanText = noTags.replace(/&nbsp;/gi, ' ');
            return cleanText.length;
        }

        /**
         * Converts milliseconds to SRT time format (HH:MM:SS,ms).
         * @param {number} ms Milliseconds.
         * @returns {string} Formatted time string.
         */
        function formatTime(ms) {
            const hours = Math.floor(ms / 3600000);
            ms %= 3600000;
            const minutes = Math.floor(ms / 60000);
            ms %= 60000;
            const seconds = Math.floor(ms / 1000);
            const milliseconds = ms % 1000;

            return [
                hours.toString().padStart(2, '0'),
                minutes.toString().padStart(2, '0'),
                seconds.toString().padStart(2, '0')
            ].join(':') + ',' + milliseconds.toString().padStart(3, '0');
        }

        /**
         * Converts SRT time format (HH:MM:SS,ms) to milliseconds.
         * @param {string} timeStr Time string in SRT format.
         * @returns {number} Milliseconds.
         */
        function parseTime(timeStr) {
            const parts = timeStr.split(',');
            const [h, m, s] = parts[0].split(':').map(Number);
            const ms = Number(parts[1]);
            return (h * 3600 + m * 60 + s) * 1000 + ms;
        }

/**
         * Convierte milisegundos a formato de frames (HH:MM:SS:FF).
         * @param {number} ms Milliseconds.
         * @param {number} fps Project FPS.
         * @returns {string} Formatted time string.
         */
        function formatFrameTime(ms, fps) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            const remainingMs = ms % 1000;
            const frames = Math.round((remainingMs / 1000) * fps);

            return [
                hours.toString().padStart(2, '0'),
                minutes.toString().padStart(2, '0'),
                seconds.toString().padStart(2, '0')
            ].join(':') + ':' + frames.toString().padStart(2, '0');
        }

        /**
         * Convierte formato de frames (HH:MM:SS:FF) a milisegundos.
         * @param {string} timeStr Time string in frame format.
         * @param {number} fps Project FPS.
         * @returns {number} Milliseconds.
         */
        function parseFrameTime(timeStr, fps) {
            const parts = timeStr.split(':');
            if (parts.length !== 4) throw new Error("Invalid frame time format");
            
            const [h, m, s, f] = parts.map(Number);
            let totalMs = 0;
            totalMs += h * 3600000;
            totalMs += m * 60000;
            totalMs += s * 1000;
            
            // Convierte los frames a los milisegundos m√°s cercanos
            totalMs += Math.round((f / fps) * 1000);
            
            return totalMs;
        }

        /**
         * Calculates Characters Per Second (CPS) for a given text and duration.
         * @param {string} text The text of the subtitle.
         * @param {number} durationMs The duration of the subtitle in milliseconds.
         * @returns {number} CPS value.
         */
        function calculateCPS(text, durationMs) {
            if (durationMs <= 0) return 0;

            // Remove ALL HTML tags
            const noTags = text.replace(/<[^>]+>/g, '');

            // Replace &nbsp; entities with spaces
            const cleanText = noTags.replace(/&nbsp;/gi, ' ');

            // Divide by seconds
            return (cleanText.length / (durationMs / 1000)).toFixed(2);
        }

        /**
         * Parses the content of an SRT file.
         * @param {string} content The full content of the SRT file.
         * @returns {Array<Object>} An array of SRT entry objects.
         */
        function parseSrtContent(content) {
            const entries = [];
            const blocks = content.split(/\r?\n\r?\n/); // Split by double newline (CRLF or LF)

            blocks.forEach(block => {
                const lines = block.trim().split(/\r?\n/);
                if (lines.length >= 3) {
                    const index = parseInt(lines[0]);
                    const timecodes = lines[1];
                    const text = lines.slice(2).join('\n'); // Join remaining lines as text

                    const [startTimeStr, endTimeStr] = timecodes.split(' --> ');
                    const startTimeMs = parseTime(startTimeStr);
                    const endTimeMs = parseTime(endTimeStr);
                    const durationMs = endTimeMs - startTimeMs;
                    const charCountOriginal = countCharactersWithoutTags(text);

                    entries.push({
                        index: index,
                        timecodes: timecodes,
                        startTimeMs: startTimeMs,
                        endTimeMs: endTimeMs,
                        durationMs: durationMs,
                        original: text,
                        translation: '', // Initialize translation as empty
                        wordCountOriginal: countWords(text),
                        wordCountTranslation: 0,
                        isTranslated: false,
                        charCountOriginal: charCountOriginal,
                        charCountTranslation: 0,
                        cpsOriginal: calculateCPS(text, durationMs),
                        cpsTranslation: 0
                    });
                }
            });
            return entries;
        }

        /**
         * Reconstructs the content of an SRT file from an array of entries.
         * @param {Array<Object>} entries The array of subtitle objects.
         * @returns {string} The reconstructed SRT file content.
         */
            function reconstructSrt(entries) {
    let srtContent = '';
    entries.forEach(entry => {
        srtContent += `${entry.index}\n`;
        srtContent += `${entry.timecodes}\n`;

        let textToWrite = entry.translation || entry.original;

        // --- INICIO DEL NUEVO PROCESO DE LIMPIEZA INTELIGENTE ---

        // 1. Normalizamos los saltos de l√≠nea generados por el editor.
        // Reemplazamos los saltos de l√≠nea de <div> y <br> por el car√°cter est√°ndar '\n'.
        textToWrite = textToWrite.replace(/<\/div>\s*<div>/gi, '\n');
        textToWrite = textToWrite.replace(/<br\s*\/?>/gi, '\n');

        // 2. Eliminamos TODAS las etiquetas HTML EXCEPTO <b> y <i>.
        // Esta es la parte clave. Usamos una expresi√≥n regular con "negative lookahead"
        // para decirle que ignore las etiquetas de formato que queremos conservar.
        textToWrite = textToWrite.replace(/<(?!(\/?b|\/?i))[^>]+>/gi, '');

        // 3. Limpiamos cualquier espacio en blanco extra al principio o al final.
        textToWrite = textToWrite.trim();
        
        // --- FIN DEL NUEVO PROCESO ---

        srtContent += `${textToWrite}\n\n`;
    });
    return srtContent.trim();
}

// --- INICIO: Funciones de Bloqueo y Zoom de Onda ---

/**
 * Alterna el estado de bloqueo de la onda de sonido.
 * Evita que las regiones se puedan arrastrar o redimensionar.
 */
function toggleWaveformLock() {
    isWaveformLocked = !isWaveformLocked;
    const waveformEl = document.getElementById('waveform');
    
    // Alternar estado visual
    waveformEl.classList.toggle('is-locked', isWaveformLocked);
    lockIconOpen.classList.toggle('hidden', isWaveformLocked);
    lockIconClosed.classList.toggle('hidden', !isWaveformLocked);
lockWaveformBtn.classList.toggle('active', isWaveformLocked);
lockWaveformBtn.title = isWaveformLocked ? translations[currentLanguage]['unlock_waveform'] : translations[currentLanguage]['lock_waveform'];

    // Deshabilitar/Habilitar drag y resize en TODAS las regiones
    if (wsRegions) {
        wsRegions.getRegions().forEach(region => {
            region.setOptions({
                drag: !isWaveformLocked,
                resize: !isWaveformLocked
            });
        });
    }
}

/**
 * Aplica zoom a la onda de sonido.
 * @param {number} direction - 1 para Zoom In, -1 para Zoom Out.
 */
function zoomWaveform(direction) {
    if (!wavesurfer) return;
    
    const newZoom = currentWaveformZoom + (direction * ZOOM_STEP);
    
    // Establecemos un l√≠mite m√≠nimo de zoom para que no se "pierda"
    if (newZoom >= 20) { 
        currentWaveformZoom = newZoom;
        wavesurfer.zoom(currentWaveformZoom);
    }
}
// --- FIN: Funciones de Bloqueo y Zoom de Onda ---

// --- Funciones de Regiones de WaveSurfer (NUEVAS y MODIFICADAS) ---
        /** Limpia todas las regiones de subt√≠tulos de la onda. */
        function clearSubtitleRegions() {
            if (wsRegions) {
                // Limpia solo regiones de subt√≠tulos, preservando otras si las hubiera
                wsRegions.getRegions().forEach(region => {
                    if (region.id.startsWith('sub-')) { // Asume que los IDs de subt√≠tulos empiezan con 'sub-'
                        region.remove();
                    }
                });
            }
        }

        /** A√±ade una regi√≥n a WaveSurfer para un subt√≠tulo espec√≠fico. */
        function addSubtitleRegion(entry) {
            // No a√±ade regi√≥n si no hay plugin, los tiempos no son v√°lidos o la duraci√≥n es cero o negativa
            if (!wsRegions || entry.startTimeMs < 0 || entry.endTimeMs <= entry.startTimeMs) return;

            // Aseg√∫rate de que el ID es √∫nico y estable
            if (!entry.regionId) {
                 entry.regionId = `sub-${entry.index}-${Date.now()}`; // Genera ID si no existe
            }

            // Evita a√±adir regiones duplicadas
            if (wsRegions.getRegions().some(r => r.id === entry.regionId)) {
                return;
            }

            try {
                const region = wsRegions.addRegion({
                    id: entry.regionId,
                    start: entry.startTimeMs / 1000, // Convertir ms a segundos
                    end: entry.endTimeMs / 1000,   // Convertir ms a segundos
                    color: 'rgba(7, 91, 162, 0.3)',
                    drag: !isWaveformLocked,
                    resize: !isWaveformLocked,
                    attributes: { // A√±adir atributos para posible estilado o selecci√≥n
                        'data-subtitle-index': entry.index
                    }
                });

              // --- INICIO: NUEVO BLOQUE para el formato de 4 l√≠neas ---
                const content = document.createElement('div');
                content.className = 'region-content';

                // L√≠nea 1: N√∫mero de subt√≠tulo
                const line1 = `#${entry.index}`;

                // L√≠nea 2: Texto original (preview)
                const originalPreview = entry.original.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                const line2 = originalPreview.substring(0, 40) + (originalPreview.length > 40 ? '...' : '');

                // L√≠nea 3: Texto traducido (preview, o vac√≠o)
                let line3 = '';
                if (entry.translation) {
                    const translationPreview = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                    line3 = translationPreview.split('\n').join(' ').substring(0, 40) + (translationPreview.length > 40 ? '...' : '');
                }

                // L√≠nea 4: Estad√≠sticas de la traducci√≥n
                let line4 = '---'; // Placeholder si no hay traducci√≥n
                if (entry.translation) {
                    const translationTextClean = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                    const transLines = translationTextClean.split('\n');
                    const transL1 = transLines[0] ? countCharactersWithoutTags(transLines[0]) : 0;
                    const transL2 = transLines.length > 1 && transLines[1] ? countCharactersWithoutTags(transLines[1]) : 0;
                    const transCPS = calculateCPS(translationTextClean.replace(/\n/g, ''), entry.durationMs);
                    line4 = `CPS: ${transCPS} | L1: ${transL1}${transLines.length > 1 ? ` / L2: ${transL2}` : ''}`;
                }

                content.innerHTML = `
                    <div class="region-line region-line1">${line1}</div>
                    <div class="region-line region-line2">${line2}</div>
                    <div class="region-line region-line3">${line3}&nbsp;</div> <div class="region-line region-line4">${line4}</div>
                `;
                // --- FIN: NUEVO BLOQUE ---
                // Peque√±o timeout para asegurar que el elemento de la regi√≥n se ha renderizado en el DOM
                setTimeout(() => {
                    const regionEl = region?.element; // Usa optional chaining por si region no est√° definida
                    if (regionEl && !regionEl.querySelector('.region-content')) { // Verifica que no se haya a√±adido ya
                        regionEl.appendChild(content);
                    }
                }, 50); // Un peque√±o retardo podr√≠a ser necesario

            } catch (error) {
                console.error(`Error adding region for subtitle ${entry.index}:`, error, entry);
            }
        }

/** Actualiza una regi√≥n existente si sus tiempos cambian en el editor. */
        function updateRegionIfNeeded(entryIndex) {
            if (!wsRegions) return;
            const entry = srtEntries[entryIndex];
            const region = wsRegions.getRegions().find(r => r.id === entry.regionId);

            if (region) {
                const newStart = entry.startTimeMs / 1000;
                const newEnd = entry.endTimeMs / 1000;

                if ((Math.abs(region.start - newStart) > 0.001 || Math.abs(region.end - newEnd) > 0.001) && newEnd > newStart) {
                    region.setOptions({ start: newStart, end: newEnd });

                    // Actualizar el contenido de la regi√≥n tambi√©n (CON LA NUEVA L√ìGICA)
                    const content = region.element?.querySelector('.region-content');
                     if (content) {
                         // --- INICIO: NUEVO BLOQUE para el formato de 4 l√≠neas ---
                         // L√≠nea 1: N√∫mero de subt√≠tulo
                         const line1 = `#${entry.index}`;

                         // L√≠nea 2: Texto original (preview)
                         const originalPreview = entry.original.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                         const line2 = originalPreview.substring(0, 40) + (originalPreview.length > 40 ? '...' : '');

                         // L√≠nea 3: Texto traducido (preview, o vac√≠o)
                         let line3 = '';
                         if (entry.translation) {
                             const translationPreview = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                             line3 = translationPreview.split('\n').join(' ').substring(0, 40) + (translationPreview.length > 40 ? '...' : '');
                         }

                         // L√≠nea 4: Estad√≠sticas de la traducci√≥n
                         let line4 = '---'; // Placeholder si no hay traducci√≥n
                         if (entry.translation) {
                             const translationTextClean = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                             const transLines = translationTextClean.split('\n');
                             const transL1 = transLines[0] ? countCharactersWithoutTags(transLines[0]) : 0;
                             const transL2 = transLines.length > 1 && transLines[1] ? countCharactersWithoutTags(transLines[1]) : 0;
                             const transCPS = calculateCPS(translationTextClean.replace(/\n/g, ''), entry.durationMs);
                             line4 = `CPS: ${transCPS} | L1: ${transL1}${transLines.length > 1 ? ` / L2: ${transL2}` : ''}`;
                         }

                         content.innerHTML = `
                             <div class="region-line region-line1">${line1}</div>
                             <div class="region-line region-line2">${line2}</div>
                             <div class="region-line region-line3">${line3}&nbsp;</div> <div class="region-line region-line4">${line4}</div>
                         `;
                         // --- FIN: NUEVO BLOQUE ---
                     }
                } else if (newEnd <= newStart) {
                    region.remove();
                }
            } else if (entry.endTimeMs > entry.startTimeMs) {
                addSubtitleRegion(entry);
            }
        }

   // --- Funciones para Edici√≥n de Tiempos ---

        /**
         * Actualiza todos los datos y la interfaz de un subt√≠tulo cuando su tiempo cambia.
         * @param {number} entryIndex - El √≠ndice del subt√≠tulo a actualizar.
         */
        function updateEntryTimes(entryIndex) {
            const entry = srtEntries[entryIndex];

            // 1. Validar que el tiempo de fin no sea anterior al de inicio
            if (entry.endTimeMs < entry.startTimeMs) {
                entry.endTimeMs = entry.startTimeMs + 1; // Asegurar una duraci√≥n m√≠nima
            }

            // 2. Recalcular la duraci√≥n
            entry.durationMs = entry.endTimeMs - entry.startTimeMs;

            // 3. Formatear las nuevas cadenas de tiempo
            let newStartTimeStr, newEndTimeStr;
if (useFrameTimecode) {
    newStartTimeStr = formatFrameTime(entry.startTimeMs, projectFPS);
    newEndTimeStr = formatFrameTime(entry.endTimeMs, projectFPS);
} else {
    newStartTimeStr = formatTime(entry.startTimeMs);
    newEndTimeStr = formatTime(entry.endTimeMs);
}

            // 4. Actualizar los elementos de la interfaz
            document.getElementById(`startTime-${entryIndex}`).value = newStartTimeStr;
            document.getElementById(`endTime-${entryIndex}`).value = newEndTimeStr;
            document.getElementById(`duration-${entryIndex}`).textContent = (entry.durationMs / 1000).toFixed(3) + 's';

            // 5. Recalcular y actualizar las estad√≠sticas (CPS, etc.)
            const translationEditor = document.getElementById(`translation-${entryIndex}`);
            if (translationEditor) {
                updateSubtitleStats(translationEditor, entry.charCountOriginal, entry.durationMs);
            }
updateRegionIfNeeded(entryIndex);
        }

        /**
         * Maneja el cambio manual de un c√≥digo de tiempo en un campo de input.
         * @param {number} entryIndex - El √≠ndice del subt√≠tulo.
         * @param {boolean} isStartTime - True si es el campo de inicio, false si es el de fin.
         * @param {HTMLInputElement} inputElement - El propio campo de input.
         */
        function handleTimecodeChange(entryIndex, isStartTime, inputElement) {
    let newTimeMs;
    try {
        if (useFrameTimecode) {
            newTimeMs = parseFrameTime(inputElement.value, projectFPS);
        } else {
            newTimeMs = parseTime(inputElement.value);
        }
        const entry = srtEntries[entryIndex];

// --- INICIO: Guardar historial de tiempo ---
                const oldTimes = { startTimeMs: entry.startTimeMs, endTimeMs: entry.endTimeMs };
                const newTimes = { ...oldTimes };
                if (isStartTime) {
                    newTimes.startTimeMs = newTimeMs;
                } else {
                    newTimes.endTimeMs = newTimeMs;
                }
                saveTimeChange(entryIndex, oldTimes, newTimes);
                // --- FIN: Guardar historial de tiempo ---
                
                if (isStartTime) {
                    entry.startTimeMs = newTimeMs;
                } else {
                    entry.endTimeMs = newTimeMs;
                }
                
                updateEntryTimes(entryIndex);
           } catch (error) {
                // Si el formato es inv√°lido, revertir al valor anterior
                console.error("Formato de tiempo inv√°lido:", error);
                
                // --- INICIO DE LA VERSI√ìN CORREGIDA ---
                const entry = srtEntries[entryIndex]; // Se declara solo UNA VEZ
                let oldTimeStr;
                
                if (useFrameTimecode) {
                    // Si estamos en modo frames, generamos el string de frames
                    oldTimeStr = isStartTime ? formatFrameTime(entry.startTimeMs, projectFPS) : formatFrameTime(entry.endTimeMs, projectFPS);
                } else {
                    // Si estamos en modo ms, usamos la l√≥gica original
                    const [startTime, endTime] = entry.timecodes.split(' --> ');
                    oldTimeStr = isStartTime ? startTime : endTime;
                }
                
                inputElement.value = oldTimeStr; // Revertimos al valor correcto
                
                // L√≥gica para mostrar el mensaje de error (esto ya lo ten√≠as bien)
                const errorKey = useFrameTimecode ? 'timecode_format_error' : 'time_format_error'; 
                const errorMsg = translations[currentLanguage][errorKey] || "Formato de tiempo inv√°lido.";
                showMessage(errorMsg);
                // --- FIN DE LA VERSI√ìN CORREGIDA ---
            }
        }

        /**
         * Ajusta el tiempo de entrada o salida en un fotograma (40ms).
         * @param {number} entryIndex - El √≠ndice del subt√≠tulo.
         * @param {boolean} isStartTime - True si se ajusta el inicio, false si es el fin.
         * @param {number} direction - 1 para a√±adir tiempo, -1 para restar.
         */
        function nudgeTimecode(entryIndex, isStartTime, direction) {
            const entry = srtEntries[entryIndex];
const frameDurationMs = Math.round(1000 / projectFPS); // Duraci√≥n de 1 frame

// --- INICIO: Guardar historial de tiempo ---
            const oldTimes = { startTimeMs: entry.startTimeMs, endTimeMs: entry.endTimeMs };
            const newTimes = { ...oldTimes };
            if (isStartTime) {
                newTimes.startTimeMs = oldTimes.startTimeMs + (direction * frameDurationMs);
            } else {
                newTimes.endTimeMs = oldTimes.endTimeMs + (direction * frameDurationMs);
            }
            saveTimeChange(entryIndex, oldTimes, newTimes);
            // --- FIN: Guardar historial de tiempo ---

            if (isStartTime) {
                entry.startTimeMs += direction * frameDurationMs;
            } else {
                entry.endTimeMs += direction * frameDurationMs;
            }

            updateEntryTimes(entryIndex);
        }

        /**
         * Avanza o retrocede el v√≠deo en un fotograma (40ms).
         * @param {number} direction - 1 para avanzar, -1 para retroceder.
         */
        function nudgeVideo(direction) {
            if (videoPlayer && videoPlayer.src) {
                const frameDurationSeconds = 0.040;
                videoPlayer.currentTime += direction * frameDurationSeconds;
            }
        }

/**
         * Reproduce el subt√≠tulo actual en un bucle un n√∫mero configurable de veces.
         * @param {number} entryIndex - El √≠ndice del subt√≠tulo a reproducir.
         */
        function playSubtitleLoop(entryIndex) {
            if (!srtEntries[entryIndex] || !videoPlayer.src) return;

            const entry = srtEntries[entryIndex];
            const loopCount = shortcuts.playSegmentLoop.loopCount || 3;
            let currentLoop = 0;
            
            // Si ya hay un bucle en ejecuci√≥n, lo cancelamos para empezar uno nuevo
            if (window.loopListener) {
                videoPlayer.removeEventListener('timeupdate', window.loopListener);
            }

            const playSegment = () => {
                if (currentLoop >= loopCount) {
                    videoPlayer.pause();
                    videoPlayer.removeEventListener('timeupdate', window.loopListener);
                    window.loopListener = null;
                    return;
                }
                
                currentLoop++;
                videoPlayer.currentTime = entry.startTimeMs / 1000;
                videoPlayer.play();
            };

            window.loopListener = () => {
                // Dejamos un peque√±o margen para asegurar que no se salte el bucle
                if (videoPlayer.currentTime >= (entry.endTimeMs / 1000) - 0.1) {
                    playSegment();
                }
            };
            
            videoPlayer.addEventListener('timeupdate', window.loopListener);
            playSegment(); // Inicia el primer ciclo
        }

        /**
         * Actualiza el contador de bucles en el objeto de atajos y lo guarda.
         * @param {string} value - El nuevo valor del campo de entrada.
         */
        function updateLoopCount(value) {
            const count = parseInt(value, 10);
            if (count > 0) {
                shortcuts.playSegmentLoop.loopCount = count;
                saveShortcuts();
            }
        }

/**
 * Inserta la sugerencia de la IA en el editor del subt√≠tulo activo.
 * @param {number} entryIndex - El √≠ndice del subt√≠tulo.
 */
function insertAiSuggestion(entryIndex, suggestionType) {
    const entry = srtEntries[entryIndex];
    const editor = document.getElementById(`translation-${entryIndex}`);

    if (entry && entry.context && entry.context.ai_suggestions && editor) {
        const textToInsert = entry.context.ai_suggestions[suggestionType];
        if (textToInsert) {
            // Reemplazamos los saltos de l√≠nea \n del JSON por <br> para el editor HTML
            editor.innerHTML = textToInsert.replace(/\n/g, '<br>');
            // Disparamos el evento 'input' para que las estad√≠sticas se actualicen
            editor.dispatchEvent(new Event('input', { bubbles: true }));
        }
    }
}

function processAndApplyContext(parsedContext) {
    if (!Array.isArray(parsedContext)) {
        throw new Error("El JSON no es un array v√°lido.");
    }

    srtEntries.forEach(entry => delete entry.context); // Limpia contexto anterior

    let appliedCount = 0;
    parsedContext.forEach(ctx => {
        if (typeof ctx.index !== 'undefined' && ctx.ai_suggestions && ctx.context_notes) {
            const entry = srtEntries.find(e => e.index === ctx.index);
            if (entry) {
                entry.context = ctx;
                appliedCount++;
            }
        }
    });

    if (appliedCount > 0) {
        showMessage(`Contexto cargado y aplicado a ${appliedCount} subt√≠tulos.`);
        const currentFocused = getCurrentFocusedIndex() || { entryIndex: 0 };
        updateContextPanel(currentFocused.entryIndex);
    } else {
        throw new Error("El formato del JSON es correcto, pero ning√∫n √≠ndice coincidi√≥ con los subt√≠tulos actuales.");
    }
}

function preTranslateAll() {
    let pretranslatedCount = 0;
    srtEntries.forEach(entry => {
        if (entry.context && entry.context.ai_suggestions && entry.context.ai_suggestions.primary) {
            if (!entry.translation.trim()) {
                entry.translation = entry.context.ai_suggestions.primary.replace(/\n/g, '<br>');
                pretranslatedCount++;
            }
        }
    });

    if (pretranslatedCount > 0) {
        renderTranslations(srtEntries, 0, true);
        showMessage(`${pretranslatedCount} subt√≠tulos han sido pretraducidos.`);
    } else {
        showMessage("No se encontraron sugerencias para pretraducir o los campos ya estaban rellenos.");
    }
}

function resetContext() {
    // Borra los datos de contexto de todos los subt√≠tulos
    srtEntries.forEach(entry => delete entry.context);

    // Llama a updateContextPanel. Como ya no hay datos, mostrar√° la vista de importaci√≥n.
    const currentFocused = getCurrentFocusedIndex() || { entryIndex: 0 };
    updateContextPanel(currentFocused.entryIndex);
}


  function reconstructOriginalSrt(entries) {
            let srtContent = '';
            entries.forEach(entry => {
                srtContent += `${entry.index}\n`;
                srtContent += `${entry.timecodes}\n`;
                srtContent += `${entry.original}\n\n`;
            });
            return srtContent.trim();
        }

       


// Variable para guardar las instrucciones personalizadas del usuario
let aiCustomInstructions = { instruction1: "", instruction2: "", instruction3: "" };


/**
 * Guarda las instrucciones personalizadas de la IA en localStorage.
 */
function saveAiCustomInstructions() {
    localStorage.setItem('aiCustomInstructions', JSON.stringify(aiCustomInstructions));
}

/**
 * Carga las instrucciones personalizadas de la IA desde localStorage.
 */
function loadAiCustomInstructions() {
    const saved = localStorage.getItem('aiCustomInstructions');
    const defaultInstruction = translations[currentLanguage]['ai_default_instruction_1']
        .replace('{0}', qaSettings.charsPerLineLimit)
        .replace('{1}', qaSettings.cpsLimit);

    if (saved) {
        aiCustomInstructions = JSON.parse(saved);
    }
    // Si no hay instrucci√≥n 1 guardada, aplicamos la din√°mica por defecto.
    if (!aiCustomInstructions.instruction1) {
        aiCustomInstructions.instruction1 = defaultInstruction;
    }
}

/**
 * Copia el prompt de la IA al portapapeles, incluyendo el SRT actual y las instrucciones personalizadas.
 */
function copyAIPrompt() {
    if (srtEntries.length === 0) {
        showMessage(translations[currentLanguage]['load_srt_first']);
        return;
    }

    // 1. Construimos din√°micamente la lista de claves y el ejemplo para el prompt.
    let suggestionKeys = `        * '"primary"': "${aiCustomInstructions.instruction1 || 'Una traducci√≥n literal y fiel al original.'}"\n`;
    let exampleKeys = `        "primary": "Traducci√≥n generada seg√∫n la instrucci√≥n 1."\n`;

    if (aiCustomInstructions.instruction2) {
        suggestionKeys += `        * '"secondary"': "${aiCustomInstructions.instruction2}"\n`;
        exampleKeys += `        "secondary": "Traducci√≥n generada seg√∫n la instrucci√≥n 2."\n`;
    }
    if (aiCustomInstructions.instruction3) {
        const instruction3_full = `${aiCustomInstructions.instruction3}, y adem√°s debe cumplir ESTRICTAMENTE las pautas t√©cnicas (m√°x. ${qaSettings.charsPerLineLimit} caracteres por l√≠nea, CPS < ${qaSettings.cpsLimit}).`;
        suggestionKeys += `        * '"tertiary"': "${instruction3_full}"\n`;
        exampleKeys += `        "tertiary": "Traducci√≥n generada seg√∫n la instrucci√≥n 3."\n`;
    }

    // 2. Construimos el prompt final usando las piezas din√°micas.
    const finalPrompt = `Act as an expert audiovisual translation assistant for subtitling. I will provide you with the content of an SRT file.

Your sole output must be a code file in JSON format, with no explanations before or after the code block.

The JSON must be an array of objects. Each object must correspond to a subtitle and have the following exact structure:

1.  A key '"index"' (number).
2.  A key '"ai_suggestions"' (object). Inside this object, there should ONLY be the following keys, each with a translation that follows its specific instruction:
${suggestionKeys}
3.  A key '"context_notes"' (text). Here you should explain idioms, cultural references, etc.

**Example of the required structure for one object:**
{
  "index": 1,
  "ai_suggestions": {
${exampleKeys}
  },
  "context_notes": "<b>Explanation:</b> Notes and link here."
}

Now, analyze the following SRT content and generate the complete JSON:

[SRT_CONTENT_PLACEHOLDER]`;

    const srtContent = reconstructOriginalSrt(srtEntries);
    const fullPrompt = finalPrompt.replace('[SRT_CONTENT_PLACEHOLDER]', srtContent);

    navigator.clipboard.writeText(fullPrompt).then(() => {
        showMessage(translations[currentLanguage]['prompt_copied_success']);
    }).catch(err => {
        console.error('Error al copiar el prompt: ', err);
    });
}
        /**
         * Pega el contenido del portapapeles en el √°rea de texto del contexto.
         */
        async function pasteJsonFromClipboard() {
            try {
                const text = await navigator.clipboard.readText();
                const contextPasteArea = document.getElementById('contextPasteArea');
                contextPasteArea.value = text;
                // Disparamos el evento 'input' para que se active la validaci√≥n
                contextPasteArea.dispatchEvent(new Event('input', { bubbles: true }));
            } catch (err) {
                console.error('Error al pegar desde el portapapeles: ', err);
                showMessage(translations[currentLanguage]['clipboard_paste_error']);
            }
        }

        /**
         * Valida en tiempo real el contenido del √°rea de texto JSON.
         */
        function validateJsonInTextarea() {
            const textarea = document.getElementById('contextPasteArea');
            const statusDiv = document.getElementById('jsonValidationStatus');
            const text = textarea.value.trim();
            const t = translations[currentLanguage];

            if (!text) {
                statusDiv.innerHTML = '';
                return;
            }

            try {
                JSON.parse(text);
                statusDiv.innerHTML = `
                    <span class="flex items-center text-green-600">
                        <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>
                        ${t['json_valid']}
                    </span>`;
            } catch (error) {
                statusDiv.innerHTML = `
                    <span class="flex items-center text-red-600">
                        <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>
                        ${t['json_invalid']}
                    </span>`;
            }
        }

function updateContextPanel(entryIndex) {
    const contextImportView = document.getElementById('contextImportView');
    const contextDisplayView = document.getElementById('contextDisplayView');
    const t = translations[currentLanguage]; // Clave: obtiene las traducciones del idioma actual

    if (srtEntries.some(e => e.context)) {
        contextImportView.classList.add('hidden');
        contextDisplayView.classList.remove('hidden');

        const entry = srtEntries[entryIndex];
        // CORRECCI√ìN: Se usan las claves de traducci√≥n (ej: t['context_notes_title'])
        let contentHTML = `
            <div class="flex justify-between items-center mb-4 pb-2 border-b">
                <h4 class="font-bold text-md">${t['context_notes_title']}</h4>
                <div class="flex items-center gap-2">
                    <button class="btn btn-primary text-xs" onclick="preTranslateAll()" title="${t['pretranslate_all_title']}">${t['pretranslate_all_btn']}</button>
                    <button class="btn btn-secondary text-xs" onclick="resetContext()" data-i18n="reset_context">${t['reset_context']}</button>
                </div>
            </div>`;

        if (entry && entry.context) {
            const suggestions = entry.context.ai_suggestions;
            
            contentHTML += `<div class="space-y-3 mb-4">`;

            const getStatsString = (text, duration) => {
                if (!text) return '';
                const lines = text.split('\n');
                const line1Length = lines[0] ? countCharactersWithoutTags(lines[0]) : 0;
                const line2Length = lines.length > 1 && lines[1] ? countCharactersWithoutTags(lines[1]) : 0;
                const textForCps = text.replace(/\n/g, '');
                const cps = calculateCPS(textForCps, duration);
                return `(L1: ${line1Length} | L2: ${line2Length} | CPS: ${cps})`;
            };

            const createSuggestionHTML = (suggestionKey, titleKey) => {
                const text = suggestions[suggestionKey];
                if (!text) return '';
                
                const stats = getStatsString(text, entry.durationMs);
                // CORRECCI√ìN: El t√≠tulo tambi√©n se obtiene de las traducciones (t[titleKey])
                return `
                    <div>
                        <div class="flex justify-between items-center text-sm font-semibold">
                            <span>${t[titleKey]} <span class="font-mono text-gray-500 ml-2">${stats}</span></span>
                            <button class="btn btn-secondary p-1" title="Insertar sugerencia" onclick="insertAiSuggestion(${entryIndex}, '${suggestionKey}')">
                                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"></path></svg>
                            </button>
                        </div>
                        <p class="bg-gray-100 p-2 rounded-md italic text-sm mt-1">"${text.replace(/\n/g, '<br>')}"</p>
                    </div>`;
            };
            
            // CORRECCI√ìN: Se pasan las claves de traducci√≥n en lugar de texto fijo
            contentHTML += createSuggestionHTML('primary', 'instruction_1');
            contentHTML += createSuggestionHTML('secondary', 'instruction_2');
            contentHTML += createSuggestionHTML('tertiary', 'instruction_3');
            
            contentHTML += `</div>`;
            
            const urlRegex = /(https?:\/\/[^\s<]+)/g;
            const formattedNotes = entry.context.context_notes.replace(urlRegex, '<a href="$1" target="_blank" class="text-blue-600 hover:underline">$1</a>');
            contentHTML += `
                <div class="border-t pt-2">
                    <div class="prose prose-sm max-w-none">${formattedNotes}</div>
                </div>`;

        } else {
            contentHTML += `<p class="text-gray-500">${t['no_context_available']}</p>`;
        }
        contextDisplayView.innerHTML = contentHTML;

    } else {
        contextImportView.classList.remove('hidden');
        contextDisplayView.classList.add('hidden');
    }
}


        /**
         * Adjusts the height of a textarea to fit its content.
         * If the translation textarea is empty, it matches the height of the original textarea.
         * @param {HTMLTextAreaElement} textarea The textarea element (translation).
         * @param {HTMLElement} [originalElement] The original element (original text pre) for height comparison.
         */
        function autoResizeTextarea(textarea, originalElement) {
            textarea.style.height = 'auto';
            if (textarea.innerHTML.trim() === '' && originalElement) {
                // If textarea is empty, set its height to match the original element's scroll height
                textarea.style.height = originalElement.scrollHeight + 'px';
            } else {
                // Otherwise, let it expand to its own content
                textarea.style.height = textarea.scrollHeight + 'px';
            }
        }

        /**
         * Updates the character count and CPS for a specific textarea, including QA checks.
         * @param {HTMLElement} editorDiv The contenteditable div element.
         * @param {number} originalLength The length of the original string segment.
         * @param {number} durationMs The duration of the subtitle in milliseconds.
         */
        function updateSubtitleStats(editorDiv, originalLength, durationMs) {
            const entryIndex = parseInt(editorDiv.dataset.entryIndex);
            const charCountSpan = document.getElementById(`charCount-${entryIndex}`);
            const cpsSpan = document.getElementById(`cps-${entryIndex}`);
            const lineCharCountsDiv = document.getElementById(`lineCharCounts-${entryIndex}`);
            const translationLength = countCharactersWithoutTags(editorDiv.innerHTML);
            const t = translations[currentLanguage];

            if (charCountSpan) {
                charCountSpan.textContent = `${t.char_count_original}${originalLength}${t.char_units} | ${t.char_count_translation}${translationLength}${t.char_units}`;
            }
            
            if (cpsSpan) {
                const currentCPS = calculateCPS(editorDiv.innerHTML, durationMs);
                cpsSpan.textContent = `${currentCPS}${t.cps}`;
                // QA Check for CPS
                if (currentCPS > qaSettings.cpsLimit) {
                    cpsSpan.classList.add('qa-error');
                } else {
                    cpsSpan.classList.remove('qa-error');
                }
            }

            if (lineCharCountsDiv) {
                const lines = editorDiv.innerText.split('\n');
                lineCharCountsDiv.innerHTML = ''; // Clear previous counts
                lines.forEach((line, i) => {
                    const lineLength = countCharactersWithoutTags(line);
                    const lineSpan = document.createElement('span');
                    lineSpan.textContent = `L${i + 1}: ${lineLength}`;
                    // QA Check for chars per line
                    if (lineLength > qaSettings.charsPerLineLimit) {
                        lineSpan.classList.add('qa-error');
                    }
                    if (i > 0) lineCharCountsDiv.append(document.createTextNode(', '));
                    lineCharCountsDiv.appendChild(lineSpan);
                });
            }
// --- INICIO: L√ìGICA DE LA BARRA DE PROGRESO CPS ---
            const currentCPS = calculateCPS(editorDiv.innerHTML, durationMs);
            const cpsLimit = qaSettings.cpsLimit;
            
            // 1. Calcula el 'porcentaje de llenado' en relaci√≥n con el l√≠mite
            const fillPercentage = (currentCPS / (cpsLimit * 1.5)) * 100; // Multiplica por 1.5 para que el 100% no sature la barra
            
            // 2. Calcula la posici√≥n del l√≠mite (ej. 20 CPS)
            const limitPosition = (cpsLimit / (cpsLimit * 1.5)) * 100;

            const barFill = document.getElementById(`cpsBarFill-${entryIndex}`);
            const barLimit = document.getElementById(`cpsBarLimit-${entryIndex}`);
            
            if (barFill && barLimit) {
                // Posiciona el l√≠mite
                barLimit.style.left = `${Math.min(limitPosition, 100)}%`;
                
                // Actualiza el relleno
                barFill.style.width = `${Math.min(fillPercentage, 100)}%`;
                
                // Asigna color (Verde si est√° por debajo, Rojo si est√° por encima)
                if (currentCPS > cpsLimit) {
                    barFill.style.backgroundColor = '#ef4444'; // Rojo (utilizando un color Tailwind predefinido)
                } else {
                    barFill.style.backgroundColor = '#22c55e'; // Verde
                }
            }
            // --- FIN: L√ìGICA DE LA BARRA DE PROGRESO CPS ---
        }

        /**
         * Configures the editable state of a translation entry (editable/read-only).
         * @param {number} entryIndex The index of the SRT entry.
         * @param {boolean} isEditable True to make it editable, false for read-only.
         */
        function setTranslationEditableState(entryIndex, isEditable) {
            const translationEditor = document.getElementById(`translation-${entryIndex}`);
            const validateButton = document.getElementById(`validateBtn-${entryIndex}`);
            const editButton = document.getElementById(`editBtn-${entryIndex}`);
            const checkIcon = document.getElementById(`checkIcon-${entryIndex}`);
            const translationUnit = document.getElementById(`translation-unit-${entryIndex}`); // Get the parent unit

            if (!translationEditor || !validateButton || !editButton || !checkIcon || !translationUnit) {
                console.error(`Elements not found for index ${entryIndex}`);
                return;
            }

            translationEditor.contentEditable = isEditable;
            if (!isEditable) {
                translationUnit.classList.remove('translation-unit-active'); // Remove active highlight on validate

                // Update translation status and words when segment is validated
                const entry = srtEntries[entryIndex];
                entry.isTranslated = translationEditor.innerText.trim() !== '';
                entry.wordCountTranslation = countWords(translationEditor.innerText);
                entry.charCountTranslation = countCharactersWithoutTags(translationEditor.innerHTML);
                entry.cpsTranslation = calculateCPS(translationEditor.innerHTML, entry.durationMs);

                updateStatsDisplay(); // Update stats
                addOrUpdateTMEntry(entry.original, entry.translation); // Add/Update TM
            } else {
                translationUnit.classList.add('translation-unit-active'); // Add active highlight on edit/focus
            }

            validateButton.style.display = isEditable ? 'inline-block' : 'none';
            editButton.style.display = isEditable ? 'none' : 'inline-block';
            checkIcon.style.display = isEditable ? 'none' : 'inline-block';

            if (isEditable) {
                translationEditor.focus();
            }
        }

        /**
         * Applies a style command (like 'bold' or 'italic') to the current selection.
         * @param {string} command The command to execute.
         */
        function formatText(command) {
            document.execCommand(command, false, null);
        }

        /**
         * Applies glossary term highlighting to a given text segment.
         * Collects terms that were successfully highlighted.
         * @param {string} text The original text to highlight.
         * @returns {{html: string, foundTerms: Set<string>}} Object with HTML string and set of found terms.
         */
        function applyGlossaryHighlightToText(text) {
            let highlightedHtml = text;
            const currentFoundTerms = new Set(); // Terms found in *this specific* segment

            if (!glossarySourceLanguage) {
                return { html: text, foundTerms: currentFoundTerms };
            }

            const sortedGlossary = [...glossary].sort((a, b) => b.srcTerm.length - a.srcTerm.length);

            sortedGlossary.forEach(glossaryEntry => {
                if (glossarySourceLanguage && glossaryEntry.srcTerm) {
                    const term = glossaryEntry.srcTerm;
                    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b(${escapedTerm})\\b`, 'gi'); 

                    if (highlightedHtml.match(regex)) {
                        highlightedHtml = highlightedHtml.replace(regex, (match, p1) => {
                            currentFoundTerms.add(term);
                            return `<span class="glossary-highlight">${p1}</span>`;
                        });
                    }
                }
            });
            return { html: highlightedHtml, foundTerms: currentFoundTerms };
        }

        /**
         * Updates highlighting in the glossary table based on terms found in the editor.
         */
        function updateGlossaryTableHighlights() {
            renderGlossary();
        }

function dismissLineBreakTooltip(event) {
            event.stopPropagation(); // Evita que otros clics se disparen
            localStorage.setItem('lineBreakTooltipDismissed', 'true');
            const tooltips = document.querySelectorAll('.line-break-tooltip');
            tooltips.forEach(tooltip => {
                tooltip.style.display = 'none'; // Oculta todas las instancias inmediatamente
            });
        }

function renderTranslations(entries, activeIndexToPreserve = null, preserveScroll = false) {
            translationsContainer.innerHTML = '';
            termsFoundInActiveSegment.clear();
           const t = translations[currentLanguage];
            const tooltipDismissed = localStorage.getItem('lineBreakTooltipDismissed') === 'true';
            let lineBreakTooltipHTML = '';
            if (!tooltipDismissed) {
                lineBreakTooltipHTML = `
                    <div class="line-break-tooltip relative flex items-center bg-blue-100 border border-blue-300 text-blue-800 text-xs px-2 py-1 rounded-md mr-2">
                        <span data-i18n="linebreak_tooltip_text">${t.linebreak_tooltip_text}</span>
                        <button onclick="dismissLineBreakTooltip(event)" class="ml-2 text-blue-800 hover:text-blue-900 font-bold text-lg leading-none">&times;</button>
                    </div>
                `;
            }

clearSubtitleRegions();            

if (entries.length === 0) {
                translationsContainer.innerHTML = `<div data-i18n="no_translations" id="initialMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md">${t.no_translations}</div>`;
                saveSrtButton.disabled = true;
                saveProjectBtn.disabled = true;
                statsContainer.classList.add('hidden');
                return;
            }

            entries.forEach((entry, entryIndex) => {
                const translationUnit = document.createElement('div');
                translationUnit.id = `translation-unit-${entryIndex}`;
                translationUnit.className = 'translation-unit-bg p-2 rounded-lg shadow-sm border border-gray-200 mb-4';

                let startTime, endTime;
if (useFrameTimecode) {
    startTime = formatFrameTime(entry.startTimeMs, projectFPS);
    endTime = formatFrameTime(entry.endTimeMs, projectFPS);
} else {
    [startTime, endTime] = entry.timecodes.split(' --> ');
}
                const durationInSeconds = (entry.durationMs / 1000).toFixed(3);

                translationUnit.innerHTML = `
                    <div class="text-md font-bold mb-2">${entry.index}</div>
                    
                    <div class="flex flex-wrap items-center justify-between gap-x-4 gap-y-2 mb-3">
                        
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium" data-i18n="entry_time">${t.entry_time}</label>
                            <div class="flex items-center">
                                <input type="text" id="startTime-${entryIndex}" value="${startTime}" onchange="handleTimecodeChange(${entryIndex}, true, this)" class="w-32 p-1 rounded-md border-2 border-gray-100 shadow-sm text-sm">
                                <div class="flex items-center gap-1 ml-2">
                                    <button class="btn btn-secondary p-1" onclick="nudgeTimecode(${entryIndex}, true, 1)">
                                        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd"></path></svg>
                                    </button>
                                    <button class="btn btn-secondary p-1" onclick="nudgeTimecode(${entryIndex}, true, -1)">
                                        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
                                    </button>
                                </div>
                                </div>
                        </div>

                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium" data-i18n="exit_time">${t.exit_time}</label>
                            <div class="flex items-center">
                                <input type="text" id="endTime-${entryIndex}" value="${endTime}" onchange="handleTimecodeChange(${entryIndex}, false, this)" class="w-32 p-1 rounded-md border-2 border-gray-100 shadow-sm text-sm">
                                <div class="flex items-center gap-1 ml-2">
                                    <button class="btn btn-secondary p-1" onclick="nudgeTimecode(${entryIndex}, false, 1)">
                                        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd"></path></svg>
                                    </button>
                                    <button class="btn btn-secondary p-1" onclick="nudgeTimecode(${entryIndex}, false, -1)">
                                        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
                                    </button>
                                </div>
                                </div>
                        </div>

                        <div class="flex items-center gap-2 ml-auto">
                            <span class="text-sm font-semibold" title="Duraci√≥n del subt√≠tulo"><span data-i18n="duration_label">${t.duration_label}</span> <span id="duration-${entryIndex}">${durationInSeconds}s</span></span>
                            <div class="flex items-center gap-1">
                                <button class="btn btn-secondary p-1" onclick="nudgeVideo(-1)" title="${t.rewind_frame_tooltip}">
                                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M8.445 14.832A1 1 0 0010 14.002V5.998a1 1 0 00-1.555-.832L3.62 9.168a1 1 0 000 1.664l4.825 4.001zM14.445 14.832A1 1 0 0016 14.002V5.998a1 1 0 00-1.555-.832L9.62 9.168a1 1 0 000 1.664l4.825 4.001z"></path></svg>
                                </button>
                                <button class="btn btn-secondary p-1" onclick="jumpToCurrentSubtitleTime(${entryIndex})" title="${t.play_segment_tooltip}">
                                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8.002v3.996a1 1 0 001.555.832l3.223-1.998a1 1 0 000-1.664L9.555 7.168z" clip-rule="evenodd"></path></svg>
                                </button>
                                <button class="btn btn-secondary p-1" onclick="nudgeVideo(1)" title="${t.forward_frame_tooltip}">
                                   <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M5.555 5.168A1 1 0 004 5.998v8.004a1 1 0 001.555.832L10.38 10.832a1 1 0 000-1.664L5.555 5.168zM11.555 5.168A1 1 0 0010 5.998v8.004a1 1 0 001.555.832L16.38 10.832a1 1 0 000-1.664l-4.825-4.001z"></path></svg>
                                </button>
<div class="flex items-center gap-1 ml-2 border-l pl-2">
    <button class="btn btn-secondary p-0 w-12 h-6 flex items-center justify-center" onclick="mergeWithNext(${entryIndex})" title="${t.merge_next_tooltip}">
        ‚Üí ‚Üê
    </button>
    <button class="btn btn-secondary p-0 w-12 h-6 flex items-center justify-center" onclick="splitSubtitle(${entryIndex})" title="${t.split_tooltip}">
        ‚Üê ‚Üí
    </button>
    <button class="btn btn-secondary p-0 w-8 h-6 flex items-center justify-center" onclick="confirmDeleteSubtitle(${entryIndex})" title="${t.delete_tooltip}">
        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.75 1A2.75 2.75 0 006 3.75v.443c-.795.077-1.58.22-2.365.468a.75.75 0 10.23 1.482l.149-.022.841 10.518A2.75 2.75 0 007.596 19h4.807a2.75 2.75 0 002.742-2.53l.841-10.52.149.023a.75.75 0 00.23-1.482A41.03 41.03 0 0014 4.193v-.443A2.75 2.75 0 0011.25 1h-2.5zM10 4c.84 0 1.673.025 2.5.075V3.75c0-.69-.56-1.25-1.25-1.25h-2.5c-.69 0-1.25.56-1.25 1.25v.325C8.327 4.025 9.16 4 10 4zM8.58 7.72a.75.75 0 00-1.5.06l.3 7.5a.75.75 0 101.5-.06l-.3-7.5zm4.34.06a.75.75 0 10-1.5-.06l-.3 7.5a.75.75 0 101.5.06l.3-7.5z" clip-rule="evenodd" /></svg>
    </button>
</div>                </div>
                        </div>
                    </div>
                    
                    <div class="translation-row mb-2">
                        <div class="original-col">
                            <label class="block text-sm font-medium mb-1" data-i18n="original_text">${t.original_text}</label>
                            <pre id="original-pre-${entryIndex}" class="subtitle-display-code p-1 rounded-md text-base overflow-auto max-h-24">${entry.original}</pre>
                        </div>
                        <div class="translation-col">
                            <div class="flex justify-between items-center">
                                <label class="block text-sm font-medium" data-i18n="translation_text">${t.translation_text}</label>
                                <span id="glossary-match-${entryIndex}" class="hidden flex items-center gap-1 text-xs font-semibold text-black bg-yellow-300 px-2 py-0.5 rounded-md truncate"></span>
                            </div>
                            <div id="translation-${entryIndex}" class="subtitle-editor mt-1 block w-full focus:ring-blue-500 focus:border-blue-500 text-base" contenteditable="true" data-entry-index="${entryIndex}" data-original-length="${entry.charCountOriginal}" data-duration-ms="${entry.durationMs}">${entry.translation}</div>
<div id="cpsBarContainer-${entryIndex}" class="cps-bar-container">
                                <div id="cpsBarFill-${entryIndex}" class="cps-bar-fill"></div>
                                <div id="cpsBarLimit-${entryIndex}" class="cps-bar-limit-marker"></div>
                            </div>
                            </div>
                            </div>
                    </div>
                    <div class="flex items-center justify-end mt-1 w-full">
    <div class="flex items-center space-x-2">
        <div class="flex items-center text-sm font-semibold">
    <span id="charCount-${entryIndex}"></span>
    &nbsp;<span class="text-black">|</span>&nbsp;
    <span id="cps-${entryIndex}"></span>
    &nbsp;<span class="text-black">|</span>&nbsp;
    <div id="lineCharCounts-${entryIndex}"></div>
</div>
        ${lineBreakTooltipHTML}
                            <button class="btn btn-secondary text-xs p-1" onclick="formatText('bold')"><b class="font-bold">B</b></button>
                            <button class="btn btn-secondary text-xs p-1" onclick="formatText('italic')"><i class="italic">I</i></button>
                            <svg id="checkIcon-${entryIndex}" class="check-icon text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                            
                            <button title="${t.validate_all_previous_tooltip}" onclick="validateUpTo(${entryIndex})" class="btn btn-secondary text-xs" data-i18n="validate_all_previous">${t.validate_all_previous}</button>
                            <button id="validateBtn-${entryIndex}" class="btn btn-primary text-xs" data-entry-index="${entryIndex}" data-i18n="validate">${t.validate}</button>
                            <button id="editBtn-${entryIndex}" class="btn btn-secondary text-xs" data-entry-index="${entryIndex}" style="display: none;" data-i18n="edit">${t.edit}</button>
                        </div>
                    </div>
                `;
                
                const translationEditor = translationUnit.querySelector(`#translation-${entryIndex}`);
                const originalColPre = translationUnit.querySelector(`#original-pre-${entryIndex}`);
                const validateButton = translationUnit.querySelector(`#validateBtn-${entryIndex}`);
                const editButton = translationUnit.querySelector(`#editBtn-${entryIndex}`);
                const checkIcon = translationUnit.querySelector(`#checkIcon-${entryIndex}`);


                if (entry.isTranslated) {
                    translationEditor.contentEditable = false;
                    validateButton.style.display = 'none';
                    // Ocultamos tambi√©n el nuevo bot√≥n si el subt√≠tulo ya est√° validado
                    translationUnit.querySelector('[onclick^="validateUpTo"]').style.display = 'none';
                    editButton.style.display = 'inline-block';
                    checkIcon.style.display = 'inline-block';
                }

        // ‚úÖ INICIO DEL BLOQUE FINAL ‚úÖ

                let oldValue = entry.translation;

                translationEditor.addEventListener('input', (event) => {
                    if (isApplyingState) return;
                    clearTimeout(debounceTimeout);

                    const currentEntry = srtEntries[entryIndex];
                    currentEntry.translation = event.target.innerHTML;
                    currentEntry.wordCountTranslation = countWords(event.target.innerText);
                    currentEntry.charCountTranslation = countCharactersWithoutTags(event.target.innerHTML);
                    currentEntry.cpsTranslation = calculateCPS(event.target.innerHTML, currentEntry.durationMs);
                    autoResizeTextarea(event.target, originalColPre);
                    updateSubtitleStats(event.target, currentEntry.charCountOriginal, currentEntry.durationMs);
                    updateStatsDisplay();
                    updateSubtitlePreview();

// --- INICIO C√ìDIGO A√ëADIDO ---
                    // Actualizar el contenido de la regi√≥n en tiempo real
                    if (wsRegions) {
                        const region = wsRegions.getRegions().find(r => r.id === currentEntry.regionId);
                        if (region) {
                            const content = region.element?.querySelector('.region-content');
                            if (content) {
                                // Reutilizamos la l√≥gica para generar el contenido de 4 l√≠neas
                                const line1 = `#${currentEntry.index}`;
                                const originalPreview = currentEntry.original.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                                const line2 = originalPreview.substring(0, 40) + (originalPreview.length > 40 ? '...' : '');
                                let line3 = '';
                                if (currentEntry.translation) {
                                    const translationPreview = currentEntry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                                    line3 = translationPreview.split('\n').join(' ').substring(0, 40) + (translationPreview.length > 40 ? '...' : '');
                                }
                                let line4 = '---';
                                if (currentEntry.translation) {
                                     const translationTextClean = currentEntry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                                     const transLines = translationTextClean.split('\n');
                                     const transL1 = transLines[0] ? countCharactersWithoutTags(transLines[0]) : 0;
                                     const transL2 = transLines.length > 1 && transLines[1] ? countCharactersWithoutTags(transLines[1]) : 0;
                                     const transCPS = calculateCPS(translationTextClean.replace(/\n/g, ''), currentEntry.durationMs);
                                     line4 = `CPS: ${transCPS} | L1: ${transL1}${transLines.length > 1 ? ` / L2: ${transL2}` : ''}`;
                                }

                                content.innerHTML = `
                                    <div class="region-line region-line1">${line1}</div>
                                    <div class="region-line region-line2">${line2}</div>
                                    <div class="region-line region-line3">${line3}&nbsp;</div>
                                    <div class="region-line region-line4">${line4}</div>
                                `;
                            }
                        }
                    }
                    // --- FIN C√ìDIGO A√ëADIDO ---

                    debounceTimeout = setTimeout(() => {
                        const newValue = event.target.innerHTML;
                        saveState(entryIndex, oldValue, newValue);
                        oldValue = newValue;
                    }, 1000);
                });

translationEditor.addEventListener('keydown', (event) => {
                    if (event.isSimulated) {
                        return;
                    }

                    if (event.key === 'Enter') {
                        if (!event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey) {
                            Object.defineProperty(event, 'shiftKey', { get: () => true });
                            event.preventDefault();
                            setTimeout(() => {
                                moveToNextEditableCell(event.currentTarget);
                            }, 0);
                            return;
                        }
                    }

                    // --- Comprobaci√≥n de atajos de EDICI√ìN y NAVEGACI√ìN ---
                    const triggeredAction = Object.keys(shortcuts).find(action => {
                        const localActions = [
                            'validateAndNext', 'goToNext', 'goToPrevious', // Se a√±aden de nuevo aqu√≠
                            'insertTM1', 'insertTM2', 'insertTM3', 'insertTM4', 'insertTM5', 
                            'insertGloss1', 'insertGloss2', 'insertGloss3', 'insertGloss4', 'insertGloss5', 
                            'bold', 'italic',
                            'jumpToTime',
                            'playSegment',
                            'playSegmentLoop',
                            'playPause',
                            'seekForward',
                            'seekBackward',
                            'seekForwardFast',
                            'seekBackwardFast'
                            
                        ];
                        if (!localActions.includes(action)) return false;

                        const shortcut = shortcuts[action];
                        const keyMatch = (shortcut.key === ' ' && event.code === 'Space') || (shortcut.key.toLowerCase() === event.key.toLowerCase());
                        return keyMatch &&
                               shortcut.ctrlKey === event.ctrlKey &&
                               shortcut.metaKey === event.metaKey &&
                               shortcut.altKey === event.altKey &&
                               shortcut.shiftKey === event.shiftKey;
                    });

                    if (triggeredAction) {
                        event.preventDefault();
                        switch (triggeredAction) {
                            case 'validateAndNext':
    setTranslationEditableState(entryIndex, false);
    goToNextTranslation(entryIndex, true);
    break;
                            // Se a√±aden los casos de navegaci√≥n de nuevo
                            case 'goToNext':
                                goToNextTranslation(entryIndex);
                                break;
                            case 'goToPrevious':
                                goToPreviousTranslation(entryIndex);
                                break;
                            case 'bold':
                                formatText('bold');
                                break;
                            case 'italic':
                                formatText('italic');
                                break;
                            case 'jumpToTime':
                            case 'playSegment':
                                jumpToCurrentSubtitleTime(entryIndex);
                                break;
                            case 'playSegmentLoop':
                                playSubtitleLoop(entryIndex);
                                break;
                            case 'playPause':
                                if (videoPlayer.paused) videoPlayer.play();
                                else videoPlayer.pause();
                                break;
                            case 'seekForward':
                                videoPlayer.currentTime += 3;
                                break;
                            case 'seekBackward':
                                videoPlayer.currentTime -= 3;
                                break;
                            case 'seekForwardFast':
                                videoPlayer.currentTime += 5;
                                break;
                            case 'seekBackwardFast':
                                videoPlayer.currentTime -= 5;
                                break;
                            case 'insertTM1':
                                tmSearch(srtEntries[entryIndex].original); // <--- A√ëADIR ESTO
                                if (currentTMLatestSearchResults.length > 0) document.execCommand('insertHTML', false, currentTMLatestSearchResults[0].tgtText);
                                break;
                            case 'insertTM2':
                                tmSearch(srtEntries[entryIndex].original); // <--- A√ëADIR ESTO
                                if (currentTMLatestSearchResults.length > 1) document.execCommand('insertHTML', false, currentTMLatestSearchResults[1].tgtText);
                                break;
                            case 'insertTM3':
                                tmSearch(srtEntries[entryIndex].original); // <--- A√ëADIR ESTO
                                if (currentTMLatestSearchResults.length > 2) document.execCommand('insertHTML', false, currentTMLatestSearchResults[2].tgtText);
                                break;
                            case 'insertTM4':
                                tmSearch(srtEntries[entryIndex].original); // <--- A√ëADIR ESTO
                                if (currentTMLatestSearchResults.length > 3) document.execCommand('insertHTML', false, currentTMLatestSearchResults[3].tgtText);
                                break;
                            case 'insertTM5':
                                tmSearch(srtEntries[entryIndex].original); // <--- A√ëADIR ESTO
                                if (currentTMLatestSearchResults.length > 4) document.execCommand('insertHTML', false, currentTMLatestSearchResults[4].tgtText);
                                break;
                           
                            default:
                                // El if de 'insertTM' ya no es necesario aqu√≠, pero dejamos el de 'insertGloss'
                                if (triggeredAction.startsWith('insertGloss')) {
                                    const index = parseInt(triggeredAction.replace('insertGloss', '')) - 1;
                                    if (currentGlossaryLatestResults.length > index) {
                                        document.execCommand('insertHTML', false, currentGlossaryLatestResults[index].tgtTerm);
                                    }
                                }
                                break;
                        }
                        return;
                    }
                          
                    // --- L√≥gica para atajos de documentaci√≥n ---
                    const triggeredDocAction = shortcuts.docResources.find(res => {
                        if (!res.shortcut) return false;
                        const sc = res.shortcut;
                        const keyMatch = (sc.key === ' ' && event.code === 'Space') || (sc.key.toLowerCase() === event.key.toLowerCase());
                        return keyMatch &&
                               sc.ctrlKey === event.ctrlKey &&
                               sc.metaKey === event.metaKey &&
                               sc.altKey === event.altKey &&
                               sc.shiftKey === event.shiftKey;
                    });

                    if (triggeredDocAction) {
                        event.preventDefault();
                        const selectedText = window.getSelection().toString().trim();
                        const resourceUrl = triggeredDocAction.url;

                        if (selectedText && resourceUrl && resourceUrl.includes('{word}')) {
                            const finalUrl = resourceUrl.replace('{word}', encodeURIComponent(selectedText));
                            window.open(finalUrl, '_blank');
                        }
                    }
                });

                translationEditor.addEventListener('focus', (event) => {
                    oldValue = translationEditor.innerHTML;
                    document.querySelectorAll('.translation-unit-active').forEach(unit => unit.classList.remove('translation-unit-active'));
                    translationUnit.classList.add('translation-unit-active');
                    termsFoundInActiveSegment.clear();
                    if (glossarySourceLanguage && glossary.length > 0) {
                        const highlightResult = applyGlossaryHighlightToText(entry.original);
                        originalColPre.innerHTML = highlightResult.html;
                        highlightResult.foundTerms.forEach(term => termsFoundInActiveSegment.add(term));
                    }

                    const glossaryMatchContainer = document.getElementById(`glossary-match-${entryIndex}`);
                    glossaryMatchContainer.innerHTML = '';
                    glossaryMatchContainer.title = '';
                    glossaryMatchContainer.classList.add('hidden');

                    if (termsFoundInActiveSegment.size > 0) {
                        let hintText = '';
                        let fullHintText = '';

                        termsFoundInActiveSegment.forEach(foundTerm => {
                            const glossaryEntry = glossary.find(g => g.srcTerm === foundTerm);
                            if (glossaryEntry) {
                                const part = `${glossaryEntry.srcTerm} -> ${glossaryEntry.tgtTerm}`;
                                hintText += part + ' | ';
                                fullHintText += part + ' | ';
                            }
                        });

                        if (hintText) {
                            glossaryMatchContainer.innerHTML = `
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg>
                                <span>${hintText.slice(0, -3)}</span>
                            `;
                            glossaryMatchContainer.title = `Glosario: ${fullHintText.slice(0, -3)}`;
                            glossaryMatchContainer.classList.remove('hidden');
                        }
                    }
                    updateGlossaryTableHighlights();
                    autoResizeTextarea(event.target, originalColPre);
                    event.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    tmSearch(srtEntries[entryIndex].original);
                    updateContextPanel(entryIndex);
                });

                translationEditor.addEventListener('blur', () => {
                    originalColPre.textContent = entry.original;
                    termsFoundInActiveSegment.clear();
                    document.getElementById(`glossary-match-${entryIndex}`).classList.add('hidden');
                    document.getElementById(`glossary-match-${entryIndex}`).title = '';
                    updateGlossaryTableHighlights();
                    tmSearch();
                });
                
                // ‚úÖ FIN DEL BLOQUE FINAL ‚úÖ

                validateButton.addEventListener('click', () => {
                    setTranslationEditableState(entryIndex, false);
                    goToNextTranslation(entryIndex);
                });

                editButton.addEventListener('click', () => setTranslationEditableState(entryIndex, true));

                translationsContainer.appendChild(translationUnit);
                updateSubtitleStats(translationEditor, entry.charCountOriginal, entry.durationMs);
addSubtitleRegion(entry);
            });
            
            saveSrtButton.disabled = false;
            saveProjectBtn.disabled = false;
            statsContainer.classList.remove('hidden');
plannerContainer.classList.remove('hidden');
            updateStatsDisplay();
            setupIntersectionObserver();

            if (!preserveScroll) {
                if (activeIndexToPreserve !== null && activeIndexToPreserve < srtEntries.length) {
                    navigateToTranslation(activeIndexToPreserve);
                } else {
                    const firstEditableSegment = getFirstEditableSegment();
                    if (firstEditableSegment) {
                        navigateToTranslation(firstEditableSegment.entryIndex);
                    }
                }
            }
        }

 /**
         * Valida el subt√≠tulo actual y todos los anteriores que no est√©n ya validados.
         * @param {number} entryIndex - El √≠ndice del subt√≠tulo actual.
         */
        function validateUpTo(entryIndex) {
            showLoadingOverlay('Validando subt√≠tulos...'); // Muestra un mensaje de carga
            
            // Usamos un timeout para que la interfaz de carga se muestre antes de empezar el proceso
            setTimeout(() => {
                for (let i = 0; i <= entryIndex; i++) {
                    // Solo validamos si no est√° ya validado para ser m√°s eficientes
                    if (!srtEntries[i].isTranslated) {
                        setTranslationEditableState(i, false);
                    }
                }
                
                // Una vez terminado, salta al siguiente subt√≠tulo pendiente
                goToNextTranslation(entryIndex, false);
                hideLoadingOverlay(); // Oculta el mensaje de carga
            }, 50); // Un peque√±o retardo de 50ms es suficiente
        }


function updateTranslations() {
    // Primero, actualizamos la tabla del glosario para que muestre los nuevos t√©rminos.
    renderGlossary();

    // Luego, recorremos cada subt√≠tulo para ver si necesita una actualizaci√≥n visual.
    srtEntries.forEach((entry, entryIndex) => {
        const originalColPre = document.getElementById(`original-pre-${entryIndex}`);
        if (!originalColPre) return; // Si el subt√≠tulo no est√° en pantalla, no hacemos nada.

        // La principal raz√≥n para refrescar es aplicar el resaltado del nuevo
        // t√©rmino del glosario en el subt√≠tulo que est√© activo.
        if (lastActiveSubtitleIndex === entryIndex) {
            const highlightResult = applyGlossaryHighlightToText(entry.original);
            originalColPre.innerHTML = highlightResult.html;
        }
    });

    // Finalmente, actualizamos las estad√≠sticas generales (contador de palabras, etc.).
    updateStatsDisplay();
}


  /**
         * Updates the display of translation progress and word counts.
         */
        function updateStatsDisplay() {
            const t = translations[currentLanguage];
            let totalSegments = srtEntries.length;
            let translatedSegments = srtEntries.filter(e => e.isTranslated).length;
            let totalWordsOriginal = srtEntries.reduce((acc, e) => acc + e.wordCountOriginal, 0);
            let totalWordsTranslated = srtEntries.reduce((acc, e) => acc + e.wordCountTranslation, 0);

            const percentage = totalSegments > 0 ? ((translatedSegments / totalSegments) * 100).toFixed(0) : 0;
            
            segmentsProgress.textContent = t.segments_progress_text.replace('{0}', translatedSegments).replace('{1}', totalSegments).replace('{2}', percentage);
            wordsTranslated.textContent = t.words_translated_text.replace('{0}', totalWordsTranslated);
            wordsTotal.textContent = t.words_total_text.replace('{0}', totalWordsOriginal);
            wordsRemaining.textContent = t.words_remaining_text.replace('{0}', totalWordsOriginal - totalWordsTranslated);

            const qaErrors = calculateAllQaErrors();
            if (qaErrors.length > 0) {
                qaErrorStats.textContent = t.qa_errors_found.replace('{0}', qaErrors.length);
                qaErrorStats.className = 'qa-error clickable';
            } else {
                qaErrorStats.textContent = t.qa_no_errors;
                qaErrorStats.className = 'qa-success';
            }

const statusBar = document.getElementById('statusBar');
            if (statusBar) {
                // Obtenemos el texto de cada span
                const progressText = segmentsProgress.textContent;
                const translatedText = wordsTranslated.textContent;
                const totalText = wordsTotal.textContent;
                const remainingText = wordsRemaining.textContent;
                const qaText = qaErrorStats.textContent;
                const isQaClickable = qaErrorStats.classList.contains('clickable'); // Verificamos si hay errores

                // Determinamos las clases CSS para el texto QA
                const qaClasses = isQaClickable ? 'qa-error' : 'qa-success'; // Usa las clases existentes

                // Creamos el HTML para el texto QA
                let qaHtml = '';
                if (isQaClickable) {
                    // Si hay errores (clickable), usa un span con ID y clases
                    qaHtml = `<span id="statusBarQaLink" class="cursor-pointer underline ${qaClasses}">${qaText}</span>`;
                } else {
                    // Si no hay errores, usa un span solo con las clases de estilo
                    qaHtml = `<span class="${qaClasses}">${qaText}</span>`;
                }

                // Combinamos todo en el innerHTML, a√±adiendo el espacio antes de qaHtml
                statusBar.innerHTML = `${progressText} | ${translatedText} / ${totalText} | ${remainingText} |&nbsp; ${qaHtml}`; //

                // Si a√±adimos el span clickable, le a√±adimos el listener AHORA
                if (isQaClickable) {
                    const statusBarQaLink = document.getElementById('statusBarQaLink');
                    if (statusBarQaLink) {
                        statusBarQaLink.addEventListener('click', () => {
                            // Reutilizamos la l√≥gica del listener original de qaErrorStats
                            if (calculateAllQaErrors().length > 0) {
                                renderQaErrorList();
                                qaErrorListModal.classList.remove('hidden');
                            }
                        });
                    }
                }
            }
        }


        /**
         * Gets the index of the currently focused translation textarea.
         * @returns {{entryIndex: number} | null} The object with index, or null.
         */
        function getCurrentFocusedIndex() {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.classList.contains('subtitle-editor')) {
                return {
                    entryIndex: parseInt(activeElement.dataset.entryIndex)
                };
            }
            return null;
        }

        /**
         * Finds the first editable segment.
         * @returns {{entryIndex: number} | null} The object with index, or null.
         */
       function getFirstEditableSegment() {
    // Recorremos todos los subt√≠tulos buscando el primero que no est√© validado.
    for (let i = 0; i < srtEntries.length; i++) {
        // Si encontramos uno que NO est√° traducido (`isTranslated` es false)...
        if (!srtEntries[i].isTranslated) {
            // ...devolvemos su √≠ndice para que el programa salte directamente a √©l.
            return { entryIndex: i };
        }
    }

    // Si el bucle termina y no hemos encontrado ninguno sin traducir
    // (es decir, todos est√°n validados), no devolvemos nada (null).
    return null;
}


        /**
         * Navigates to and focuses a specific translation field.
         * @param {number} entryIndex The index of the SRT entry.
         */
   function navigateToTranslation(entryIndex) {
    const targetEditor = document.getElementById(`translation-${entryIndex}`);
    if (targetEditor) {
        const currentlyFocusedEditor = document.activeElement;
        if (currentlyFocusedEditor && currentlyFocusedEditor.classList.contains('subtitle-editor') && currentlyFocusedEditor !== targetEditor) {
            currentlyFocusedEditor.blur();
        }
        setTranslationEditableState(entryIndex, true);
        targetEditor.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
       
        // --- MODIFIED BLOCK ---
        if (videoPlayer.src && srtEntries[entryIndex]) {
            // Set the video time to the start of the focused subtitle, but DO NOT play.
            videoPlayer.currentTime = srtEntries[entryIndex].startTimeMs / 1000;
        }
        // --- END MODIFIED BLOCK ---
    }
}

        /**
         * Moves focus to the next translation field.
         * @param {number} currentEntryIndex The current index of the SRT entry.
         */
        function goToNextTranslation(currentEntryIndex, autoPlayNext = false) {
            if (srtEntries.length === 0) return;

            let nextEntryIndex = currentEntryIndex + 1;

            if (nextEntryIndex < srtEntries.length) {
                // Esto enfoca, hace scroll y ajusta el tiempo del v√≠deo
                navigateToTranslation(nextEntryIndex);
                
                // Si la orden fue "validar y seguir", reproducimos el segmento
                if (autoPlayNext) {
                    jumpToCurrentSubtitleTime(nextEntryIndex);
                }
            } else {
                showMessage(errorMessages[currentLanguage]['reached_last']);
            }
        }

        /**
         * Moves focus to the previous translation field.
         * @param {number} currentEntryIndex The current index of the SRT entry.
         */
        function goToPreviousTranslation(currentEntryIndex) {
            if (srtEntries.length === 0) return;

            let prevEntryIndex = currentEntryIndex - 1;

            if (prevEntryIndex >= 0) {
                navigateToTranslation(prevEntryIndex);
            } else {
                showMessage(errorMessages[currentLanguage]['reached_first']);
            }
        }

function setupIntersectionObserver() {
    const options = {
        root: document.getElementById('editorMainContent'),
        rootMargin: '-50% 0px -50% 0px', // Elige el elemento que est√° en el centro
        threshold: 0
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                // Cuando un subt√≠tulo entra en el centro de la vista,
                // guardamos su √≠ndice como el √∫ltimo activo.
                lastActiveSubtitleIndex = parseInt(entry.target.querySelector('.subtitle-editor').dataset.entryIndex, 10);
            }
        });
    }, options);

    // Hacemos que el observador vigile cada uno de los subt√≠tulos
    document.querySelectorAll('.translation-unit-bg').forEach(unit => {
        observer.observe(unit);
    });
}

// --- INICIO DEL C√ìDIGO A A√ëADIR ---

        // --- Undo/Redo Logic ---

        /**
         * Actualiza el estado de los botones Deshacer/Rehacer (activado/desactivado).
         */
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn && redoBtn) {
                undoBtn.disabled = historyStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }
        }

       /**
         * Guarda el estado de un cambio de texto en el historial. // <- Texto modificado
         * @param {number} entryIndex - El √≠ndice del subt√≠tulo modificado.
         * @param {string} oldValue - El contenido ANTES del cambio.
         * @param {string} newValue - El contenido DESPU√âS del cambio.
         */
        function saveState(entryIndex, oldValue, newValue) {
            // A√ëADIR ESTA L√çNEA ->
            if (isApplyingState) return; // No guardar estados mientras se deshace/rehace
            // Si el valor no ha cambiado, no guardamos nada.
            if (oldValue === newValue) return;

            // A√ëADIR type: 'text' ->
            historyStack.push({ type: 'text', entryIndex, oldValue, newValue });
            redoStack = []; // Un nuevo cambio borra el historial de "rehacer"
            updateUndoRedoButtons();
        }

        /**
         * Deshace la √∫ltima acci√≥n del historial.
         */
        function undo() {
            if (historyStack.length === 0) return;

isApplyingState = true;

            const lastAction = historyStack.pop();
            const { entryIndex, oldValue, newValue } = lastAction;

            // Guardamos la acci√≥n inversa en el historial de "rehacer"
            redoStack.push(lastAction);

            // Aplicamos el estado anterior
            const entry = srtEntries[entryIndex];
            const editor = document.getElementById(`translation-${entryIndex}`);
            if (entry && editor) {
                entry.translation = oldValue;
                editor.innerHTML = oldValue;
                editor.dispatchEvent(new Event('input', { bubbles: true })); // Para actualizar estad√≠sticas
            }

            updateUndoRedoButtons();
isApplyingState = false;
        }

        /**
         * Rehace la √∫ltima acci√≥n deshecha.
         */
        function redo() {
            if (redoStack.length === 0) return;
isApplyingState = true; 

            const lastUndo = redoStack.pop();
            const { entryIndex, oldValue, newValue } = lastUndo;

            // Devolvemos la acci√≥n al historial principal
            historyStack.push(lastUndo);

            // Aplicamos el estado posterior
            const entry = srtEntries[entryIndex];
            const editor = document.getElementById(`translation-${entryIndex}`);
            if (entry && editor) {
                entry.translation = newValue;
                editor.innerHTML = newValue;
                editor.dispatchEvent(new Event('input', { bubbles: true })); // Para actualizar estad√≠sticas
            }

            updateUndoRedoButtons();
isApplyingState = false;
        }
        // --- FIN DEL C√ìDIGO A A√ëADIR ---

        // --- Event Handlers ---

        srtFile.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                await processFile(file);
            }
        });

        saveSrtButton.addEventListener('click', () => {
            if (srtEntries.length === 0) {
                showMessage(errorMessages[currentLanguage]['no_translations_to_save']);
                return;
            }
            fileNameInput.value = currentFileName.replace(/\.srt$/i, '') + '_trad.srt';
            saveSrtModal.classList.remove('hidden');
            fileNameInput.focus();
        });

        cancelSaveBtn.addEventListener('click', () => {
            saveSrtModal.classList.add('hidden');
        });

        confirmSaveBtn.addEventListener('click', () => {
            const filename = fileNameInput.value;
            if (!filename) {
                showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                return;
            }
            showLoadingOverlay(errorMessages[currentLanguage]['saving_file']);
            try {
                const updatedSrtContent = reconstructSrt(srtEntries);
                const blob = new Blob([updatedSrtContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename.endsWith('.srt') ? filename : filename + '.srt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showMessage(errorMessages[currentLanguage]['file_saved_successfully']);
            } catch (error) {
                showMessage(`${errorMessages[currentLanguage]['error_saving_file']} ${error.message}`);
                console.error("Error saving file:", error);
            } finally {
                hideLoadingOverlay();
                saveSrtModal.classList.add('hidden');
            }
        });

        async function processFile(file) {
            currentFileName = file.name;
            videoFileName = null; // Reset video file name when a new SRT is loaded
            showLoadingOverlay(errorMessages[currentLanguage]['loading_file']);

           
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        srtEntries = parseSrtContent(content);
 historyStack = [];
                    redoStack = [];
                    updateUndoRedoButtons();
                        renderTranslations(srtEntries);
                        runFullQaCheck();
                        updateStatsDisplay();
                        resolve();
                    } catch (error) {
                        showMessage(`${errorMessages[currentLanguage]['error_reading_file']} ${error.message}`);
                        console.error("Error parsing file:", error);
                        translationsContainer.innerHTML = `<div class="text-center text-red-500 p-4 border border-red-300 rounded-md">${errorMessages[currentLanguage]['file_processing_error']}</div>`;
                        saveSrtButton.disabled = true;
                        saveProjectBtn.disabled = true;
                        statsContainer.classList.add('hidden');
                        resolve();
                    } finally {
                        hideLoadingOverlay();
                    }
                };
                reader.onerror = () => {
                    showMessage(errorMessages[currentLanguage]['error_reading_file'] + (file.name || ''));
                    saveSrtButton.disabled = true;
                    saveProjectBtn.disabled = true;
                    statsContainer.classList.add('hidden');
                    hideLoadingOverlay();
                    resolve();
                };
                reader.readAsText(file);
            });
        }

        
      function showMessage(msg) {
            // Limpia cualquier temporizador anterior
            clearTimeout(messageTimeout);
            
            messageText.textContent = msg;

            // ‚ùó CORRECCI√ìN: Quitamos la clase 'hidden' para que el contenedor exista
            messageBox.classList.remove('hidden'); 
            
            // Hacemos visible el mensaje, iniciando la transici√≥n de "fade in"
            setTimeout(() => {
                messageBox.classList.add('is-visible');
            }, 10); // Un peque√±o retardo para asegurar que la animaci√≥n se ejecute

            // Configuramos un nuevo temporizador para ocultarlo
            messageTimeout = setTimeout(() => {
                // Quitamos la clase, iniciando la transici√≥n de "fade out"
                messageBox.classList.remove('is-visible');
                 // Esperamos a que la animaci√≥n de salida termine para volver a ocultarlo
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, 300); // Coincide con la duraci√≥n de la transici√≥n en CSS
            }, 3000); // El mensaje estar√° visible por 3 segundos
        }

        // --- Keyboard Shortcuts Modal ---
        shortcutsBtn.addEventListener('click', () => {
            renderShortcutsModal();
            shortcutsModal.classList.remove('hidden');
        });

        shortcutsCloseBtn.addEventListener('click', () => {
            window.removeEventListener('keydown', recordShortcutHandler, true); // Use correct handler
            recordingAction = null;
            shortcutsModal.classList.add('hidden');
        });

        function formatShortcut(shortcut) {
            let parts = [];
            if (shortcut.ctrlKey) parts.push('Ctrl');
            if (shortcut.metaKey) parts.push('Cmd');

            
            if (shortcut.altKey) {
                // Si el perfil es 'mac', usa "Option". Si no, usa "Alt".
                const altKeyName = activeProfile === 'mac' ? 'Option' : 'Alt';
                parts.push(altKeyName);
            }
            

            if (shortcut.shiftKey) parts.push('Shift');
            
            let keyName = shortcut.key;
            if (keyName === ' ') keyName = 'Space';
            
            parts.push(keyName.charAt(0).toUpperCase() + keyName.slice(1));
            return parts.join(' + ');
        }

      function renderShortcutsModal() {
            shortcutsList.innerHTML = '';
            const t = translations[currentLanguage];
            const activeShortcuts = shortcutProfiles[activeProfile];

            for (const action in activeShortcuts) {
                if (action === 'docResources') continue;

                const shortcut = activeShortcuts[action];
                const row = document.createElement('div');
                row.className = 'flex justify-between items-center p-2 border-b';
                
                const description = t[shortcut.descriptionKey] || shortcut.descriptionKey;
                
                let shortcutControlsHTML = `
                    <span id="shortcut-display-${action}" class="shortcut-input font-mono">${formatShortcut(shortcut)}</span>
                    <button class="btn btn-secondary text-sm" data-action="${action}" data-i18n="edit_shortcut_btn">${t.edit_shortcut_btn}</button>
                `;

                if (action === 'playSegmentLoop') {
                    shortcutControlsHTML = `
                        <input type="number" min="1" value="${shortcut.loopCount || 3}" onchange="updateLoopCount(this.value)" class="w-16 p-1 border border-gray-300 rounded-md text-center">
                        ${shortcutControlsHTML}
                    `;
                }

                row.innerHTML = `
                    <span>${description}</span>
                    <div class="flex items-center gap-2">
                        ${shortcutControlsHTML}
                    </div>
                `;
                shortcutsList.appendChild(row);
            }

            // ... (El c√≥digo para la secci√≥n "Productive Documentation" no cambia, por lo que se omite por brevedad) ...
            const docSection = document.createElement('div');
            docSection.className = 'mt-6 pt-4 border-t';
            docSection.innerHTML = `<h3 class="text-lg font-bold mb-3" data-i18n="productive_documentation">${t.productive_documentation}</h3>`;
            activeShortcuts.docResources.forEach((resource, index) => {
                const row = document.createElement('div');
                row.className = 'flex justify-between items-center p-2 gap-4';
                const urlInput = document.createElement('input');
                urlInput.type = 'text';
                urlInput.className = 'w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white';
                urlInput.placeholder = t.doc_resource_placeholder;
                urlInput.value = resource.url;
                urlInput.oninput = (e) => {
                    shortcutProfiles[activeProfile].docResources[index].url = e.target.value;
                    saveShortcuts();
                };
                const shortcutContainer = document.createElement('div');
                shortcutContainer.className = 'flex items-center gap-2';
                const shortcutDisplay = document.createElement('span');
                shortcutDisplay.id = `shortcut-display-doc_${index}`;
                shortcutDisplay.className = 'shortcut-input font-mono';
                shortcutDisplay.textContent = resource.shortcut ? formatShortcut(resource.shortcut) : '...';
                const editButton = document.createElement('button');
                editButton.className = 'btn btn-secondary text-sm';
                editButton.dataset.action = `doc_${index}`;
                editButton.textContent = t.edit_shortcut_btn;
                shortcutContainer.appendChild(shortcutDisplay);
                shortcutContainer.appendChild(editButton);
                row.appendChild(urlInput);
                row.appendChild(shortcutContainer);
                docSection.appendChild(row);
            });
            shortcutsList.appendChild(docSection);

            shortcutsList.querySelectorAll('button[data-action]').forEach(button => {
                button.addEventListener('click', () => startRecording(button.dataset.action));
            });

            // L√≥gica para el selector de perfil
            const profileSelector = document.getElementById('shortcutProfileSelector');
            profileSelector.value = activeProfile;
            profileSelector.onchange = (e) => {
                activeProfile = e.target.value;
                localStorage.setItem('shortcutProfile', activeProfile); // Guardar preferencia
                shortcuts = { ...shortcutProfiles[activeProfile] }; // Actualizar atajos activos
                renderShortcutsModal(); // Volver a renderizar el modal con el nuevo perfil
            };
        }
        let recordingAction = null;
        const recordShortcutHandler = (e) => {
            if (!recordingAction) return;
        
            e.preventDefault();
            e.stopPropagation();
        
            const modifierKeys = ['Control', 'Alt', 'Shift', 'Meta'];
            if (modifierKeys.includes(e.key)) {
                return; 
            }
        
            window.removeEventListener('keydown', recordShortcutHandler, true);
        
            const newShortcut = {
                key: e.key === ' ' ? ' ' : e.key.toLowerCase(),
                ctrlKey: e.ctrlKey,
                altKey: e.altKey,
                shiftKey: e.shiftKey,
metaKey: e.metaKey
            };
        
            // Check for conflicts
            let conflict = Object.keys(shortcuts).some(action => {
                if (action === 'docResources' || action === recordingAction) return false;
                const sc = shortcuts[action];
                return sc.key === newShortcut.key && sc.ctrlKey === newShortcut.ctrlKey && sc.altKey === newShortcut.altKey && sc.shiftKey === newShortcut.shiftKey;
            });

            if (!conflict) {
                conflict = shortcuts.docResources.some((res, i) => {
                    const actionId = `doc_${i}`;
                    if (!res.shortcut || actionId === recordingAction) return false;
                    const sc = res.shortcut;
                    return sc.key === newShortcut.key && sc.ctrlKey === newShortcut.ctrlKey && sc.altKey === newShortcut.altKey && sc.shiftKey === newShortcut.shiftKey;
                });
            }

            if (conflict) {
                showMessage(errorMessages[currentLanguage].shortcut_conflict);
            } else {
                if (recordingAction.startsWith('doc_')) {
                    // It's a documentation shortcut
                    const index = parseInt(recordingAction.split('_')[1]);
                    shortcuts.docResources[index].shortcut = newShortcut;
                } else {
                    // It's a regular application shortcut
                   shortcutProfiles[activeProfile][recordingAction] = { ...shortcutProfiles[activeProfile][recordingAction], ...newShortcut };
                }
                saveShortcuts();
            }
        
            recordingAction = null;
            renderShortcutsModal();
        };

        function startRecording(action) {
            // Clear any previous recording state
            window.removeEventListener('keydown', recordShortcutHandler, true);
            document.querySelectorAll('.shortcut-input.recording').forEach(el => {
                const prevAction = el.id.replace('shortcut-display-', '');
                let shortcutToFormat;
                if (prevAction.startsWith('doc_')) {
                    const index = parseInt(prevAction.split('_')[1]);
                    shortcutToFormat = shortcuts.docResources[index].shortcut;
                } else {
                    shortcutToFormat = shortcuts[prevAction];
                }
                el.textContent = shortcutToFormat ? formatShortcut(shortcutToFormat) : '...';
            });

            recordingAction = action;
            const displayEl = document.getElementById(`shortcut-display-${action}`);
            displayEl.classList.add('recording');
            displayEl.textContent = translations[currentLanguage].recording_shortcut_text;
            
            window.addEventListener('keydown', recordShortcutHandler, true);
        }

        async function saveShortcuts() {
            try {
                await db.settings.put({ key: 'shortcutProfiles', value: shortcutProfiles });
            } catch (error) {
                console.error("Failed to save shortcuts:", error);
            }
        }

async function loadShortcuts() {
            // 1. Define el perfil base de Windows/Linux
            const windowsProfile = {
                validateAndNext: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'enter', descriptionKey: 'shortcut_desc_validateAndNext' },
                goToNext: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'arrowdown', descriptionKey: 'shortcut_desc_goToNext' },
                goToPrevious: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'arrowup', descriptionKey: 'shortcut_desc_goToPrevious' },
                 insertTM1: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '1', descriptionKey: 'shortcut_desc_insertTM1' },
                insertTM2: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '2', descriptionKey: 'shortcut_desc_insertTM2' },
                insertTM3: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '3', descriptionKey: 'shortcut_desc_insertTM3' },
                insertTM4: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '4', descriptionKey: 'shortcut_desc_insertTM4' },
                insertTM5: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '5', descriptionKey: 'shortcut_desc_insertTM5' },
                insertGloss1: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '1', descriptionKey: 'shortcut_desc_insertGloss1' },
                insertGloss2: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '2', descriptionKey: 'shortcut_desc_insertGloss2' },
                insertGloss3: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '3', descriptionKey: 'shortcut_desc_insertGloss3' },
                insertGloss4: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '4', descriptionKey: 'shortcut_desc_insertGloss4' },
                insertGloss5: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '5', descriptionKey: 'shortcut_desc_insertGloss5' },
                jumpToTime: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'j', descriptionKey: 'shortcut_desc_jumpToTime' },
                playSegment: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: ' ', descriptionKey: 'shortcut_desc_playSegment' },
                playPause: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '0', descriptionKey: 'shortcut_desc_playPause' },
                playSegmentLoop: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'l', descriptionKey: 'shortcut_desc_playSegmentLoop', loopCount: 3 },
                seekForward: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: true, key: 'arrowright', descriptionKey: 'shortcut_desc_seekForward' },
                seekBackward: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: true, key: 'arrowleft', descriptionKey: 'shortcut_desc_seekBackward' },
                seekForwardFast: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: true, key: 'arrowright', descriptionKey: 'shortcut_desc_seekForwardFast' },
                seekBackwardFast: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: true, key: 'arrowleft', descriptionKey: 'shortcut_desc_seekBackwardFast' },
                bold: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'b', descriptionKey: 'shortcut_desc_bold' },
                italic: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'i', descriptionKey: 'shortcut_desc_italic' },
        docResources: Array.from({ length: 5 }, () => ({ url: '', shortcut: null }))
            };

 // 2. Crea el perfil de Mac a partir del de Windows
            // Esta copia asegura que el perfil de Mac tenga todos los atajos definidos
            const macProfile = JSON.parse(JSON.stringify(windowsProfile));

            // 3. Carga los perfiles guardados si existen
            try {
                const savedProfiles = await db.settings.get('shortcutProfiles');
                shortcutProfiles.windows = savedProfiles?.value?.windows || windowsProfile;
                shortcutProfiles.mac = savedProfiles?.value?.mac || macProfile;
            } catch (e) {
                console.error("No se pudieron cargar los perfiles de atajos, usando valores por defecto.", e);
                shortcutProfiles.windows = windowsProfile;
                shortcutProfiles.mac = macProfile;
            }

            // 4. Carga y activa el perfil preferido del usuario
            activeProfile = localStorage.getItem('shortcutProfile') || (navigator.platform.toUpperCase().indexOf('MAC') >= 0 ? 'mac' : 'windows');
            shortcuts = { ...shortcutProfiles[activeProfile] };
        }
        
        restoreShortcutsBtn.addEventListener('click', async () => {
            shortcuts = JSON.parse(JSON.stringify(defaultShortcuts)); // Deep copy
            // Re-initialize docResources
            shortcuts.docResources = [];
            for (let i = 0; i < 5; i++) {
                shortcuts.docResources.push({ url: '', shortcut: null });
            }
            await saveShortcuts();
            renderShortcutsModal();
        });

        exportShortcutsBtn.addEventListener('click', () => {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(shortcuts, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "subpanda_shortcuts.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        });

        importShortcutsInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedShortcuts = JSON.parse(e.target.result);
                    if (typeof importedShortcuts === 'object' && importedShortcuts !== null) {
                        shortcuts = { ...defaultShortcuts, ...importedShortcuts };
                        await loadShortcuts(); // Re-run load to ensure docResources is validated
                        await saveShortcuts();
                        renderShortcutsModal();
                    } else {
                        throw new Error("Invalid format");
                    }
                } catch (err) {
                    showMessage(errorMessages[currentLanguage].shortcut_import_error);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        });

  setupPanel('findReplacePanel', 'findReplaceBtn', () => {
            findInput.focus();
        });
        

        findNextBtn.addEventListener('click', () => findAndNavigate(true));
        findPrevBtn.addEventListener('click', () => findAndNavigate(false));
        replaceBtn.addEventListener('click', replaceCurrentMatch);
        replaceAllBtn.addEventListener('click', replaceAllMatches);

        function findAndNavigate(forward = true) {
            const query = findInput.value;
            if (!query) {
                showMessage(errorMessages[currentLanguage]['no_find_query']);
                return;
            }

            findState.query = query;
            findState.caseSensitive = caseSensitiveCheckbox.checked;
            findState.useRegex = regexCheckbox.checked;

            let regex;
            try {
                regex = findState.useRegex ? new RegExp(findState.query, findState.caseSensitive ? '' : 'i') : null;
            } catch (e) {
                showMessage(`Error de expresi√≥n regular: ${e.message}`);
                return;
            }

            let startEntryIndex = 0;
            let startMatchIndex = 0;

            if (findState.lastFound) {
                startEntryIndex = findState.lastFound.entryIndex;
                startMatchIndex = forward ? findState.lastFound.matchEnd : findState.lastFound.matchStart - 1;
            } else {
                if (!forward) {
                    startEntryIndex = srtEntries.length - 1;
                    startMatchIndex = Infinity;
                }
            }

            let found = false;
            let currentEntryIndex = startEntryIndex;
            const totalEntries = srtEntries.length;

            for (let i = 0; i < totalEntries; i++) {
                const entry = srtEntries[currentEntryIndex];
                const text = entry.translation;
                let match;

                if (findState.useRegex) {
                    regex.lastIndex = 0;
                    if (forward) {
                        let searchFrom = (currentEntryIndex === startEntryIndex) ? startMatchIndex : 0;
                        const subText = text.substring(searchFrom);
                        match = regex.exec(subText);
                        if (match) {
                            match.index += searchFrom;
                        }
                    } else {
                        let allMatches = [];
                        let tempRegex = new RegExp(regex.source, regex.flags.includes('g') ? regex.flags : regex.flags + 'g');
                        let tempMatch;
                        while((tempMatch = tempRegex.exec(text)) !== null) {
                            allMatches.push(tempMatch);
                        }
                        let searchUntil = (currentEntryIndex === startEntryIndex) ? startMatchIndex : text.length;
                        match = allMatches.reverse().find(m => m.index < searchUntil);
                    }
                } else {
                    const searchText = findState.caseSensitive ? text : text.toLowerCase();
                    const queryLower = findState.caseSensitive ? findState.query : findState.query.toLowerCase();

                    if (forward) {
                        let searchFrom = (currentEntryIndex === startEntryIndex) ? startMatchIndex : 0;
                        const foundIndex = searchText.indexOf(queryLower, searchFrom);
                        if (foundIndex !== -1) {
                            match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                        }
                    } else {
                        let searchUntil = (currentEntryIndex === startEntryIndex) ? startMatchIndex : text.length;
                        const foundIndex = searchText.lastIndexOf(queryLower, searchUntil);
                        if (foundIndex !== -1) {
                            match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                        }
                    }
                }

                if (match) {
                    findState.lastFound = {
                        entryIndex: currentEntryIndex,
                        matchStart: match.index,
                        matchEnd: match.index + match[0].length,
                    };
                    navigateToTranslation(currentEntryIndex);
                    const targetEditor = document.getElementById(`translation-${currentEntryIndex}`);
                    if (targetEditor) {
                        const range = document.createRange();
                        const sel = window.getSelection();
                        range.setStart(targetEditor.firstChild, findState.lastFound.matchStart);
                        range.setEnd(targetEditor.firstChild, findState.lastFound.matchEnd);
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                    found = true;
                    return;
                }

                currentEntryIndex = (currentEntryIndex + (forward ? 1 : -1) + totalEntries) % totalEntries;
            }

            if (!found) {
                showMessage(errorMessages[currentLanguage]['no_match_found']);
                findState.lastFound = null;
            }
        }


    function replaceCurrentMatch() {
            const replaceWith = replaceInput.value; // <-- L√çNEA A√ëADIDA: Ahora s√≠ lee el texto de reemplazo

            if (!findState.lastFound || !findState.query) {
                showMessage(errorMessages[currentLanguage]['no_match_found']);
                return;
            }

            const { entryIndex, matchStart, matchEnd } = findState.lastFound;
            const entry = srtEntries[entryIndex];
            const targetEditor = document.getElementById(`translation-${entryIndex}`);

            if (!entry || !targetEditor) return; // Comprobaci√≥n de seguridad

            let originalText = entry.translation;
            let replacedText;

            // Esta l√≥gica ahora usa 'replaceWith' para construir el nuevo texto
            if (findState.useRegex) {
                const regex = new RegExp(findState.query, findState.caseSensitive ? '' : 'i');
                replacedText = originalText.substring(0, matchStart) +
                               originalText.substring(matchStart, matchEnd).replace(regex, replaceWith) +
                               originalText.substring(matchEnd);
            } else {
                replacedText = originalText.substring(0, matchStart) +
                               replaceWith +
                               originalText.substring(matchEnd);
            }

            // MEJORA: Actualizamos los datos y la interfaz directamente sin recargar toda la lista
            entry.translation = replacedText;
            targetEditor.innerHTML = replacedText;
            targetEditor.dispatchEvent(new Event('input', { bubbles: true })); // Esto recalcula las estad√≠sticas (CPS, etc.)

            // Buscamos autom√°ticamente la siguiente coincidencia
            findAndNavigate(true);
        }

        function replaceAllMatches() {
            const query = findInput.value;
            const replaceWith = replaceInput.value;
            if (!query) {
                showMessage(errorMessages[currentLanguage]['no_find_query']);
                return;
            }

            let replacedCount = 0;
            let regex;
            
            // ‚ùó CORRECCI√ìN: Se ha arreglado la creaci√≥n de la expresi√≥n regular
            try {
                if (regexCheckbox.checked) {
                    // Si el usuario escribe una expresi√≥n regular, la usamos tal cual
                    regex = new RegExp(query, (caseSensitiveCheckbox.checked ? 'g' : 'ig'));
                } else {
                    // Si es texto normal, escapamos caracteres especiales para que no den error
                    const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    regex = new RegExp(escapedQuery, (caseSensitiveCheckbox.checked ? 'g' : 'ig'));
                }
            } catch (e) {
                showMessage(`Error de expresi√≥n regular: ${e.message}`);
                return;
            }

            srtEntries.forEach(entry => {
                let originalTranslation = entry.translation;
                
                // Contamos las coincidencias antes de reemplazar
                const matches = originalTranslation.match(regex);
                if (matches) {
                    replacedCount += matches.length;
                }

                // Realizamos el reemplazo
                const newTranslation = originalTranslation.replace(regex, replaceWith);

                if (originalTranslation !== newTranslation) {
                    entry.translation = newTranslation;
                }
            });

            if (replacedCount > 0) {
                // MEJORA: Actualizamos la interfaz de forma m√°s eficiente
                const scrollPosition = document.getElementById('editorMainContent').scrollTop;
                const activeIndex = getCurrentFocusedIndex()?.entryIndex ?? 0;
                renderTranslations(srtEntries, activeIndex, true);
                document.getElementById('editorMainContent').scrollTop = scrollPosition;
                updateStatsDisplay();
                showMessage(translations[currentLanguage]['replacements_made'].replace('{0}', replacedCount));
            } else {
                showMessage(errorMessages[currentLanguage]['no_match_found']);
            }

            findState.lastFound = null;
        }

       function setLanguage(lang) {
    // --- INICIO DE LA L√ìGICA A√ëADIDA ---
    // 1. Antes de cambiar el idioma, generamos el prompt por defecto del idioma ACTUAL (el viejo).
    const oldDefaultPrompt = translations[currentLanguage]['ai_default_instruction_1']
        .replace('{0}', qaSettings.charsPerLineLimit)
        .replace('{1}', qaSettings.cpsLimit);
    
    // 2. Comprobamos si el usuario est√° usando (o dej√≥) el prompt por defecto sin modificar.
    const isUsingDefaultPrompt = (aiCustomInstructions.instruction1 === oldDefaultPrompt);
    // --- FIN DE LA PRIMERA PARTE ---

    currentLanguage = lang;
    
    langEsBtn.classList.toggle('active', lang === 'es');
    langEnBtn.classList.toggle('active', lang === 'en');

    // --- INICIO DE LA SEGUNDA PARTE ---
    // 3. Si estaba usando el prompt por defecto, lo actualizamos al del NUEVO idioma.
    if (isUsingDefaultPrompt) {
        const newDefaultPrompt = translations[currentLanguage]['ai_default_instruction_1']
            .replace('{0}', qaSettings.charsPerLineLimit)
            .replace('{1}', qaSettings.cpsLimit);
        aiCustomInstructions.instruction1 = newDefaultPrompt;
        saveAiCustomInstructions(); // Guardamos el cambio para que persista.
    }
    // --- FIN DE LA L√ìGICA A√ëADIDA ---
    
    const t = translations[lang];
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (t[key]) el.textContent = t[key];
    });
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if (t[key]) el.placeholder = t[key];
    });
    
    if (srtEntries.length > 0) {
        const activeIndex = getCurrentFocusedIndex()?.entryIndex ?? lastActiveSubtitleIndex;
        renderTranslations(srtEntries, activeIndex, true);
    } else {
         const initialMessageElement = document.getElementById('initialMessage');
        if (initialMessageElement) initialMessageElement.textContent = t.no_translations;
    }
    renderGlossary();
    tmSearch();

    // --- INICIO DE LA CORRECCI√ìN ---
    // Esta l√≠nea fuerza la actualizaci√≥n del panel de la IA con el nuevo idioma.
    // Comprueba si hay datos de contexto antes de intentar redibujar el panel.
    if (srtEntries.some(e => e.context)) {
        updateContextPanel(lastActiveSubtitleIndex);
    }
    // --- FIN DE LA CORRECCI√ìN ---

// Actualizar t√≠tulos de botones din√°micamente
    document.getElementById('zoomOutBtn').title = t['zoom_out'];
    document.getElementById('zoomInBtn').title = t['zoom_in'];
    // Actualiza el t√≠tulo del bot√≥n de bloqueo seg√∫n su estado actual
    lockWaveformBtn.title = isWaveformLocked ? t['unlock_waveform'] : t['lock_waveform'];
followPlaybackBtn.title = isFollowPlaybackActive ? t['follow_playback_off'] : t['follow_playback_on'];
}


        // --- Terminology Sidebar Logic ---
        function setupPanel(panelId, buttonId, openCallback) {
            const panel = document.getElementById(panelId);
            const button = document.getElementById(buttonId);
            const closeButton = panel.querySelector('button[id^="close"]');
            const resetButton = panel.querySelector('.reset-panel-btn');

            button.addEventListener('click', () => {
                openFloatingPanel(panel, button, openCallback);
            });

            closeButton.addEventListener('click', () => {
                closeFloatingPanel(panel, button);
            });
            
            resetButton.addEventListener('click', (e) => {
                e.stopPropagation();
                resetPanelPosition(panel);
            });
        }

        function populateIsoLanguagesDatalist() {
            isoLanguagesDatalist.innerHTML = '';
            isoLanguagesData.forEach(lang => {
                const option = document.createElement('option');
                option.value = lang.code;
                option.textContent = lang.name;
                isoLanguagesDatalist.appendChild(option);
            });
        }

        function resetGlossary() {
            glossary = [];
            glossarySourceLanguage = '';
            glossaryTargetLanguage = '';
            if (configSrcLang) configSrcLang.value = 'en-US';
            if (configTgtLang) configTgtLang.value = 'es-ES';
            if (srcTermInput) srcTermInput.value = "";
            if (tgtTermInput) tgtTermInput.value = "";
            if (searchTermInput) searchTermInput.value = "";
            if (terminologyLanguageConfigSection && terminologyEditorSection) {
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }
            renderGlossary();
        }

        function showLanguageConfigSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection) {
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }
        }

        function showGlossaryEditorSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection && displaySrcLang && displayTgtLang) {
                terminologyLanguageConfigSection.style.display = 'none';
                terminologyEditorSection.style.display = 'block';
                displaySrcLang.value = glossarySourceLanguage;
                displayTgtLang.value = glossaryTargetLanguage;
                renderGlossary();
            }
        }

        function confirmGlossaryLanguages() {
            const srcLang = configSrcLang ? configSrcLang.value.trim() : '';
            const tgtLang = configTgtLang ? configTgtLang.value.trim() : '';
            if (!srcLang || !tgtLang) {
                showMessage(errorMessages[currentLanguage]['lang_config_required']);
                return;
            }
            glossarySourceLanguage = srcLang;
            glossaryTargetLanguage = tgtLang;
            showGlossaryEditorSection();
            renderTranslations(srtEntries);
        }

        function addTerm() {
            const srcTerm = srcTermInput ? srcTermInput.value.trim() : '';
            const tgtTerm = tgtTermInput ? tgtTermInput.value.trim() : '';
            if (!srcTerm || !tgtTerm) {
                showMessage(errorMessages[currentLanguage]['both_terms_required']);
                return;
            }

            const t = translations[currentLanguage];

            if (editingTermIndex !== -1) {
                // --- MODO EDICI√ìN ---
                // 1. Actualizar el t√©rmino existente
                glossary[editingTermIndex].srcTerm = srcTerm;
                glossary[editingTermIndex].tgtTerm = tgtTerm;

                // 2. Resetear el estado de edici√≥n
                editingTermIndex = -1;

                // 3. Cambiar el bot√≥n de nuevo a "A√±adir"
                const addBtn = document.querySelector('button[onclick="addTerm()"]');
                addBtn.textContent = t.add_button;

            } else {
                // --- MODO A√ëADIR (L√≥gica original) ---
                glossary.push({
                    srcLang: glossarySourceLanguage,
                    srcTerm: srcTerm,
                    tgtLang: glossaryTargetLanguage,
                    tgtTerm: tgtTerm
                });
            }

            // L√≥gica de limpieza (com√∫n para ambos modos)
            if (srcTermInput) srcTermInput.value = "";
            if (tgtTermInput) tgtTermInput.value = "";
            
            updateTranslations();
        }
        function editTerm(index) {
            const entry = glossary[index];
            if (!entry) return;

            // 1. Rellenar los campos de entrada
            srcTermInput.value = entry.srcTerm;
            tgtTermInput.value = entry.tgtTerm;

            // 2. Guardar el √≠ndice que estamos editando
            editingTermIndex = index;

            // 3. Cambiar el texto del bot√≥n "A√±adir" a "Guardar cambios"
            const addBtn = document.querySelector('button[onclick="addTerm()"]');
            const t = translations[currentLanguage];
            addBtn.textContent = t.save_changes_btn;

            // 4. (Opcional) Asegurarse de que el acorde√≥n est√© abierto y visible
            if (addTermContent.classList.contains('collapsed')) {
                addTermHeader.click(); // Simula un clic para abrirlo
            }
            // 5. (Opcional) Mover la vista al formulario de edici√≥n
            addTermHeader.scrollIntoView({ behavior: 'smooth', block: 'center' });
            srcTermInput.focus();
        }
        function deleteTerm(index) {
            const t = translations[currentLanguage];
            // --- A√ëADIR ESTE BLOQUE ---
            if (index === editingTermIndex) {
                // Si eliminamos el t√©rmino que estamos editando, reseteamos el formulario
                editingTermIndex = -1;
                srcTermInput.value = "";
                tgtTermInput.value = "";
                const addBtn = document.querySelector('button[onclick="addTerm()"]');
                addBtn.textContent = translations[currentLanguage].add_button;
            } else if (index < editingTermIndex) {
                // Si eliminamos un t√©rmino anterior, el √≠ndice de edici√≥n debe disminuir
                editingTermIndex--;
            }
            // --- FIN DEL BLOQUE A√ëADIDO ---
            glossary.splice(index, 1);
            // Llamamos a la nueva funci√≥n, que ya se encarga de todo.
            updateTranslations();
        }
// --- A√ëADIR TODA ESTA NUEVA FUNCI√ìN ---
        /**
         * Carga un t√©rmino existente en los campos de entrada para su edici√≥n.
         * @param {number} index - El √≠ndice del t√©rmino en el array 'glossary'.
         */
        function editTerm(index) {
            const entry = glossary[index];
            if (!entry) return;

            // 1. Rellenar los campos de entrada
            srcTermInput.value = entry.srcTerm;
            tgtTermInput.value = entry.tgtTerm;

            // 2. Guardar el √≠ndice que estamos editando
            editingTermIndex = index;

            // 3. Cambiar el texto del bot√≥n "A√±adir" a "Guardar cambios"
            const addBtn = document.querySelector('button[onclick="addTerm()"]');
            const t = translations[currentLanguage];
            addBtn.textContent = t.save_changes_btn;

            // 4. (Opcional) Asegurarse de que el acorde√≥n est√© abierto y visible
            if (addTermContent.classList.contains('collapsed')) {
                addTermHeader.click(); // Simula un clic para abrirlo
            }
            // 5. (Opcional) Mover la vista al formulario de edici√≥n
            addTermHeader.scrollIntoView({ behavior: 'smooth', block: 'center' });
            srcTermInput.focus();
        }
        // --- FIN DE LA NUEVA FUNCI√ìN ---

        function deleteTerm(index) {
            // --- A√ëADIR ESTE BLOQUE ---
            if (index === editingTermIndex) {
                // Si eliminamos el t√©rmino que estamos editando, reseteamos el formulario
                editingTermIndex = -1;
                srcTermInput.value = "";
                tgtTermInput.value = "";
                const addBtn = document.querySelector('button[onclick="addTerm()"]');
                addBtn.textContent = translations[currentLanguage].add_button;
            } else if (index < editingTermIndex) {
                // Si eliminamos un t√©rmino anterior, el √≠ndice de edici√≥n debe disminuir
                editingTermIndex--;
            }
            // --- FIN DEL BLOQUE A√ëADIDO ---
    glossary.splice(index, 1);
    // Llamamos a la nueva funci√≥n, que ya se encarga de todo.
    updateTranslations();
}

        function renderGlossary() {
            if (!glossaryTableBody) return;
            const search = searchTermInput ? searchTermInput.value.toLowerCase() : '';
            glossaryTableBody.innerHTML = "";
            const t = translations[currentLanguage];
            const filteredGlossary = glossary.filter(entry =>
                (entry.srcTerm && entry.srcTerm.toLowerCase().includes(search)) ||
                (entry.tgtTerm && entry.tgtTerm.toLowerCase().includes(search))
            );
            const highlightedTerms = [];
            const otherTerms = [];
            filteredGlossary.forEach(entry => {
                if (entry.srcTerm && termsFoundInActiveSegment.has(entry.srcTerm)) {
                    highlightedTerms.push(entry);
                } else {
                    otherTerms.push(entry);
                }
            });
            currentGlossaryLatestResults = [...highlightedTerms, ...otherTerms.sort((a, b) => a.srcTerm.localeCompare(b.srcTerm))];
            
            const renderRow = (entry) => {
                 const row = document.createElement("tr");
                if (highlightedTerms.includes(entry)) {
                    row.classList.add('glossary-row-highlight');
                }
                const originalIndex = glossary.indexOf(entry);
                row.innerHTML = `
                    <td>${entry.srcTerm}</td>
                    <td>${entry.tgtTerm}</td>
                    <td class="flex gap-1">
                        <button class="btn btn-secondary text-xs" onclick="editTerm(${originalIndex})" data-i18n="edit_button">${t.edit_button}</button>
                        <button class="btn btn-destructive text-xs" onclick="deleteTerm(${originalIndex})" data-i18n="delete_button">${t.delete_button}</button>
                    </td>
                `;
                glossaryTableBody.appendChild(row);
            };

            currentGlossaryLatestResults.forEach(renderRow);
        }

// --- FUNCIONES DE EXPORTACI√ìN TMX (RECUPERANDO LA VERSI√ìN OLD COMPATIBLE TAO) ---

/**
 * Funci√≥n auxiliar para escapar caracteres especiales para el formato XML/TMX.
 * Esto asegura que el TMX sea v√°lido y convierte los saltos de l√≠nea a <br/>.
 * @param {string} text El texto a sanear.
 * @returns {string} El texto saneado.
 */
function sanitizeForXML(text) {
    if (!text) return '';
    
    // 1. Normalizaci√≥n de saltos de l√≠nea de contenido editable a <br/>
    text = text.replace(/<\/div>\s*<div>/gi, '<br/>'); // Divs internos a <br/>
    text = text.replace(/<div[^>]*>/gi, '').replace(/<\/div>/gi, ''); // Eliminar divs restantes
    text = text.replace(/<br\s*\/?>/gi, '<br/>'); // Br a <br/>
    text = text.replace(/<[^>]+>/g, ''); // Eliminar otras etiquetas HTML
    text = text.trim();
    
    // 2. Escapar caracteres XML est√°ndar
    return text.replace(/&/g, '&amp;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;')
               .replace(/"/g, '&quot;')
               .replace(/'/g, '&apos;');
}


/**
 * Exporta la Memoria de Traducci√≥n (TM) al formato TMX 1.4 compatible.
 */
function exportTMX() {
    // Nota: Asume la existencia de las variables globales 'translationMemory', 'sourceLang', 'targetLang', 'fileNameInput', 'errorMessages' y 'translations'.
    
    if (!translationMemory || translationMemory.length === 0) {
        showMessage(errorMessages[currentLanguage]['no_tm_to_save'] || "No hay Memoria de Traducci√≥n para guardar.");
        return;
    }
    
    const srcLangCode = sourceLang || 'en-US';
    const tgtLangCode = targetLang || 'es-ES';

    // 1. Construir el Encabezado TMX
    const tmxHeader = `<?xml version="1.0" encoding="UTF-8"?>
<tmx version="1.4">
  <header datatype="plaintext" segtype="sentence"
    adminlang="en-us" srclang="${srcLangCode}"
    o-tmf="none" creationtool="subpandaTM" creationtoolversion="1.0">
  </header>
  <body>`;
    
    // 2. Construir el Cuerpo TMX (Unidades de Traducci√≥n)
    const tmxBody = translationMemory.map(entry => {
        // Usar sanitizeForXML para limpiar y escapar el texto, convirtiendo saltos de l√≠nea a <br/>
        let sourceText = sanitizeForXML(entry.source); 
        let targetText = sanitizeForXML(entry.target); 

        return `    <tu>
      <tuv xml:lang="${srcLangCode}">
        <seg>${sourceText}</seg>
      </tuv>
      <tuv xml:lang="${tgtLangCode}">
        <seg>${targetText}</seg>
      </tuv>
    </tu>`;
    }).join('\n');

    // 3. Construir el Pie de P√°gina TMX
    const tmxFooter = `
  </body>
</tmx>`;
    
    const tmxContent = tmxHeader + tmxBody + tmxFooter;

    // 4. L√≥gica para guardar el archivo
    const baseFilename = (fileNameInput.value.trim() || 'TranslationMemory'); 
    const filename = baseFilename.endsWith('.tmx') ? baseFilename : baseFilename + '.tmx';

    try {
        const blob = new Blob([tmxContent], { type: 'text/xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", url);
        downloadAnchorNode.setAttribute("download", filename);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        document.body.removeChild(downloadAnchorNode);
        URL.revokeObjectURL(url);
        
        showMessage(translations[currentLanguage]['file_saved_successfully_tmx'] || "Archivo TMX guardado correctamente.");
    } catch (error) {
        showMessage(errorMessages[currentLanguage]['error_saving_file'] || `Error al guardar el archivo: ${error.message}`);
        console.error("Error saving TMX file:", error);
    }
}

// --- FIN: FUNCIONES DE EXPORTACI√ìN TMX ---

        function generateTBX() {
            const xml = [`<?xml version="1.0" encoding="UTF-8"?><martif type="TBX" xml:lang="${glossarySourceLanguage}"><text><body>`];
            glossary.forEach(entry => {
                xml.push(`<termEntry><LangSet xml:lang="${entry.srcLang}"><tig><term>${entry.srcTerm}</term></tig></LangSet><LangSet xml:lang="${entry.tgtLang}"><tig><term>${entry.tgtTerm}</term></tig></LangSet></termEntry>`);
            });
            xml.push(`</body></text></martif>`);
            return xml.join("\n");
        }

        /**
         * Opens a modal to ask for a filename before downloading the TBX file.
         */
        function downloadTBX() {
            if (glossary.length === 0 && (!glossarySourceLanguage || !glossaryTargetLanguage)) {
                showMessage(errorMessages[currentLanguage]['cannot_download_empty_or_unconfigured_glossary']);
                return;
            }
            fileNameInputTbx.value = 'glossary.tbx';
            saveTbxModal.classList.remove('hidden');
            fileNameInputTbx.focus();
        }

        function loadTBX() {
            if (!tbxFileInput) return;
            tbxFileInput.click();
            tbxFileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                showLoadingOverlay(errorMessages[currentLanguage]['loading_file']);
                try {
                    const reader = new FileReader();
                    await new Promise((resolve, reject) => {
                        reader.onload = () => {
                            try {
                                const parser = new DOMParser();
                                const xmlDoc = parser.parseFromString(reader.result, "application/xml");
                                if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                                    throw new Error("Invalid XML/TBX format: " + xmlDoc.getElementsByTagName("parsererror")[0].textContent);
                                }
                                if (xmlDoc.getElementsByTagName("tu").length > 0) {
                                    showTMInternalMessage(errorMessages[currentLanguage]['tbx_file_expected_tmx_found'], true);
                                    reject(new Error("Attempted to load TMX into Glossary."));
                                    return;
                                }
                                const entries = xmlDoc.getElementsByTagName("termEntry");
                                glossary = [];
                                let firstEntryLangs = { src: '', tgt: '' };
                                if (entries.length > 0) {
                                    const firstSets = entries[0].getElementsByTagName("LangSet");
                                    if (firstSets.length >= 2) {
                                        firstEntryLangs.src = firstSets[0].getAttribute("xml:lang");
                                        firstEntryLangs.tgt = firstSets[1].getAttribute("xml:lang");
                                    }
                                }
                                for (let entry of entries) {
                                    const sets = entry.getElementsByTagName("LangSet");
                                    if (sets.length >= 2) {
                                        const lang1 = sets[0].getAttribute("xml:lang");
                                        const term1 = sets[0].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                                        const lang2 = sets[1].getAttribute("xml:lang");
                                        const term2 = sets[1].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                                        glossary.push({ srcLang: lang1, srcTerm: term1, tgtLang: lang2, tgtTerm: term2 });
                                    }
                                }
                                if (glossary.length > 0 && firstEntryLangs.src && firstEntryLangs.tgt) {
                                    glossarySourceLanguage = firstEntryLangs.src;
                                    glossaryTargetLanguage = firstEntryLangs.tgt;
                                } else if (glossary.length === 0) {
                                    showMessage(errorMessages[currentLanguage]['error_loading_tbx_file']);
                                }
                                showGlossaryEditorSection();
                                updateTranslations();
                                resolve();
                            } catch (error) {
                                reject(error);
                            }
                        };
                        reader.onerror = reject;
                        reader.readAsText(file);
                    });
                } catch (error) {
                    console.error("Error loading TBX file:", error);
                    if (!error.message.includes("Attempted to load TMX")) {
                        showMessage(errorMessages[currentLanguage]['error_loading_tbx_file']);
                    }
                    resetGlossary();
                } finally {
                    hideLoadingOverlay();
                }
            };
        }

        // --- Translation Memory (TM) Logic ---
        function levenshteinDistance(a, b) {
            const an = a.length, bn = b.length;
            if (an === 0) return bn;
            if (bn === 0) return an;
            const matrix = Array(bn + 1).fill(null).map(() => Array(an + 1).fill(null));
            for (let i = 0; i <= an; i++) matrix[0][i] = i;
            for (let i = 0; i <= bn; i++) matrix[i][0] = i;
            for (let i = 1; i <= bn; i++) {
                for (let j = 1; j <= an; j++) {
                    const cost = a[j - 1] === b[i - 1] ? 0 : 1;
                    matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + cost);
                }
            }
            return matrix[bn][an];
        }

        function calculateSimilarity(s1, s2) {
            if (!s1 || !s2) return 0;
            const longerLength = Math.max(s1.length, s2.length);
            if (longerLength === 0) return 100;
            const distance = levenshteinDistance(s1, s2);
            return ((longerLength - distance) / longerLength) * 100;
        }
        
        function renderDiff(tmText, originalText) {
            const dmp = new diff_match_patch();
            const diffs = dmp.diff_main(tmText, originalText);
            dmp.diff_cleanupSemantic(diffs);

            return diffs.map(([op, text]) => {
                const safeText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '&para;<br>');
                switch (op) {
                    case DIFF_INSERT: return `<span class="diff-insertion">${safeText}</span>`;
                    case DIFF_DELETE: return `<span class="diff-deletion">${safeText}</span>`;
                    case DIFF_EQUAL: return safeText;
                }
            }).join('');
        }

        function showTMInternalMessage(msg, isError = false) {
            if (tmInternalMessage) {
                tmInternalMessage.textContent = msg;
                tmInternalMessage.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'border-red-500', 'bg-blue-100', 'text-blue-800', 'border-blue-500');
                tmInternalMessage.classList.add(isError ? 'bg-red-100' : 'bg-blue-100', isError ? 'text-red-800' : 'text-blue-800', isError ? 'border-red-500' : 'border-blue-500');
                tmInternalMessage.classList.remove('hidden');
            }
        }

        function hideTMInternalMessage() {
            if (tmInternalMessage) {
                tmInternalMessage.classList.add('hidden');
                tmInternalMessage.textContent = '';
            }
        }

        function resetTM() {
            translationMemory = [];
            tmSearchInput.value = '';
            renderTMSearchResults([]);
            showTMLanguageConfigSection();
            hideTMInternalMessage(); // Hide the message on reset
        }

        function showTMLanguageConfigSection() {
            if (tmLanguageConfigSection && tmEditorSection) {
                tmLanguageConfigSection.style.display = 'block';
                tmEditorSection.style.display = 'none';
                if (tmConfigSrcLang) tmConfigSrcLang.value = 'en-US';
                if (tmConfigTgtLang) tmConfigTgtLang.value = 'es-ES';
                hideTMInternalMessage();
            }
        }

        function showTMEditorSection() {
            if (tmLanguageConfigSection && tmEditorSection && displayTmSrcLang && displayTmTgtLang) {
                tmLanguageConfigSection.style.display = 'none';
                tmEditorSection.style.display = 'block';
                displayTmSrcLang.value = tmSourceLanguage;
                displayTmTgtLang.value = tmTargetLanguage;
                tmSearch();
                hideTMInternalMessage();
            }
        }

        function confirmTMLanguages() {
            const srcLang = tmConfigSrcLang ? tmConfigSrcLang.value.trim() : '';
            const tgtLang = tmConfigTgtLang ? tmConfigTgtLang.value.trim() : '';
            if (!srcLang || !tgtLang) {
                showTMInternalMessage(errorMessages[currentLanguage]['lang_config_required'], true);
                return;
            }
            tmSourceLanguage = srcLang;
            tmTargetLanguage = tgtLang;
            showTMEditorSection();
        }

        
async function loadTMX(file) {
            showLoadingOverlay(errorMessages[currentLanguage]['loading_file']);
            hideTMInternalMessage();

            // Helper function to unescape XML special characters back to HTML.
            const unescapeXml = (safe) => {
                if (typeof safe !== 'string') return '';
                // The order matters for correctness
                return safe.replace(/&lt;/g, '<')
                           .replace(/&gt;/g, '>')
                           .replace(/&apos;/g, '\'')
                           .replace(/&quot;/g, '"')
                           .replace(/&amp;/g, '&');
            };

            try {
                const reader = new FileReader();
                await new Promise((resolve, reject) => {
                    reader.onload = () => {
                        try {
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(reader.result, "application/xml");
                            const parserError = xmlDoc.getElementsByTagName("parsererror");

                            if (parserError.length > 0) {
                                console.error("Parser Error:", parserError[0].textContent);
                                throw new Error("The file contains invalid XML and could not be parsed.");
                            }
                            
                            if (xmlDoc.getElementsByTagName("termEntry").length > 0) {
                                showTMInternalMessage(errorMessages[currentLanguage]['tmx_file_expected_tbx_found'], true);
                                reject(new Error("Attempted to load TBX into Translation Memory."));
                                return;
                            }
                            
                            const tuElements = xmlDoc.getElementsByTagName("tu");
                            let newTM = [];
                            
                            const header = xmlDoc.getElementsByTagName("header")[0];
                            let detectedSrcLang = header ? header.getAttribute('srclang') : '';
                            let detectedTgtLang = ''; // Target language is not a standard header attribute

                            for (let tu of tuElements) {
                                const tuvElements = tu.getElementsByTagName("tuv");
                                if (tuvElements.length >= 2) {
                                    const srcTuv = tuvElements[0], tgtTuv = tuvElements[1];
                                    const srcLang = srcTuv.getAttribute("xml:lang"), tgtLang = tgtTuv.getAttribute("xml:lang");
                                    
                                    const srcSeg = srcTuv.getElementsByTagName("seg")[0]?.textContent || '';
                                    const tgtSeg = tgtTuv.getElementsByTagName("seg")[0]?.textContent || '';

                                    const unescapedSrcText = unescapeXml(srcSeg);
                                    const unescapedTgtText = unescapeXml(tgtSeg);

                                    newTM.push({
                                        srcLang,
                                        srcText: unescapedSrcText,
                                        tgtLang,
                                        tgtText: unescapedTgtText,
                                        srcWordCount: countWords(unescapedSrcText),
                                        tgtWordCount: countWords(unescapedTgtText)
                                    });
                                    
                                    if (!detectedSrcLang) detectedSrcLang = srcLang;
                                    if (!detectedTgtLang) detectedTgtLang = tgtLang;
                                }
                            }
                            
                            translationMemory = newTM;
                            tmSourceLanguage = detectedSrcLang || (tmConfigSrcLang ? tmConfigSrcLang.value : 'en-US');
                            tmTargetLanguage = detectedTgtLang || (tmConfigTgtLang ? tmConfigTgtLang.value : 'es-ES');
                            
                            showTMInternalMessage(`TMX loaded successfully with ${translationMemory.length} translation units.`);
                            showTMEditorSection();
                            tmSearch();
                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            } catch (error) {
                console.error("Error loading TMX file:", error);
                if (!error.message.includes("Attempted to load TBX")) {
                    showTMInternalMessage(`${errorMessages[currentLanguage]['error_loading_tmx_file']} - ${error.message}`, true);
                }
                resetTM();
            } finally {
                hideLoadingOverlay();
            }
        }



function generateTMX() {
            if (translationMemory.length === 0) {
                showTMInternalMessage(errorMessages[currentLanguage]['cannot_download_empty_tm'], true);
                return null;
            }

            // Helper function to escape characters that are special in XML.
            const escapeXml = (unsafe) => {
                if (typeof unsafe !== 'string') return '';
                return unsafe.replace(/[<>&'"]/g, (c) => {
                    switch (c) {
                        case '<': return '&lt;';
                        case '>': return '&gt;';
                        case '&': return '&amp;';
                        case '\'': return '&apos;';
                        case '"': return '&quot;';
                    }
                });
            };
            
            // Generate a UTC timestamp as required by the TMX standard for creationdate
            const creationDate = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');

            // A more compliant TMX header
            const header = `<?xml version="1.0" encoding="UTF-8"?>\n<tmx version="1.4">\n  <header\n    creationtool="subpandaTM"\n    creationtoolversion="1.0"\n    segtype="sentence"\n    o-tmf="subpandaTM"\n    adminlang="en-US"\n    srclang="${escapeXml(tmSourceLanguage || 'en-US')}"\n    datatype="unknown"\n    creationdate="${creationDate}"\n  >\n  </header>\n  <body>`;
            
            const xml = [header];
            
            translationMemory.forEach(entry => {
                const safeSrcText = escapeXml(entry.srcText);
                const safeTgtText = escapeXml(entry.tgtText);
                
                // Using template literals for better readability and ensuring no extra whitespace
                const tu = `    <tu creationdate="${creationDate}">\n      <tuv xml:lang="${escapeXml(entry.srcLang)}">\n        <seg>${safeSrcText}</seg>\n      </tuv>\n      <tuv xml:lang="${escapeXml(entry.tgtLang)}">\n        <seg>${safeTgtText}</seg>\n      </tuv>\n    </tu>`;
                xml.push(tu);
            });

            xml.push(`  </body>\n</tmx>`);
            // The .join('\n') ensures proper line breaks for readability
            return xml.join('\n');
        }
        /**
         * Opens a modal to ask for a filename before downloading the TMX file.
         */
        function downloadTMX() {
            if (translationMemory.length === 0) {
                showMessage(errorMessages[currentLanguage]['cannot_download_empty_tm']);
                return;
            }
            fileNameInputTmx.value = 'translation_memory.tmx';
            saveTmxModal.classList.remove('hidden');
            fileNameInputTmx.focus();
        }

        function addOrUpdateTMEntry(original, translation) {
            if (!original || !translation || !tmSourceLanguage || !tmTargetLanguage) return;
            const existingIndex = translationMemory.findIndex(e => e.srcText === original && e.srcLang === tmSourceLanguage && e.tgtLang === tmTargetLanguage);
            if (existingIndex !== -1) {
                translationMemory[existingIndex].tgtText = translation;
                translationMemory[existingIndex].tgtWordCount = countWords(translation);
            } else {
                translationMemory.push({ srcLang: tmSourceLanguage, srcText: original, tgtLang: tmTargetLanguage, tgtText: translation, srcWordCount: countWords(original), tgtWordCount: countWords(translation) });
            }
            tmSearch();
        }

        function findBestTMMatch(sourceSegmentText) {
            if (translationMemory.length === 0 || !sourceSegmentText.trim() || !tmSourceLanguage || !tmTargetLanguage) return null;
            let bestMatch = null, highestScore = 0;
            const MIN_FUZZY_THRESHOLD = 70;
            translationMemory.forEach(entry => {
                if (entry.srcLang === tmSourceLanguage && entry.tgtLang === tmTargetLanguage && entry.srcText.trim()) {
                    const score = calculateSimilarity(sourceSegmentText, entry.srcText);
                    if (score >= MIN_FUZZY_THRESHOLD && score > highestScore) {
                        highestScore = score;
                        bestMatch = { ...entry, score: score.toFixed(0) };
                    }
                }
            });
            return bestMatch;
        }

        function tmSearch(activeSegmentOriginalText = null) {
            const query = tmSearchInput ? tmSearchInput.value.toLowerCase().trim() : '';
            if (!activeSegmentOriginalText) {
                const currentFocused = getCurrentFocusedIndex();
                if (currentFocused && srtEntries[currentFocused.entryIndex]) {
                    activeSegmentOriginalText = srtEntries[currentFocused.entryIndex].original;
                }
            }

            const filteredTM = translationMemory.filter(entry => {
                if (query) {
                    return (entry.srcText && entry.srcText.toLowerCase().includes(query)) || (entry.tgtText && entry.tgtText.toLowerCase().includes(query));
                }
                return true;
            });

            let resultsToRender = filteredTM.map(entry => {
                let score = 0;
                let diffHtml = entry.srcText;
                if (activeSegmentOriginalText) {
                    score = calculateSimilarity(activeSegmentOriginalText, entry.srcText);
                    diffHtml = renderDiff(entry.srcText, activeSegmentOriginalText);
                } else if (query) {
                    score = calculateSimilarity(query, entry.srcText);
                }
                return { ...entry, score: score.toFixed(0), diffHtml: diffHtml };
            });

            resultsToRender.sort((a, b) => b.score - a.score);

            const MIN_FUZZY_THRESHOLD = 70;
            resultsToRender.forEach((result, index) => {
                result.isBestMatch = index === 0 && result.score >= MIN_FUZZY_THRESHOLD;
            });

            currentTMLatestSearchResults = resultsToRender;
            renderTMSearchResults(resultsToRender);
        }

        function renderTMSearchResults(results) {
            if (!tmSearchResultsTableBody) return;
            const t = translations[currentLanguage];
            tmSearchResultsTableBody.innerHTML = '';
            if (results.length === 0) {
                if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.remove('hidden');
                return;
            } 
            if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.add('hidden');
            
            hideTMInternalMessage();
            results.forEach(entry => {
                const row = document.createElement('tr');
                if (entry.isBestMatch) row.classList.add('tm-best-match-highlight');
                
                const originalContent = (entry.diffHtml || entry.srcText).replace(/\n/g, '<br>');
                const translationContent = entry.tgtText.replace(/\n/g, '<br>');

                row.innerHTML = `<td>${entry.score}%</td><td class="align-top">${originalContent}</td><td class="align-top">${translationContent}</td>`;
                
                row.addEventListener('click', () => {
                    const currentFocused = getCurrentFocusedIndex();
                    if (currentFocused) {
                        const targetEditor = document.getElementById(`translation-${currentFocused.entryIndex}`);
                        if (targetEditor && targetEditor.contentEditable === 'true') {
                            targetEditor.innerHTML = entry.tgtText;
                            const event = new Event('input', { bubbles: true });
                            targetEditor.dispatchEvent(event);
                        }
                    }
                });
                tmSearchResultsTableBody.appendChild(row);
            });
        }

        function showLoadingOverlay(message) {
            if (loadingMessage && loadingOverlay) {
                loadingMessage.textContent = message;
                loadingOverlay.classList.remove('hidden');
            }
        }

        function hideLoadingOverlay() {
            if (loadingOverlay) {
                loadingOverlay.classList.add('hidden');
            }
        }

        if (dropArea) {
            dropArea.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.add('border-blue-500');
            });
            dropArea.addEventListener('dragleave', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-blue-500');
            });
            dropArea.addEventListener('drop', async (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-blue-500');
                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    const fileToProcess = Array.from(files).find(file => file.name.toLowerCase().endsWith('.srt') || file.name.toLowerCase().endsWith('.subpanda'));
                    if (fileToProcess.name.toLowerCase().endsWith('.srt')) {
                        await processFile(fileToProcess);
                    } else if (fileToProcess.name.toLowerCase().endsWith('.subpanda')) {
                        await loadProject({ target: { files: [fileToProcess] } });
                    } else {
                         showMessage('Por favor, suelta un archivo .srt o .subpanda v√°lido.');
                    }
                }
            });
        }

        if (addTermHeader && addTermContent && addTermAccordionIcon) {
            addTermHeader.addEventListener('click', () => {
                const isCollapsed = addTermContent.classList.contains('collapsed');
                if (isCollapsed) {
                    addTermContent.classList.remove('collapsed');
                    addTermContent.classList.add('expanded');
                    addTermAccordionIcon.classList.remove('rotated');
                } else {
                    addTermContent.classList.remove('expanded');
                    addTermContent.classList.add('collapsed');
                    addTermAccordionIcon.classList.add('rotated');
                }
            });
        }

        if (statsAccordionHeader && statsAccordionContent && statsAccordionIcon) {
            statsAccordionHeader.addEventListener('click', () => {
                const isCollapsed = statsAccordionContent.classList.contains('collapsed');
                if (isCollapsed) {
                    statsAccordionContent.classList.remove('collapsed');
                    statsAccordionContent.classList.add('expanded');
                    statsAccordionIcon.classList.remove('rotated');
                } else {
                    statsAccordionContent.classList.remove('expanded');
                    statsAccordionContent.classList.add('collapsed');
                    statsAccordionIcon.classList.add('rotated');
                }
            });
        }

        videoFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                videoFileName = file.name; // Store video file name
                const videoURL = URL.createObjectURL(file);
                videoPlayer.src = videoURL;
                wavesurfer.load(videoURL);
                document.getElementById('waveform').classList.remove('hidden');
                videoPlayer.controls = true;
                videoPlayer.load();
                     
                document.getElementById('videoLogoPlaceholder').classList.add('hidden');
        
                const loadVideoBtnSpan = document.querySelector('#loadVideoBtn span');
                if (loadVideoBtnSpan) {
                    loadVideoBtnSpan.textContent = translations[currentLanguage]['change_video'];
                }
            } else {
                showMessage(errorMessages[currentLanguage]['video_load_error']);
            }
        });

        /**
         * Jumps the video player to the start time of the specified subtitle and plays until the end time.
         * @param {number} entryIndex The index of the SRT entry to play.
         */
        function jumpToCurrentSubtitleTime(entryIndex) {
            if (srtEntries[entryIndex] && videoPlayer.src) {
                const entry = srtEntries[entryIndex];
                // CORRECCI√ìN: Quitamos el "- 200". Ahora se detiene justo al final.
                const stopTime = entry.endTimeMs / 1000; 
                videoPlayer.currentTime = entry.startTimeMs / 1000;
                videoPlayer.play();

                if (timeUpdateListener) {
                    videoPlayer.removeEventListener('timeupdate', timeUpdateListener);
                }

                timeUpdateListener = () => {
                    // CORRECCI√ìN: El listener ahora tambi√©n se detiene si el v√≠deo se pausa
                    // por cualquier otro motivo (ej. el usuario le da a la pausa).
                    if (videoPlayer.currentTime >= stopTime || videoPlayer.paused) {
                        videoPlayer.pause(); // Pausa
                        videoPlayer.removeEventListener('timeupdate', timeUpdateListener);
                        timeUpdateListener = null;
                    }
                };
                
                videoPlayer.addEventListener('timeupdate', timeUpdateListener);

// Centra la vista de la onda en la regi√≥n (A√ëADIDO)
                 if (wsRegions) {
                     const region = wsRegions.getRegions().find(r => r.id === entry.regionId);
                     if (region) {
                         // Centrar la regi√≥n en la vista de la onda
                         const duration = wavesurfer.getDuration();
                         const regionCenter = (region.start + region.end) / 2;
                         // Opcional: un peque√±o zoom si es necesario
                         // wavesurfer.zoom(Number(document.getElementById('zoom-slider')?.value || 100));
         }
                 }
             }
        } // Fin de jumpToCurrentSubtitleTime
       
/**
 * Gestiona el resaltado y scroll autom√°tico durante la reproducci√≥n si el seguimiento est√° activo.
 */
function handlePlaybackTracking() {
    if (!isFollowPlaybackActive || !videoPlayer.src || srtEntries.length === 0 || !wsRegions) {
        // Si la funci√≥n est√° desactivada o no hay nada que seguir, limpiamos resaltados
        clearPlaybackHighlights();
        return;
    }

    const currentTime = videoPlayer.currentTime;
    let activeEntryIndex = -1;
    let activeEntry = null;

    // Encuentra el subt√≠tulo activo (igual que en updateSubtitlePreview)
    for (let i = 0; i < srtEntries.length; i++) {
        const entry = srtEntries[i];
        const startTime = entry.startTimeMs / 1000;
        const endTime = entry.endTimeMs / 1000;
        if (currentTime >= startTime && currentTime < endTime) { // Usamos < endTime para evitar solapamientos
            activeEntryIndex = i;
            activeEntry = entry;
            break;
        }
    }

    // Si NO encontramos un subt√≠tulo activo
    if (activeEntryIndex === -1) {
        clearPlaybackHighlights();
        currentlyTrackedRegionId = null;
        currentlyTrackedEditorIndex = -1;
// --- INICIO C√ìDIGO A√ëADIDO ---
        // Limpiar la clase activa si no hay ning√∫n subt√≠tulo en reproducci√≥n
        if (lastFocusedEditorUnitIndex !== -1) {
            const prevUnit = document.getElementById(`translation-unit-${lastFocusedEditorUnitIndex}`);
            if (prevUnit) prevUnit.classList.remove('translation-unit-active');
            lastFocusedEditorUnitIndex = -1;
        }
        // --- FIN C√ìDIGO A√ëADIDO ---
        return;
    }

    // Si el subt√≠tulo activo es el MISMO que ya est√°bamos siguiendo, no hacemos nada m√°s
    if (currentlyTrackedEditorIndex === activeEntryIndex) {
        return;
    }

    // --- HEMOS ENCONTRADO UN NUEVO SUBT√çTULO ACTIVO ---

    // 1. Limpia los resaltados anteriores
    clearPlaybackHighlights();

    // 2. Resalta la nueva regi√≥n en la onda
    const activeRegion = wsRegions.getRegions().find(r => r.id === activeEntry.regionId);
    if (activeRegion && activeRegion.element) {
        activeRegion.element.classList.add('region-playback-active');
        currentlyTrackedRegionId = activeEntry.regionId; // Guarda el ID actual
    }

    // 3. Haz scroll y activa el foco en el editor
        const editorUnit = document.getElementById(`translation-unit-${activeEntryIndex}`);
        if (editorUnit) {
            // --- INICIO C√ìDIGO A√ëADIDO ---
            // Busca el div editable DENTRO de la unidad del subt√≠tulo
            const editorDiv = editorUnit.querySelector(`div[contenteditable="true"][data-entry-index="${activeEntryIndex}"]`);
            // --- FIN C√ìDIGO A√ëADIDO ---

            // Solo hacemos scroll si el elemento no est√° ya visible en el centro
            const rect = editorUnit.getBoundingClientRect();
            // CORRECCI√ìN: Aseg√∫rate de que parentElement.parentElement existe
            const parentContainer = document.getElementById('editorMainContent'); // Usar ID es m√°s seguro
            const parentRect = parentContainer ? parentContainer.getBoundingClientRect() : null;
            const isVisible = parentRect && rect.top >= parentRect.top && rect.bottom <= parentRect.bottom;


            if (!isVisible) {
                 editorUnit.scrollIntoView({ behavior: 'smooth', block: 'center' });
                 // --- C√ìDIGO A√ëADIDO (Focus despu√©s del scroll) ---
                 // A√±adimos un peque√±o retardo para asegurar que el scroll ha terminado
                 // antes de intentar poner el foco, especialmente con 'smooth' scroll.
                 if (editorDiv) {
// --- INICIO C√ìDIGO A√ëADIDO ---
                // Limpiar la clase del anterior subt√≠tulo con foco si existe
                if (lastFocusedEditorUnitIndex !== -1 && lastFocusedEditorUnitIndex !== activeEntryIndex) {
                    const prevUnit = document.getElementById(`translation-unit-${lastFocusedEditorUnitIndex}`);
                    if (prevUnit) prevUnit.classList.remove('translation-unit-active');
                }
                // A√±adir la clase al actual
                if (editorUnit) editorUnit.classList.add('translation-unit-active');
                lastFocusedEditorUnitIndex = activeEntryIndex; // Actualizar
                // --- FIN C√ìDIGO A√ëADIDO ---
                    setTimeout(() => editorDiv.focus(), 300); // 300ms de retardo
                 }
                 // --- FIN C√ìDIGO A√ëADIDO ---
            } else {
                // --- C√ìDIGO A√ëADIDO (Focus si ya es visible) ---
                 // Si ya estaba visible, ponemos el foco directamente
                 if (editorDiv && document.activeElement !== editorDiv) {
// --- INICIO C√ìDIGO A√ëADIDO ---
                // Limpiar la clase del anterior subt√≠tulo con foco si existe
                if (lastFocusedEditorUnitIndex !== -1 && lastFocusedEditorUnitIndex !== activeEntryIndex) {
                    const prevUnit = document.getElementById(`translation-unit-${lastFocusedEditorUnitIndex}`);
                    if (prevUnit) prevUnit.classList.remove('translation-unit-active');
                }
                // A√±adir la clase al actual
                if (editorUnit) editorUnit.classList.add('translation-unit-active');
                lastFocusedEditorUnitIndex = activeEntryIndex; // Actualizar
                // --- FIN C√ìDIGO A√ëADIDO ---
                     editorDiv.focus();
                 }
                 // --- FIN C√ìDIGO A√ëADIDO ---
            }

            currentlyTrackedEditorIndex = activeEntryIndex; // Guarda el √≠ndice actual
        }
    }

/**
 * Limpia los resaltados visuales aplicados por handlePlaybackTracking.
 */
function clearPlaybackHighlights() {
    // Limpiar regi√≥n de la onda
    if (currentlyTrackedRegionId && wsRegions) {
        const previousRegion = wsRegions.getRegions().find(r => r.id === currentlyTrackedRegionId);
        if (previousRegion && previousRegion.element) {
            previousRegion.element.classList.remove('region-playback-active');
        }
    }
    // Limpiar editor (si a√±adiste una clase espec√≠fica)
    // if (currentlyTrackedEditorIndex !== -1) {
    //     const previousEditorUnit = document.getElementById(`translation-unit-${currentlyTrackedEditorIndex}`);
    //     if (previousEditorUnit) {
    //         previousEditorUnit.classList.remove('playback-active');
    //     }
    // }
}
 
        /**
         * Updates the subtitle preview overlay based on the video's current time and user selection.
         */
        function updateSubtitlePreview() {
            if (!videoPlayer.src || srtEntries.length === 0) {
                subtitlePreviewText.innerHTML = '';
                return;
            }



            const currentTime = videoPlayer.currentTime;
            let activeSubtitle = null;

            for (const entry of srtEntries) {
                const startTime = entry.startTimeMs / 1000;
                const endTime = entry.endTimeMs / 1000;
                if (currentTime >= startTime && currentTime <= endTime) {
                    activeSubtitle = entry;
                    break;
                }
            }

            if (activeSubtitle) {
                let textToShow = '';
                if (previewSource === 'translation') {
                    textToShow = activeSubtitle.translation.trim() || activeSubtitle.original;
                } else {
                    textToShow = activeSubtitle.original;
                }
                subtitlePreviewText.innerHTML = textToShow;
            } else {
                subtitlePreviewText.innerHTML = '';
            }
        }
        
// A√ëADE ESTAS DOS FUNCIONES NUEVAS
/**
 * Actualiza el tama√±o de la fuente de los subt√≠tulos en la vista previa.
 * @param {number} newSize - El nuevo tama√±o de la fuente en p√≠xeles.
 */
// C√ìDIGO CORREGIDO
function updateFontSize(newSize) {
    if (newSize < 10 || newSize > 60) return;

    subtitleFontSize = newSize;
    fontSizeDisplay.textContent = `${subtitleFontSize}px`;
    document.documentElement.style.setProperty('--user-font-size', `${subtitleFontSize}px`);

    // --- L√ìGICA A√ëADIDA ---
    // Si estamos en pantalla completa, actualiza el tama√±o directamente.
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
    if (isFullscreen) {
        const fullscreenSize = subtitleFontSize + 26;
        subtitlePreviewText.style.fontSize = `${fullscreenSize}px`;
    }
}

/**
 * Establece la fuente de texto para la vista previa (original o traducci√≥n).
 * @param {string} source - Puede ser 'original' o 'translation'.
 */
function setPreviewSource(source) {
    previewSource = source;

    // Actualiza la clase 'active' en los botones
    setPreviewOriginal.classList.toggle('active', source === 'original');
    setPreviewTranslation.classList.toggle('active', source === 'translation');

    // Refresca la vista previa inmediatamente
    updateSubtitlePreview();
}

function toggleFullscreen() {
    // Comprueba si ya estamos en modo pantalla completa
    if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
        // Si no lo estamos, solicita la pantalla completa para el CONTENEDOR
        if (videoPlayerWrapper.requestFullscreen) {
            videoPlayerWrapper.requestFullscreen();
        } else if (videoPlayerWrapper.webkitRequestFullscreen) { /* Safari */
            videoPlayerWrapper.webkitRequestFullscreen();
        } else if (videoPlayerWrapper.msRequestFullscreen) { /* IE11 */
            videoPlayerWrapper.msRequestFullscreen();
        }
    } else {
        // Si ya estamos en pantalla completa, salimos
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen();
        }
    }
}

function goToSubtitleByNumber() {
    if (srtEntries.length === 0) return;
    const targetIndex = parseInt(goToSubtitleInput.value, 10);
    if (isNaN(targetIndex) || targetIndex < 1 || targetIndex > srtEntries.length) {
        showMessage(`Por favor, introduce un n√∫mero entre 1 y ${srtEntries.length}.`);
        return;
    }
    // El usuario introduce el √≠ndice 1, pero en el array es el 0.
    navigateToTranslation(targetIndex - 1);
}

/**
 * Navega al subt√≠tulo m√°s cercano a un timecode espec√≠fico.
 */
function goToSubtitleByTimecode() {
    if (srtEntries.length === 0 || !videoPlayer.src) return;
    try {
        let targetTimeMs;
if (useFrameTimecode) {
    targetTimeMs = parseFrameTime(goToTimecodeInput.value, projectFPS);
} else {
    targetTimeMs = parseTime(goToTimecodeInput.value);
}
        videoPlayer.currentTime = targetTimeMs / 1000;

        // Buscamos el subt√≠tulo cuyo inicio es m√°s cercano (pero no posterior) al tiempo introducido.
        let foundIndex = 0;
        for (let i = 0; i < srtEntries.length; i++) {
            if (srtEntries[i].startTimeMs <= targetTimeMs) {
                foundIndex = i;
            } else {
                break;
            }
        }
        navigateToTranslation(foundIndex);
    } catch (error) {
        showMessage("El formato del timecode no es v√°lido. Usa HH:MM:SS,ms");
    }
}

// --- START: Subtitle Structural Editing & Undo/Redo Logic ---

        function saveStructuralState(oldState, newState) {
            // A√ëADIR ESTA L√çNEA ->
            if (isApplyingState) return;
            historyStack.push({ type: 'structural', oldState, newState });
            redoStack = []; // Un nuevo cambio borra el historial de "rehacer"
            updateUndoRedoButtons();
        }



        /** <- A√ëADIR ESTE BLOQUE COMPLETO ->
         * Guarda el estado de un cambio de tiempo en el historial.
         * @param {number} entryIndex - El √≠ndice del subt√≠tulo modificado.
         * @param {object} oldValue - {startTimeMs, endTimeMs} ANTES del cambio.
         * @param {object} newValue - {startTimeMs, endTimeMs} DESPU√âS del cambio.
         */
        function saveTimeChange(entryIndex, oldValue, newValue) {
            if (isApplyingState) return;
            // No guardar si los tiempos no han cambiado realmente
            if (oldValue.startTimeMs === newValue.startTimeMs && oldValue.endTimeMs === newValue.endTimeMs) return;

            historyStack.push({ type: 'timeChange', entryIndex, oldValue, newValue });
            redoStack = [];
            updateUndoRedoButtons();
        }
        // <- FIN DEL BLOQUE A√ëADIDO ->

        
        /**
         * Deshace la √∫ltima acci√≥n del historial (textual o estructural).
         */
        function undo() {
            if (historyStack.length === 0) return;

            isApplyingState = true;
            const lastAction = historyStack.pop();
            redoStack.push(lastAction); // Guardamos la acci√≥n en la pila de "rehacer"

            if (lastAction.type === 'structural') {
                // Si es un cambio estructural, restauramos toda la lista de subt√≠tulos
                srtEntries = JSON.parse(JSON.stringify(lastAction.oldState));
                renderTranslations(srtEntries, 0, true);
           } else if (lastAction.type === 'timeChange') { // <-- CORREGIDO
            // --- NUEVO: Manejar deshacer cambio de tiempo ---
            const { entryIndex, oldValue } = lastAction; // <-- CORREGIDO
            const entry = srtEntries[entryIndex];
            if (entry) {
                entry.startTimeMs = oldValue.startTimeMs;
                entry.endTimeMs = oldValue.endTimeMs;
                updateEntryTimes(entryIndex); // Actualiza UI y regi√≥n de la onda
            }
        } else { // <-- MODIFICAR: Este 'else' ahora solo maneja 'text'
            // Manejar cambio de texto
            const { entryIndex, newValue } = lastUndo;
            const entry = srtEntries[entryIndex];
            const editor = document.getElementById(`translation-${entryIndex}`);
                if (entry && editor) {
                    entry.translation = newValue; // <-- CORREGIDO
                    editor.innerHTML = newValue;  // <-- CORREGIDO
                    editor.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }

            updateUndoRedoButtons();
            isApplyingState = false;
        }

        /**
         * Rehace la √∫ltima acci√≥n deshecha (textual o estructural).
         */
        function redo() {
            if (redoStack.length === 0) return;
            isApplyingState = true;
            const lastUndo = redoStack.pop();
            historyStack.push(lastUndo); // Devolvemos la acci√≥n al historial principal

            if (lastUndo.type === 'structural') {
                // Si es un cambio estructural, aplicamos el nuevo estado
                srtEntries = JSON.parse(JSON.stringify(lastUndo.newState));
                renderTranslations(srtEntries, 0, true);
            } else {
                // Si es un cambio de texto, aplicamos el nuevo texto
                const { entryIndex, newValue } = lastUndo;
                const entry = srtEntries[entryIndex];
                const editor = document.getElementById(`translation-${entryIndex}`);
                if (entry && editor) {
                    entry.translation = newValue;
                    editor.innerHTML = newValue;
                    editor.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }

            updateUndoRedoButtons();
            isApplyingState = false;
        }


        /**
         * Vuelve a numerar los √≠ndices de los subt√≠tulos despu√©s de una modificaci√≥n (a√±adir/eliminar).
         * @param {number} startIndex - El √≠ndice del array a partir del cual empezar a renumerar.
         */
        function renumberSubtitles(startIndex = 0) {
            for (let i = startIndex; i < srtEntries.length; i++) {
                srtEntries[i].index = i + 1;
            }
        }

        /**
         * Fusiona un subt√≠tulo con el siguiente.
         * @param {number} entryIndex - El √≠ndice del subt√≠tulo actual.
         */
        function mergeWithNext(entryIndex) {
            if (entryIndex >= srtEntries.length - 1) return; // No se puede fusionar el √∫ltimo

            const oldState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado PREVIO

            const currentEntry = srtEntries[entryIndex];
            const nextEntry = srtEntries[entryIndex + 1];

            currentEntry.original += `\n${nextEntry.original}`;
            currentEntry.translation += `<br>${nextEntry.translation}`;
            currentEntry.endTimeMs = nextEntry.endTimeMs;
            currentEntry.durationMs = currentEntry.endTimeMs - currentEntry.startTimeMs;
            currentEntry.timecodes = `${formatTime(currentEntry.startTimeMs)} --> ${formatTime(currentEntry.endTimeMs)}`;

            srtEntries.splice(entryIndex + 1, 1);
            renumberSubtitles(entryIndex + 1);
            
            const newState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado POSTERIOR
            saveStructuralState(oldState, newState); // Registrar en el historial

            renderTranslations(srtEntries, entryIndex, true);
        }

        /**
         * Separa un subt√≠tulo en dos en la posici√≥n del cursor.
         * @param {number} entryIndex - El √≠ndice del subt√≠tulo a separar.
         */
        /**
         * Separa un subt√≠tulo en dos en la posici√≥n del cursor.
         * @param {number} entryIndex - El √≠ndice del subt√≠tulo a separar.
         */
        function splitSubtitle(entryIndex) {
            const editor = document.getElementById(`translation-${entryIndex}`);
            const selection = window.getSelection();
            if (!editor || !selection.rangeCount > 0) return;

            const range = selection.getRangeAt(0);
            const splitPoint = range.startOffset;
            const textContent = editor.innerText;

            if (splitPoint === 0 || splitPoint === textContent.length) {
                showMessage("Coloca el cursor en el punto donde quieres separar el subt√≠tulo.");
                return;
            }
            
            const oldState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado PREVIO

            // --- INICIO DE LA MODIFICACI√ìN ---

            // 1. Calculamos el hueco de 2 fotogramas
            const frameDurationMs = Math.round(1000 / projectFPS);
            const gapMs = frameDurationMs * 2;

            const currentEntry = srtEntries[entryIndex];
            const firstPartTranslation = editor.innerHTML.substring(0, splitPoint);
            const secondPartTranslation = editor.innerHTML.substring(splitPoint);

            const splitRatio = splitPoint / textContent.length;
            const originalSplitPoint = Math.round(currentEntry.original.length * splitRatio);
            const firstPartOriginal = currentEntry.original.substring(0, originalSplitPoint).trim();
            const secondPartOriginal = currentEntry.original.substring(originalSplitPoint).trim();

            // 2. Calculamos los nuevos tiempos
            const midPointTimeMs = currentEntry.startTimeMs + Math.round(currentEntry.durationMs * splitRatio);
            
            // El primer subt√≠tulo termina en el punto de corte
            const firstPartEndTimeMs = midPointTimeMs;
            
            // El segundo subt√≠tulo empieza DESPU√âS del hueco
            let secondPartStartTimeMs = midPointTimeMs + gapMs;

            // Guardamos el tiempo final original
            const originalEndTimeMs = currentEntry.endTimeMs;

            // 3. Comprobaci√≥n de seguridad:
            // Si el hueco de 2 fotogramas es tan grande que "come" todo el segundo subt√≠tulo...
            if (secondPartStartTimeMs >= originalEndTimeMs) {
                // ...lo forzamos a tener una duraci√≥n m√≠nima (ej. 1 fotograma)
                secondPartStartTimeMs = originalEndTimeMs - frameDurationMs;
                // Y nos aseguramos de que el primero no se solape
                if (firstPartEndTimeMs >= secondPartStartTimeMs) {
                    firstPartEndTimeMs = secondPartStartTimeMs - 1; // Dejamos 1ms de separaci√≥n
                }
            }

            // 4. Creamos y actualizamos los subt√≠tulos con los tiempos corregidos

            const newEntry = { 
                ...currentEntry, 
                index: currentEntry.index + 1, 
                original: secondPartOriginal, 
                translation: secondPartTranslation, 
                startTimeMs: secondPartStartTimeMs,         // <--- MODIFICADO
                endTimeMs: originalEndTimeMs,               // <--- MODIFICADO (usa el final original)
                durationMs: originalEndTimeMs - secondPartStartTimeMs, // <--- MODIFICADO
                timecodes: `${formatTime(secondPartStartTimeMs)} --> ${formatTime(originalEndTimeMs)}` // <--- MODIFICADO
            };
            
            delete newEntry.regionId; // (Esto es de tu correcci√≥n anterior, y est√° perfecto)

            currentEntry.original = firstPartOriginal;
            currentEntry.translation = firstPartTranslation;
            currentEntry.endTimeMs = firstPartEndTimeMs;        // <--- MODIFICADO
            currentEntry.durationMs = currentEntry.endTimeMs - currentEntry.startTimeMs;
            currentEntry.timecodes = `${formatTime(currentEntry.startTimeMs)} --> ${formatTime(firstPartEndTimeMs)}`; // <--- MODIFICADO
            
            // --- FIN DE LA MODIFICACI√ìN ---

            srtEntries.splice(entryIndex + 1, 0, newEntry);
            renumberSubtitles(entryIndex + 1);
            
            const newState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado POSTERIOR
            saveStructuralState(oldState, newState); // Registrar en el historial

            renderTranslations(srtEntries, entryIndex + 1, true);
        }

        /**
         * Muestra un di√°logo de confirmaci√≥n antes de eliminar un subt√≠tulo.
         * @param {number} entryIndex - El √≠ndice del subt√≠tulo a eliminar.
         */
        function confirmDeleteSubtitle(entryIndex) {
            // Usamos la clave del objeto de traducciones para el mensaje
            if (confirm(translations[currentLanguage]['delete_subtitle_confirm'])) {
                deleteSubtitle(entryIndex);
            }
        }
        
        /**
         * Elimina un subt√≠tulo del proyecto.
         * @param {number} entryIndex - El √≠ndice del subt√≠tulo a eliminar.
         */
        function deleteSubtitle(entryIndex) {
            const oldState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado PREVIO
            
            srtEntries.splice(entryIndex, 1);
            renumberSubtitles(entryIndex);
            
            const newState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado POSTERIOR
            saveStructuralState(oldState, newState); // Registrar en el historial
            
            const newIndexToFocus = Math.min(entryIndex, srtEntries.length - 1);
            renderTranslations(srtEntries, newIndexToFocus, true);
        }
        
        // --- END: Subtitle Structural Editing & Undo/Redo Logic ---
        // --- Backup and Restore Functions ---
        function getProjectState() {
            if (srtEntries.length === 0) return null;
            return {
                fileName: currentFileName, srtEntries: srtEntries,
                glossary: { data: glossary, sourceLang: glossarySourceLanguage, targetLang: glossaryTargetLanguage },
                translationMemory: { data: translationMemory, sourceLang: tmSourceLanguage, targetLang: tmTargetLanguage },
                qaSettings: qaSettings, lastModified: new Date(),
 sessionPlan: sessionPlan
            };
        }

        async function saveBackup() {
            const projectState = getProjectState();
            if (!projectState) {
                backupBtn.classList.remove('animate-pulse-yellow');
                return;
            }
            try {
                await db.projects.put({ id: 1, ...projectState });
                backupBtn.classList.add('animate-pulse-yellow');
            } catch (error) {
                console.error('Error saving backup to IndexedDB:', error);
            }
        }
        
        function restoreProject(backupData) {
            currentFileName = backupData.fileName;
            srtEntries = backupData.srtEntries;
            glossary = backupData.glossary.data || [];
            glossarySourceLanguage = backupData.glossary.sourceLang;
            glossaryTargetLanguage = backupData.glossary.targetLang;
            translationMemory = backupData.translationMemory.data || [];
            tmSourceLanguage = backupData.translationMemory.sourceLang;
            tmTargetLanguage = backupData.translationMemory.targetLang;
            qaSettings = backupData.qaSettings || { cpsLimit: 20, charsPerLineLimit: 42 };
            
            renderTranslations(srtEntries);
            showGlossaryEditorSection();
            showTMEditorSection();
            
            showMessage(errorMessages[currentLanguage]['project_restored_message']);
        }

        // --- QA Functions ---
        function runFullQaCheck() {
            srtEntries.forEach((entry, index) => {
                const editorDiv = document.getElementById(`translation-${index}`);
                if (editorDiv) {
                    updateSubtitleStats(editorDiv, entry.charCountOriginal, entry.durationMs);
                }
            });
            updateStatsDisplay();
        }

        function calculateAllQaErrors() {
            const errors = [];
            srtEntries.forEach((entry, index) => {
                const errorTypes = new Set();
                const currentCPS = calculateCPS(entry.translation, entry.durationMs);
                if (currentCPS > qaSettings.cpsLimit) {
                    errorTypes.add('CPS');
                }
                const lines = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '').split('\n');
                lines.forEach(line => {
                    if (countCharactersWithoutTags(line) > qaSettings.charsPerLineLimit) {
                        errorTypes.add('Line length');
                    }
                });

                if (errorTypes.size > 0) {
                    errors.push({
                        index: index,
                        subtitleIndex: entry.index,
                        text: entry.translation.replace(/<[^>]+>/g, ' ').substring(0, 50) + '...',
                        errors: Array.from(errorTypes)
                    });
                }
            });
            return errors;
        }

        function renderQaErrorList() {
            const errors = calculateAllQaErrors();
            qaErrorListContainer.innerHTML = '';
            const t = translations[currentLanguage];
            if (errors.length === 0) {
                qaErrorListContainer.textContent = t.qa_no_errors;
                return;
            }
            
            errors.forEach(error => {
                const errorItem = document.createElement('div');
                errorItem.className = 'qa-error-item';
                errorItem.dataset.entryIndex = error.index;
                errorItem.innerHTML = `
                    <div class="font-bold">Subtitle #${error.subtitleIndex} <span class="text-red-500">(${error.errors.join(', ')})</span></div>
                    <div class="text-sm text-gray-600">${error.text}</div>
                `;
                qaErrorListContainer.appendChild(errorItem);
            });
        }

        // --- Project Save/Load Functions ---
async function saveProject(filename) {
            if (srtEntries.length === 0) {
                showMessage(errorMessages[currentLanguage]['no_project_to_save']);
                return;
            }
            showLoadingOverlay(translations[currentLanguage]['saving_file']);

            const projectData = {
                version: '1.0',
                srtEntries,
                glossary,
                glossarySourceLanguage,
                glossaryTargetLanguage,
                translationMemory,
                tmSourceLanguage,
                tmTargetLanguage,
                qaSettings,
                videoFileName,
                sessionPlan,
                currentLanguage
            };

            try {
                const zip = new JSZip();
                zip.file("project.json", JSON.stringify(projectData, null, 2));

                const content = await zip.generateAsync({ type: "blob" });
                
                const a = document.createElement("a");
                const url = URL.createObjectURL(content);
                a.href = url;
                a.download = filename.endsWith('.subpanda') ? filename : filename + '.subpanda'; // <-- L√çNEA MODIFICADA
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(url);
                a.remove();
                
                showMessage('Proyecto guardado con √©xito.');
                
                // --- L√ìGICA A√ëADIDA ---
                if (typeof afterSaveAction === 'function') {
                    afterSaveAction();
                    afterSaveAction = null; // Resetea la acci√≥n
                }
                // --- FIN DE L√ìGICA A√ëADIDA ---

            } catch (error) {
                console.error("Error saving project:", error);
                showMessage('Error al guardar el proyecto.');
                afterSaveAction = null; // Resetea tambi√©n en caso de error
            } finally {
                hideLoadingOverlay();
            }
        }
        async function loadProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoadingOverlay(translations[currentLanguage]['loading_file']);
            try {
                const zip = await JSZip.loadAsync(file);
                const projectJsonFile = zip.file("project.json");

                if (!projectJsonFile) {
                    throw new Error("Archivo de proyecto inv√°lido: no se encontr√≥ project.json.");
                }

                const projectData = JSON.parse(await projectJsonFile.async("string"));
                
currentFileName = file.name;

 historyStack = [];
                    redoStack = [];
                    updateUndoRedoButtons();

                restoreProjectState(projectData);

                showMessage(errorMessages[currentLanguage]['project_loaded_success']);
                
                if (projectData.videoFileName) {
                    reselectVideoInfo.textContent = translations[currentLanguage]['reselect_video_prompt'].replace('{0}', projectData.videoFileName);
                    reselectVideoModal.classList.remove('hidden');
                }

            } catch (error) {
                console.error("Error loading project:", error);
                showMessage(`${errorMessages[currentLanguage]['error_loading_project']}: ${error.message}`);
            } finally {
                hideLoadingOverlay();
                event.target.value = ''; // Reset file input
            }
        }

        function restoreProjectState(data) {
            srtEntries = data.srtEntries || [];
            glossary = data.glossary || [];
            glossarySourceLanguage = data.glossarySourceLanguage || '';
            glossaryTargetLanguage = data.glossaryTargetLanguage || '';
            translationMemory = data.translationMemory || [];
            tmSourceLanguage = data.tmSourceLanguage || '';
            tmTargetLanguage = data.tmTargetLanguage || '';
            qaSettings = data.qaSettings || { cpsLimit: 20, charsPerLineLimit: 42 };
            videoFileName = data.videoFileName || null;
sessionPlan = data.sessionPlan || [];

            setLanguage(data.currentLanguage || 'es');
            
            renderTranslations(srtEntries);

renderPlanner();
            
            if (glossarySourceLanguage) {
                showGlossaryEditorSection();
            } else {
                showLanguageConfigSection();
            }

            if (tmSourceLanguage) {
                showTMEditorSection();
            } else {
                showTMLanguageConfigSection();
            }
        }

        function resetApplicationState() {
            srtEntries = [];
            currentFileName = 'subtitles.srt';
            videoFileName = null;
            
historyStack = [];
            redoStack = [];
            updateUndoRedoButtons();

            resetGlossary();
            resetTM();
            
            videoPlayer.pause();
            videoPlayer.src = '';
if (wavesurfer) {
                wavesurfer.empty();
clearSubtitleRegions();
                document.getElementById('waveform').classList.add('hidden');
            }
sessionPlan = []; // <-- A√ëADIR ESTA L√çNEA
if (document.getElementById('plannerContainer')) { 
    document.getElementById('plannerContainer').classList.add('hidden');
    document.getElementById('sessionResults').innerHTML = '';
}
            document.getElementById('videoLogoPlaceholder').classList.remove('hidden');
            const loadVideoBtnSpan = document.querySelector('#loadVideoBtn span');
            if (loadVideoBtnSpan) {
                loadVideoBtnSpan.textContent = translations[currentLanguage]['load_video'];
            }
            
            renderTranslations([]);
            updateStatsDisplay();
            
            confirmNewProjectModal.classList.add('hidden');
        }

/**
 * Borra todos los datos de la aplicaci√≥n (LocalStorage e IndexedDB)
 * y recarga la p√°gina para empezar desde cero.
 */
function resetApplicationCache() {
    const t = translations[currentLanguage];
    const confirmation = confirm(t['reset_app_confirm']);

    if (confirmation) {
        try {
            // Borra todo el LocalStorage (ajustes de IA, atajos, etc.)
            localStorage.clear();

            // Borra la base de datos IndexedDB (proyectos y backups)
            db.delete().then(() => {
                showMessage(t['reset_app_success']);
                // Espera un segundo para que el usuario vea el mensaje y recarga la p√°gina.
                setTimeout(() => {
                    location.reload();
                }, 1000);
            }).catch(err => {
                console.error("Error al borrar la base de datos:", err);
                showMessage(t['reset_db_error']);
            });

        } catch (error) {
            console.error("Error al resetear el almacenamiento:", error);
            showMessage(t['reset_storage_error']);
        }
    }
}

// --- START: PLANNER LOGIC ---

let sessionPlan = [];
let activeSessionIndex = -1;
let timerInterval = null;
let sessionStartTime = 0;

function calculateSessions() {
    const t = translations[currentLanguage]; // Obtenemos el diccionario del idioma actual

    if (srtEntries.length === 0) {
        showMessage(t['planner_load_srt_warning']); // Usamos la traducci√≥n
        return;
    }

    const numSessions = parseInt(document.getElementById('sessionCount').value, 10);
    const method = document.getElementById('divisionMethod').value;

    sessionPlan = [];
    activeSessionIndex = -1;
    clearInterval(timerInterval);

    const totalSubs = srtEntries.length;
    const totalDuration = srtEntries[totalSubs - 1].endTimeMs;
    const totalWords = srtEntries.reduce((sum, entry) => sum + entry.wordCountOriginal, 0);

    let lastIndex = 0;

    for (let i = 1; i <= numSessions; i++) {
        let session = {
            id: i,
            startSub: 0,
            endSub: 0,
            text: '',
            isCompleted: false,
            elapsedTime: 0
        };

        session.startSub = lastIndex + 1;

        if (method === 'subtitles') {
            const subsPerSession = Math.ceil(totalSubs / numSessions);
            session.endSub = Math.min(i * subsPerSession, totalSubs);
            session.text = t['planner_session_subs'].replace('{0}', session.startSub).replace('{1}', session.endSub);
        } 
        else if (method === 'time') {
            const timePerSession = totalDuration / numSessions;
            const sessionEndTime = i * timePerSession;
            const endEntry = srtEntries.find(entry => entry.startTimeMs >= sessionEndTime) || srtEntries[totalSubs - 1];
            session.endSub = endEntry.index;
            if (i === numSessions) session.endSub = totalSubs;

            const startTimeMs = Math.round((i - 1) * timePerSession);
            const endTimeMs = Math.round(sessionEndTime);
            const startTimeStr = formatTime(startTimeMs);
            const endTimeStr = formatTime(endTimeMs);
            session.text = t['planner_session_time'].replace('{0}', startTimeStr).replace('{1}', endTimeStr).replace('{2}', session.endSub);
        }
        else if (method === 'words') {
            const wordsPerSession = totalWords / numSessions;
            let currentWords = 0;
            let endSubIndex = lastIndex;
            for (let j = lastIndex; j < totalSubs; j++) {
                currentWords += srtEntries[j].wordCountOriginal;
                if ((j > lastIndex && currentWords > (wordsPerSession * 0.8)) || j === totalSubs - 1) {
                     endSubIndex = j;
                     if (i === numSessions) {
                         endSubIndex = totalSubs -1;
                     }
                     break;
                }
            }
             session.endSub = endSubIndex + 1;
             if (i === numSessions) session.endSub = totalSubs;
             const approxWords = Math.round(wordsPerSession);
             session.text = t['planner_session_words'].replace('{0}', session.startSub).replace('{1}', session.endSub).replace('{2}', approxWords);
        }

        lastIndex = session.endSub;
        sessionPlan.push(session);
    }

// --- INICIO DEL BLOQUE A A√ëADIR ---
// A√±adimos el √≠tem fijo de Revisi√≥n / QA al final del plan
sessionPlan.push({
    id: numSessions + 1,
    startSub: null, // No tiene subt√≠tulo de inicio
    endSub: null,
    text: t['planner_session_qa'],
    isCompleted: false,
    elapsedTime: 0
});
// --- FIN DEL BLOQUE A A√ëADIR ---

    renderPlanner();
}

function renderPlanner() {
    const resultsContainer = document.getElementById('sessionResults');
    resultsContainer.innerHTML = '';

    sessionPlan.forEach((session, index) => {
        const row = document.createElement('div');
        row.className = 'session-row';
        if (session.isCompleted) row.classList.add('completed');
        if (index === activeSessionIndex) row.classList.add('active');

        row.innerHTML = `
            <input type="checkbox" class="session-checkbox form-checkbox h-5 w-5 text-blue-600" data-index="${index}" ${session.isCompleted ? 'checked' : ''}>
            <div class="session-text">${session.text}</div>
            <div class="session-time" id="time-${index}">${formatElapsedTime(session.elapsedTime)}</div>
            <button class="btn btn-secondary text-xs" id="timer-btn-${index}" data-index="${index}">‚ñ∂</button>
            <button class="btn btn-secondary text-xs" id="reset-btn-${index}" data-index="${index}">‚Üª</button>
        `;
        resultsContainer.appendChild(row);
    });

    // Add event listeners
    resultsContainer.querySelectorAll('.session-checkbox').forEach(cb => {
        cb.addEventListener('change', (e) => {
            const index = parseInt(e.target.dataset.index, 10);
            sessionPlan[index].isCompleted = e.target.checked;
            if (e.target.checked) pauseTimer();
            renderPlanner();
        });
    });

    resultsContainer.querySelectorAll('.session-row').forEach(row => {
    row.addEventListener('click', (e) => {
        if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') {
            const index = parseInt(e.target.closest('.session-row').querySelector('.session-checkbox').dataset.index, 10);

            // Solo navegamos si la sesi√≥n tiene un subt√≠tulo de inicio definido
            if (sessionPlan[index] && sessionPlan[index].startSub) {
                navigateToTranslation(sessionPlan[index].startSub - 1);
            }
        } // <-- ESTA ES LA LLAVE QUE SE HA MOVIDO A SU SITIO CORRECTO
    });
});

     resultsContainer.querySelectorAll('[id^=timer-btn-]').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(e.target.dataset.index, 10);

            if (activeSessionIndex === index && timerInterval) {
                pauseTimer();
            } else {
                startTimer(index);
            }
        });
    });

    resultsContainer.querySelectorAll('[id^=reset-btn-]').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(e.target.dataset.index, 10);
            resetTimer(index);
        });
    });
}

function startTimer(index) {
    clearInterval(timerInterval);
    activeSessionIndex = index;
    sessionStartTime = Date.now() - sessionPlan[index].elapsedTime;

    timerInterval = setInterval(updateTimerDisplay, 1000);
    renderPlanner(); // Re-render to show active state and button text change
    document.getElementById(`timer-btn-${index}`).textContent = '‚ùö‚ùö';
}

function pauseTimer() {
    if (activeSessionIndex === -1) return;
    clearInterval(timerInterval);
    timerInterval = null;
    sessionPlan[activeSessionIndex].elapsedTime = Date.now() - sessionStartTime;
    document.getElementById(`timer-btn-${activeSessionIndex}`).textContent = '‚ñ∂';
}

function resetTimer(index) {
    if(activeSessionIndex === index) pauseTimer();
    sessionPlan[index].elapsedTime = 0;
    document.getElementById(`time-${index}`).textContent = '00:00:00';
}

function updateTimerDisplay() {
    const elapsedTime = Date.now() - sessionStartTime;
    document.getElementById(`time-${activeSessionIndex}`).textContent = formatElapsedTime(elapsedTime);
}

function formatElapsedTime(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

// --- END: PLANNER LOGIC ---

        // --- START: Floating Panel Logic (Drag, Resize, and Close) ---
        function closeFloatingPanel(panel, triggerButton) {
            panel.classList.remove('is-visible');
             if (triggerButton) {
                triggerButton.classList.remove('btn-active');
            }
        }

        function openFloatingPanel(panelToOpen, triggerButton, callback) {
            if (panelToOpen.classList.contains('is-visible')) {
                closeFloatingPanel(panelToOpen, triggerButton);
                return;
            }
            
            panelToOpen.classList.add('is-visible');
            
                 if (triggerButton) {
                triggerButton.classList.add('btn-active');
            }

            if (callback) {
                callback();
            }
        }
        
        function resetPanelPosition(panel) {
            // Remove inline styles set by dragging/resizing
            panel.style.left = '';
            panel.style.top = '';
            panel.style.width = '';
            panel.style.height = '';
            panel.style.right = '';
            panel.style.bottom = '';
            panel.style.transform = '';
            
            // Remove the moved data attribute
            delete panel.dataset.moved;
            
            // Re-apply visibility to ensure it's positioned correctly by CSS
            panel.classList.remove('is-visible');
            setTimeout(() => panel.classList.add('is-visible'), 10);
        }

        function makePanelDraggable(panel) {
            const header = panel.querySelector('.sidebar-header');
            let isDragging = false;
            let offsetX, offsetY;

            header.addEventListener('mousedown', (e) => {
                // Ignore clicks on buttons inside the header
                if (e.target.closest('button')) return;
                
                isDragging = true;
                panel.dataset.moved = 'true'; // Mark as moved
                
                const rect = panel.getBoundingClientRect();
                panel.style.left = `${rect.left}px`;
                panel.style.top = `${rect.top}px`;
                panel.style.right = 'auto';
                panel.style.bottom = 'auto';
                
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                
                panel.style.transition = 'none';
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'move';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                let newX = e.clientX - offsetX;
                let newY = e.clientY - offsetY;

                panel.style.left = `${newX}px`;
                panel.style.top = `${newY}px`;
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    panel.style.transition = ''; // Restore transitions
                    document.body.style.userSelect = '';
                    document.body.style.cursor = '';
                }
            });
        }
        
        function makePanelResizable(panel) {
            const resizers = document.createElement('div');
            resizers.innerHTML = `
                <div class="panel-resizer top-left"></div> <div class="panel-resizer top"></div> <div class="panel-resizer top-right"></div>
                <div class="panel-resizer left"></div>                                       <div class="panel-resizer right"></div>
                <div class="panel-resizer bottom-left"></div> <div class="panel-resizer bottom"></div> <div class="panel-resizer bottom-right"></div>
            `;
            panel.appendChild(resizers);
            
            let originalWidth, originalHeight, originalX, originalY, originalMouseX, originalMouseY;

            resizers.querySelectorAll('.panel-resizer').forEach(resizer => {
                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    panel.dataset.moved = 'true';
                    originalWidth = panel.offsetWidth;
                    originalHeight = panel.offsetHeight;
                    originalX = panel.offsetLeft;
                    originalY = panel.offsetTop;
                    originalMouseX = e.pageX;
                    originalMouseY = e.pageY;

                    const mouseMoveHandler = (e) => {
                        const dx = e.pageX - originalMouseX;
                        const dy = e.pageY - originalMouseY;

                        if (resizer.classList.contains('right')) {
                            panel.style.width = `${originalWidth + dx}px`;
                        } else if (resizer.classList.contains('left')) {
                            panel.style.width = `${originalWidth - dx}px`;
                            panel.style.left = `${originalX + dx}px`;
                        }

                        if (resizer.classList.contains('bottom')) {
                            panel.style.height = `${originalHeight + dy}px`;
                        } else if (resizer.classList.contains('top')) {
                            panel.style.height = `${originalHeight - dy}px`;
                            panel.style.top = `${originalY + dy}px`;
                        }
                        
                        // Handle corners
                        if (resizer.classList.contains('bottom-right')) {
                           panel.style.width = `${originalWidth + dx}px`;
                           panel.style.height = `${originalHeight + dy}px`;
                        } else if (resizer.classList.contains('bottom-left')) {
                           panel.style.width = `${originalWidth - dx}px`;
                           panel.style.left = `${originalX + dx}px`;
                           panel.style.height = `${originalHeight + dy}px`;
                        } else if (resizer.classList.contains('top-right')) {
                           panel.style.width = `${originalWidth + dx}px`;
                           panel.style.height = `${originalHeight - dy}px`;
                           panel.style.top = `${originalY + dy}px`;
                        } else if (resizer.classList.contains('top-left')) {
                           panel.style.width = `${originalWidth - dx}px`;
                           panel.style.left = `${originalX + dx}px`;
                           panel.style.height = `${originalHeight - dy}px`;
                           panel.style.top = `${originalY + dy}px`;
                        }
                    };

                    const mouseUpHandler = () => {
                        document.removeEventListener('mousemove', mouseMoveHandler);
                        document.removeEventListener('mouseup', mouseUpHandler);
                    };

                    document.addEventListener('mousemove', mouseMoveHandler);
                    document.addEventListener('mouseup', mouseUpHandler);
                });
            });
        }
        // --- END: Floating Panel Logic ---


        // --- Initialization on page load ---
        document.addEventListener('DOMContentLoaded', async () => {
            await loadShortcuts();
loadAiCustomInstructions();
            populateIsoLanguagesDatalist();
            setLanguage('es'); 
            resetApplicationState();

            // Initialize floating panels
            const terminologyPanel = document.getElementById('terminologySidebar');
            const tmPanel = document.getElementById('translationMemorySidebar');
            
            makePanelDraggable(terminologyPanel);
            makePanelResizable(terminologyPanel);
            makePanelDraggable(tmPanel);
            makePanelResizable(tmPanel);

const contextPanel = document.getElementById('contextSidebar');
makePanelDraggable(contextPanel);
makePanelResizable(contextPanel);
makePanelDraggable(goToSubtitlePanel);
makePanelResizable(goToSubtitlePanel);
           makePanelDraggable(findReplacePanel);
            makePanelResizable(findReplacePanel);

// --- INICIO: Inicializaci√≥n de WaveSurfer ---
            const waveformContainer = document.getElementById('waveform');
            const videoPlayer = document.getElementById('videoPlayer'); // Ya tienes esta variable
            
           wavesurfer = WaveSurfer.create({
                container: waveformContainer,
                media: videoPlayer,
                waveColor: '#A8DBA8',
                progressColor: '#3B8686',
                cursorColor: '#FFD700',
                cursorWidth: 2,
                barWidth: 3,
                barRadius: 3,
                barGap: 2,
                height: 96,
                responsive: true,
                minPxPerSec: 100,
                plugins: [
                    WaveSurfer.Regions.create(),
                ]
            });

            wsRegions = wavesurfer.plugins[0];

             wavesurfer.on('ready', () => {
                 document.getElementById('waveform').classList.remove('hidden');
waveformControls.classList.remove('hidden');
                 // A√ëADIDO: Solo renderiza si hay subt√≠tulos cargados
                 if (srtEntries && srtEntries.length > 0) {
                     renderTranslations(srtEntries, lastActiveSubtitleIndex, true); // Renderiza subt√≠tulos Y regiones
                 }
             });
            wavesurfer.on('error', (err) => {
                 console.error('WaveSurfer error:', err);
                 // MODIFICADO: Mensaje m√°s gen√©rico o quitarlo si no se carga video
                 // showMessage("Error con la onda de sonido.");
             });
              // Listener para cuando una regi√≥n se mueve o redimensiona
             wsRegions.on('region-updated', (region) => {
                 const entryIndex = srtEntries.findIndex(e => e.regionId === region.id);
                 if (entryIndex !== -1) {
                     const entry = srtEntries[entryIndex];
                     const newStartTimeMs = Math.round(region.start * 1000);
                     const newEndTimeMs = Math.round(region.end * 1000);

                     // Comprueba si los tiempos realmente cambiaron para evitar bucles infinitos
                     if (entry.startTimeMs !== newStartTimeMs || entry.endTimeMs !== newEndTimeMs) {
                         // Guarda el estado ANTES de modificar los datos
if (!isApplyingState) { // Solo guarda si no estamos deshaciendo/rehaciendo
                        const oldTimes = { startTimeMs: entry.startTimeMs, endTimeMs: entry.endTimeMs };
                        const newTimes = { startTimeMs: newStartTimeMs, endTimeMs: newEndTimeMs };
                        saveTimeChange(entryIndex, oldTimes, newTimes);
                    }
                         entry.startTimeMs = newStartTimeMs;
                         entry.endTimeMs = newEndTimeMs;
                         updateEntryTimes(entryIndex); // Actualiza la tabla y la propia regi√≥n
                     }
                 }
             });
              // Listener para clic en una regi√≥n
             wsRegions.on('region-clicked', (region, e) => {
                 e.stopPropagation(); // Evita que el clic se propague al contenedor de la onda
                 const entryIndex = srtEntries.findIndex(e => e.regionId === region.id);
                 if (entryIndex !== -1) {
                      wavesurfer.setTime(region.start); // Va al inicio de la regi√≥n
                      navigateToTranslation(entryIndex); // Activa el subt√≠tulo en la lista
                 }
             });

// --- A√ëADIR ESTE BLOQUE ---
const plannerContainer = document.getElementById('plannerContainer');
const plannerAccordionHeader = document.getElementById('plannerAccordionHeader');
const plannerAccordionContent = document.getElementById('plannerAccordionContent');
const plannerAccordionIcon = plannerAccordionHeader.querySelector('.accordion-icon');
const calculateSessionsBtn = document.getElementById('calculateSessionsBtn');
 const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);


plannerAccordionHeader.addEventListener('click', () => {
    const isCollapsed = plannerAccordionContent.classList.contains('collapsed');
    plannerAccordionContent.classList.toggle('collapsed', !isCollapsed);
    plannerAccordionContent.classList.toggle('expanded', isCollapsed);
    plannerAccordionIcon.classList.toggle('rotated', isCollapsed);
});
calculateSessionsBtn.addEventListener('click', calculateSessions);
// --- FIN DEL BLOQUE A A√ëADIR ---
            
            // Setup panel buttons
            setupPanel('terminologySidebar', 'terminologyBtn', () => {
                 if (!glossarySourceLanguage || !glossaryTargetLanguage) {
                    showLanguageConfigSection();
                } else {
                    showGlossaryEditorSection();
                }
            });
            setupPanel('translationMemorySidebar', 'tmBtn', () => {
                if (!tmSourceLanguage || !tmTargetLanguage) {
                    showTMLanguageConfigSection();
                } else {
                    showTMEditorSection();
                    tmSearch();
                }
            });
setupPanel('contextSidebar', 'contextBtn');
setupPanel('goToSubtitlePanel', 'goToSubtitleBtn');
goToSubtitleActionBtn.addEventListener('click', goToSubtitleByNumber);
goToTimecodeActionBtn.addEventListener('click', goToSubtitleByTimecode);

            if (saveSrtButton) saveSrtButton.disabled = true;
            if (statsContainer) statsContainer.classList.add('hidden');
            if (addTermContent) addTermContent.classList.add('collapsed');
            if (statsAccordionContent) statsAccordionContent.classList.add('collapsed');
            
videoPlayer.addEventListener('timeupdate', () => {
    updateSubtitlePreview(); // Actualiza el texto de vista previa
    handlePlaybackTracking(); // Gestiona el resaltado/scroll autom√°tico
});

            // Inicializa los nuevos controles del reproductor
updateFontSize(subtitleFontSize);
setPreviewSource('translation'); // Establece el estado inicial

// Event listeners para los nuevos botones
setPreviewOriginal.addEventListener('click', () => setPreviewSource('original'));
setPreviewTranslation.addEventListener('click', () => setPreviewSource('translation'));
increaseFontSize.addEventListener('click', () => updateFontSize(subtitleFontSize + 2));
decreaseFontSize.addEventListener('click', () => updateFontSize(subtitleFontSize - 2));

// Event listener para nuestro bot√≥n de pantalla completa
customFullscreenBtn.addEventListener('click', toggleFullscreen);

// Detecta cualquier cambio en el estado de la pantalla completa
document.addEventListener('fullscreenchange', handleFullscreenClass);
document.addEventListener('webkitfullscreenchange', handleFullscreenClass);
document.addEventListener('mozfullscreenchange', handleFullscreenClass);
document.addEventListener('MSFullscreenChange', handleFullscreenClass);

function handleFullscreenClass() {
    // Comprueba si hay alg√∫n elemento en pantalla completa
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
    
    // A√±ade o quita la clase .is-fullscreen del contenedor del v√≠deo
    videoPlayerWrapper.classList.toggle('is-fullscreen', isFullscreen);
}

// Event listener para cambiar el icono cuando cambia el estado de la pantalla completa
function handleFullscreenChange() {
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);

    fullscreenEnterChar.classList.toggle('hidden', isFullscreen);
    fullscreenExitChar.classList.toggle('hidden', !isFullscreen);

    // --- L√ìGICA A√ëADIDA ---
    if (isFullscreen) {
        // Al entrar en pantalla completa, calculamos y forzamos el nuevo tama√±o.
        const newSize = subtitleFontSize + 26;
        subtitlePreviewText.style.fontSize = `${newSize}px`;
    } else {
        // Al salir, limpiamos el estilo para que vuelva a usar la regla normal.
        subtitlePreviewText.style.fontSize = ''; 
    }
}
// 2. "Escuchamos" todas las versiones del evento que usan los navegadores.
document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
document.addEventListener('mozfullscreenchange', handleFullscreenChange);
document.addEventListener('MSFullscreenChange', handleFullscreenChange);          
            // Language switcher events
            langEsBtn.addEventListener('click', () => setLanguage('es'));
            langEnBtn.addEventListener('click', () => setLanguage('en'));

            // Resizer logic
            const horizontalResizer = document.getElementById('horizontal-resizer');
            const videoSection = document.querySelector('.video-player-section');
            let isHorizontalResizing = false;
            horizontalResizer.addEventListener('mousedown', () => { isHorizontalResizing = true; document.body.style.cursor = 'col-resize'; });
            document.addEventListener('mousemove', (e) => { if (isHorizontalResizing) { const container = document.querySelector('.main-app-content'); const newVideoWidthPercent = ((e.clientX - container.getBoundingClientRect().left) / container.offsetWidth) * 100; if (newVideoWidthPercent > 20 && newVideoWidthPercent < 80) videoSection.style.flexBasis = `${newVideoWidthPercent}%`; } });
            document.addEventListener('mouseup', () => { isHorizontalResizing = false; document.body.style.cursor = ''; });
            
            // Backup Initialization
            try {
                const backup = await db.projects.get(1);
                if (backup) backupBtn.classList.add('animate-pulse-yellow');
            } catch (error) {
                console.error('Error checking initial backup:', error);
            }
            setInterval(saveBackup, 300000);

            backupBtn.addEventListener('click', async () => {
                const backup = await db.projects.get(1);
                if (backup) {
                    backupFileName.textContent = backup.fileName;
                    backupLastModified.textContent = new Date(backup.lastModified).toLocaleString();
                    backupFoundView.classList.remove('hidden');
                    noBackupFoundView.classList.add('hidden');
                } else {
                    backupFoundView.classList.add('hidden');
                    noBackupFoundView.classList.remove('hidden');
                }
                backupModal.classList.remove('hidden');
            });
            closeBackupModalBtn.addEventListener('click', () => backupModal.classList.add('hidden'));

confirmRestoreBtn.addEventListener('click', async () => {
                // Mensaje de confirmaci√≥n a√±adido
                if (confirm(translations[currentLanguage]['confirm_restore_message'])) {
                    const backup = await db.projects.get(1);
                    if (backup) {
                        restoreProject(backup);
                        backupModal.classList.add('hidden');
                    }
                }
            });
      
            deleteBackupBtn.addEventListener('click', async () => {
                if (confirm(errorMessages[currentLanguage]['backup_deleted_confirmation'])) {
                    await db.projects.delete(1);
                    backupBtn.classList.remove('animate-pulse-yellow');
                    backupModal.classList.add('hidden');
                    showMessage(errorMessages[currentLanguage]['backup_deleted_message']);
                }
            });
            exportSrtFromBackupBtn.addEventListener('click', async () => {
                const backup = await db.projects.get(1);
                if (!backup) { showMessage(errorMessages[currentLanguage]['no_backup_to_export']); return; }
                try {
                    const srtContent = reconstructSrt(backup.srtEntries);
                    const newFileName = `${backup.fileName.replace(/\.srt$/i, '')}_recuperado_${new Date().toISOString().slice(0, 10)}.srt`;
                    const blob = new Blob([srtContent], { type: 'text/plain;charset=utf-8' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = newFileName;
                    a.click();
                    URL.revokeObjectURL(a.href);
                    showMessage(`${errorMessages[currentLanguage]['backup_export_success']}: "${newFileName}"`);
                } catch (error) {
                    showMessage(`${errorMessages[currentLanguage]['backup_export_error']}${error.message}`);
                }
            });

            // QA Modal Initialization
            qaBtn.addEventListener('click', () => {
                qaCpsLimitInput.value = qaSettings.cpsLimit;
                qaCharsPerLineLimitInput.value = qaSettings.charsPerLineLimit;
                qaModal.classList.remove('hidden');
            });
            closeQaModalBtn.addEventListener('click', () => qaModal.classList.add('hidden'));
            saveQaSettingsBtn.addEventListener('click', () => {
    // 1. Generamos el texto de la 'antigua' instrucci√≥n por defecto para comparar.
    const oldDefaultInstruction = translations[currentLanguage]['ai_default_instruction_1']
        .replace('{0}', qaSettings.charsPerLineLimit)
        .replace('{1}', qaSettings.cpsLimit);

    // 2. Comprobamos si la instrucci√≥n actual es la que est√° por defecto.
    const isUsingDefault = (aiCustomInstructions.instruction1 === oldDefaultInstruction);

    // 3. Actualizamos los ajustes de QA con los nuevos valores de los campos.
    qaSettings.cpsLimit = parseInt(qaCpsLimitInput.value, 10) || qaSettings.cpsLimit;
    qaSettings.charsPerLineLimit = parseInt(qaCharsPerLineLimitInput.value, 10) || qaSettings.charsPerLineLimit;

    // 4. Si se estaba usando la instrucci√≥n por defecto, la regeneramos y la guardamos.
    if (isUsingDefault) {
        const newDefaultInstruction = translations[currentLanguage]['ai_default_instruction_1']
            .replace('{0}', qaSettings.charsPerLineLimit)
            .replace('{1}', qaSettings.cpsLimit);

        aiCustomInstructions.instruction1 = newDefaultInstruction;
        saveAiCustomInstructions(); // Guardamos el cambio en la configuraci√≥n de la IA
    }

    // 5. Ejecutamos el chequeo de QA y cerramos la ventana.
    runFullQaCheck();
    qaModal.classList.add('hidden');
});

            // QA Error List Modal Initialization
            qaErrorStats.addEventListener('click', () => {
                if (calculateAllQaErrors().length > 0) {
                    renderQaErrorList();
                    qaErrorListModal.classList.remove('hidden');
                }
            });
            closeQaErrorListModalBtn.addEventListener('click', () => qaErrorListModal.classList.add('hidden'));
            qaErrorListContainer.addEventListener('click', (event) => {
                const errorItem = event.target.closest('.qa-error-item');
                if (errorItem) {
                    navigateToTranslation(parseInt(errorItem.dataset.entryIndex, 10));
                    qaErrorListModal.classList.add('hidden');
                }
            });

            // Event listeners for TBX/TMX modals
            cancelSaveTbxBtn.addEventListener('click', () => {
                saveTbxModal.classList.add('hidden');
            });

            confirmSaveTbxBtn.addEventListener('click', () => {
                const filename = fileNameInputTbx.value;
                if (!filename) {
                    showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                    return;
                }
                showLoadingOverlay(errorMessages[currentLanguage]['saving_file']);
                try {
                    const tbxContent = generateTBX();
                    const blob = new Blob([tbxContent], { type: "application/xml" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = filename.endsWith('.tbx') ? filename : filename + '.tbx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showMessage(errorMessages[currentLanguage]['file_saved_successfully_tbx']);
                } catch (error) {
                    showMessage(`${errorMessages[currentLanguage]['error_saving_file']} ${error.message}`);
                    console.error("Error downloading TBX:", error);
                } finally {
                    hideLoadingOverlay();
                    saveTbxModal.classList.add('hidden');
                }
            });

            cancelSaveTmxBtn.addEventListener('click', () => {
                saveTmxModal.classList.add('hidden');
            });

            confirmSaveTmxBtn.addEventListener('click', () => {
                const filename = fileNameInputTmx.value;
                if (!filename) {
                    showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                    return;
                }
                showLoadingOverlay(errorMessages[currentLanguage]['saving_file']);
                try {
                    const tmxContent = generateTMX();
                    if (!tmxContent) return;
                    const blob = new Blob([tmxContent], { type: "application/xml" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = filename.endsWith('.tmx') ? filename : filename + '.tmx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showMessage(errorMessages[currentLanguage]['file_saved_successfully_tmx']);
                } catch (error) {
                    showMessage(`${errorMessages[currentLanguage]['error_saving_file']} ${error.message}`);
                    console.error("Error downloading TMX:", error);
                } finally {
                    hideLoadingOverlay();
                    saveTmxModal.classList.add('hidden');
                }
            });

            // Project Save/Load Listeners
            newProjectBtn.addEventListener('click', () => {
                if (srtEntries.length > 0) {
                    confirmNewProjectModal.classList.remove('hidden');
                } else {
                    resetApplicationState();
                }
            });

// --- Timecode Modal Listeners ---
            const timecodeModal = document.getElementById('timecodeModal');
            const timecodeSettingsBtn = document.getElementById('timecodeSettingsBtn');
            const closeTimecodeModalBtn = document.getElementById('closeTimecodeModalBtn');
            const saveTimecodeSettingsBtn = document.getElementById('saveTimecodeSettingsBtn');
            const projectFpsInput = document.getElementById('projectFpsInput');
            const useFrameTimecodeToggle = document.getElementById('useFrameTimecodeToggle');

            timecodeSettingsBtn.addEventListener('click', () => {
                // Cargar valores actuales en el modal
                projectFpsInput.value = projectFPS;
                useFrameTimecodeToggle.checked = useFrameTimecode;
                timecodeModal.classList.remove('hidden');
            });

            closeTimecodeModalBtn.addEventListener('click', () => {
                timecodeModal.classList.add('hidden');
            });

            saveTimecodeSettingsBtn.addEventListener('click', () => {
                // Guardar nuevos valores
                const newFPS = parseFloat(projectFpsInput.value);
                projectFPS = isNaN(newFPS) || newFPS <= 0 ? 25 : newFPS;
                useFrameTimecode = useFrameTimecodeToggle.checked;

                // Actualizar el placeholder del panel "Ir a..."
                if (useFrameTimecode) {
                    goToTimecodeInput.value = formatFrameTime(0, projectFPS);
                } else {
                    goToTimecodeInput.value = formatTime(0);
                }
                
                // Refrescar la lista de traducci√≥n para mostrar el nuevo formato
                renderTranslations(srtEntries, lastActiveSubtitleIndex, true);
                
                timecodeModal.classList.add('hidden');
            });

// --- L√≥gica de importaci√≥n de contexto ---
const contextFileInput = document.getElementById('contextFileInput');
const importFromPasteBtn = document.getElementById('importFromPasteBtn');
const contextPasteArea = document.getElementById('contextPasteArea');

contextFileInput.addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    showLoadingOverlay(translations[currentLanguage]['loading_file']);
    try {
        const content = await file.text();
        const parsedContext = JSON.parse(content);
        processAndApplyContext(parsedContext);
    } catch (error) {
        showMessage(`Error: ${error.message}`);
        console.error(error);
    } finally {
        hideLoadingOverlay();
        event.target.value = ''; // Resetea el input
    }
});

importFromPasteBtn.addEventListener('click', () => {
    const content = contextPasteArea.value;
    if (!content.trim()) {
        showMessage("El √°rea de texto est√° vac√≠a.");
        return;
    }
    showLoadingOverlay("Procesando contexto...");
    try {
        const parsedContext = JSON.parse(content);
        processAndApplyContext(parsedContext);
    } catch (error) {
        showMessage(`Error en el JSON: ${error.message}`);
        console.error(error);
    } finally {
        hideLoadingOverlay();
    }
});

    saveProjectBtn.addEventListener('click', () => {
                if (srtEntries.length === 0) {
                    showMessage(errorMessages[currentLanguage]['no_project_to_save']);
                    return;
                }
                // Sugiere un nombre de archivo basado en el SRT actual
                projectFileNameInput.value = currentFileName.replace(/\.[^/.]+$/, '');
                saveProjectModal.classList.remove('hidden');
                projectFileNameInput.focus();
            });

 confirmSaveProjectBtn.addEventListener('click', () => {
                const filename = projectFileNameInput.value.trim();
                if (!filename) {
                    showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                    return;
                }
                saveProject(filename); // Llama a la funci√≥n de guardado con el nuevo nombre
                saveProjectModal.classList.add('hidden');
            });

            cancelSaveProjectBtn.addEventListener('click', () => {
                saveProjectModal.classList.add('hidden');
                afterSaveAction = null; // Cancela cualquier acci√≥n pendiente
            });

            projectFile.addEventListener('change', loadProject);
resetAppBtn.addEventListener('click', resetApplicationCache);            

            // TMX File Input Listener
            tmFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    loadTMX(file);
                }
                event.target.value = ''; // Reset input
            });

            // New Project Confirmation Modal Listeners
            cancelNewProjectBtn.addEventListener('click', () => {
                confirmNewProjectModal.classList.add('hidden');
            });
            continueWithoutSavingBtn.addEventListener('click', () => {
                resetApplicationState();
            });
saveAndContinueBtn.addEventListener('click', () => {
                confirmNewProjectModal.classList.add('hidden');
                // Define la acci√≥n a ejecutar despu√©s de guardar
                afterSaveAction = resetApplicationState;
                // Dispara el clic en el bot√≥n de guardar para abrir el modal
                saveProjectBtn.click();
            });

const copyPromptBtn = document.getElementById('copyPromptBtn');
const pasteJsonBtn = document.getElementById('pasteJsonBtn');

copyPromptBtn.addEventListener('click', copyAIPrompt);
pasteJsonBtn.addEventListener('click', pasteJsonFromClipboard);
contextPasteArea.addEventListener('input', validateJsonInTextarea);


      reselectVideoInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
              if (file) {
        videoFileName = file.name;
        const videoURL = URL.createObjectURL(file); // <-- CORREGIDO: Creada ANTES
        videoPlayer.src = videoURL; // <-- CORREGIDO: Mover src aqu√≠ tambi√©n
        wavesurfer.load(videoURL); // <-- Ahora videoURL existe
        document.getElementById('waveform').classList.remove('hidden');
        videoPlayer.controls = true;
                    videoPlayer.load();
                                
                    document.getElementById('videoLogoPlaceholder').classList.add('hidden');
            
                    const loadVideoBtnSpan = document.querySelector('#loadVideoBtn span');
                    if (loadVideoBtnSpan) {
                        loadVideoBtnSpan.textContent = translations[currentLanguage]['change_video'];
                    }
                    reselectVideoModal.classList.add('hidden');
                }
            });

            skipReselectVideoBtn.addEventListener('click', () => {
                reselectVideoModal.classList.add('hidden');
            });

            // L√≥gica para los modales de confirmaci√≥n de reseteo
            confirmResetGlossaryBtn.addEventListener('click', () => {
                resetGlossary();
                confirmResetGlossaryModal.classList.add('hidden');
            });

            cancelResetGlossaryBtn.addEventListener('click', () => {
                confirmResetGlossaryModal.classList.add('hidden');
            });

            confirmResetTmBtn.addEventListener('click', () => {
                resetTM();
                confirmResetTmModal.classList.add('hidden');
            });

             cancelResetTmBtn.addEventListener('click', () => {
                confirmResetTmModal.classList.add('hidden');
            });

        // Funciones para mostrar los modales de confirmaci√≥n
        function showConfirmResetGlossary() {
            if (glossary.length === 0) {
                resetGlossary();
                return;
            }
            confirmResetGlossaryModal.classList.remove('hidden');
        }

       function showConfirmResetTm() {
            if (translationMemory.length === 0) {
                resetTM();
                return;
            }
            confirmResetTmModal.classList.remove('hidden');
        }

// --- L√≥gica para el modal de Ajustes de IA ---
const aiSettingsModal = document.getElementById('aiSettingsModal');
const aiSettingsBtn = document.getElementById('aiSettingsBtn');
const closeAiSettingsModalBtn = document.getElementById('closeAiSettingsModalBtn');
const saveAiSettingsBtn = document.getElementById('saveAiSettingsBtn');
const aiInstruction1 = document.getElementById('aiInstruction1');
const aiInstruction2 = document.getElementById('aiInstruction2');
const aiInstruction3 = document.getElementById('aiInstruction3');

aiSettingsBtn.addEventListener('click', () => {
    // Carga las instrucciones actuales en los campos de texto
    aiInstruction1.value = aiCustomInstructions.instruction1;
    aiInstruction2.value = aiCustomInstructions.instruction2;
    aiInstruction3.value = aiCustomInstructions.instruction3;
    aiSettingsModal.classList.remove('hidden');
});

closeAiSettingsModalBtn.addEventListener('click', () => {
    aiSettingsModal.classList.add('hidden');
});

saveAiSettingsBtn.addEventListener('click', () => {
    const defaultInstruction = translations[currentLanguage]['ai_default_instruction_1']
        .replace('{0}', qaSettings.charsPerLineLimit)
        .replace('{1}', qaSettings.cpsLimit);

    // Guarda los nuevos valores
    aiCustomInstructions.instruction1 = aiInstruction1.value.trim() || defaultInstruction;
    aiCustomInstructions.instruction2 = aiInstruction2.value.trim();
    aiCustomInstructions.instruction3 = aiInstruction3.value.trim();
    saveAiCustomInstructions();
    aiSettingsModal.classList.add('hidden');
    showMessage("Ajustes de la IA guardados.");
});

if (contextHelpHeader && contextHelpContent) {
                contextHelpHeader.addEventListener('click', () => {
                    const isCollapsed = contextHelpContent.classList.contains('collapsed');
                    const icon = contextHelpHeader.querySelector('.accordion-icon');
                    if (isCollapsed) {
                        contextHelpContent.classList.remove('collapsed');
                        contextHelpContent.classList.add('expanded');
                        if (icon) icon.classList.add('rotated');
                    } else {
                        contextHelpContent.classList.remove('expanded');
                        contextHelpContent.classList.add('collapsed');
                        if (icon) icon.classList.remove('rotated');
                    }
                });
            }

// --- INICIO: Listeners para la botonera de la onda ---
        lockWaveformBtn.addEventListener('click', toggleWaveformLock);
        zoomInBtn.addEventListener('click', () => zoomWaveform(1));
        zoomOutBtn.addEventListener('click', () => zoomWaveform(-1));
        // --- FIN: Listeners para la botonera de la onda ---

// --- INICIO: Listener para bot√≥n de seguimiento ---
followPlaybackBtn.addEventListener('click', () => {
    isFollowPlaybackActive = !isFollowPlaybackActive;
    followPlaybackBtn.classList.toggle('active', isFollowPlaybackActive); // Usa la clase 'active' gen√©rica
    followPlaybackBtn.title = isFollowPlaybackActive
        ? translations[currentLanguage]['follow_playback_off']
        : translations[currentLanguage]['follow_playback_on'];

    // Si se acaba de desactivar, limpia los resaltados
    if (!isFollowPlaybackActive) {
        clearPlaybackHighlights();
        currentlyTrackedRegionId = null;
        currentlyTrackedEditorIndex = -1;
    } else {
         handlePlaybackTracking(); // Intenta resaltar inmediatamente si se activa
    }
});
// --- FIN: Listener para bot√≥n de seguimiento ---

const statusBar = document.getElementById('statusBar');
    const toggleStatusBarBtn = document.getElementById('toggleStatusBarBtn');

// --- INICIO: MODIFICAR ESTE BLOQUE (L√≥gica de la Barra de Estado) ---
        if (statusBar && toggleStatusBarBtn) {
            // Comprueba el estado guardado al cargar la p√°gina
            const savedState = localStorage.getItem('statusBarVisible') === 'true';
            let textKey = 'show_status_bar_btn'; // Texto por defecto

            if (savedState) {
                statusBar.classList.add('is-visible');
                document.body.classList.add('status-bar-visible'); // Mantenemos esto por si acaso, aunque no afecte visualmente ahora
                textKey = 'hide_status_bar_btn'; // Texto si est√° visible
            }
            // Establecemos el atributo i18n para que se actualice con el idioma
            const buttonSpan = toggleStatusBarBtn.querySelector('span'); // Guardamos el span en una variable
            if (buttonSpan) { // Comprobamos si el span existe
                 buttonSpan.setAttribute('data-i18n', textKey);
                 // A√±adimos esta l√≠nea para asegurar que el texto se actualice al cargar
                 buttonSpan.textContent = translations[currentLanguage][textKey];
            }


            // Listener del bot√≥n
            toggleStatusBarBtn.addEventListener('click', () => {
                // A√±adimos un console.log para depurar
                console.log("Bot√≥n de barra de estado pulsado. Estado actual:", statusBar.classList.contains('is-visible'));

                const isVisible = statusBar.classList.toggle('is-visible');
                document.body.classList.toggle('status-bar-visible', isVisible);

                // Actualiza el texto del bot√≥n y el atributo i18n
                const newTextKey = isVisible ? 'hide_status_bar_btn' : 'show_status_bar_btn';
                if (buttonSpan) { // Usamos la variable guardada
                    buttonSpan.textContent = translations[currentLanguage][newTextKey];
                    buttonSpan.setAttribute('data-i18n', newTextKey);
                }

                // Guardar el estado en el navegador
                localStorage.setItem('statusBarVisible', isVisible);

                // A√±adimos otro console.log para ver el estado despu√©s del toggle
                console.log("Nuevo estado:", isVisible);
            });
        } else {
             // A√±adimos un log si los elementos no se encuentran
             console.error("Error: No se encontr√≥ statusBar o toggleStatusBarBtn.");
        }
        // --- FIN: MODIFICAR ESTE BLOQUE ---

// --- INICIO: NUEVO ESCUCHA GLOBAL DE ATAJOS DE TECLADO ---
document.addEventListener('keydown', (event) => {
    const activeElement = document.activeElement;
    const isTypingInInput = activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable;

    // --- L√≥gica para Atajos de Documentaci√≥n ---
    const triggeredDocAction = shortcuts.docResources.find(res => {
        if (!res.shortcut) return false;
        const sc = res.shortcut;
        const keyMatch = (sc.key === ' ' && event.code === 'Space') || (sc.key.toLowerCase() === event.key.toLowerCase());
        return keyMatch &&
               sc.ctrlKey === event.ctrlKey &&
               sc.metaKey === event.metaKey &&
               sc.altKey === event.altKey &&
               sc.shiftKey === event.shiftKey;
    });

    if (triggeredDocAction) {
        event.preventDefault();
        const selectedText = window.getSelection().toString().trim();
        const resourceUrl = triggeredDocAction.url;
        if (selectedText && resourceUrl && resourceUrl.includes('{word}')) {
            const finalUrl = resourceUrl.replace('{word}', encodeURIComponent(selectedText));
            window.open(finalUrl, '_blank');
        }
        return;
    }
    
    if (isTypingInInput) {
        return;
    }

    // --- L√≥gica para Atajos Globales (SOLO V√çDEO) ---
    const globalActions = [
        'jumpToTime', 'playSegment', 'playSegmentLoop', 'playPause', 
        'seekForward', 'seekBackward', 'seekForwardFast', 'seekBackwardFast'
    ];
    
    const triggeredGlobalAction = Object.keys(shortcuts).find(action => {
        if (!globalActions.includes(action)) return false;
        const shortcut = shortcuts[action];
        const keyMatch = (shortcut.key === ' ' && event.code === 'Space') || (shortcut.key.toLowerCase() === event.key.toLowerCase());
        return keyMatch &&
               shortcut.ctrlKey === event.ctrlKey &&
               shortcut.metaKey === event.metaKey &&
               shortcut.altKey === event.altKey &&
               shortcut.shiftKey === event.shiftKey;
    });

    if (triggeredGlobalAction) {
        event.preventDefault();
        switch (triggeredGlobalAction) {
            case 'jumpToTime':
            case 'playSegment':
                jumpToCurrentSubtitleTime(lastActiveSubtitleIndex);
                break;
            case 'playSegmentLoop':
                playSubtitleLoop(lastActiveSubtitleIndex);
                break;
            case 'playPause':
                if (videoPlayer.paused) videoPlayer.play();
                else videoPlayer.pause();
                break;
            case 'seekForward':
                videoPlayer.currentTime += 3;
                break;
            case 'seekBackward':
                videoPlayer.currentTime -= 3;
                break;
            case 'seekForwardFast':
                videoPlayer.currentTime += 5;
                break;
            case 'seekBackwardFast':
                videoPlayer.currentTime -= 5;
                break;
        }
    }
});
// --- FIN: NUEVO ESCUCHA GLOBAL DE ATAJOS DE TECLADO ---
   
followPlaybackBtn.title = translations[currentLanguage]['follow_playback_on'];
    });
   
</script>
<div id="statusBar"></div>
</body>
</html>
