<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">subpandaTM</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class', // Importante: activa el modo oscuro por clases
        }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    <script src="https://unpkg.com/dexie@latest/dist/dexie.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/7.7.5/plugins/regions.min.js"></script>
    <style>

        /* General styles for body and font */
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: #f3f4f6;
            color: #202020;
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-y: auto;
        }

        /* Ensures preformatted text respects line breaks and doesn't overflow */
        pre {
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Style for the check icon (SVG) */
        .check-icon {
            display: none;
            margin-left: 8px;
            vertical-align: middle;
            width: 20px;
            height: 20px;
            color: #22c55e;
        }

#statsContainer {
            display: none !important; /* Oculta el div de estad칤sticas permanentemente */
        }

        /* Estilo del contenedor principal de la barra */
.cps-bar-container {
    width: 100%;
    height: 6px; /* Altura fina */
    background-color: #e5e7eb; /* Fondo gris claro */
    border-radius: 3px;
    margin-top: 5px; /* Separaci칩n del editor */
    position: relative;
    overflow: hidden; /* Asegura que la barra de llenado no se salga */
}

/* Estilo de la barra de llenado */
.cps-bar-fill {
    height: 100%;
    width: 0; /* Inicialmente a 0 */
    background-color: #22c55e; /* Verde por debajo del l칤mite */
    transition: width 0.1s ease-out, background-color 0.3s ease; /* Transici칩n suave */
}

/* Estilo del indicador de l칤mite (la 'l칤nea') */
.cps-bar-limit-marker {
    position: absolute;
    top: 0;
    width: 2px; /* Ancho de la l칤nea de l칤mite */
    height: 100%;
    background-color: #075BA2; /* Color de la l칤nea de l칤mite */
    z-index: 10; /* Asegura que est칠 por encima del relleno */
    box-shadow: 0 0 2px rgba(0, 0, 0, 0.2);
    /* Se posicionar치 din치micamente con JavaScript */
}

/* --- ESTILOS PARA LAS REGIONES DE WAVESURFER (MODIFICADO v2) --- */
        #waveform ::part(region) {
            z-index: 10;
            overflow: visible !important;
            background-color: rgba(7, 91, 162, 0.7);
            border-left: 1px solid rgba(7, 91, 162, 0.9);
            border-right: 1px solid rgba(7, 91, 162, 0.9);
            transition: background-color 0.15s ease;
font-size: small;
    color: #fff !important;
    padding: 10px;
        }
        #waveform ::part(region):hover {
            background-color: rgba(6, 78, 138, 0.8);
        }
        #waveform ::part(region-handle-left),
        #waveform ::part(region-handle-right) {
            background-color: rgba(7, 91, 162, 0.9);
            width: 5px;
            cursor: ew-resize;
        }
        .region-content {
            position: absolute;
            top: -65px; /* Ajustado para 4 l칤neas */
            left: 0;
            width: 100%;
            font-size: 8px;
            line-height: 1.3; /* Espaciado entre l칤neas */
            color: #fff;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 3px 6px; /* Padding reducido verticalmente */
            border-radius: 3px;
            pointer-events: none;
            box-sizing: border-box;
            overflow: hidden; /* Oculta el desbordamiento general */
        }
        .region-content .region-line {
            white-space: nowrap; /* Evita que el texto salte de l칤nea */
            overflow: hidden; /* Oculta el texto que se sale */
            text-overflow: ellipsis; /* A침ade puntos suspensivos (...) */
            margin-bottom: 1px; /* Peque침o espacio entre l칤neas */
        }
        .region-content .region-line:last-child {
            margin-bottom: 0; /* Sin margen inferior en la 칰ltima l칤nea */
        }
        .region-content .region-line1 { /* N칰mero */
            font-weight: bold;
            color: #E0E0E0; /* Blanco un poco m치s tenue */
        }
        .region-content .region-line2 { /* Original */
            color: #A0A0A0; /* Gris치ceo para diferenciar */
        }
        .region-content .region-line3 { /* Traducci칩n */
            color: #FFFFFF; /* Blanco brillante */
            min-height: 1.3em; /* Asegura altura m칤nima aunque est칠 vac칤o */
        }
        .region-content .region-line4 { /* Stats */
            color: #facc15; /* Amarillo para stats */
            font-family: monospace; /* Fuente monoespaciada para stats */
        }
        /* --- FIN ESTILOS REGIONES --- */

/* --- INICIO: ESTILOS PARA ONDA BLOQUEADA --- */
        #waveform.is-locked ::part(region) {
            opacity: 0.4 !important; /* M치s transparente */
            transition: opacity 0.3s ease; /* Transici칩n para la opacidad */
        }

        /* Oculta el icono de candado que no corresponda */
        #lockWaveformBtn .lock-icon-open.hidden,
        #lockWaveformBtn .lock-icon-closed.hidden {
            display: none;
        }
        /* --- FIN: ESTILOS PARA ONDA BLOQUEADA --- */

/* --- INICIO: ESTILO PARA REGI칍N ACTIVA EN SEGUIMIENTO --- */
        #waveform ::part(region.region-playback-active) {
            background-color: rgba(255, 165, 0, 0.6) !important; /* Naranja semi-transparente */
            border-left: 2px solid rgba(255, 140, 0, 0.9);
            border-right: 2px solid rgba(255, 140, 0, 0.9);
            transition: background-color 0.1s ease-out, border-color 0.1s ease-out;
        }
        /* --- FIN: ESTILO PARA REGI칍N ACTIVA --- */

/* --- INICIO: ESTILOS PARA SUBT칈TULO ACTIVO EN EDITOR --- */
        /* Estilo para el div editable cuando tiene el foco */
        .translation-editor-wrapper div[contenteditable="true"]:focus {
            border-color: #333 !important; /* Borde m치s oscuro */
            box-shadow: 0 0 0 1px #333; /* Opcional: una sombra sutil para realzar */
        }

        /* Estilo para la unidad completa del subt칤tulo cuando un editor interno tiene el foco */
        .translation-unit-active {
            background-color: #ffffff !important; 
            transition: background-color 0.2s ease-in-out; /* Transici칩n suave */
        }
        /* --- FIN: ESTILOS PARA SUBT칈TULO ACTIVO EN EDITOR --- */

        /* --- UNIFIED BUTTON STYLES --- */
        .btn {
            padding: 0.25rem 0.75rem; /* Reduced padding */
            font-size: 0.875rem; /* Smaller font size */
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid transparent;
            white-space: nowrap;
        }
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Primary button style */
        .btn-primary {
            background-color: #075BA2;
            color: white;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #064f8a;
        }

        /* Secondary button style */
        .btn-secondary {
            background-color: #e5e7eb;
            color: #1f2937;
            border-color: #d1d5db;
        }

       .btn-secondary:hover:not(:disabled) {
            background-color: #d1d5db; /* Gris claro al pasar el rat칩n */
        }

        /* A칌ADIR ESTA REGLA: Mantener azul en hover si est치 activo */
        .btn-secondary.active:hover:not(:disabled) {
            background-color: #064f8a; /* Un azul ligeramente m치s oscuro que el activo, opcional */
            /* O si prefieres que NO cambie NADA al hacer hover cuando est치 activo: */
            /* background-color: #075BA2 !important; /* Mantiene el azul primario */
        }

/* Active style for toggle buttons */
.btn-secondary.active {
    background-color: #075BA2;
    color: white;
    font-weight: 700;
}

        /* Destructive button style */
        .btn-destructive {
            background-color: #ef4444;
            color: white;
        }
        .btn-destructive:hover:not(:disabled) {
            background-color: #dc2626;
        }
        
        /* Language button style */
        .btn-lang {
            background-color: #f3f4f6;
            color: #4b5563;
            padding: 0.25rem 0.75rem;
        }
        .btn-lang.active {
            background-color: #075BA2;
            color: white;
            font-weight: 700;
        }

.btn-active {
            background-color: #075BA2 !important; /* Mismo azul que el primario */
            color: white !important; /* Forzamos el color blanco */
            font-weight: 700 !important; /* Forzamos la negrita */
        }




        /* Specific styles for code display fields (original, translation) */
        .subtitle-display-code {
            background-color: #e3e3e3;
            border: 1px solid #000;
            color: #202020;
        }
        .subtitle-editor {
            background-color: #ffffff;
            color: #000000;
            min-height: 50px;
            border: 1px solid #d1d5db;
            padding: 0.5rem;
            border-radius: 0.375rem;
        }
        .subtitle-editor[contenteditable="false"] {
            background-color: #f3f4f6;
        }

        /* Background of translation units */
        .translation-unit-bg {
            background-color: #f8f8f8;
            border-color: #e5e7eb;
        }

        /* 2-column layout classes */
        .translation-row {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        @media (min-width: 768px) {
            .translation-row {
                flex-direction: row;
            }
            .original-col, .translation-col {
                flex: 1;
            }
        }

        /* Modal (pop-up) styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            width: 500px;
        }
        #shortcutsModal .modal-content,
        #findReplaceModal .modal-content {
            width: 650px;
            max-width: 95%;
        }
        .shortcut-icon {
            display: inline-block;
            width: 1em;
            height: 1em;
            vertical-align: middle;
            margin: 0 4px;
        }
        .shortcut-input {
            border: 1px solid #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: #f9f9f9;
            cursor: pointer;
            text-align: center;
            min-width: 120px;
            display: inline-block;
        }
        .shortcut-input.recording {
            background-color: #fffbe6;
            border-color: #facc15;
        }

        /* --- START: Floating Panel Styles --- */
        .floating-panel {
            position: fixed;
            width: 480px;
            min-width: 350px;
            max-width: 80vw;
            height: 75vh;
            min-height: 300px;
            background-color: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 950;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Changed from 'hidden' to allow resizers to be placed outside */
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

        #terminologySidebar {
            top: auto;
            right: auto;
            bottom: 20px;
            left: 20px;
            transform-origin: bottom left;
        }

        #translationMemorySidebar {
            top: auto;
            right: 20px;
            bottom: 20px;
            left: auto;
            transform-origin: bottom right;
        }

        .floating-panel.is-visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        
        .floating-panel .sidebar-header {
            cursor: move;
            background-color: #f9fafb;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e5e7eb;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .floating-panel .sidebar-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .panel-resizer {
            position: absolute;
            background: transparent;
        }
        .panel-resizer.top { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .panel-resizer.bottom { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .panel-resizer.left { top: 0; bottom: 0; left: -5px; width: 10px; cursor: ew-resize; }
        .panel-resizer.right { top: 0; bottom: 0; right: -5px; width: 10px; cursor: ew-resize; }
        .panel-resizer.top-left { top: -5px; left: -5px; width: 10px; height: 10px; cursor: nwse-resize; z-index: 1; }
        .panel-resizer.top-right { top: -5px; right: -5px; width: 10px; height: 10px; cursor: nesw-resize; z-index: 1; }
        .panel-resizer.bottom-left { bottom: -5px; left: -5px; width: 10px; height: 10px; cursor: nesw-resize; z-index: 1; }
        .panel-resizer.bottom-right { bottom: -5px; right: -5px; width: 10px; height: 10px; cursor: nwse-resize; z-index: 1; }
        
        /* --- END: Floating Panel Styles --- */


        /* Glossary/TM specific styles */
        .glossary-input-group input, .glossary-input-group select,
        .tm-input-group input, .tm-input-group select,
        .qa-input-group input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9rem;
            margin-top: 4px;
            color: #202020;
            background-color: #fff;
        }
        .glossary-info-box, .tm-info-box {
            background-color: #f0f8ff;
            border: 1px solid #d0e8f8;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            color: #333;
        }
        .glossary-highlight {
            background-color: #ffcc00;
            padding: 0 2px;
            border-radius: 3px;
        }
        .glossary-row-highlight {
            background-color: #ffcc00 !important;
            transition: background-color 0.3s ease;
        }

        /* Active translation unit highlight */
        .translation-unit-active {
            border: 2px solid #075BA2;
            box-shadow: 0 0 0 3px rgba(7, 91, 162, 0.25);
        }

        /* Loading Overlay Styles */
        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1001; font-size: 1.2rem; color: #333;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db;
            border-radius: 50%; width: 40px; height: 40px;
            animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Accordion styles */
        .accordion-item { border: 1px solid #e5e7eb; border-radius: 0.5rem; overflow: hidden; margin-bottom: 1rem; }
        .accordion-header { display: flex; align-items: center; justify-content: space-between; cursor: pointer; padding: 0.75rem 1rem; background-color: #f9fafb; border-bottom: 1px solid #e5e7eb; user-select: none; }
        .accordion-header:hover { background-color: #f3f4f6; color: #075BA2; }
        .accordion-icon { transition: transform 0.3s ease; }
        .accordion-icon.rotated { transform: rotate(180deg); }
        .accordion-content { overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; padding: 0 1rem; }
        .accordion-content.collapsed { max-height: 0; padding-top: 0; padding-bottom: 0; }
        .accordion-content.expanded { max-height: 500px; padding-top: 1rem; padding-bottom: 1rem; }

        /* TM Table styles */
        .tm-table {
            table-layout: fixed;
            width: 100%;
        }
        .tm-table th:nth-child(1), .tm-table td:nth-child(1) { width: 15%; text-align: center; }
        .tm-table th:nth-child(2), .tm-table td:nth-child(2),
        .tm-table th:nth-child(3), .tm-table td:nth-child(3) {
            width: 42.5%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        .tm-best-match-highlight { background-color: #d1fae5 !important; border-color: #10b981 !important; border-width: 2px; box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.25); }
        
        /* Diff styles */
        .diff-deletion { background-color: #fdd; text-decoration: line-through; }
        .diff-insertion { background-color: #dfd; }

        /* QA Error Styles */
        .qa-error { color: #ef4444; font-weight: 700; }
        .qa-success { color: #22c55e; font-weight: 700; }
        #qaErrorStats.clickable { cursor: pointer; text-decoration: underline; }
        .qa-error-item { padding: 0.5rem; border-bottom: 1px solid #e5e7eb; cursor: pointer; transition: background-color 0.2s; }
        .qa-error-item:hover { background-color: #f3f4f6; }
        #qaErrorListContainer { max-height: 60vh; overflow-y: auto; }

        /* Header styles */
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 900;
            flex-wrap: wrap;
        }
        .header-main-actions {
            display: flex;
            flex-grow: 1;
            justify-content: center;
            gap: 0.5rem; /* Reduced gap for smaller buttons */
            flex-wrap: wrap;
        }
        .header-lang-switcher {
            display: flex;
            gap: 0.5rem;
        }

        /* Main content area */
        .main-app-content { display: flex; flex-direction: column; flex-grow: 1; padding: 1rem; gap: 1rem; }
        .editor-and-sidebars-wrapper { display: flex; flex-direction: column; flex-grow: 1; gap: 1rem; min-height: 0;}
        #horizontal-resizer { width: 10px; height: auto; cursor: col-resize; background-color: #e5e7eb; border-left: 1px solid #d1d5db; border-right: 1px solid #d1d5db; }
        #horizontal-resizer:hover { background-color: #d1d5db; }

        @media (min-width: 1024px) {
            .main-app-content { flex-direction: row; align-items: stretch; gap: 0; }
            .video-player-section { flex-shrink: 0; flex-basis: 33%; position: sticky; top: 60px; align-self: flex-start; 
max-height: calc(100vh - 80px); /* Altura m치xima = 100% de la pantalla menos el header y un margen */
    overflow-y: auto; /* Muestra la barra de scroll vertical solo si es necesario */
    padding-right: 0.5rem; /* Peque침o espacio para que la barra no se pegue al contenido */
}
            .right-panel-content { 
                flex-grow: 1; 
                display: flex; 
                flex-direction: column; 
                gap: 0;
                overflow: hidden; /* ADDED to contain the scrolling child */
                min-height: 0;
            }
            .editor-and-sidebars-wrapper { flex-direction: column; flex-grow: 1; display: flex; }
            /* Let the editor grow to fill the available space */
            .editor-main-content { flex-grow: 1; overflow-y: auto; }
            /* Hide the old sidebar container and its resizer */
            .sidebars-container, #vertical-resizer { display: none; }
        }

        /* Video player styles */
        #videoPlayerContainer { width: 100%; background-color: #000; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem; gap: 1rem; }
        #videoPlayerWrapper { position: relative; width: 100%; line-height: 0; background-color: #000; border-radius: 0.5rem; min-height: 250px; }
        #videoPlayer { width: 100%; height: auto; max-height: calc(50vh - 105px); border-radius: 0.5rem; object-fit: contain; background-color: #000; }
        #subtitlePreviewOverlay { position: absolute; bottom: 10%; left: 0; right: 0; padding: 1rem; text-align: center; pointer-events: none; transition: opacity 0.3s ease; }
        #subtitlePreviewText { font-weight: 500; font-size: var(--user-font-size); color: white; padding: 0.10em 0.10em; background-color: rgba(0, 0, 0, 0.4); border-radius: 0.25rem; line-height: 1.4; text-shadow: 0px 0px 3px rgba(0,0,0,1); white-space: pre-wrap; }
        #videoFileInput { display: none; }

        /* Animation for Restore button */
        @keyframes pulse-yellow { 0%, 100% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.7); } 50% { box-shadow: 0 0 0 8px rgba(250, 204, 21, 0); } }
        .animate-pulse-yellow { animation: pulse-yellow 2s infinite; }

/* --- START: Fullscreen Video Controls & Subtitles --- */

/* Muestra la barra de controles en hover O en pantalla completa (con prefijos de compatibilidad) */
#videoPlayerWrapper:hover #videoControlsBar,
#videoPlayerWrapper:-webkit-full-screen #videoControlsBar,
#videoPlayerWrapper:-moz-full-screen #videoControlsBar,
#videoPlayerWrapper:fullscreen #videoControlsBar {
    opacity: 1;
}

/* Ajusta la posici칩n de los subt칤tulos en pantalla completa para que no choquen con los controles */
#videoPlayerWrapper:-webkit-full-screen #subtitlePreviewOverlay,
#videoPlayerWrapper:-moz-full-screen #subtitlePreviewOverlay,
#videoPlayerWrapper:fullscreen #subtitlePreviewOverlay {
    bottom: 8%; 
}

/* Anula la restricci칩n de altura del v칤deo S칍LO en pantalla completa */
#videoPlayerWrapper.is-fullscreen #videoPlayer {
    width: 100% !important;
    height: 100% !important;
    max-height: 100% !important;
    object-fit: contain; 
}

/* --- END: Fullscreen Video Controls & Subtitles --- */

/* --- START: Custom Video Controls Styles --- */


        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #4a5568;
            border-radius: 5px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -4px; /* Center thumb on track */
        }
        input[type=range]:focus::-webkit-slider-runnable-track {
            background: #2d3748;
        }

          .volume-control {
            position: relative;
            /* A침adimos padding para crear un "puente" para el hover */
            padding-bottom: 0.5rem;
            margin-bottom: -0.5rem; /* Compensamos el padding para no mover otros elementos */
        }

        .volume-slider-container {
            position: absolute;
            /* Ajustamos la posici칩n para que quede justo encima del bot칩n */
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(17, 24, 39, 0.75);
            padding: 1rem 0.75rem;
            border-radius: 0.75rem;
            display: none;
        }

        .volume-control:hover .volume-slider-container {
            display: block;
        }

        #volumeBar {
            -webkit-appearance: slider-vertical;
            writing-mode: bt-lr;
            background-color: transparent;
            width: 15px;
            height: 96px;
        }

video::-webkit-media-controls-fullscreen-button {
    display: none;
}
video::-moz-fullscreen-button {
    display: none !important; /* Mantenemos esto con !important por si acaso */
    opacity: 0 !important;    /* Lo hacemos totalmente transparente */
    width: 0 !important;     /* Forzamos a que no tenga anchura */
    pointer-events: none;    /* Desactivamos cualquier clic sobre 칠l */
}

video::-ms-fullscreen-button {
    display: none;
}

        /* --- END: Custom Video Controls Styles --- */

#customFullscreenBtn span {
    font-size: 28px;      /* Tama침o grande para el car치cter */
    line-height: 1;       /* Centrado vertical perfecto */
}

/* --- START: Vertical Size Control Styles --- */
.size-control {
    position: relative;
    padding-bottom: 0.5rem;
    margin-bottom: -0.5rem;
}

.size-slider-container {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(17, 24, 39, 0.75);
    padding: 1rem 0.75rem;
    border-radius: 0.75rem;
    display: none;
}

.size-control:hover .size-slider-container {
    display: block;
}

#subtitleFontSize {
    -webkit-appearance: slider-vertical;
    writing-mode: bt-lr;
    background-color: transparent;
    width: 15px;
    height: 96px;
    cursor: pointer;
}

#subtitleFontSize::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 16px;
    width: 16px;
    border-radius: 50%;
    background: #ffffff;
    cursor: pointer;
    margin-top: 0;
    margin-left: -4px;
}

/* Estilos para el manejador en Firefox */
#volumeBar::-moz-range-thumb,
#subtitleFontSize::-moz-range-thumb {
    height: 16px;
    width: 16px;
    border-radius: 50%;
    background: #ffffff;
    cursor: pointer;
    border: none; /* Importante para evitar estilos por defecto */
}

/* Estilos para la pista en Firefox (opcional pero recomendado) */
#volumeBar::-moz-range-track,
#subtitleFontSize::-moz-range-track {
  background: #4a5568;
  border-radius: 5px;
  width: 8px;
}

/* --- START: Subtitle Source Control Styles --- */
.source-control {
    position: relative;
    padding-bottom: 0.5rem;
    margin-bottom: -0.5rem; /* Puente para el hover */
}

.source-options-container {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(17, 24, 39, 0.75);
    padding: 0.5rem;
    border-radius: 0.75rem;
    display: none; /* Oculto por defecto */
    flex-direction: column;
    gap: 0.25rem;
    width: 120px; /* Ancho fijo para el men칰 */
}

.source-control:hover .source-options-container {
    display: flex; /* Se muestra al hacer hover */
}

.source-option {
    background-color: transparent;
    color: white;
    padding: 0.5rem;
    border-radius: 0.5rem;
    text-align: center;
    font-size: 0.875rem;
    width: 100%;
    transition: background-color 0.2s ease;
}

.source-option:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.source-option.active {
    background-color: #075BA2; /* Color primario para la opci칩n activa */
    font-weight: 700;
}
/* --- END: Subtitle Source Control Styles --- */

/* --- Planner Styles --- */
.session-row {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.5rem;
    border-radius: 0.5rem;
    border: 1px solid #e5e7eb;
    transition: background-color 0.2s;
    cursor: pointer;
}
.session-row:hover {
    background-color: #f9fafb;
}
.session-row.completed {
    background-color: #f0fdf4; /* green-50 */
}
.session-row.completed .session-text {
    text-decoration: line-through;
    color: #6b7280;
}
.session-row.active {
    border-color: #075BA2;
    box-shadow: 0 0 0 2px rgba(7, 91, 162, 0.2);
}
.session-text {
    flex-grow: 1;
    font-size: 0.875rem;
}
.session-time {
    font-family: monospace;
    font-weight: 600;
    background-color: #e5e7eb;
    padding: 0.1rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.9rem;
}

#sessionResults {
    max-height: 250px; /* Altura m치xima para la lista antes de que aparezca el scroll */
    overflow-y: auto; /* Muestra el scroll vertical solo si la lista es m치s alta que max-height */
    padding-right: 0.25rem; /* Espacio para la barra de scroll */
}

#videoPlayerContainer {
    flex-shrink: 0;
}

/* --- END: Planner Styles --- */

/* --- Notificaciones (Toast) --- */
        #messageBox {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: auto;
            max-width: 350px;
            z-index: 2000;
            transition: opacity 0.3s ease-in-out; /* Solo transicionamos la opacidad */
            opacity: 0; /* Por defecto, es invisible */
            pointer-events: none; /* Evita que se pueda hacer clic cuando est치 invisible */
        }
        #messageBox.is-visible {
            opacity: 1;
            pointer-events: auto; /* Permite interacci칩n cuando es visible */
        }
        #messageBox .modal-content {
            padding: 1rem 1.5rem;
            text-align: center;
        }
        #messageClose {
            display: none;
        }

/* --- INICIO: C칍DIGO PARA LA BARRA DE CONTROLES ADAPTABLE (DEFINITIVO) --- */

#videoPlayerWrapper {
    container-type: inline-size;
    container-name: video-wrapper;
}

@container video-wrapper (max-width: 480px) {
    #videoControlsBar .btn {
        font-size: 0.75rem;
        padding: 0.2rem 0.5rem;
    }
    #videoControlsRight {
        gap: 0.5rem;
    }
    #fontSizeDisplay {
        width: 2.75rem;
    }
    #videoControlsLeft span {
        display: none;
    }
    #videoControlsLeft::after {
        content: '游꿘';
        font-size: 1.25rem;
        line-height: 1;
    }

    /* --- 칔LTIMO AJUSTE DE ALINEACI칍N --- */
    #setPreviewOriginal,
    #setPreviewTranslation {
        color: transparent;
        position: relative;
        width: 2rem;   /* Igualamos al ancho de los otros botones (w-8) */
        height: 2rem;  /* Igualamos a la altura de los otros botones (h-8) */
        padding-top: 0;
        padding-bottom: 0;
    }
    #setPreviewOriginal::after {
        content: 'O';
        font-size: 0.75rem;
        color: black;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
    #setPreviewTranslation::after {
        content: 'T';
        font-size: 0.75rem;
        color: white;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
}
/* --- FIN: C칍DIGO PARA LA BARRA DE CONTROLES ADAPTABLE --- */

/* --- INICIO: A칌ADIR ESTE BLOQUE DE CSS --- */
        #statusBar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30px; /* Altura de la barra */
            background-color: #ffffff;
            border-top: 1px solid #d1d5db; /* Borde superior sutil */
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.05); /* Sombra ligera */
            z-index: 980; /* Encima del contenido, debajo de modales */
            padding: 0 1rem; /* Espaciado horizontal */
            display: flex;
            align-items: center;
            justify-content: center; /* Para contenido futuro */
            font-size: 0.875rem;
            color: #374151; /* Color de texto gris oscuro */
            transition: transform 0.3s ease-in-out;
            transform: translateY(100%); /* Oculto por defecto (movido hacia abajo) */
        }
        #statusBar.is-visible {
            transform: translateY(0); /* Visible (en su posici칩n original) */
        }


/* --- FIN: A칌ADIR ESTE BLOQUE DE CSS --- */

/* --- ESTILOS MODO OSCURO --- */
        
        /* Fondo base y texto */
        html.dark body {
            background-color: #111827; /* Gris muy oscuro */
            color: #e5e7eb; /* Texto claro */
        }

        /* Paneles, Modales y Tarjetas */
        html.dark .bg-white, 
        html.dark .modal-content, 
        html.dark .floating-panel,
        html.dark .translation-unit-active,
        html.dark .subtitle-editor {
            background-color: #1f2937 !important; /* Gris oscuro panel */
            color: #e5e7eb !important;
            border-color: #374151 !important;
        }

        /* Inputs y Textareas */
        html.dark input, 
        html.dark select, 
        html.dark textarea,
        html.dark .subtitle-display-code {
            background-color: #374151 !important;
            color: #fff !important;
            border-color: #4b5563 !important;
        }

        /* Headers y Fondos claros */
        html.dark .app-header,
        html.dark .bg-gray-50,
        html.dark .bg-gray-100 {
            background-color: #111827 !important;
            color: #e5e7eb !important;
            border-color: #374151 !important;
        }

        /* Textos oscuros forzados a claro */
        html.dark .text-gray-700,
        html.dark .text-gray-900,
        html.dark .text-black {
            color: #d1d5db !important;
        }

        /* Hover en men칰s */
        html.dark .hover\:bg-gray-100:hover {
            background-color: #374151 !important;
        }

        /* Botones secundarios */
        html.dark .btn-secondary {
            background-color: #374151;
            color: #e5e7eb;
            border-color: #4b5563;
        }
        html.dark .btn-secondary:hover:not(:disabled) {
            background-color: #4b5563;
        }
        
        /* Correcciones espec칤ficas */
        html.dark .translation-unit-bg {
            background-color: #1f2937; /* Fondo de la tarjeta de subt칤tulo */
            border-color: #374151;
        }
        html.dark #statusBar {
            background-color: #1f2937;
            border-top-color: #374151;
            color: #9ca3af;
        }
        html.dark .accordion-header {
             background-color: #1f2937;
             border-bottom-color: #374151;
        }
        html.dark .accordion-header:hover {
             background-color: #374151;
        }

/* --- CORRECCIONES ADICIONALES MODO OSCURO --- */

        /* Encabezados de los paneles laterales (Terminolog칤a, TM, etc.) */
        html.dark .sidebar-header {
            background-color: #1f2937 !important; /* Mismo gris que el panel */
            border-bottom-color: #374151 !important; /* Borde sutil */
            color: #e5e7eb !important;
        }

        /* Cajas de informaci칩n (Info Boxes) de glosarios y TM */
        html.dark .glossary-info-box, 
        html.dark .tm-info-box,
        html.dark .bg-blue-50, /* Cajas de aviso azules */
        html.dark .bg-gray-100 { /* Cajas de estad칤sticas */
            background-color: #374151 !important; /* Un gris un poco m치s claro para destacar */
            border-color: #4b5563 !important;
            color: #d1d5db !important;
        }

        /* Correcci칩n para textos azules dentro de las cajas oscuras (para que se lean bien) */
        html.dark .text-blue-700,
        html.dark .text-blue-800 {
            color: #93c5fd !important; /* Azul claro legible */
        }
        
        /* Botones de cerrar (X) y restaurar en los paneles */
        html.dark .sidebar-header button {
            color: #9ca3af !important;
        }
        html.dark .sidebar-header button:hover {
            color: #fff !important;
        }

        /* --- AJUSTES FINALES DE COLORES EN MODO OSCURO --- */

        /* 1. Resizer Horizontal (Barra separadora) */
        html.dark #horizontal-resizer {
            background-color: #020617 !important; /* Casi negro */
            border-left-color: #1f2937 !important;
            border-right-color: #1f2937 !important;
        }
        html.dark #horizontal-resizer:hover {
            background-color: #374151 !important; /* Gris oscuro al pasar el rat칩n */
        }
        
        /* 2. Memoria de Traducci칩n (TM): Diferencias */
        /* Inserciones (Verde) */
        html.dark .diff-insertion {
            background-color: #064e3b !important; /* Verde botella oscuro */
            color: #ecfccb !important; /* Texto verde muy claro para contraste */
            border: 1px solid #065f46; /* Borde sutil */
        }
        /* Eliminaciones (Rojo) */
        html.dark .diff-deletion {
            background-color: #450a0a !important; /* Rojo sangre oscuro */
            color: #fecaca !important; /* Texto rojo muy claro */
            text-decoration-color: #f87171 !important; /* Color de la l칤nea de tachado */
        }
        /* Fila de "Mejor coincidencia" (Best Match) */
        html.dark .tm-best-match-highlight {
            background-color: rgba(6, 78, 59, 0.3) !important; /* Verde oscuro transparente */
            border-color: #065f46 !important;
            box-shadow: 0 0 0 3px rgba(6, 95, 70, 0.3) !important;
        }

        /* 3. Glosario: Resaltados (Amarillo) */
        /* T칠rmino resaltado dentro del texto original */
        html.dark .glossary-highlight {
            background-color: #713f12 !important; /* Ocre/Dorado oscuro */
            color: #fef08a !important; /* Amarillo p치lido para el texto */
            border: 1px solid #854d0e;
        }
        /* Fila resaltada en la tabla lateral */
        html.dark .glossary-row-highlight {
            background-color: rgba(113, 63, 18, 0.4) !important; /* Marr칩n dorado semitransparente */
        }

/* Fondo principal de la aplicaci칩n */
        /* Lo oscurecemos casi hasta el negro para mejorar el contraste con las tarjetas */
        html.dark .main-app-content {
            background-color: #0b121a !important; /* Tono "Slate 950", muy cercano al negro */
        }
        /* Etiqueta de coincidencia de glosario (encima del subt칤tulo) */
        /* Cambiamos el amarillo brillante por un ocre oscuro legible */
        html.dark span[id^="glossary-match-"] {
            background-color: #713f12 !important; /* Marr칩n/Dorado oscuro */
            color: #fef08a !important; /* Texto amarillo p치lido */
            border: 1px solid #854d0e !important; /* Borde sutil para definici칩n */
        }
    </style>
</head>
<body class="bg-gray-100">
    <header class="app-header">
        <div class="header-main-actions">
            <div class="relative group">
                <button class="btn btn-primary inline-flex items-center">
                    <span data-i18n="project_menu">Proyecto</span>
                    <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </button>
                <div class="absolute z-10 -left-2 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform-gpu group-hover:scale-100 scale-95">
                    <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="options-menu">
                        <button id="newProjectBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
                            <span data-i18n="new_project">Nuevo proyecto</span>
                        </button>
                        <label for="projectFile" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 cursor-pointer" role="menuitem">
                            <span data-i18n="load_project">Cargar proyecto</span>
                            <input type="file" id="projectFile" accept=".subpanda" class="hidden">
                        </label>
                        <button id="saveProjectBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 disabled:text-gray-400" role="menuitem" disabled>
                            <span data-i18n="save_project">Guardar proyecto</span>
                        </button>
<div class="border-t border-gray-100"></div>
 <button id="backupBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
        <span data-i18n="backup_btn">Copia de seguridad</span>
    </button>
<div class="border-t border-gray-100"></div>
<button id="resetAppBtn" class="block w-full text-left px-4 py-2 text-sm text-red-700 hover:bg-red-50 hover:text-red-900" role="menuitem">
    <span data-i18n="reset_app_btn">Resetear aplicaci칩n</span>
</button>
                    </div>
                </div>
            </div>
            
            <div class="relative group">
    <button class="btn btn-secondary inline-flex items-center">
        <span data-i18n="import_menu">Importar</span>
        <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
    </button>
    <div class="absolute z-10 -left-2 mt-2 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform-gpu group-hover:scale-100 scale-95">
        <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="options-menu">
            <label for="srtFile" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 cursor-pointer" role="menuitem">
                <span data-i18n="import_srt">Importar .srt original</span>
                <input type="file" id="srtFile" accept=".srt" class="hidden">
            </label>
            
            <label for="translatedSrtFile" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 cursor-pointer" role="menuitem" data-i18n-title="import_translated_tooltip" title="Carga un SRT traducido para rellenar la columna derecha">
                <span data-i18n="import_translated_srt">Importar traducci칩n (.srt)</span>
                <input type="file" id="translatedSrtFile" accept=".srt" class="hidden">
            </label>
        </div>
    </div>
</div>
            <button id="saveSrt" class="btn btn-secondary" disabled>
                <span data-i18n="export_srt">Exportar .srt</span>
            </button>
<div class="relative group">
    <button class="btn btn-secondary inline-flex items-center">
        <span data-i18n="tools_menu">Herramientas</span>
        <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
    </button>
    <div class="absolute z-10 -left-2 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform-gpu group-hover:scale-100 scale-95">
        <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="options-menu">
 <button id="undoBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 disabled:text-gray-400" role="menuitem" disabled>
            <span data-i18n="undo_btn">Deshacer</span>
        </button>
        <button id="redoBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 disabled:text-gray-400" role="menuitem" disabled>
            <span data-i18n="redo_btn">Rehacer</span>
        </button>
        <div class="border-t border-gray-200"></div>
            <button id="findReplaceBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
                <span data-i18n="find_replace_btn">Buscar y reemplazar</span>
            </button>
            <button id="shortcutsBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
                <span data-i18n="shortcuts_btn">Atajos</span>
            </button>
            <button id="notesBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900">
    <span data-i18n="notes_btn">Notas</span>
</button>
<button id="goToSubtitleBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
        <span data-i18n="go_to_subtitle_menu">Ir a...</span>
    </button>
<button id="timecodeSettingsBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
    <span data-i18n="timecode_settings_btn">Ajustes de Timecode</span>
</button>
<button id="toggleStatusBarBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
                <span data-i18n="show_status_bar_btn">Mostrar barra de estado</span>
            </button>
        </div>
    </div>
</div>
                        <button id="qaBtn" class="btn btn-secondary">
                <span data-i18n="qa_btn">QA</span>
            </button>
            <button id="contextBtn" class="btn btn-secondary">
    <span data-i18n="context_btn">IA</span>
</button>

            <button id="terminologyBtn" class="btn btn-secondary">
                <span data-i18n="terminology_btn">Terminolog칤a</span>
            </button>
            <button id="tmBtn" class="btn btn-secondary">
                <span data-i18n="tm_btn">Memoria de traducci칩n</span>
            </button>
        </div>
        <div class="header-lang-switcher flex items-center gap-2">
            <button id="themeToggleBtn" class="btn btn-secondary p-2" title="Cambiar tema">
                <svg id="icon-moon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                <svg id="icon-sun" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
            </button>
            <div class="h-6 w-px bg-gray-300 mx-1"></div>
            <button id="lang-es" class="btn btn-lang active">ES</button>
            <button id="lang-en" class="btn btn-lang">EN</button>
        </div>
    </header>

    <div class="main-app-content">
       <div class="video-player-section flex flex-col items-center justify-center p-4">

    <div id="videoPlayerContainer" class="w-full">
        <div id="videoPlayerWrapper" class="relative bg-black rounded-lg group">
            <div id="videoControlsBar" class="absolute top-0 left-0 right-0 z-10 w-full flex justify-between items-center p-2 bg-black bg-opacity-50 transition-opacity duration-300 opacity-0 group-hover:opacity-100">
        
        <label for="videoFileInput" id="videoControlsLeft" class="btn btn-primary py-2">
            <span data-i18n="load_video">Cargar v칤deo</span>
            <input type="file" id="videoFileInput" accept="video/*" class="hidden">
        </label>
    
        <div id="videoControlsRight" class="flex items-center gap-4">
            <div class="flex items-center gap-1 p-1 bg-gray-700 rounded-md">
                <button id="setPreviewOriginal" class="btn py-2 btn-secondary" data-i18n="original_text_option">Original</button>
                <button id="setPreviewTranslation" class="btn py-2 btn-secondary" data-i18n="translation_text_option">Traducci칩n</button>
            </div>
            <div class="flex items-center gap-2 text-white">
                <button id="decreaseFontSize" class="btn btn-secondary w-8 h-8 flex items-center justify-center text-lg">-</button>
                <span id="fontSizeDisplay" class="font-semibold text-sm w-12 text-center">22px</span>
                <button id="increaseFontSize" class="btn btn-secondary w-8 h-8 flex items-center justify-center text-lg">+</button>
                <button id="customFullscreenBtn" class="btn btn-secondary w-8 h-8 flex items-center justify-center">
                    <span id="fullscreen-enter-char">久</span>
                    <span id="fullscreen-exit-char" class="hidden">咎</span>
                </button>
            </div>
        </div>
    </div>
    <video id="videoPlayer" class="w-full h-auto rounded-lg"></video>
    
            <div id="videoLogoPlaceholder" class="absolute inset-0 flex items-center justify-center pointer-events-none">
                <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/subpandatm-logo.png" alt="subpandaTM Logo" class="h-24 w-auto opacity-75">
            </div>
    
            <div id="subtitlePreviewOverlay">
                <span id="subtitlePreviewText"></span>
            </div>
        </div>
    </div>
    
    <div id="waveform" class="bg-white p-4 rounded-lg shadow-xl w-full mt-4 hidden">
        </div>
        <div id="waveformControls" class="w-full bg-gray-50 p-2 rounded-b-lg shadow-lg flex justify-center items-center gap-3 -mt-1 hidden">
            <button id="lockWaveformBtn" class="btn btn-secondary" title="Bloquear/Desbloquear onda">
                <svg class="lock-icon-open w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5V6.75a4.5 4.5 0 1 0-9 0v3.75m.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" />
                </svg>
                <svg class="lock-icon-closed hidden w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 10.5V6.75a4.5 4.5 0 1 0-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" />
                </svg>
            </button>
<button id="followPlaybackBtn" class="btn btn-secondary">
        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M2.036 12.322a1.012 1.012 0 0 1 0-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178Z" />
          <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
        </svg>
    </button>
            <button id="zoomOutBtn" class="btn btn-secondary" data-i18n-title="zoom_out">
                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607ZM7.5 10.5h6" /> </svg>
            </button>
            <button id="zoomInBtn" class="btn btn-secondary" data-i18n-title="zoom_in">
                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607ZM10.5 7.5v3m0 0v3m0-3h3m-3 0h-3" />
                </svg>
            </button>
        </div>
                <div id="statsContainer" class="bg-white p-4 rounded-lg shadow-xl w-full mt-4 hidden">
                    <div class="accordion-item">
                        <div class="accordion-header" id="statsAccordionHeader">
                            <h3 class="text-lg font-bold" data-i18n="translation_stats_title">Estad칤sticas</h3>
                            <svg class="w-5 h-5 accordion-icon rotated" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </div>
                        <div class="accordion-content collapsed" id="statsAccordionContent">
                            <div class="bg-gray-100 p-3 rounded-md shadow-sm text-sm text-center space-y-1">
                                <p><span id="segmentsProgress"></span></p>
                                <p><span id="wordsTranslated"></span> / <span id="wordsTotal"></span></p>
                                <p><span id="wordsRemaining"></span></p>
                                <p id="qaErrorStats"></p>
                            </div>
                        </div>
                    </div>
                </div>
    <div id="plannerContainer" class="bg-white p-4 rounded-lg shadow-xl w-full mt-4 hidden">
        <div class="accordion-item">
            <div class="accordion-header" id="plannerAccordionHeader">
                <h3 class="text-lg font-bold" data-i18n="planner_title">Planificador</h3>
                <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </div>
            <div class="accordion-content collapsed" id="plannerAccordionContent">
                <div class="flex flex-col sm:flex-row items-center gap-2 p-2 bg-gray-50 rounded-lg">
        <div class="flex items-center gap-2 flex-shrink-0">
            <label for="sessionCount" class="text-sm font-medium" data-i18n="planner_divide_in">Dividir en:</label>
            <input type="number" id="sessionCount" value="3" min="1" class="w-16 p-1 border border-gray-300 rounded-md text-center">
            <label for="sessionCount" class="text-sm font-medium" data-i18n="planner_sessions">sesiones</label>
        </div>
        <div class="flex-grow w-full">
            <select id="divisionMethod" class="w-full p-1.5 border border-gray-300 rounded-md text-sm">
                <option value="subtitles" data-i18n="planner_method_subs">Por n칰mero de subt칤tulos</option>
                <option value="words" data-i18n="planner_method_words">Por n칰mero de palabras</option>
                <option value="time" data-i18n="planner_method_time">Por tiempo</option>
            </select>
        </div>
        <button id="calculateSessionsBtn" class="btn btn-primary w-full sm:w-auto" data-i1admin="planner_calculate">Calcular</button>
    </div>
                <div id="sessionResults" class="mt-4 space-y-2">
                    </div>
            </div>
        </div>
    </div>

</div> <div id="horizontal-resizer"></div>

        <div class="right-panel-content">
            <div class="editor-and-sidebars-wrapper" id="editorAndSidebarsWrapper">
                <div class="editor-main-content space-y-4 pr-2" id="editorMainContent">
                    <div id="translationsContainer">
                        <div data-i18n="no_translations" id="initialMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md">
                           Importa un archivo .srt y un v칤deo para empezar a trabajar. Si lo deseas, puedes trabajar con una memoria de traducci칩n TMX y un glosario TBX, que puedes importar o crear desde cero.
                        </div>
                    </div>
                </div>

                <div id="vertical-resizer"></div>

                <div class="sidebars-container">
                </div>
            </div>
        </div>
    </div>

    <div id="terminologySidebar" class="floating-panel">
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="terminology_sidebar_title">Terminolog칤a</h3>
            <div class="flex items-center">
                <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posici칩n y tama침o">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
                </button>
                <button id="closeTerminologySidebarBtn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>
        <div class="sidebar-content">
            <div id="terminologyLanguageConfigSection" class="space-y-4">
                <h4 class="text-md font-semibold mb-2" data-i18n="config_lang_title">Configurar idiomas del glosario</h4>
                <div class="glossary-info-box mb-4">
                    <p data-i18n="config_lang_info"></p>
                </div>
                <div class="flex flex-col space-y-2 mb-4">
                    <div class="glossary-input-group">
                        <label for="configSrcLang" data-i18n="source_language">Idioma de origen:</label>
                        <input id="configSrcLang" list="isoLanguages" value="en-US" class="block w-full rounded-md" />
                    </div>
                    <div class="glossary-input-group">
                        <label for="configTgtLang" data-i18n="target_language">Idioma de destino:</label>
                        <input id="configTgtLang" list="isoLanguages" value="es-ES" class="block w-full rounded-md" />
                    </div>
                    <button onclick="confirmGlossaryLanguages()" data-i18n="confirm_languages" class="btn btn-primary w-full">Confirmar idiomas</button>
                </div>
            </div>

            <div id="terminologyEditorSection" style="display:none;">
                <div class="flex flex-col sm:flex-row gap-2 mb-4">
                    <button onclick="loadTBX()" data-i18n="import_tbx" class="btn btn-secondary flex-1 text-sm">Importar TBX</button>
                    <input type="file" id="tbxFileInput" accept=".xml,.tbx" class="hidden" />
                    <button onclick="downloadTBX()" data-i18n="download_tbx" class="btn btn-secondary flex-1 text-sm">Descargar TBX</button>
                    <button id="newGlossaryBtn" data-i18n="new_glossary" class="btn btn-secondary flex-1 text-sm">Nuevo glosario</button>
                </div>
                <h4 class="text-md font-semibold mb-2" data-i18n="current_lang_title">Idiomas actuales del glosario</h4>
                <div class="flex space-x-2 mb-4">
                    <div class="glossary-input-group flex-1">
                        <label data-i18n="source_language">Idioma de origen:</label>
                        <input id="displaySrcLang" disabled class="block w-full rounded-md" />
                    </div>
                    <div class="glossary-input-group flex-1">
                        <label data-i18n="target_language">Idioma de destino:</label>
                        <input id="displayTgtLang" disabled class="block w-full rounded-md" />
                    </div>
                </div>
                <div class="accordion-item">
                    <div class="accordion-header" id="addTermHeader">
                        <h4 class="text-md font-semibold m-0" data-i18n="add_term_title">A침adir t칠rmino</h4>
                        <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </div>
                    <div class="accordion-content collapsed" id="addTermContent">
                        <div class="flex flex-col space-y-2 mb-4">
                            <div class="glossary-input-group">
                                <label for="srcTerm" data-i18n="term">T칠rmino:</label>
                                <input id="srcTerm" class="block w-full rounded-md" />
                            </div>
                            <div class="glossary-input-group">
                                <label for="tgtTerm" data-i18n="translation">Traducci칩n:</label>
                                <input id="tgtTerm" class="block w-full rounded-md" />
                            </div>
                            <button onclick="addTerm()" data-i18n="add_button" class="btn btn-primary w-full">A침adir</button>
                        </div>
                    </div>
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="search_title">Buscar</h4>
                <div class="mb-4">
                    <input id="searchTerm" data-i18n-placeholder="search_placeholder" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white" oninput="renderGlossary()" />
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="glossary_list_title">Glosario</h4>
                <div class="overflow-x-auto">
                    <table class="w-full">
                        <thead>
                            <tr>
                                <th data-i18n="source_term_col">T칠rmino de origen</th>
                                <th data-i18n="target_term_col">T칠rmino de destino</th>
                                <th data-i18n="actions_col">Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="glossaryTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
        <datalist id="isoLanguages"></datalist>
    </div>

    <div id="translationMemorySidebar" class="floating-panel">
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="tm_sidebar_title">Memoria de traducci칩n</h3>
            <div class="flex items-center">
                <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posici칩n y tama침o">
                   <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
                </button>
                <button id="closeTranslationMemorySidebarBtn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>
        <div class="sidebar-content">
            <div id="tmInternalMessage" class="tm-info-box mb-4 hidden"></div>
            <div id="tmLanguageConfigSection" class="space-y-4">
                <h4 class="text-md font-semibold mb-2" data-i18n="tm_config_lang_title">Configurar idiomas de la TM</h4>
                <div class="tm-info-box mb-4">
                    <p data-i18n="tm_config_lang_info"></p>
                </div>
                <div class="flex flex-col space-y-2 mb-4">
                    <div class="tm-input-group">
                        <label for="tmConfigSrcLang" data-i18n="source_language">Idioma de origen:</label>
                        <input id="tmConfigSrcLang" list="isoLanguages" value="en-US" class="block w-full rounded-md" />
                    </div>
                    <div class="tm-input-group">
                        <label for="tmConfigTgtLang" data-i18n="target_language">Idioma de destino:</label>
                        <input id="tmConfigTgtLang" list="isoLanguages" value="es-ES" class="block w-full rounded-md" />
                    </div>
                    <button onclick="confirmTMLanguages()" data-i18n="confirm_languages" class="btn btn-primary w-full">Confirmar idiomas</button>
                </div>
            </div>

            <div id="tmEditorSection" style="display:none;">
                <div class="flex flex-col sm:flex-row gap-2 mb-4">
                    <button id="newTmBtn" data-i18n="new_tm" class="btn btn-secondary flex-1 text-sm">Nueva TM</button>
                    <label for="tmFileInput" class="btn btn-secondary flex-1 text-sm text-center">
                        <span data-i18n="import_tmx">Importar TMX</span>
                        <input type="file" id="tmFileInput" accept=".xml,.tmx" class="hidden" />
                    </label>
                    <button onclick="downloadTMX()" data-i18n="download_tmx" class="btn btn-secondary flex-1 text-sm">Descargar TMX</button>
                </div>
                <h4 class="text-md font-semibold mb-2" data-i18n="current_tm_lang_title">Idiomas actuales de la TM</h4>
                <div class="flex space-x-2 mb-4">
                    <div class="tm-input-group flex-1">
                        <label data-i18n="source_language">Idioma de origen:</label>
                        <input id="displayTmSrcLang" disabled class="block w-full rounded-md" />
                    </div>
                    <div class="tm-input-group flex-1">
                        <label data-i18n="target_language">Idioma de destino:</label>
                        <input id="displayTmTgtLang" disabled class="block w-full rounded-md" />
                    </div>
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="tm_search_title">Buscar en TM</h4>
                <div class="mb-4">
                    <input id="tmSearchInput" data-i18n-placeholder="tm_search_placeholder" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white" oninput="tmSearch()" />
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="tm_search_results_title">Resultados de b칰squeda en TM</h4>
                <div class="overflow-x-auto mb-4">
                    <table class="tm-table w-full">
                        <thead>
                            <tr>
                                <th data-i18n="tm_score_col">%</th>
                                <th data-i18n="tm_original_col">Original</th>
                                <th data-i18n="tm_translation_col">Traducci칩n</th>
                            </tr>
                        </thead>
                        <tbody id="tmSearchResultsTableBody"></tbody>
                    </table>
                </div>
                <div data-i18n="tm_no_match_found" id="tmNoMatchFoundMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md hidden">
                    No se encontraron coincidencias en la TM.
                </div>
            </div>
        </div>
    </div>

    <div id="messageBox" class="modal hidden">
        <div class="modal-content">
            <p id="messageText" class="text-lg font-semibold mb-4"></p>
            <button id="messageClose" class="btn btn-primary w-full" data-i18n="ok">OK</button>
        </div>
    </div>
    
    <div id="shortcutsModal" class="modal hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 data-i18n="shortcuts_title" class="text-xl font-bold">Atajos de teclado</h2>
                <div class="flex gap-2">
                    <label for="importShortcutsInput" class="btn btn-secondary text-sm" data-i18n="import_shortcuts_btn">Importar</label>
                    <input type="file" id="importShortcutsInput" class="hidden" accept=".json">
                    <button id="exportShortcutsBtn" class="btn btn-secondary text-sm" data-i18n="export_shortcuts_btn">Exportar</button>
                </div>
<div class="flex items-center gap-2">
                    <label for="shortcutProfileSelector" class="text-sm font-medium">Perfil:</label>
                    <select id="shortcutProfileSelector" class="text-sm rounded-md border-gray-300 shadow-sm">
                        <option value="windows">Windows / Linux</option>
                        <option value="mac">macOS</option>
                    </select>
                </div>
            </div>
            <div id="shortcutsList" class="space-y-2 max-h-[60vh] overflow-y-auto pr-2">
                </div>
            <div class="flex justify-between items-center mt-6">
                <button id="restoreShortcutsBtn" class="btn btn-destructive" data-i18n="restore_defaults_btn">Restaurar valores por defecto</button>
                <button id="shortcutsCloseBtn" class="btn btn-primary" data-i18n="close_btn">Cerrar</button>
            </div>
        </div>
    </div>

<div id="findReplacePanel" class="floating-panel" style="width: 600px; height: auto;">
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="find_replace_title">Buscar y reemplazar</h3>
            <div class="flex items-center">
                <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posici칩n y tama침o">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
                </button>
                <button id="closeFindReplacePanelBtn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>
        <div class="sidebar-content p-4">
            <div class="space-y-4">
                <div>
                    <label for="findInput" data-i18n="find_label" class="block text-sm font-medium mb-1">Buscar:</label>
                    <input type="text" id="findInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div>
                    <label for="replaceInput" data-i18n="replace_label" class="block text-sm font-medium mb-1">Reemplazar con:</label>
                    <input type="text" id="replaceInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex items-center space-x-4">
                    <label class="flex items-center">
                        <input type="checkbox" id="caseSensitiveCheckbox" class="mr-2 rounded">
                        <span data-i18n="case_sensitive">Distinguir may칰sculas y min칰sculas</span>
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" id="regexCheckbox" class="mr-2 rounded">
                        <span data-i18n="regular_expression">Expresi칩n regular</span>
                    </label>
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="findPrevBtn" class="btn btn-secondary" data-i18n="find_prev">Buscar anterior</button>
                    <button id="findNextBtn" class="btn btn-secondary" data-i18n="find_next">Buscar siguiente</button>
                    <button id="replaceBtn" class="btn btn-primary" data-i18n="replace">Reemplazar</button>
                    <button id="replaceAllBtn" class="btn btn-destructive" data-i18n="replace_all">Reemplazar todo</button>
                </div>
            </div>
        </div>
    </div>

    <div id="saveSrtModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_srt_title" class="text-xl font-bold mb-4">Exportar Archivo SRT</h2>
            <div class="space-y-4">
                <div>
                    <label for="fileNameInput" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="fileNameInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>
    <div id="saveTbxModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_tbx_title" class="text-xl font-bold mb-4">Exportar Archivo TBX</h2>
            <div class="space-y-4">
                <div>
                    <label for="fileNameInputTbx" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="fileNameInputTbx" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveTbxBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveTbxBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>

    <div id="saveTmxModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_tmx_title" class="text-xl font-bold mb-4">Exportar Archivo TMX</h2>
            <div class="space-y-4">
                <div>
                    <label for="fileNameInputTmx" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="fileNameInputTmx" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveTmxBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveTmxBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>
    <div id="backupModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="backup_modal_title" class="text-xl font-bold mb-4">Copia de Seguridad</h2>
            <div id="backupFoundView">
                <div id="backupInfo" class="bg-gray-100 p-4 rounded-md mb-4">
                    <p data-i18n="restore_backup_info"></p>
                    <p><strong><span data-i18n="file_label"></span></strong> <span id="backupFileName"></span></p>
                    <p><strong><span data-i18n="last_modified_label"></span></strong> <span id="backupLastModified"></span></p>
                </div>
                <div class="flex justify-end space-x-2 flex-wrap gap-2">
                    <button data-i18n="export_srt_btn" id="exportSrtFromBackupBtn" class="btn btn-primary">Exportar SRT</button>
                    <button data-i18n="delete_backup_btn" id="deleteBackupBtn" class="btn btn-destructive">Borrar Backup</button>
                    <button data-i18n="restore_btn" id="confirmRestoreBtn" class="btn btn-primary">Restaurar</button>
                </div>
            </div>
            <div id="noBackupFoundView" class="hidden">
                 <p data-i18n="no_backup_found_info"></p>
            </div>
            <button data-i18n="close_btn" id="closeBackupModalBtn" class="btn btn-secondary w-full mt-6">Cerrar</button>
        </div>
    </div>
    <div id="qaModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="qa_modal_title" class="text-xl font-bold mb-4">Configuraci칩n de QA</h2>
            <div class="space-y-4">
                <div class="qa-input-group">
                    <label for="qaCpsLimit" data-i18n="cps_limit_label" class="block text-sm font-medium mb-1">L칤mite de CPS:</label>
                    <input type="number" id="qaCpsLimit" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="qa-input-group">
                    <label for="qaCharsPerLineLimit" data-i18n="chars_per_line_limit_label" class="block text-sm font-medium mb-1">L칤mite de caracteres por l칤nea:</label>
                    <input type="number" id="qaCharsPerLineLimit" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
            </div>
            <div class="flex justify-end space-x-2 mt-6">
                 <button id="closeQaModalBtn" class="btn btn-secondary" data-i18n="close_btn">Cerrar</button>
                <button id="saveQaSettingsBtn" class="btn btn-primary" data-i18n="save_and_apply_btn">Guardar y aplicar</button>
            </div>
        </div>
    </div>
    <div id="qaErrorListModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="qa_error_list_title" class="text-xl font-bold mb-4">Lista de Errores de QA</h2>
            <div id="qaErrorListContainer"></div>
            <button id="closeQaErrorListModalBtn" class="btn btn-secondary w-full mt-6" data-i18n="close_btn">Cerrar</button>
        </div>
    </div>
    <div id="reselectVideoModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="reselect_video_title" class="text-xl font-bold mb-4">Seleccionar v칤deo</h2>
            <p data-i18n="reselect_video_info" id="reselectVideoInfo" class="mb-4"></p>
            <label for="reselectVideoInput" class="btn btn-primary w-full">
                <span data-i18n="load_video">Cargar v칤deo</span>
                <input type="file" id="reselectVideoInput" accept="video/*" class="hidden">
            </label>
            <button id="skipReselectVideoBtn" class="btn btn-secondary w-full mt-2" data-i18n="skip_btn">Omitir</button>
        </div>
    </div>
<div id="saveProjectModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_project_title" class="text-xl font-bold mb-4">Guardar Proyecto</h2>
            <div class="space-y-4">
                <div>
                    <label for="projectFileNameInput" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="projectFileNameInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveProjectBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveProjectBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>
    <div id="confirmNewProjectModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="confirm_new_project_title" class="text-xl font-bold mb-4">Crear nuevo proyecto</h2>
            <p data-i18n="confirm_new_project_message" class="mb-6">Tienes cambios sin guardar. 쯈uieres guardar el proyecto actual antes de continuar?</p>
            <div class="flex justify-end space-x-2">
                <button id="cancelNewProjectBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                <button id="continueWithoutSavingBtn" class="btn btn-destructive" data-i18n="continue_without_saving_btn">Continuar sin guardar</button>
                <button id="saveAndContinueBtn" class="btn btn-primary" data-i18n="save_and_continue_btn">Guardar y continuar</button>
            </div>
        </div>
    </div>

    <div id="confirmResetGlossaryModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="confirm_new_glossary_title" class="text-xl font-bold mb-4">Confirmar nuevo glosario</h2>
            <p data-i18n="confirm_new_glossary_message" class="mb-6">Solo puedes tener un glosario activo. Si contin칰as, se borrar치n todos los datos del glosario actual. Para evitar perder tu trabajo, aseg칰rate de exportarlo primero como un archivo TBX.</p>
            <div class="flex justify-end space-x-2">
                <button id="cancelResetGlossaryBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                <button id="confirmResetGlossaryBtn" class="btn btn-destructive" data-i18n="continue_btn">Continuar</button>
            </div>
        </div>
    </div>

    <div id="confirmResetTmModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="confirm_new_tm_title" class="text-xl font-bold mb-4">Confirmar nueva TM</h2>
            <p data-i18n="confirm_new_tm_message" class="mb-6">Solo puedes tener una memoria de traducci칩n (TM) activa. Si contin칰as, se borrar치n todos los datos de la TM actual. Para evitar perder tu trabajo, aseg칰rate de exportarla primero como un archivo TMX.</p>
            <div class="flex justify-end space-x-2">
                <button id="cancelResetTmBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                <button id="confirmResetTmBtn" class="btn btn-destructive" data-i18n="continue_btn">Continuar</button>
            </div>
        </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="loading-spinner"></div>
        <p id="loadingMessage"></p>
    </div>

<div id="notesSidebar" class="floating-panel" style="width: 350px; height: 500px;">
    <div class="sidebar-header">
        <h3 class="text-lg font-bold">
            <span data-i18n="notes_sidebar_title">Notas</span> 
            <span id="notesSubtitleIndex" class="text-sm font-normal text-gray-500 ml-2"></span>
        </h3>
        <div class="flex items-center">
            <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posici칩n">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
            </button>
            <button id="closeNotesSidebarBtn" class="text-gray-500 hover:text-gray-700">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>
    <div class="sidebar-content p-4 flex flex-col gap-4 h-full overflow-y-auto">
        <div class="glossary-info-box mb-2">
            <p data-i18n="notes_info">Guarda borradores y consulta sus estad칤sticas.</p>
        </div>

        <div class="flex flex-col gap-1">
            <div class="flex justify-between items-center">
                <label class="text-xs font-bold text-gray-500 uppercase">Opci칩n 1</label>
                <button onclick="insertNoteToEditor(1)" class="text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 px-2 py-1 rounded flex items-center gap-1 transition-colors" title="A침adir al editor">
                    <span>Insertar</span>
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18"></path></svg>
                </button>
            </div>
            <textarea id="noteArea1" class="w-full border border-gray-300 rounded-md p-2 text-sm focus:ring-blue-500 focus:border-blue-500 resize-none h-20 font-mono"></textarea>
            <div class="w-full h-1.5 bg-gray-200 rounded-full overflow-hidden">
                <div id="noteBar1" class="h-full bg-green-500 transition-all duration-300" style="width: 0%"></div>
            </div>
            <div id="noteStats1" class="text-xs text-right text-gray-500 font-mono">CPS: 0 | L1: 0</div>
        </div>

        <div class="flex flex-col gap-1">
            <div class="flex justify-between items-center">
                <label class="text-xs font-bold text-gray-500 uppercase">Opci칩n 2</label>
                <button onclick="insertNoteToEditor(2)" class="text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 px-2 py-1 rounded flex items-center gap-1 transition-colors" title="A침adir al editor">
                    <span>Insertar</span>
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18"></path></svg>
                </button>
            </div>
            <textarea id="noteArea2" class="w-full border border-gray-300 rounded-md p-2 text-sm focus:ring-blue-500 focus:border-blue-500 resize-none h-20 font-mono"></textarea>
            <div class="w-full h-1.5 bg-gray-200 rounded-full overflow-hidden">
                <div id="noteBar2" class="h-full bg-green-500 transition-all duration-300" style="width: 0%"></div>
            </div>
            <div id="noteStats2" class="text-xs text-right text-gray-500 font-mono">CPS: 0 | L1: 0</div>
        </div>

        <div class="flex flex-col gap-1">
            <div class="flex justify-between items-center">
                <label class="text-xs font-bold text-gray-500 uppercase">Opci칩n 3</label>
                <button onclick="insertNoteToEditor(3)" class="text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 px-2 py-1 rounded flex items-center gap-1 transition-colors" title="A침adir al editor">
                    <span>Insertar</span>
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18"></path></svg>
                </button>
            </div>
            <textarea id="noteArea3" class="w-full border border-gray-300 rounded-md p-2 text-sm focus:ring-blue-500 focus:border-blue-500 resize-none h-20 font-mono"></textarea>
            <div class="w-full h-1.5 bg-gray-200 rounded-full overflow-hidden">
                <div id="noteBar3" class="h-full bg-green-500 transition-all duration-300" style="width: 0%"></div>
            </div>
            <div id="noteStats3" class="text-xs text-right text-gray-500 font-mono">CPS: 0 | L1: 0</div>
        </div>
    </div>
</div>

    <div id="contextSidebar" class="floating-panel">
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="context_sidebar_title">Contexto IA</h3>
            <div class="flex items-center">
                <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posici칩n y tama침o">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
                </button>
                <button id="closeContextSidebarBtn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>
        <div class="sidebar-content p-4" id="contextSidebarContent">
            <div id="contextImportView">
                <h4 class="font-bold text-md mb-2" data-i18n="load_context_title">Cargar Contexto</h4>
                <div class="accordion-item mb-4">
    <div class="accordion-header" id="contextHelpHeader">
        <h4 class="text-md font-semibold m-0" data-i18n="context_help_title">쮺칩mo funciona?</h4>
        <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
    </div>
    <div class="accordion-content collapsed" id="contextHelpContent">
        <div class="space-y-2 text-sm">
            <p data-i18n="context_help_intro"></p>
            <p data-i18n="context_help_format"></p>
        </div>
    </div>
</div>
                
                <div class="flex items-center gap-2 mb-1">
    <button id="copyPromptBtn" class="btn btn-primary flex-1" data-i18n="copy_prompt_btn"></button>
    <button id="pasteJsonBtn" class="btn btn-secondary" data-i18n="paste_json_btn"></button>
    <button id="aiSettingsBtn" class="btn btn-secondary p-2" title="Personalizar Prompt">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
    </button>
</div>
                <div id="jsonValidationStatus" class="text-xs h-5 mb-2"></div>
                
                <textarea id="contextPasteArea" class="w-full h-32 p-2 border rounded-md mb-2" data-i18n-placeholder="paste_json_placeholder"></textarea>
                <button id="importFromPasteBtn" class="btn btn-primary w-full mb-4" data-i18n="import_from_paste_btn"></button>
                
                <div class="text-center my-2 text-gray-500 font-semibold" data-i18n="or_divider"></div>
                
<label for="contextFileInput" class="btn btn-secondary w-full text-center cursor-pointer block">
                    <span data-i18n="import_from_file_btn"></span>
                    <input type="file" id="contextFileInput" accept=".json" class="hidden">
                </label>
            </div>

            <div id="contextDisplayView" class="hidden"></div>
        </div>
    </div>

<div id="aiSettingsModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="ai_settings_title" class="text-xl font-bold mb-4">Personalizar prompt de IA</h2>
            <p data-i18n="ai_settings_intro" class="text-sm text-gray-600 mb-4">
                A침ade hasta tres instrucciones para la IA. La primera es obligatoria y viene con un texto por defecto que puedes modificar. Las pautas de QA se a침adir치n autom치ticamente.
            </p>
            <div class="space-y-3">
                <div>
                    <label for="aiInstruction1" class="block text-sm font-medium mb-1" data-i18n="ai_instruction_1_label">Instrucci칩n 1 (Obligatoria):</label>
                    <textarea id="aiInstruction1" rows="3" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></textarea>
                </div>
                <div>
                    <label for="aiInstruction2" class="block text-sm font-medium mb-1" data-i18n="ai_instruction_2_label">Instrucci칩n 2 (Opcional):</label>
                    <textarea id="aiInstruction2" rows="2" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></textarea>
                </div>
                <div>
                    <label for="aiInstruction3" class="block text-sm font-medium mb-1" data-i18n="ai_instruction_3_label">Instrucci칩n 3 (Opcional):</label>
                    <textarea id="aiInstruction3" rows="2" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></textarea>
                </div>
            </div>
            <div class="flex justify-end space-x-2 mt-6">
                 <button id="closeAiSettingsModalBtn" class="btn btn-secondary" data-i18n="close_btn">Cerrar</button>
                <button id="saveAiSettingsBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
            </div>
        </div>
    </div>

<div id="timecodeModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="timecode_modal_title" class="text-xl font-bold mb-4">Ajustes de Timecode</h2>
            <div class="space-y-4">
                
                <div class="qa-input-group">
                    <label for="projectFpsInput" data-i18n="project_fps_label" class="block text-sm font-medium mb-1">FPS del Proyecto:</label>
                    <select id="projectFpsInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                        <option value="23.976">23.976</option>
                        <option value="24">24</option>
                        <option value="25" selected>25</option>
                        <option value="29.97">29.97</option>
                        <option value="30">30</option>
                        <option value="50">50</option>
                        <option value="59.94">59.94</option>
                        <option value="60">60</option>
                        <option value="custom">Otro...</option>
                    </select>
                    <input type="number" id="projectFpsCustomInput" step="0.001" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white mt-2 hidden" placeholder="Escribe FPS personalizado">
                </div>
                
                <div class="glossary-info-box bg-blue-50 border-blue-200">
                    <p data-i18n="fps_recommendation_note" class="text-blue-700"></p>
                </div>
                <div class="flex items-center">
                    <input type="checkbox" id="useFrameTimecodeToggle" class="mr-2 rounded">
                    <label for="useFrameTimecodeToggle" data-i18n="show_frames_label" class="text-sm font-medium">Mostrar timecode en frames (ej. 00:00:10:05)</label>
                </div>
                <div class="glossary-info-box">
                    <p data-i18n="timecode_warning">Aviso: La exportaci칩n SRT siempre usar치 milisegundos por compatibilidad.</p>
                </div>
            </div>
            <div class="flex justify-end space-x-2 mt-6">
                 <button id="closeTimecodeModalBtn" class="btn btn-secondary" data-i18n="close_btn">Cerrar</button>
                <button id="saveTimecodeSettingsBtn" class="btn btn-primary" data-i18n="save_and_apply_btn">Guardar y aplicar</button>
            </div>
        </div>
    </div>

<div id="goToSubtitlePanel" class="floating-panel" style="width: 320px; height: auto;">
    <div class="sidebar-header">
        <h3 class="text-lg font-bold" data-i18n="go_to_subtitle_title">Ir a Subt칤tulo / TC</h3>
        <div class="flex items-center">
            <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posici칩n y tama침o">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
            </button>
            <button id="closeGoToSubtitlePanelBtn" class="text-gray-500 hover:text-gray-700">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>
    <div class="sidebar-content p-4 space-y-4">
        <div>
            <label for="goToSubtitleInput" class="block text-sm font-medium mb-1" data-i18n="go_to_subtitle_label">Ir al subt칤tulo N췈:</label>
            <div class="flex gap-2">
                <input type="number" id="goToSubtitleInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white" min="1">
                <button id="goToSubtitleActionBtn" class="btn btn-primary" data-i18n="go_btn">Ir</button>
            </div>
        </div>
        <div>
            <label for="goToTimecodeInput" class="block text-sm font-medium mb-1" data-i18n="go_to_timecode_label">Ir al timecode:</label>
            <div class="flex gap-2">
                <input type="text" id="goToTimecodeInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 font-mono text-black bg-white" value="00:00:00,000" onfocus="this.select()">
                <button id="goToTimecodeActionBtn" class="btn btn-primary" data-i18n="go_btn">Ir</button>
            </div>
        </div>
    </div>
</div>


    <script>
        // --- IndexedDB Setup (Dexie.js) ---
        const db = new Dexie("subpandaTM_v2");
        db.version(1).stores({
            projects: '++id, fileName',
            settings: 'key' // Using 'key' as the primary key for settings objects
        });

        // Global variables
        let srtEntries = [];
        let currentFileName = 'subtitles.srt';
        let videoFileName = null;
let wavesurfer = null;
let wsRegions = null;
        let currentLanguage = 'es';
        let findState = { query: '', replace: '', caseSensitive: false, useRegex: false, lastFound: null };
        let previewSource = 'translation';
let subtitleFontSize = 20; // Tama침o de fuente inicial en p칤xeles
        let qaSettings = { cpsLimit: 20, charsPerLineLimit: 42 };
        let termsFoundInActiveSegment = new Set();
        let glossary = [];
        let glossarySourceLanguage = '';
        let glossaryTargetLanguage = '';
        let currentGlossaryLatestResults = [];
        let translationMemory = [];
        let tmSourceLanguage = '';
        let tmTargetLanguage = '';
        let tmBestMatchForActiveSegment = null;
        let currentTMLatestSearchResults = [];
        let editingTermIndex = -1; 
        let timeUpdateListener = null;
let contextData = [];
let lastActiveSubtitleIndex = 0;
let afterSaveAction = null;
let messageTimeout = null;
let projectFPS = 25;
let useFrameTimecode = false;
let historyStack = [];
let redoStack = [];
let debounceTimeout = null;
let isApplyingState = false; 
let isWaveformLocked = false;
let currentWaveformZoom = 100; // Valor inicial (minPxPerSec)
const ZOOM_STEP = 20; // Cu치nto zoom a침adir/quitar cada vez
let isFollowPlaybackActive = false;
let currentlyTrackedRegionId = null;
let currentlyTrackedEditorIndex = -1;
let lastFocusedEditorUnitIndex = -1;
        
        const DIFF_DELETE = -1;
        const DIFF_INSERT = 1;
        const DIFF_EQUAL = 0;

        // DOM elements
        const notesBtn = document.getElementById('notesBtn');
        const notesSidebar = document.getElementById('notesSidebar');
        const closeNotesSidebarBtn = document.getElementById('closeNotesSidebarBtn');
        const notesSubtitleIndex = document.getElementById('notesSubtitleIndex');
        const noteArea1 = document.getElementById('noteArea1');
        const noteArea2 = document.getElementById('noteArea2');
        const noteArea3 = document.getElementById('noteArea3');
        let activeNoteSubtitleIndex = -1;
        const srtFile = document.getElementById('srtFile');
        const translatedSrtFile = document.getElementById('translatedSrtFile');
        const saveSrtButton = document.getElementById('saveSrt');
        const translationsContainer = document.getElementById('translationsContainer');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageClose = document.getElementById('messageClose');
        const dropArea = document.querySelector('.main-app-content');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const videoPlayerContainer = document.getElementById('videoPlayerContainer');
        const videoPlayer = document.getElementById('videoPlayer');
        const videoFileInput = document.getElementById('videoFileInput');
        const subtitlePreviewText = document.getElementById('subtitlePreviewText');
const setPreviewOriginal = document.getElementById('setPreviewOriginal');
const setPreviewTranslation = document.getElementById('setPreviewTranslation');
const decreaseFontSize = document.getElementById('decreaseFontSize');
const increaseFontSize = document.getElementById('increaseFontSize');
const fontSizeDisplay = document.getElementById('fontSizeDisplay');
const videoPlayerWrapper = document.getElementById('videoPlayerWrapper');
const customFullscreenBtn = document.getElementById('customFullscreenBtn');
const fullscreenEnterChar = document.getElementById('fullscreen-enter-char');
const fullscreenExitChar = document.getElementById('fullscreen-exit-char');
                const statsContainer = document.getElementById('statsContainer');
        const segmentsProgress = document.getElementById('segmentsProgress');
        const wordsTranslated = document.getElementById('wordsTranslated');
        const wordsTotal = document.getElementById('wordsTotal');
        const wordsRemaining = document.getElementById('wordsRemaining');
        const qaErrorStats = document.getElementById('qaErrorStats');
        const statsAccordionHeader = document.getElementById('statsAccordionHeader');
        const statsAccordionContent = document.getElementById('statsAccordionContent');
        const statsAccordionIcon = statsAccordionHeader.querySelector('.accordion-icon');
        const shortcutsBtn = document.getElementById('shortcutsBtn');
        const shortcutsModal = document.getElementById('shortcutsModal');
        const shortcutsCloseBtn = document.getElementById('shortcutsCloseBtn');
        const findReplaceBtn = document.getElementById('findReplaceBtn');
        const findReplacePanel = document.getElementById('findReplacePanel');
        const closeFindReplacePanelBtn = document.getElementById('closeFindReplacePanelBtn');
        const findInput = document.getElementById('findInput');
        const replaceInput = document.getElementById('replaceInput');
        const caseSensitiveCheckbox = document.getElementById('caseSensitiveCheckbox');
        const regexCheckbox = document.getElementById('regexCheckbox');
        const findPrevBtn = document.getElementById('findPrevBtn');
        const findNextBtn = document.getElementById('findNextBtn');
        const replaceBtn = document.getElementById('replaceBtn');
        const replaceAllBtn = document.getElementById('replaceAllBtn');
        const findReplaceCloseBtn = document.getElementById('findReplaceCloseBtn');
        const saveSrtModal = document.getElementById('saveSrtModal');
        const fileNameInput = document.getElementById('fileNameInput');
        const confirmSaveBtn = document.getElementById('confirmSaveBtn');
        const cancelSaveBtn = document.getElementById('cancelSaveBtn');
        const backupBtn = document.getElementById('backupBtn');
        const backupModal = document.getElementById('backupModal');
        const backupFoundView = document.getElementById('backupFoundView');
        const noBackupFoundView = document.getElementById('noBackupFoundView');
        const backupFileName = document.getElementById('backupFileName');
        const backupLastModified = document.getElementById('backupLastModified');
        const closeBackupModalBtn = document.getElementById('closeBackupModalBtn');
        const exportSrtFromBackupBtn = document.getElementById('exportSrtFromBackupBtn');
        const deleteBackupBtn = document.getElementById('deleteBackupBtn');
        const confirmRestoreBtn = document.getElementById('confirmRestoreBtn');
        const qaBtn = document.getElementById('qaBtn');
        const qaModal = document.getElementById('qaModal');
        const qaCpsLimitInput = document.getElementById('qaCpsLimit');
        const qaCharsPerLineLimitInput = document.getElementById('qaCharsPerLineLimit');
        const saveQaSettingsBtn = document.getElementById('saveQaSettingsBtn');
        const closeQaModalBtn = document.getElementById('closeQaModalBtn');
        const qaErrorListModal = document.getElementById('qaErrorListModal');
        const qaErrorListContainer = document.getElementById('qaErrorListContainer');
        const closeQaErrorListModalBtn = document.getElementById('closeQaErrorListModalBtn');
        const terminologyBtn = document.getElementById('terminologyBtn');
        const terminologySidebar = document.getElementById('terminologySidebar');
        const closeTerminologySidebarBtn = document.getElementById('closeTerminologySidebarBtn');
        const terminologyLanguageConfigSection = document.getElementById('terminologyLanguageConfigSection');
        const terminologyEditorSection = document.getElementById('terminologyEditorSection');
        const configSrcLang = document.getElementById('configSrcLang');
        const configTgtLang = document.getElementById('configTgtLang');
        const displaySrcLang = document.getElementById('displaySrcLang');
        const displayTgtLang = document.getElementById('displayTgtLang');
        const srcTermInput = document.getElementById('srcTerm');
        const tgtTermInput = document.getElementById('tgtTerm');
        const searchTermInput = document.getElementById('searchTerm');
        const glossaryTableBody = document.getElementById('glossaryTableBody');
        const tbxFileInput = document.getElementById('tbxFileInput');
        const isoLanguagesDatalist = document.getElementById('isoLanguages');
        const addTermHeader = document.getElementById('addTermHeader');
        const addTermContent = addTermHeader.nextElementSibling;
        const addTermAccordionIcon = addTermHeader.querySelector('.accordion-icon');
        const tmBtn = document.getElementById('tmBtn');
        const translationMemorySidebar = document.getElementById('translationMemorySidebar');
        const closeTranslationMemorySidebarBtn = document.getElementById('closeTranslationMemorySidebarBtn');
        const tmFileInput = document.getElementById('tmFileInput');
        const tmSearchInput = document.getElementById('tmSearchInput');
        const tmSearchResultsTableBody = document.getElementById('tmSearchResultsTableBody');
        const tmNoMatchFoundMessage = document.getElementById('tmNoMatchFoundMessage');
        const tmLanguageConfigSection = document.getElementById('tmLanguageConfigSection');
        const tmEditorSection = document.getElementById('tmEditorSection');
        const tmConfigSrcLang = document.getElementById('tmConfigSrcLang');
        const tmConfigTgtLang = document.getElementById('tmConfigTgtLang');
        const displayTmSrcLang = document.getElementById('displayTmSrcLang');
        const displayTmTgtLang = document.getElementById('displayTmTgtLang');
        const tmInternalMessage = document.getElementById('tmInternalMessage');
        const langEsBtn = document.getElementById('lang-es');
        const langEnBtn = document.getElementById('lang-en');
        const shortcutsList = document.getElementById('shortcutsList');
        const exportShortcutsBtn = document.getElementById('exportShortcutsBtn');
        const importShortcutsInput = document.getElementById('importShortcutsInput');
        const restoreShortcutsBtn = document.getElementById('restoreShortcutsBtn');
        const saveTbxModal = document.getElementById('saveTbxModal');
        const fileNameInputTbx = document.getElementById('fileNameInputTbx');
        const confirmSaveTbxBtn = document.getElementById('confirmSaveTbxBtn');
        const cancelSaveTbxBtn = document.getElementById('cancelSaveTbxBtn');
        const saveTmxModal = document.getElementById('saveTmxModal');
        const fileNameInputTmx = document.getElementById('fileNameInputTmx');
        const confirmSaveTmxBtn = document.getElementById('confirmSaveTmxBtn');
        const cancelSaveTmxBtn = document.getElementById('cancelSaveTmxBtn');
        // Project elements
        const newProjectBtn = document.getElementById('newProjectBtn');
        const saveProjectBtn = document.getElementById('saveProjectBtn');
        const projectFile = document.getElementById('projectFile');
const resetAppBtn = document.getElementById('resetAppBtn');
        const reselectVideoModal = document.getElementById('reselectVideoModal');
        const reselectVideoInfo = document.getElementById('reselectVideoInfo');
        const reselectVideoInput = document.getElementById('reselectVideoInput');
        const skipReselectVideoBtn = document.getElementById('skipReselectVideoBtn');
        const confirmNewProjectModal = document.getElementById('confirmNewProjectModal');
        const cancelNewProjectBtn = document.getElementById('cancelNewProjectBtn');
        const continueWithoutSavingBtn = document.getElementById('continueWithoutSavingBtn');
        const saveAndContinueBtn = document.getElementById('saveAndContinueBtn');
        const saveProjectModal = document.getElementById('saveProjectModal');
const projectFileNameInput = document.getElementById('projectFileNameInput');
const confirmSaveProjectBtn = document.getElementById('confirmSaveProjectBtn');
const cancelSaveProjectBtn = document.getElementById('cancelSaveProjectBtn');
        const confirmResetGlossaryModal = document.getElementById('confirmResetGlossaryModal');
        const confirmResetGlossaryBtn = document.getElementById('confirmResetGlossaryBtn');
        const cancelResetGlossaryBtn = document.getElementById('cancelResetGlossaryBtn');
        const confirmResetTmModal = document.getElementById('confirmResetTmModal');
        const confirmResetTmBtn = document.getElementById('confirmResetTmBtn');
        const cancelResetTmBtn = document.getElementById('cancelResetTmBtn');

const contextBtn = document.getElementById('contextBtn');
const contextSidebar = document.getElementById('contextSidebar');
const closeContextSidebarBtn = document.getElementById('closeContextSidebarBtn');
const contextFile = document.getElementById('contextFile');
const goToSubtitleBtn = document.getElementById('goToSubtitleBtn');
const goToSubtitlePanel = document.getElementById('goToSubtitlePanel');
const closeGoToSubtitlePanelBtn = document.getElementById('closeGoToSubtitlePanelBtn');
const goToSubtitleInput = document.getElementById('goToSubtitleInput');
const goToSubtitleActionBtn = document.getElementById('goToSubtitleActionBtn');
const goToTimecodeInput = document.getElementById('goToTimecodeInput');
const goToTimecodeActionBtn = document.getElementById('goToTimecodeActionBtn');
const contextHelpHeader = document.getElementById('contextHelpHeader');
const contextHelpContent = document.getElementById('contextHelpContent');
// --- INICIO: Nuevos elementos DOM de la botonera ---
const waveformControls = document.getElementById('waveformControls');
const lockWaveformBtn = document.getElementById('lockWaveformBtn');
const zoomInBtn = document.getElementById('zoomInBtn');
const zoomOutBtn = document.getElementById('zoomOutBtn');
const lockIconOpen = document.querySelector('.lock-icon-open');
const lockIconClosed = document.querySelector('.lock-icon-closed');
const followPlaybackBtn = document.getElementById('followPlaybackBtn'); 
// --- FIN: Nuevos elementos DOM de la botonera ---

        // --- I18N & SHORTCUTS SETUP ---

        const translations = {
            'es': {
                'title': 'subpandaTM', 'import_menu': 'Importar', 'import_srt': 'Importar .srt', 'export_srt': 'Exportar .srt', 'backup_btn': 'Copia de seguridad', 'qa_btn': 'QA', 'shortcuts_btn': 'Atajos', 'find_replace_btn': 'Buscar y reemplazar', 'terminology_btn': 'Terminolog칤a', 'tm_btn': 'Memoria de traducci칩n', 'load_video': 'Cargar v칤deo', 'change_video': 'Cambiar v칤deo', 'preview_size': 'Tama침o:', 'preview_source': 'Mostrar:', 'translation_text_option': 'Traducci칩n', 'original_text_option': 'Original', 'translation_stats_title': 'Estad칤sticas', 'segments_progress_text': '{0}/{1} subt칤tulos traducidos ({2}%)', 'words_translated_text': '{0} palabras traducidas', 'words_total_text': '{0} palabras originales totales', 'words_remaining_text': '{0} palabras pendientes', 'no_translations': 'Importa un archivo .srt y un v칤deo para empezar a trabajar. Si lo deseas, puedes trabajar con una memoria de traducci칩n TMX y un glosario TBX, que puedes importar o crear desde cero.', 'time_codes': 'C칩digos de tiempo:', 'original_text': 'Original:', 'translation_text': 'Traducci칩n:', 'validate': 'Validar', 'edit': 'Editar', 'char_count_original': 'Original: ', 'char_count_translation': 'Traducci칩n: ', 'char_units': ' c', 'cps': ' CPS', 'ok': 'OK', 'close_btn': 'Cerrar', 'save_btn': 'Guardar', 'cancel_btn': 'Cancelar', 'shortcuts_title': 'Atajos de teclado',
                'shortcut_desc_validateAndNext': 'Validar traducci칩n y pasar a la siguiente', 'shortcut_desc_goToNext': 'Ir al siguiente subt칤tulo', 'shortcut_desc_goToPrevious': 'Ir al subt칤tulo anterior', 'shortcut_desc_insertTM1': 'Insertar 1춹 sugerencia de la MT', 'shortcut_desc_insertTM2': 'Insertar 2춹 sugerencia de la MT', 'shortcut_desc_insertTM3': 'Insertar 3춹 sugerencia de la MT', 'shortcut_desc_insertTM4': 'Insertar 4춹 sugerencia de la MT', 'shortcut_desc_insertTM5': 'Insertar 5춹 sugerencia de la MT', 'shortcut_desc_insertGloss1': 'Insertar 1er t칠rmino del glosario', 'shortcut_desc_insertGloss2': 'Insertar 2췈 t칠rmino del glosario', 'shortcut_desc_insertGloss3': 'Insertar 3er t칠rmino del glosario', 'shortcut_desc_insertGloss4': 'Insertar 4췈 t칠rmino del glosario', 'shortcut_desc_insertGloss5': 'Insertar 5췈 t칠rmino del glosario', 'shortcut_desc_jumpToTime': 'Saltar al tiempo de inicio del subt칤tulo actual', 'shortcut_desc_playSegment': 'Reproducir el subt칤tulo actual', 'shortcut_desc_playPause': 'Reproducir/pausar v칤deo', 'shortcut_desc_seekForward': 'Avanzar 3 segundos', 'shortcut_desc_seekBackward': 'Retroceder 3 segundos', 'shortcut_desc_seekForwardFast': 'Avanzar 5 segundos', 'shortcut_desc_seekBackwardFast': 'Retroceder 5 segundos', 'shortcut_desc_bold': 'Aplicar negrita', 'shortcut_desc_italic': 'Aplicar cursiva',
                'find_replace_title': 'Buscar y reemplazar', 'find_label': 'Buscar:', 'replace_label': 'Reemplazar con:', 'case_sensitive': 'Distinguir may칰sculas y min칰sculas', 'regular_expression': 'Expresi칩n regular', 'find_prev': 'Buscar anterior', 'find_next': 'Buscar siguiente', 'replace': 'Reemplazar', 'replace_all': 'Reemplazar todo', 'save_srt_title': 'Exportar Archivo SRT', 'save_tbx_title': 'Exportar Archivo TBX', 'save_tmx_title': 'Exportar Archivo TMX', 'file_name_label': 'Nombre del archivo:', 'backup_modal_title': 'Copia de Seguridad', 'restore_backup_info': 'Se ha encontrado una copia de seguridad de una sesi칩n no guardada.', 'file_label': 'Archivo:', 'last_modified_label': '칔ltima modificaci칩n:', 'export_srt_btn': 'Exportar SRT', 'delete_backup_btn': 'Borrar Backup', 'restore_btn': 'Restaurar', 'no_backup_found_info': 'No se ha encontrado ninguna copia de seguridad autom치tica.', 'qa_modal_title': 'Configuraci칩n de QA', 'cps_limit_label': 'L칤mite de CPS:', 'chars_per_line_limit_label': 'L칤mite de caracteres por l칤nea:', 'save_and_apply_btn': 'Guardar y aplicar', 'qa_error_list_title': 'Lista de Errores de QA', 'qa_errors_found': '{0} errores de QA encontrados', 'qa_no_errors': 'No se han encontrado errores de QA.', 'terminology_sidebar_title': 'Terminolog칤a', 'config_lang_title': 'Configurar idiomas del glosario', 'config_lang_info': 'Define los idiomas de origen y destino de tu glosario. Es fundamental que el c칩digo ISO sea correcto. Tras configurar el idioma, podr치s importar o crear un glosario desde cero.', 'source_language': 'Idioma de origen:', 'target_language': 'Idioma de destino:', 'confirm_languages': 'Confirmar idiomas', 'current_lang_title': 'Idiomas actuales del glosario', 'add_term_title': 'A침adir t칠rmino', 'term': 'T칠rmino:', 'translation': 'Traducci칩n:', 'add_button': 'A침adir', 'search_title': 'Buscar', 'search_placeholder': 'Buscar t칠rmino...', 'import_tbx': 'Importar TBX', 'download_tbx': 'Descargar TBX', 'new_glossary': 'Nuevo glosario', 'glossary_list_title': 'Glosario', 'source_term_col': 'T칠rmino de origen', 'target_term_col': 'T칠rmino de destino', 'actions_col': 'Acciones', 'edit_button': 'Editar', 'delete_button': 'Eliminar', 'save_changes_btn': 'Guardar cambios', 'tm_sidebar_title': 'Memoria de traducci칩n', 'tm_config_lang_title': 'Configurar idiomas de la TM', 'tm_config_lang_info': 'Define los idiomas de origen y destino de tu memoria de traducci칩n. Es fundamental que el c칩digo ISO sea correcto. Tras configurar el idioma, podr치s importar o crear una memoria desde cero.', 'current_tm_lang_title': 'Idiomas actuales de la TM', 'new_tm': 'Nueva TM', 'import_tmx': 'Importar TMX', 'download_tmx': 'Descargar TMX', 'tm_search_title': 'Buscar en TM', 'tm_search_placeholder': 'Buscar en la memoria...', 'tm_search_results_title': 'Resultados de b칰squeda en TM', 'tm_score_col': '%', 'tm_original_col': 'Original', 'tm_translation_col': 'Traducci칩n', 'tm_no_match_found': 'No se encontraron coincidencias en la TM.',
                'import_shortcuts_btn': 'Importar', 'export_shortcuts_btn': 'Exportar', 'restore_defaults_btn': 'Restaurar valores por defecto', 'edit_shortcut_btn': 'Editar', 'recording_shortcut_text': 'Pulsar tecla...', 'project_menu': 'Proyecto', 'load_project': 'Cargar proyecto', 'save_project': 'Guardar proyecto', 'new_project': 'Nuevo proyecto', 'reselect_video_title': 'Seleccionar v칤deo', 'reselect_video_info': 'Proyecto cargado. Para sincronizar el v칤deo, por favor, selecciona el archivo de v칤deo original:', 'reselect_video_prompt': 'Proyecto cargado. Por favor, selecciona el archivo de v칤deo original: {0}', 'skip_btn': 'Omitir', 'confirm_new_project_title': 'Crear nuevo proyecto', 'confirm_new_project_message': 'Tienes cambios sin guardar. 쯈uieres guardar el proyecto actual antes de continuar?', 'continue_without_saving_btn': 'Continuar sin guardar',  'save_and_continue_btn': 'Guardar y continuar',
                'confirm_new_glossary_title': 'Confirmar nuevo glosario', 'confirm_new_glossary_message': 'Solo puedes tener un glosario activo. Si contin칰as, se borrar치n todos los datos del glosario actual. Para evitar perder tu trabajo, aseg칰rate de exportarlo primero como un archivo TBX.','confirm_new_tm_title': 'Confirmar nueva TM','confirm_new_tm_message': 'Solo puedes tener una memoria de traducci칩n (TM) activa. Si contin칰as, se borrar치n todos los datos de la TM actual. Para evitar perder tu trabajo, aseg칰rate de exportarla primero como un archivo TMX.', 'continue_btn': 'Continuar',
                'productive_documentation': 'Documentaci칩n productiva', 'doc_resource_placeholder': 'Ej: https://dle.rae.es/{word}', 
'entry_time': 'Entrada:',
                'exit_time': 'Salida:',
                'duration_label': 'Duraci칩n:',
                'rewind_frame_tooltip': 'Retroceder 1 fotograma (40ms)',
                'play_segment_tooltip': 'Reproducir subt칤tulo',
                'forward_frame_tooltip': 'Avanzar 1 fotograma (40ms)',
'shortcut_desc_playSegmentLoop': 'Reproducir subt칤tulo actual en bucle',
'validate_all_previous': 'Validar ant.',
'validate_all_previous_tooltip': 'Validar este y todos los subt칤tulos anteriores',
'context_sidebar_title': 'Asistente de IA',
'context_btn': 'IA',
'import_context': 'Importar contexto',
'ai_translation_title': 'Sugerencia de la IA:',
'context_notes_title': 'Consultas:',
'pretranslate_all_btn': 'Pretraducir todo',
        'pretranslate_all_title': 'Rellena todos los subt칤tulos con la sugerencia principal de la IA',
        'instruction_1': 'Instrucci칩n 1',
        'instruction_2': 'Instrucci칩n 2',
        'instruction_3': 'Instrucci칩n 3',
'no_context_available': 'No hay contexto disponible para este subt칤tulo.',
'load_context_title': 'Importar sugerencias de la IA',
'context_help_title': '쮺칩mo funciona?',
'context_help_intro': 'Este asistente sirve para a침adir propuestas o sugerencias de la IA que ir치n apareciendo en cada subt칤tulo a medida que vayas traduciendo. Puedes personalizar hasta 3 consultas que se ir치n mostrando a la vez, junto con aclaraciones sobre el contexto o problemas de traducci칩n que detecte la IA que uses. ',
'context_help_format': 'Para usar esta caracter칤stica, primero debes asegurarte de haber importado un archivo SRT. Si ya lo has importado, el siguiente paso es personalizar tus prompts en el icono de la rueda mec치nica. Cuando hayas terminado de redactar tus prompts, solo tendr치s que darle a "Copiar prompt" y pegar y enviar el texto copiado a la IA que hayas elegido (recomendamos Gemini Pro). La respuesta que obtendr치s ser치 un c칩digo JSON que debes copiar y pegar en el siguiente recuadro haciendo clic en "Pegar c칩digo". Si el c칩digo que hayas pegado est치 correcto, ver치s un aviso en color verde. En ese caso, haz clic en "Importar desde texto" y en adelante podr치s usar las sugerencias de la IA para cada subt칤tulo en esta misma ventana.',
'paste_json_placeholder': 'Pega aqu칤 el c칩digo JSON...',
'import_from_paste_btn': 'Importar desde texto',
'or_divider': 'o',
'import_from_file_btn': 'Importar desde archivo .json',
'reset_context': 'Cargar nuevo',
'copy_prompt_btn': 'Copiar prompt',
'paste_json_btn': 'Pegar c칩digo',
'json_valid': 'El c칩digo JSON es v치lido.',
'json_invalid': 'El c칩digo JSON es incorrecto.',
'prompt_copied_success': 'Prompt copiado al portapapeles.',
'clipboard_paste_error': 'No se ha podido pegar desde el portapapeles.',
'load_srt_first': 'Primero debes cargar un archivo SRT.',
'suggestion_primary': 'Traducci칩n literal',
'suggestion_natural': 'Natural y fluida',
'suggestion_technical': 'Ajustada a CPS y CPL',
'tools_menu': 'Herramientas',
'go_to_subtitle_menu': 'Ir a...',
'go_to_subtitle_title': 'Ir a...',
'go_to_subtitle_label': 'Ir al subt칤tulo n췈:',
'go_to_timecode_label': 'Ir al c칩digo de tiempo:',
'go_btn': 'Ir',
'ai_default_instruction_1': 'Traduce los subt칤tulos a espa침ol de Espa침a. Separa en dos l칤neas los subt칤tulos que tengan m치s de {0} caracteres. Procura que todos los subt칤tulos tengan menos de {1} caracteres por segundo.',
'reset_app_btn': 'Resetear aplicaci칩n',
'reset_app_confirm': '쮼st치s seguro de que quieres resetear la aplicaci칩n? Se borrar치n todos los proyectos, backups y ajustes guardados en este navegador. Esta acci칩n no se puede deshacer.',
'reset_app_success': 'Aplicaci칩n reseteada. Recargando...',
'reset_db_error': 'Error al resetear la aplicaci칩n. Por favor, borra la cach칠 del navegador manualmente.',
'reset_storage_error': 'Ha ocurrido un error durante el reseteo.',
'planner_title': 'Planificador',
'planner_divide_in': 'Dividir en:',
'planner_sessions': 'sesiones',
'planner_method_subs': 'Por n칰mero de subt칤tulos',
'planner_method_words': 'Por n칰mero de palabras',
'planner_method_time': 'Por tiempo',
'planner_calculate': 'Calcular',
'planner_load_srt_warning': 'Carga un archivo SRT para poder usar el planificador.',
'planner_session_subs': 'Subt칤tulos #{0} - #{1}',
'planner_session_time': 'Tiempo {0} - {1} (hasta Sub. #{2})',
'planner_session_words': 'Subt칤tulos #{0} - #{1} (~{2} palabras)',
'planner_words_label': 'palabras',
'planner_session_qa': 'Revisi칩n / QA',
'save_project_title': 'Guardar proyecto',
                'confirm_restore_message': '쮼st치s seguro de que quieres restaurar la copia de seguridad? Se perder치 todo el trabajo no guardado en la sesi칩n actual.',
'replacements_made': 'Se han hecho {0} reemplazos.',
'undo_btn': 'Deshacer',
'redo_btn': 'Rehacer',
'linebreak_tooltip_text': 'Salto de l칤nea = Mayus + Enter',
'delete_subtitle_confirm': '쯉eguro que quieres eliminar este subt칤tulo? ', 
'merge_next_tooltip': 'Fusionar con el subt칤tulo siguiente',
    'split_tooltip': 'Separar subt칤tulo en la posici칩n del cursor',
    'delete_tooltip': 'Eliminar subt칤tulo',
'lock_waveform': 'Bloquear onda',
'unlock_waveform': 'Desbloquear onda',
'zoom_out': 'Alejar zoom',
'zoom_in': 'Aumentar zoom',
'follow_playback_on': 'Activar seguimiento de reproducci칩n',
'follow_playback_off': 'Desactivar seguimiento de reproducci칩n',
'show_status_bar_btn': 'Mostrar estad칤sticas',
            'hide_status_bar_btn': 'Ocultar estad칤sticas',
'timecode_settings_btn': 'Ajustes de tiempo',
'timecode_modal_title': 'Ajustes de tiempo',
'project_fps_label': 'FPS del proyecto:',
'fps_recommendation_note': 'Sugerencia: Para una sincronizaci칩n precisa, comprueba los FPS de tu archivo de v칤deo en las propiedades y selecciona el mismo valor aqu칤.', 
'show_frames_label': 'Mostrar c칩digo de tiempo en frames (ej. 00:00:10:05)',
'timecode_warning': 'Aviso: La exportaci칩n SRT siempre usar치 milisegundos por compatibilidad.',
'timecode_format_error': 'El formato del c칩digo de tiempo noes v치lido. Usa HH:MM:SS:FF.',
'import_translated_srt': 'Importar traducci칩n (.srt)',
'import_translated_tooltip': 'Carga un SRT traducido para rellenar la columna derecha',
'error_no_original_srt': 'Primero debes cargar el archivo SRT original.',
'translation_imported_success': 'Se han importado {0} subt칤tulos traducidos.',
'translation_mismatch_warning': 'Aviso: El archivo traducido tiene {0} subt칤tulos, pero el original tiene {1}. Se han fusionado hasta donde ha sido posible.',
'notes_btn': 'Notas',
'notes_sidebar_title': 'Notas del subt칤tulo',
'notes_info': 'Estas notas se guardan con el proyecto y est치n asociadas a este subt칤tulo espec칤fico.',
'notes_placeholder': 'Escribe aqu칤 tus notas...',

            },
            'en': {
                'title': 'subpandaTM', 'import_menu': 'Import', 'import_srt': 'Import .srt', 'export_srt': 'Export .srt', 'backup_btn': 'Backup', 'qa_btn': 'QA', 'shortcuts_btn': 'Shortcuts', 'find_replace_btn': 'Find & Replace', 'terminology_btn': 'Terminology', 'tm_btn': 'Translation Memory', 'load_video': 'Load Video', 'change_video': 'Change Video', 'preview_size': 'Size:', 'preview_source': 'Show:', 'translation_text_option': 'Translation', 'original_text_option': 'Original', 'translation_stats_title': 'Statistics', 'segments_progress_text': '{0}/{1} subtitles translated ({2}%)', 'words_translated_text': '{0} words translated', 'words_total_text': '{0} total original words', 'words_remaining_text': '{0} words remaining', 'no_translations': 'Import an .srt file and a video to start working. If you wish, you can work with a TMX translation memory and a TBX glossary, which you can import or create from scratch.', 'time_codes': 'Time codes:', 'original_text': 'Original:', 'translation_text': 'Translation:', 'validate': 'Validate', 'edit': 'Edit', 'char_count_original': 'Original: ', 'char_count_translation': 'Translation: ', 'char_units': ' c', 'cps': ' CPS', 'ok': 'OK', 'close_btn': 'Close', 'save_btn': 'Save', 'cancel_btn': 'Cancel', 'shortcuts_title': 'Keyboard Shortcuts',
                'shortcut_desc_validateAndNext': 'Validate translation and move to next', 'shortcut_desc_goToNext': 'Go to next subtitle', 'shortcut_desc_goToPrevious': 'Go to previous subtitle', 'shortcut_desc_insertTM1': 'Insert 1st TM suggestion', 'shortcut_desc_insertTM2': 'Insert 2nd TM suggestion', 'shortcut_desc_insertTM3': 'Insert 3rd TM suggestion', 'shortcut_desc_insertTM4': 'Insert 4th TM suggestion', 'shortcut_desc_insertTM5': 'Insert 5th TM suggestion', 'shortcut_desc_insertGloss1': 'Insert 1st glossary term', 'shortcut_desc_insertGloss2': 'Insert 2nd glossary term', 'shortcut_desc_insertGloss3': 'Insert 3rd glossary term', 'shortcut_desc_insertGloss4': 'Insert 4th glossary term', 'shortcut_desc_insertGloss5': 'Insert 5th glossary term', 'shortcut_desc_jumpToTime': 'Jump to current subtitle start time', 'shortcut_desc_playSegment': 'Play current subtitle', 'shortcut_desc_playPause': 'Play/pause video', 'shortcut_desc_seekForward': 'Seek forward 3 seconds', 'shortcut_desc_seekBackward': 'Seek backward 3 seconds', 'shortcut_desc_seekForwardFast': 'Seek forward 5 seconds', 'shortcut_desc_seekBackwardFast': 'Seek backward 5 seconds', 'shortcut_desc_bold': 'Apply bold', 'shortcut_desc_italic': 'Apply italics',
                'find_replace_title': 'Find and Replace', 'find_label': 'Find:', 'replace_label': 'Replace with:', 'case_sensitive': 'Case sensitive', 'regular_expression': 'Regular expression', 'find_prev': 'Find previous', 'find_next': 'Find next', 'replace': 'Replace', 'replace_all': 'Replace all', 'save_srt_title': 'Export SRT File', 'save_tbx_title': 'Export TBX File', 'save_tmx_title': 'Export TMX File', 'file_name_label': 'File name:', 'backup_modal_title': 'Backup', 'restore_backup_info': 'A backup of an unsaved session has been found.', 'file_label': 'File:', 'last_modified_label': 'Last modified:', 'export_srt_btn': 'Export SRT', 'delete_backup_btn': 'Delete Backup', 'restore_btn': 'Restore', 'no_backup_found_info': 'No automatic backup has been found.', 'qa_modal_title': 'QA Settings', 'cps_limit_label': 'CPS Limit:', 'chars_per_line_limit_label': 'Characters per line limit:', 'save_and_apply_btn': 'Save and apply', 'qa_error_list_title': 'QA Error List', 'qa_errors_found': '{0} QA errors found', 'qa_no_errors': 'No QA errors found.', 'terminology_sidebar_title': 'Terminology', 'config_lang_title': 'Set up glossary languages', 'config_lang_info': 'Define the source and target languages for your glossary. The ISO code must be correct. After setting the language, you can import or create a glossary from scratch.', 'source_language': 'Source language:', 'target_language': 'Target language:', 'confirm_languages': 'Confirm languages', 'current_lang_title': 'Current glossary languages', 'add_term_title': 'Add term', 'term': 'Term:', 'translation': 'Translation:', 'add_button': 'Add', 'search_title': 'Search', 'search_placeholder': 'Search term...', 'import_tbx': 'Import TBX', 'download_tbx': 'Download TBX', 'new_glossary': 'New glossary', 'glossary_list_title': 'Glossary', 'source_term_col': 'Source term', 'target_term_col': 'Target term', 'actions_col': 'Actions', 'delete_button': 'Delete', 'edit_button': 'Edit', 'save_changes_btn': 'Save Changes', 'tm_sidebar_title': 'Translation Memory', 'tm_config_lang_title': 'Set up TM languages', 'tm_config_lang_info': 'Define the source and target languages for your translation memory. The ISO code must be correct. After setting the language, you can import or create a memory from scratch.', 'current_tm_lang_title': 'Current TM languages', 'new_tm': 'New TM', 'import_tmx': 'Import TMX', 'download_tmx': 'Download TMX', 'tm_search_title': 'Search TM', 'tm_search_placeholder': 'Search in memory...', 'tm_search_results_title': 'TM Search Results', 'tm_score_col': '%', 'tm_original_col': 'Original', 'tm_translation_col': 'Translation', 'tm_no_match_found': 'No matches found in the TM.',
                'import_shortcuts_btn': 'Import', 'export_shortcuts_btn': 'Export', 'restore_defaults_btn': 'Restore Defaults', 'edit_shortcut_btn': 'Edit', 'recording_shortcut_text': 'Press key...',
                'project_menu': 'Project', 'load_project': 'Load project', 'save_project': 'Save project', 'new_project': 'New project', 'reselect_video_title': 'Select Video', 'reselect_video_info': 'Project loaded. To sync the video, please select the original video file:', 'reselect_video_prompt': 'Project loaded. Please select the original video file: {0}', 'skip_btn': 'Skip', 'confirm_new_project_title': 'Create new project', 'confirm_new_project_message': 'You have unsaved changes. Do you want to save the current project before continuing?',
                'continue_without_saving_btn': 'Continue without saving', 
                'save_and_continue_btn': 'Save and continue',
                'confirm_new_glossary_title': 'Confirm New Glossary',
                'confirm_new_glossary_message': 'You can only have one active glossary. If you continue, all data from the current glossary will be deleted. To avoid losing your work, make sure to export it as a TBX file first.',
                'confirm_new_tm_title': 'Confirm New TM',
                'confirm_new_tm_message': 'You can only have one active Translation Memory (TM). If you continue, all data from the current TM will be deleted. To avoid losing your work, make sure to export it as a TMX file first.',
                'continue_btn': 'Continue', 
                'productive_documentation': 'Productivity Documentation',
                'doc_resource_placeholder': 'E.g., https://www.wordreference.com/es/en/{word}',
'entry_time': 'Start:',
                'exit_time': 'End:',
                'duration_label': 'Duration:',
                'rewind_frame_tooltip': 'Rewind 1 frame (40ms)',
                'play_segment_tooltip': 'Play current subtitle',
                'forward_frame_tooltip': 'Forward 1 frame (40ms)',
'shortcut_desc_playSegmentLoop': 'Play current subtitle in a loop',
'validate_all_previous': 'Validate prev.',
'validate_all_previous_tooltip': 'Validate this and all previous subtitles',
'context_sidebar_title': 'AI Assistant',
'context_btn': 'AI',
'import_context': 'Import Context',
'ai_translation_title': 'AI Suggestion:',
'context_notes_title': 'Prompts:',
'pretranslate_all_btn': 'Pre-translate all',
        'pretranslate_all_title': 'Fill all subtitles with the main AI suggestion',
        'instruction_1': 'Prompt  1',
        'instruction_2': 'Prompt  2',
        'instruction_3': 'Prompt  3',
'no_context_available': 'No context available for this subtitle.',
'load_context_title': 'Import AI Suggestions',
'context_help_title': 'How does it work?',
'context_help_intro': 'This assistant helps you add AI-powered suggestions that appear alongside each subtitle as you translate. You can set up to three custom prompts to show at once, along with notes the AI detects about context or possible translation issues.',
'context_help_format': 'To get started, make sure you뗬e imported an SRT file. If you have, click the gear icon to set up your prompts. When youre happy with them, hit Copy prompt, then paste and send that text to your preferred AI (we recommend Gemini Pro). The AI will return a JSON code  just copy it, click Paste code below, and drop it in. If everything looks good, you뗣l see a green confirmation. From there, click Import from text, and you뗣l start seeing the AI뗩 suggestions for each subtitle right here in this window.',
'paste_json_placeholder': 'Paste the JSON code here...',
'import_from_paste_btn': 'Import from text',
'or_divider': 'or',
'import_from_file_btn': 'Import from .json file',
'reset_context': 'Load New',
'copy_prompt_btn': 'Copy prompt',
'paste_json_btn': 'Paste code',
'json_valid': 'Valid JSON code.',
'json_invalid': 'Incorrect JSON code.',
'prompt_copied_success': 'Prompt copied to clipboard.',
'clipboard_paste_error': 'Could not paste from clipboard.',
'load_srt_first': 'You must load an SRT file first.',
'suggestion_primary': 'Literal translation',
'suggestion_natural': 'Natural and fluent',
'suggestion_technical': 'Within the CPS and CPL guidelines',
'tools_menu': 'Tools',
'go_to_subtitle_menu': 'Go to...',
'go_to_subtitle_title': 'Go to...',
'go_to_subtitle_label': 'Go to subtitle #:',
'go_to_timecode_label': 'Go to timecode:',
'go_btn': 'Go',
'ai_default_instruction_1': 'Translate the subtitles to Spanish (Spain). Split subtitles longer than {0} characters into two lines. Try to keep all subtitles under {1} characters per second.',
'reset_app_btn': 'Reset Application',
'reset_app_confirm': 'Are you sure you want to reset the application? All saved projects, backups, and settings in this browser will be deleted. This action cannot be undone.',
'reset_app_success': 'Application reset. Reloading...',
'reset_db_error': 'Error resetting the database. Please clear your browser cache manually.',
'reset_storage_error': 'An error occurred during the reset.',
'planner_title': 'Planner',
'planner_divide_in': 'Divide into:',
'planner_sessions': 'sessions',
'planner_method_subs': 'By number of subtitles',
'planner_method_words': 'By number of words',
'planner_method_time': 'By time',
'planner_calculate': 'Calculate',
'planner_load_srt_warning': 'Load an SRT file to use the planner.',
'planner_session_subs': 'Subtitles #{0} - #{1}',
'planner_session_time': 'Time {0} - {1} (up to Sub #{2})',
'planner_session_words': 'Subtitles #{0} - #{1} (~{2} words)',
'planner_words_label': 'words',
'planner_session_qa': 'Review / QA',
'save_project_title': 'Save Project',
                'confirm_restore_message': 'Are you sure you want to restore the backup? All unsaved work in the current session will be lost.',
'replacements_made': '{0} replacements have been made.',
'undo_btn': 'Undo',
'redo_btn': 'Redo',
'linebreak_tooltip_text': 'Linebreak = Shift + Enter',
'ai_settings_title': 'Customize AI Prompt',
'ai_settings_intro': 'Add up to three instructions for the AI. The first is mandatory and comes with default text that you can modify. QA guidelines will be added automatically.',
'ai_instruction_1_label': 'Instruction 1 (Required):',
'ai_instruction_2_label': 'Instruction 2 (Optional):',
'ai_instruction_3_label': 'Instruction 3 (Optional):',
'delete_subtitle_confirm': 'Are you sure you want to delete this subtitle?',
'merge_next_tooltip': 'Merge with next subtitle',
    'split_tooltip': 'Split subtitle at cursor position',
    'delete_tooltip': 'Delete subtitle',
'lock_waveform': 'Lock waveform',
'unlock_waveform': 'Unlock waveform',
'zoom_out': 'Zoom out',
'zoom_in': 'Zoom in',
'follow_playback_on': 'Enable playback tracking',
'follow_playback_off': 'Disable playback tracking',
'show_status_bar_btn': 'Show statss bar',
            'hide_status_bar_btn': 'Hide stats bar',
'timecode_settings_btn': 'Timecode Settings',
'timecode_modal_title': 'Timecode Settings',
'project_fps_label': 'Project FPS:',
'fps_recommendation_note': "Tip: For accurate timing, check your video file's FPS (Right-click > Properties > Details) and select the same value here.", 
'show_frames_label': 'Show timecode in frames (e.g. 00:00:10:05)',
'timecode_warning': 'Note: SRT export will always use milliseconds for compatibility.',
'timecode_format_error': 'Invalid timecode format. Use HH:MM:SS:FF.',
'import_translated_srt': 'Import translated .srt',
'import_translated_tooltip': 'Load a translated SRT to fill the right column', 
'error_no_original_srt': 'You must load the original SRT file first.',
'translation_imported_success': '{0} translated subtitles imported successfully.',
'translation_mismatch_warning': 'Warning: The translated file has {0} subtitles, but the original has {1}. Merged as much as possible.',
'notes_btn': 'Notes',
'notes_sidebar_title': 'Subtitle Notes',
'notes_info': 'These notes are saved with the project and linked to this specific subtitle.',
'notes_placeholder': 'Type your notes here...',
            }
        };

        const errorMessages = {
            'es': {
                'error_reading_file': 'Error al leer o analizar archivo .srt: ', 'error_saving_file': 'Error al guardar archivo: ', 'file_saved_successfully': 'Archivo .srt guardado con 칠xito.', 'file_saved_successfully_tbx': 'Archivo TBX guardado con 칠xito.', 'file_saved_successfully_tmx': 'Archivo TMX guardado con 칠xito.', 'please_enter_filename': 'Por favor, introduce un nombre de archivo.', 'no_translations_to_save': 'No hay subt칤tulos para guardar. Carga un archivo .srt primero.', 'reached_last': 'Has llegado al 칰ltimo subt칤tulo.', 'reached_first': 'Ya est치s en el primer subt칤tulo.', 'file_processing_error': '춰Error! No se pudo procesar el archivo. Aseg칰rate de que es un archivo .srt v치lido.', 'no_match_found': 'No se encontr칩 ninguna coincidencia.', 'replaced_all': 'Todas las ocurrencias reemplazadas.', 'no_find_query': 'Por favor, introduce el texto a buscar.', 'loading_file': 'Cargando archivo...', 'saving_file': 'Guardando archivo...', 'video_load_error': 'Error al cargar el v칤deo. Aseg칰rate de que el formato es compatible.', 'both_terms_required': 'Ambos t칠rminos son requeridos.', 'lang_config_required': 'Por favor, configura los idiomas de origen y destino para el glosario.', 'cannot_download_empty_or_unconfigured_glossary': 'No se puede descargar un glosario vac칤o o sin configurar.', 'error_loading_tbx_file': 'Error al cargar el archivo TBX. Aseg칰rate de que sea un XML/TBX v치lido.', 'tmx_file_expected_tbx_found': 'Este archivo parece ser una memoria de traducci칩n (TMX). Por favor, usa la opci칩n "Importar TMX" en el panel de Memoria de Traducci칩n.', 'tbx_file_expected_tmx_found': 'Este archivo parece ser un glosario (TBX). Por favor, usa la opci칩n "Importar TBX" en el panel de Terminolog칤a.', 'error_loading_tmx_file': 'Error al cargar el archivo TMX. Aseg칰rate de que sea un XML/TMX v치lido.', 'cannot_download_empty_tm': 'No se puede descargar una memoria de traducci칩n vac칤a.', 'backup_deleted_confirmation': '쮼st치s seguro de que quieres borrar permanentemente este backup? Esta acci칩n no se puede deshacer.', 'backup_deleted_message': 'El backup ha sido borrado.', 'project_restored_message': 'Proyecto restaurado con 칠xito.', 'no_backup_to_export': 'No hay datos de backup disponibles para exportar.', 'backup_export_error': 'Error al exportar el SRT del backup: ', 'backup_export_success': 'El archivo ha sido exportado con 칠xito.',
                'shortcut_import_error': 'Error al importar los atajos. Aseg칰rate de que es un archivo JSON v치lido.', 'shortcut_conflict': 'Este atajo ya est치 en uso. Por favor, elige otro.',
                'project_loaded_success': 'Proyecto cargado con 칠xito.', 'error_loading_project': 'Error al cargar el proyecto', 'no_project_to_save': 'No hay ning칰n proyecto activo para guardar.'
            },
            'en': {
                'error_reading_file': 'Error reading or parsing .srt file: ', 'error_saving_file': 'Error saving file: ', 'file_saved_successfully': '.srt file saved successfully.', 'file_saved_successfully_tbx': 'TBX file saved successfully.', 'file_saved_successfully_tmx': 'TMX file saved successfully.', 'please_enter_filename': 'Please enter a filename.', 'no_translations_to_save': 'No subtitles to save. Load an .srt file first.', 'reached_last': 'You have reached the last subtitle.', 'reached_first': 'You are already at the first subtitle.', 'file_processing_error': 'Error! Could not process the file. Make sure it is a valid .srt file.', 'no_match_found': 'No match found.', 'replaced_all': 'All occurrences replaced.', 'no_find_query': 'Please enter text to search for.', 'loading_file': 'Loading file...', 'saving_file': 'Saving file...', 'video_load_error': 'Error loading video. Make sure the format is supported.', 'both_terms_required': 'Both terms are required.', 'lang_config_required': 'Please set up the source and target languages for the glossary.', 'cannot_download_empty_or_unconfigured_glossary': 'Cannot download an empty or unconfigured glossary.', 'error_loading_tbx_file': 'Error loading TBX file. Make sure it is a valid XML/TBX.', 'tmx_file_expected_tbx_found': 'This file appears to be a Translation Memory (TMX). Please use the "Import TMX" option in the Translation Memory panel.', 'tbx_file_expected_tmx_found': 'This file appears to be a Glossary (TBX). Please use the "Import TBX" option in the Terminology panel.', 'error_loading_tmx_file': 'Error loading TMX file. Make sure it is a valid XML/TMX.', 'cannot_download_empty_tm': 'Cannot download an empty translation memory.', 'backup_deleted_confirmation': 'Are you sure you want to permanently delete this backup? This action cannot be undone.', 'backup_deleted_message': 'The backup has been deleted.', 'project_restored_message': 'Project restored successfully.', 'no_backup_to_export': 'No backup data available to export.', 'backup_export_error': 'Error exporting SRT from backup: ', 'backup_export_success': 'File exported successfully.',
                'shortcut_import_error': 'Error importing shortcuts. Please ensure it is a valid JSON file.', 'shortcut_conflict': 'This shortcut is already in use. Please choose another one.',
                'project_loaded_success': 'Project loaded successfully.', 'error_loading_project': 'Error loading project', 'no_project_to_save': 'There is no active project to save.'
            }
        };

const AI_PROMPT_TEMPLATE = `Act칰a como un asistente experto en traducci칩n audiovisual para subtitulaci칩n. Te proporcionar칠 el contenido de un archivo SRT.

Tu 칰nica salida debe ser un archivo de c칩digo en formato JSON, sin ninguna explicaci칩n antes o despu칠s del bloque de c칩digo.

El JSON debe ser un array de objetos. Cada objeto debe corresponder a un subt칤tulo y tener la siguiente estructura exacta:

1.  Una clave '"index"' (n칰mero).
2.  Una clave '"ai_suggestions"' (objeto). Dentro de este objeto, debe haber tres claves:
    * '"primary"': Tu mejor traducci칩n al espa침ol de Espa침a.
    * '"natural"': Una versi칩n m치s coloquial o fluida.
    * '"technical"': Una versi칩n optimizada para subtitulaci칩n (m치x. 42 caracteres por l칤nea, CPS < 20), usando '\\n' para los saltos de l칤nea.
3.  Una clave '"context_notes"' (texto). Aqu칤 debes explicar modismos, referencias culturales, etc., y a침adir un enlace a una fuente fiable que respalde tus decisiones.

Aseg칰rate de que la clave '"context_notes"' est칠 al mismo nivel que '"index"' y '"ai_suggestions"', y NO dentro de '"ai_suggestions"'.

**Ejemplo de la estructura requerida para un objeto:**
{
  "index": 1,
  "ai_suggestions": {
    "primary": "Traducci칩n principal aqu칤.",
    "natural": "Traducci칩n natural aqu칤.",
    "technical": "Traducci칩n t칠cnica aqu칤."
  },
  "context_notes": "<b>Explicaci칩n:</b> Notas y enlace aqu칤. Fuente: https://www.ejemplo.com"
}

Ahora, analiza el siguiente contenido SRT y genera el JSON completo:

[SRT_CONTENT_PLACEHOLDER]`;

 let shortcutProfiles = {}; // contendr치 los perfiles 'windows' y 'mac'
        let activeProfile = 'windows'; // perfil por defecto
        let shortcuts = {}; // se rellenar치 con el perfil activo
     
   // List of common ISO 639-1 language codes for the datalist
        const isoLanguagesData = [
          { code: "en", name: "English" }, { code: "en-US", name: "English (United States)" }, { code: "en-GB", name: "English (United Kingdom)" },
          { code: "es", name: "Espa침ol" }, { code: "es-AR", name: "Espa침ol (Argentina)" }, { code: "es-ES", name: "Espa침ol (Espa침a)" }, { code: "es-MX", name: "Espa침ol (M칠xico)" },
          { code: "fr", name: "Fran칞ais" }, { code: "de", name: "Deutsch" }, { code: "it", name: "Italiano" }, { code: "pt", name: "Portugu칡s" },
          { code: "ja", name: "了봱랿妨 (Japanese)" }, { code: "zh", name: "疸쇉둖 (Chinese)" }, { code: "ar", name: "좢쐊뻋궺 (Arabic)" },
          { code: "ru", name: "먬혜혜햨햦햧 (Russian)" }, { code: "ko", name: "涯럵옰諄 (Korean)" }, { code: "nl", name: "Nederlands" },
          { code: "sv", name: "Svenska" }, { code: "da", name: "Dansk" }, { code: "no", name: "Norsk" }, { code: "fi", "name": "Suomi" },
          { code: "tr", name: "T칲rk칞e" }, { code: "pl", name: "Polski" }, { code: "cs", name: "캛e코tina" }, { code: "hu", name: "Magyar" },
          { code: "el", name: "풋풭풭풩풯풫풬풟 (Greek)" }, { code: "he", name: "뮁놩뻉뙁 (Hebrew)" }, { code: "th", name: "薑舡舡 (Thai)" },
          { code: "vi", name: "Ti故쯡g Vi敲t (Vietnamese)" }, { code: "id", name: "Bahasa Indonesia" }, { code: "ms", name: "Bahasa Melayu" },
          { code: "ca", name: "Catal" }, { code: "eu", name: "Euskara" }, { code: "gl", name: "Galego" }, { code: "ro", name: "Rom칙n캒" },
          { code: "uk", name: "햒햨햟혱햫혜혧햨햟 (Ukrainian)" }, { code: "bg", name: "햄혥햩햡햟혜햨햦 (Bulgarian)" }, { code: "hr", name: "Hrvatski" },
          { code: "sr", name: "Srpski" }, { code: "sk", name: "Sloven캜ina" }, { code: "sl", name: "Sloven코캜ina" }, { code: "lt", name: "Lietuvi콥" },
          { code: "lv", name: "Latvie코u" }, { code: "et", name: "Eesti" }, { code: "is", name: "칈slenska" }, { code: "ga", name: "Gaeilge" },
          { code: "mt", name: "Malti" },
        ];


        /**
         * Counts words in a given text string.
         * @param {string} text The text to count words from.
         * @returns {number} The number of words.
         */
        function countWords(text) {
            if (!text) return 0;
            // Trim leading/trailing whitespace and split by one or more whitespace characters
            const words = text.trim().split(/\s+/);
            // Filter out empty strings that might result from multiple spaces
            return words.filter(word => word.length > 0).length;
        }
        
        /**
         * Counts characters in a string, ignoring HTML tags.
         * @param {string} text The text to count.
         * @returns {number} The character count without tags.
         */
        function countCharactersWithoutTags(text) {
            if (!text) return 0;
            // Remove all HTML tags
            const noTags = text.replace(/<[^>]+>/g, '');
            // Convert entities like &nbsp; to space
            const cleanText = noTags.replace(/&nbsp;/gi, ' ');
            return cleanText.length;
        }

        /**
         * Converts milliseconds to SRT time format (HH:MM:SS,ms).
         * @param {number} ms Milliseconds.
         * @returns {string} Formatted time string.
         */
        function formatTime(ms) {
            const hours = Math.floor(ms / 3600000);
            ms %= 3600000;
            const minutes = Math.floor(ms / 60000);
            ms %= 60000;
            const seconds = Math.floor(ms / 1000);
            const milliseconds = ms % 1000;

            return [
                hours.toString().padStart(2, '0'),
                minutes.toString().padStart(2, '0'),
                seconds.toString().padStart(2, '0')
            ].join(':') + ',' + milliseconds.toString().padStart(3, '0');
        }

        /**
         * Converts SRT time format (HH:MM:SS,ms) to milliseconds.
         * @param {string} timeStr Time string in SRT format.
         * @returns {number} Milliseconds.
         */
        function parseTime(timeStr) {
            const parts = timeStr.split(',');
            const [h, m, s] = parts[0].split(':').map(Number);
            const ms = Number(parts[1]);
            return (h * 3600 + m * 60 + s) * 1000 + ms;
        }

/**
         * Convierte milisegundos a formato de frames (HH:MM:SS:FF).
         * @param {number} ms Milliseconds.
         * @param {number} fps Project FPS.
         * @returns {string} Formatted time string.
         */
        function formatFrameTime(ms, fps) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            const remainingMs = ms % 1000;
            const frames = Math.round((remainingMs / 1000) * fps);

            return [
                hours.toString().padStart(2, '0'),
                minutes.toString().padStart(2, '0'),
                seconds.toString().padStart(2, '0')
            ].join(':') + ':' + frames.toString().padStart(2, '0');
        }

        /**
         * Convierte formato de frames (HH:MM:SS:FF) a milisegundos.
         * @param {string} timeStr Time string in frame format.
         * @param {number} fps Project FPS.
         * @returns {number} Milliseconds.
         */
        function parseFrameTime(timeStr, fps) {
            const parts = timeStr.split(':');
            if (parts.length !== 4) throw new Error("Invalid frame time format");
            
            const [h, m, s, f] = parts.map(Number);
            let totalMs = 0;
            totalMs += h * 3600000;
            totalMs += m * 60000;
            totalMs += s * 1000;
            
            // Convierte los frames a los milisegundos m치s cercanos
            totalMs += Math.round((f / fps) * 1000);
            
            return totalMs;
        }

        /**
         * Calculates Characters Per Second (CPS) for a given text and duration.
         * @param {string} text The text of the subtitle.
         * @param {number} durationMs The duration of the subtitle in milliseconds.
         * @returns {number} CPS value.
         */
        function calculateCPS(text, durationMs) {
            if (durationMs <= 0) return 0;

            // Remove ALL HTML tags
            const noTags = text.replace(/<[^>]+>/g, '');

            // Replace &nbsp; entities with spaces
            const cleanText = noTags.replace(/&nbsp;/gi, ' ');

            // Divide by seconds
            return (cleanText.length / (durationMs / 1000)).toFixed(2);
        }

        /**
         * Parses the content of an SRT file.
         * @param {string} content The full content of the SRT file.
         * @returns {Array<Object>} An array of SRT entry objects.
         */
        function parseSrtContent(content) {
            const entries = [];
            const blocks = content.split(/\r?\n\r?\n/); // Split by double newline (CRLF or LF)

            blocks.forEach(block => {
                const lines = block.trim().split(/\r?\n/);
                if (lines.length >= 3) {
                    const index = parseInt(lines[0]);
                    const timecodes = lines[1];
                    const text = lines.slice(2).join('\n'); // Join remaining lines as text

                    const [startTimeStr, endTimeStr] = timecodes.split(' --> ');
                    const startTimeMs = parseTime(startTimeStr);
                    const endTimeMs = parseTime(endTimeStr);
                    const durationMs = endTimeMs - startTimeMs;
                    const charCountOriginal = countCharactersWithoutTags(text);

                    entries.push({
                        index: index,
                        timecodes: timecodes,
                        startTimeMs: startTimeMs,
                        endTimeMs: endTimeMs,
                        durationMs: durationMs,
                        original: text,
                        translation: '', // Initialize translation as empty
                        wordCountOriginal: countWords(text),
                        wordCountTranslation: 0,
                        isTranslated: false,
                        charCountOriginal: charCountOriginal,
                        charCountTranslation: 0,
                        cpsOriginal: calculateCPS(text, durationMs),
                        cpsTranslation: 0
                    });
                }
            });
            return entries;
        }

        /**
         * Reconstructs the content of an SRT file from an array of entries.
         * @param {Array<Object>} entries The array of subtitle objects.
         * @returns {string} The reconstructed SRT file content.
         */
            function reconstructSrt(entries) {
    let srtContent = '';
    entries.forEach(entry => {
        srtContent += `${entry.index}\n`;
        srtContent += `${entry.timecodes}\n`;

        let textToWrite = entry.translation || entry.original;

        // --- INICIO DEL NUEVO PROCESO DE LIMPIEZA INTELIGENTE ---

        // 1. Normalizamos los saltos de l칤nea generados por el editor.
        // Reemplazamos los saltos de l칤nea de <div> y <br> por el car치cter est치ndar '\n'.
        textToWrite = textToWrite.replace(/<\/div>\s*<div>/gi, '\n');
        textToWrite = textToWrite.replace(/<br\s*\/?>/gi, '\n');

        // 2. Eliminamos TODAS las etiquetas HTML EXCEPTO <b> y <i>.
        // Esta es la parte clave. Usamos una expresi칩n regular con "negative lookahead"
        // para decirle que ignore las etiquetas de formato que queremos conservar.
        textToWrite = textToWrite.replace(/<(?!(\/?b|\/?i))[^>]+>/gi, '');

        // 3. Limpiamos cualquier espacio en blanco extra al principio o al final.
        textToWrite = textToWrite.trim();
        
        // --- FIN DEL NUEVO PROCESO ---

        srtContent += `${textToWrite}\n\n`;
    });
    return srtContent.trim();
}

// --- INICIO: Funciones de Bloqueo y Zoom de Onda ---

/**
 * Alterna el estado de bloqueo de la onda de sonido.
 * Evita que las regiones se puedan arrastrar o redimensionar.
 */
function toggleWaveformLock() {
    isWaveformLocked = !isWaveformLocked;
    const waveformEl = document.getElementById('waveform');
    
    // Alternar estado visual
    waveformEl.classList.toggle('is-locked', isWaveformLocked);
    lockIconOpen.classList.toggle('hidden', isWaveformLocked);
    lockIconClosed.classList.toggle('hidden', !isWaveformLocked);
lockWaveformBtn.classList.toggle('active', isWaveformLocked);
lockWaveformBtn.title = isWaveformLocked ? translations[currentLanguage]['unlock_waveform'] : translations[currentLanguage]['lock_waveform'];

    // Deshabilitar/Habilitar drag y resize en TODAS las regiones
    if (wsRegions) {
        wsRegions.getRegions().forEach(region => {
            region.setOptions({
                drag: !isWaveformLocked,
                resize: !isWaveformLocked
            });
        });
    }
}

/**
 * Aplica zoom a la onda de sonido.
 * @param {number} direction - 1 para Zoom In, -1 para Zoom Out.
 */
function zoomWaveform(direction) {
    if (!wavesurfer) return;
    
    const newZoom = currentWaveformZoom + (direction * ZOOM_STEP);
    
    // Establecemos un l칤mite m칤nimo de zoom para que no se "pierda"
    if (newZoom >= 20) { 
        currentWaveformZoom = newZoom;
        wavesurfer.zoom(currentWaveformZoom);
    }
}
// --- FIN: Funciones de Bloqueo y Zoom de Onda ---

// --- Funciones de Regiones de WaveSurfer (NUEVAS y MODIFICADAS) ---
        /** Limpia todas las regiones de subt칤tulos de la onda. */
        function clearSubtitleRegions() {
            if (wsRegions) {
                // Limpia solo regiones de subt칤tulos, preservando otras si las hubiera
                wsRegions.getRegions().forEach(region => {
                    if (region.id.startsWith('sub-')) { // Asume que los IDs de subt칤tulos empiezan con 'sub-'
                        region.remove();
                    }
                });
            }
        }

        /** A침ade una regi칩n a WaveSurfer para un subt칤tulo espec칤fico. */
        function addSubtitleRegion(entry) {
            // No a침ade regi칩n si no hay plugin, los tiempos no son v치lidos o la duraci칩n es cero o negativa
            if (!wsRegions || entry.startTimeMs < 0 || entry.endTimeMs <= entry.startTimeMs) return;

            // Aseg칰rate de que el ID es 칰nico y estable
            if (!entry.regionId) {
                 entry.regionId = `sub-${entry.index}-${Date.now()}`; // Genera ID si no existe
            }

            // Evita a침adir regiones duplicadas
            if (wsRegions.getRegions().some(r => r.id === entry.regionId)) {
                return;
            }

            try {
                const region = wsRegions.addRegion({
                    id: entry.regionId,
                    start: entry.startTimeMs / 1000, // Convertir ms a segundos
                    end: entry.endTimeMs / 1000,   // Convertir ms a segundos
                    color: 'rgba(7, 91, 162, 0.3)',
                    drag: !isWaveformLocked,
                    resize: !isWaveformLocked,
                    attributes: { // A침adir atributos para posible estilado o selecci칩n
                        'data-subtitle-index': entry.index
                    }
                });

              // --- INICIO: NUEVO BLOQUE para el formato de 4 l칤neas ---
                const content = document.createElement('div');
                content.className = 'region-content';

                // L칤nea 1: N칰mero de subt칤tulo
                const line1 = `#${entry.index}`;

                // L칤nea 2: Texto original (preview)
                const originalPreview = entry.original.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                const line2 = originalPreview.substring(0, 40) + (originalPreview.length > 40 ? '...' : '');

                // L칤nea 3: Texto traducido (preview, o vac칤o)
                let line3 = '';
                if (entry.translation) {
                    const translationPreview = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                    line3 = translationPreview.split('\n').join(' ').substring(0, 40) + (translationPreview.length > 40 ? '...' : '');
                }

                // L칤nea 4: Estad칤sticas de la traducci칩n
                let line4 = '---'; // Placeholder si no hay traducci칩n
                if (entry.translation) {
                    const translationTextClean = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                    const transLines = translationTextClean.split('\n');
                    const transL1 = transLines[0] ? countCharactersWithoutTags(transLines[0]) : 0;
                    const transL2 = transLines.length > 1 && transLines[1] ? countCharactersWithoutTags(transLines[1]) : 0;
                    const transCPS = calculateCPS(translationTextClean.replace(/\n/g, ''), entry.durationMs);
                    line4 = `CPS: ${transCPS} | L1: ${transL1}${transLines.length > 1 ? ` / L2: ${transL2}` : ''}`;
                }

                content.innerHTML = `
                    <div class="region-line region-line1">${line1}</div>
                    <div class="region-line region-line2">${line2}</div>
                    <div class="region-line region-line3">${line3}&nbsp;</div> <div class="region-line region-line4">${line4}</div>
                `;
                // --- FIN: NUEVO BLOQUE ---
                // Peque침o timeout para asegurar que el elemento de la regi칩n se ha renderizado en el DOM
                setTimeout(() => {
                    const regionEl = region?.element; // Usa optional chaining por si region no est치 definida
                    if (regionEl && !regionEl.querySelector('.region-content')) { // Verifica que no se haya a침adido ya
                        regionEl.appendChild(content);
                    }
                }, 50); // Un peque침o retardo podr칤a ser necesario

            } catch (error) {
                console.error(`Error adding region for subtitle ${entry.index}:`, error, entry);
            }
        }

/** Actualiza una regi칩n existente si sus tiempos cambian en el editor. */
        function updateRegionIfNeeded(entryIndex) {
            if (!wsRegions) return;
            const entry = srtEntries[entryIndex];
            const region = wsRegions.getRegions().find(r => r.id === entry.regionId);

            if (region) {
                const newStart = entry.startTimeMs / 1000;
                const newEnd = entry.endTimeMs / 1000;

                if ((Math.abs(region.start - newStart) > 0.001 || Math.abs(region.end - newEnd) > 0.001) && newEnd > newStart) {
                    region.setOptions({ start: newStart, end: newEnd });

                    // Actualizar el contenido de la regi칩n tambi칠n (CON LA NUEVA L칍GICA)
                    const content = region.element?.querySelector('.region-content');
                     if (content) {
                         // --- INICIO: NUEVO BLOQUE para el formato de 4 l칤neas ---
                         // L칤nea 1: N칰mero de subt칤tulo
                         const line1 = `#${entry.index}`;

                         // L칤nea 2: Texto original (preview)
                         const originalPreview = entry.original.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                         const line2 = originalPreview.substring(0, 40) + (originalPreview.length > 40 ? '...' : '');

                         // L칤nea 3: Texto traducido (preview, o vac칤o)
                         let line3 = '';
                         if (entry.translation) {
                             const translationPreview = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                             line3 = translationPreview.split('\n').join(' ').substring(0, 40) + (translationPreview.length > 40 ? '...' : '');
                         }

                         // L칤nea 4: Estad칤sticas de la traducci칩n
                         let line4 = '---'; // Placeholder si no hay traducci칩n
                         if (entry.translation) {
                             const translationTextClean = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                             const transLines = translationTextClean.split('\n');
                             const transL1 = transLines[0] ? countCharactersWithoutTags(transLines[0]) : 0;
                             const transL2 = transLines.length > 1 && transLines[1] ? countCharactersWithoutTags(transLines[1]) : 0;
                             const transCPS = calculateCPS(translationTextClean.replace(/\n/g, ''), entry.durationMs);
                             line4 = `CPS: ${transCPS} | L1: ${transL1}${transLines.length > 1 ? ` / L2: ${transL2}` : ''}`;
                         }

                         content.innerHTML = `
                             <div class="region-line region-line1">${line1}</div>
                             <div class="region-line region-line2">${line2}</div>
                             <div class="region-line region-line3">${line3}&nbsp;</div> <div class="region-line region-line4">${line4}</div>
                         `;
                         // --- FIN: NUEVO BLOQUE ---
                     }
                } else if (newEnd <= newStart) {
                    region.remove();
                }
            } else if (entry.endTimeMs > entry.startTimeMs) {
                addSubtitleRegion(entry);
            }
        }

   // --- Funciones para Edici칩n de Tiempos ---

        /**
         * Actualiza todos los datos y la interfaz de un subt칤tulo cuando su tiempo cambia.
         * @param {number} entryIndex - El 칤ndice del subt칤tulo a actualizar.
         */
        function updateEntryTimes(entryIndex) {
            const entry = srtEntries[entryIndex];

            // 1. Validar que el tiempo de fin no sea anterior al de inicio
            if (entry.endTimeMs < entry.startTimeMs) {
                entry.endTimeMs = entry.startTimeMs + 1; // Asegurar una duraci칩n m칤nima
            }

            // 2. Recalcular la duraci칩n
            entry.durationMs = entry.endTimeMs - entry.startTimeMs;

            // 3. Formatear las nuevas cadenas de tiempo
            let newStartTimeStr, newEndTimeStr;
if (useFrameTimecode) {
    newStartTimeStr = formatFrameTime(entry.startTimeMs, projectFPS);
    newEndTimeStr = formatFrameTime(entry.endTimeMs, projectFPS);
} else {
    newStartTimeStr = formatTime(entry.startTimeMs);
    newEndTimeStr = formatTime(entry.endTimeMs);
}

            // 4. Actualizar los elementos de la interfaz
            document.getElementById(`startTime-${entryIndex}`).value = newStartTimeStr;
            document.getElementById(`endTime-${entryIndex}`).value = newEndTimeStr;
            document.getElementById(`duration-${entryIndex}`).textContent = (entry.durationMs / 1000).toFixed(3) + 's';

            // 5. Recalcular y actualizar las estad칤sticas (CPS, etc.)
            const translationEditor = document.getElementById(`translation-${entryIndex}`);
            if (translationEditor) {
                updateSubtitleStats(translationEditor, entry.charCountOriginal, entry.durationMs);
            }
updateRegionIfNeeded(entryIndex);
        }

        /**
         * Maneja el cambio manual de un c칩digo de tiempo en un campo de input.
         * @param {number} entryIndex - El 칤ndice del subt칤tulo.
         * @param {boolean} isStartTime - True si es el campo de inicio, false si es el de fin.
         * @param {HTMLInputElement} inputElement - El propio campo de input.
         */
        function handleTimecodeChange(entryIndex, isStartTime, inputElement) {
    let newTimeMs;
    try {
        if (useFrameTimecode) {
            newTimeMs = parseFrameTime(inputElement.value, projectFPS);
        } else {
            newTimeMs = parseTime(inputElement.value);
        }
        const entry = srtEntries[entryIndex];

// --- INICIO: Guardar historial de tiempo ---
                const oldTimes = { startTimeMs: entry.startTimeMs, endTimeMs: entry.endTimeMs };
                const newTimes = { ...oldTimes };
                if (isStartTime) {
                    newTimes.startTimeMs = newTimeMs;
                } else {
                    newTimes.endTimeMs = newTimeMs;
                }
                saveTimeChange(entryIndex, oldTimes, newTimes);
                // --- FIN: Guardar historial de tiempo ---
                
                if (isStartTime) {
                    entry.startTimeMs = newTimeMs;
                } else {
                    entry.endTimeMs = newTimeMs;
                }
                
                updateEntryTimes(entryIndex);
           } catch (error) {
                // Si el formato es inv치lido, revertir al valor anterior
                console.error("Formato de tiempo inv치lido:", error);
                
                // --- INICIO DE LA VERSI칍N CORREGIDA ---
                const entry = srtEntries[entryIndex]; // Se declara solo UNA VEZ
                let oldTimeStr;
                
                if (useFrameTimecode) {
                    // Si estamos en modo frames, generamos el string de frames
                    oldTimeStr = isStartTime ? formatFrameTime(entry.startTimeMs, projectFPS) : formatFrameTime(entry.endTimeMs, projectFPS);
                } else {
                    // Si estamos en modo ms, usamos la l칩gica original
                    const [startTime, endTime] = entry.timecodes.split(' --> ');
                    oldTimeStr = isStartTime ? startTime : endTime;
                }
                
                inputElement.value = oldTimeStr; // Revertimos al valor correcto
                
                // L칩gica para mostrar el mensaje de error (esto ya lo ten칤as bien)
                const errorKey = useFrameTimecode ? 'timecode_format_error' : 'time_format_error'; 
                const errorMsg = translations[currentLanguage][errorKey] || "Formato de tiempo inv치lido.";
                showMessage(errorMsg);
                // --- FIN DE LA VERSI칍N CORREGIDA ---
            }
        }

        /**
         * Ajusta el tiempo de entrada o salida en un fotograma (40ms).
         * @param {number} entryIndex - El 칤ndice del subt칤tulo.
         * @param {boolean} isStartTime - True si se ajusta el inicio, false si es el fin.
         * @param {number} direction - 1 para a침adir tiempo, -1 para restar.
         */
        function nudgeTimecode(entryIndex, isStartTime, direction) {
            const entry = srtEntries[entryIndex];
const frameDurationMs = Math.round(1000 / projectFPS); // Duraci칩n de 1 frame

// --- INICIO: Guardar historial de tiempo ---
            const oldTimes = { startTimeMs: entry.startTimeMs, endTimeMs: entry.endTimeMs };
            const newTimes = { ...oldTimes };
            if (isStartTime) {
                newTimes.startTimeMs = oldTimes.startTimeMs + (direction * frameDurationMs);
            } else {
                newTimes.endTimeMs = oldTimes.endTimeMs + (direction * frameDurationMs);
            }
            saveTimeChange(entryIndex, oldTimes, newTimes);
            // --- FIN: Guardar historial de tiempo ---

            if (isStartTime) {
                entry.startTimeMs += direction * frameDurationMs;
            } else {
                entry.endTimeMs += direction * frameDurationMs;
            }

            updateEntryTimes(entryIndex);
        }

        /**
         * Avanza o retrocede el v칤deo en un fotograma (40ms).
         * @param {number} direction - 1 para avanzar, -1 para retroceder.
         */
        function nudgeVideo(direction) {
            if (videoPlayer && videoPlayer.src) {
                const frameDurationSeconds = 0.040;
                videoPlayer.currentTime += direction * frameDurationSeconds;
            }
        }

/**
         * Reproduce el subt칤tulo actual en un bucle un n칰mero configurable de veces.
         * @param {number} entryIndex - El 칤ndice del subt칤tulo a reproducir.
         */
        function playSubtitleLoop(entryIndex) {
            if (!srtEntries[entryIndex] || !videoPlayer.src) return;

            const entry = srtEntries[entryIndex];
            const loopCount = shortcuts.playSegmentLoop.loopCount || 3;
            let currentLoop = 0;
            
            // Si ya hay un bucle en ejecuci칩n, lo cancelamos para empezar uno nuevo
            if (window.loopListener) {
                videoPlayer.removeEventListener('timeupdate', window.loopListener);
            }

            const playSegment = () => {
                if (currentLoop >= loopCount) {
                    videoPlayer.pause();
                    videoPlayer.removeEventListener('timeupdate', window.loopListener);
                    window.loopListener = null;
                    return;
                }
                
                currentLoop++;
                videoPlayer.currentTime = entry.startTimeMs / 1000;
                videoPlayer.play();
            };

            window.loopListener = () => {
                // Dejamos un peque침o margen para asegurar que no se salte el bucle
                if (videoPlayer.currentTime >= (entry.endTimeMs / 1000) - 0.1) {
                    playSegment();
                }
            };
            
            videoPlayer.addEventListener('timeupdate', window.loopListener);
            playSegment(); // Inicia el primer ciclo
        }

        /**
         * Actualiza el contador de bucles en el objeto de atajos y lo guarda.
         * @param {string} value - El nuevo valor del campo de entrada.
         */
        function updateLoopCount(value) {
            const count = parseInt(value, 10);
            if (count > 0) {
                shortcuts.playSegmentLoop.loopCount = count;
                saveShortcuts();
            }
        }

function updateNotesPanel(index) {
    activeNoteSubtitleIndex = index;
    const entry = srtEntries[index];
    
    if (entry) {
        if (notesSubtitleIndex) notesSubtitleIndex.textContent = `#${entry.index}`;
        
        // Cargar texto
        noteArea1.value = entry.note1 || '';
        noteArea2.value = entry.note2 || '';
        noteArea3.value = entry.note3 || '';
        
        // Habilitar campos
        noteArea1.disabled = false;
        noteArea2.disabled = false;
        noteArea3.disabled = false;

        // --- NUEVO: Calcular estad칤sticas iniciales para las 3 notas ---
        updateSingleNoteStats(1);
        updateSingleNoteStats(2);
        updateSingleNoteStats(3);

    } else {
        notesSubtitleIndex.textContent = '';
        noteArea1.value = '';
        noteArea2.value = '';
        noteArea3.value = '';
        
        noteArea1.disabled = true;
        noteArea2.disabled = true;
        noteArea3.disabled = true;
        
        // Limpiar visuales visuales si no hay subt칤tulo
        [1,2,3].forEach(n => {
            document.getElementById(`noteBar${n}`).style.width = '0%';
            document.getElementById(`noteStats${n}`).textContent = '';
        });
    }
}

// --- Funci칩n de c치lculo de estad칤sticas para Notas ---
function updateSingleNoteStats(noteNum) {
    // 1. Obtener elementos
    const textArea = document.getElementById(`noteArea${noteNum}`);
    const bar = document.getElementById(`noteBar${noteNum}`);
    const statsText = document.getElementById(`noteStats${noteNum}`);
    
    // 2. Obtener datos del subt칤tulo actual (para la duraci칩n)
    const entry = srtEntries[activeNoteSubtitleIndex];
    if (!entry || !textArea) return;

    const text = textArea.value;
    const durationMs = entry.durationMs;

    // 3. Calcular CPS
    // Usamos las mismas funciones globales que usa el editor principal
    const cps = calculateCPS(text.replace(/\n/g, ''), durationMs); 
    
    // 4. Calcular caracteres por l칤nea
    const lines = text.split('\n');
    let lineStatsHtml = '';
    lines.forEach((line, i) => {
        const len = countCharactersWithoutTags(line);
        // Si se pasa del l칤mite, lo ponemos en rojo en el texto
        const colorClass = len > qaSettings.charsPerLineLimit ? 'text-red-500 font-bold' : '';
        lineStatsHtml += `${i > 0 ? ' | ' : ''}L${i + 1}: <span class="${colorClass}">${len}</span>`;
    });

    // 5. Actualizar Texto de Estad칤sticas
    const cpsClass = cps > qaSettings.cpsLimit ? 'text-red-500 font-bold' : '';
    statsText.innerHTML = `CPS: <span class="${cpsClass}">${cps}</span> | ${lineStatsHtml}`;

    // 6. Actualizar Barra Visual (L칩gica id칠ntica al editor)
    const cpsLimit = qaSettings.cpsLimit;
    // Calculamos porcentaje (usamos 1.5 veces el l칤mite como tope visual para que no se llene al 100% con 1 CPS de m치s)
    const fillPercentage = Math.min((cps / (cpsLimit * 1.5)) * 100, 100);
    
    bar.style.width = `${fillPercentage}%`;
    
    if (cps > cpsLimit) {
        bar.classList.remove('bg-green-500');
        bar.classList.add('bg-red-500');
    } else {
        bar.classList.remove('bg-red-500');
        bar.classList.add('bg-green-500');
    }
}

function insertNoteToEditor(noteNum) {
    const entry = srtEntries[activeNoteSubtitleIndex];
    if (!entry) return;
    const textToInsert = entry[`note${noteNum}`]; 
    if (!textToInsert) return; 

    const editor = document.getElementById(`translation-${activeNoteSubtitleIndex}`);
    if (editor) {
        editor.focus();
        document.execCommand('insertText', false, textToInsert);
        editor.dispatchEvent(new Event('input', { bubbles: true }));
    }
}  
/**
 * Inserta la sugerencia de la IA en el editor del subt칤tulo activo.
 * @param {number} entryIndex - El 칤ndice del subt칤tulo.
 */
function insertAiSuggestion(entryIndex, suggestionType) {
    const entry = srtEntries[entryIndex];
    const editor = document.getElementById(`translation-${entryIndex}`);

    if (entry && entry.context && entry.context.ai_suggestions && editor) {
        const textToInsert = entry.context.ai_suggestions[suggestionType];
        if (textToInsert) {
            // Reemplazamos los saltos de l칤nea \n del JSON por <br> para el editor HTML
            editor.innerHTML = textToInsert.replace(/\n/g, '<br>');
            // Disparamos el evento 'input' para que las estad칤sticas se actualicen
            editor.dispatchEvent(new Event('input', { bubbles: true }));
        }
    }
}

function processAndApplyContext(parsedContext) {
    if (!Array.isArray(parsedContext)) {
        throw new Error("El JSON no es un array v치lido.");
    }

    srtEntries.forEach(entry => delete entry.context); // Limpia contexto anterior

    let appliedCount = 0;
    parsedContext.forEach(ctx => {
        if (typeof ctx.index !== 'undefined' && ctx.ai_suggestions && ctx.context_notes) {
            const entry = srtEntries.find(e => e.index === ctx.index);
            if (entry) {
                entry.context = ctx;
                appliedCount++;
            }
        }
    });

    if (appliedCount > 0) {
        showMessage(`Contexto cargado y aplicado a ${appliedCount} subt칤tulos.`);
        const currentFocused = getCurrentFocusedIndex() || { entryIndex: 0 };
        updateContextPanel(currentFocused.entryIndex);
    } else {
        throw new Error("El formato del JSON es correcto, pero ning칰n 칤ndice coincidi칩 con los subt칤tulos actuales.");
    }
}

function preTranslateAll() {
    let pretranslatedCount = 0;
    srtEntries.forEach(entry => {
        if (entry.context && entry.context.ai_suggestions && entry.context.ai_suggestions.primary) {
            if (!entry.translation.trim()) {
                entry.translation = entry.context.ai_suggestions.primary.replace(/\n/g, '<br>');
                pretranslatedCount++;
            }
        }
    });

    if (pretranslatedCount > 0) {
        renderTranslations(srtEntries, 0, true);
        showMessage(`${pretranslatedCount} subt칤tulos han sido pretraducidos.`);
    } else {
        showMessage("No se encontraron sugerencias para pretraducir o los campos ya estaban rellenos.");
    }
}

function resetContext() {
    // Borra los datos de contexto de todos los subt칤tulos
    srtEntries.forEach(entry => delete entry.context);

    // Llama a updateContextPanel. Como ya no hay datos, mostrar치 la vista de importaci칩n.
    const currentFocused = getCurrentFocusedIndex() || { entryIndex: 0 };
    updateContextPanel(currentFocused.entryIndex);
}


  function reconstructOriginalSrt(entries) {
            let srtContent = '';
            entries.forEach(entry => {
                srtContent += `${entry.index}\n`;
                srtContent += `${entry.timecodes}\n`;
                srtContent += `${entry.original}\n\n`;
            });
            return srtContent.trim();
        }

       


// Variable para guardar las instrucciones personalizadas del usuario
let aiCustomInstructions = { instruction1: "", instruction2: "", instruction3: "" };


/**
 * Guarda las instrucciones personalizadas de la IA en localStorage.
 */
function saveAiCustomInstructions() {
    localStorage.setItem('aiCustomInstructions', JSON.stringify(aiCustomInstructions));
}

/**
 * Carga las instrucciones personalizadas de la IA desde localStorage.
 */
function loadAiCustomInstructions() {
    const saved = localStorage.getItem('aiCustomInstructions');
    const defaultInstruction = translations[currentLanguage]['ai_default_instruction_1']
        .replace('{0}', qaSettings.charsPerLineLimit)
        .replace('{1}', qaSettings.cpsLimit);

    if (saved) {
        aiCustomInstructions = JSON.parse(saved);
    }
    // Si no hay instrucci칩n 1 guardada, aplicamos la din치mica por defecto.
    if (!aiCustomInstructions.instruction1) {
        aiCustomInstructions.instruction1 = defaultInstruction;
    }
}

/**
 * Copia el prompt de la IA al portapapeles, incluyendo el SRT actual y las instrucciones personalizadas.
 */
function copyAIPrompt() {
    if (srtEntries.length === 0) {
        showMessage(translations[currentLanguage]['load_srt_first']);
        return;
    }

    // 1. Construimos din치micamente la lista de claves y el ejemplo para el prompt.
    let suggestionKeys = `        * '"primary"': "${aiCustomInstructions.instruction1 || 'Una traducci칩n literal y fiel al original.'}"\n`;
    let exampleKeys = `        "primary": "Traducci칩n generada seg칰n la instrucci칩n 1."\n`;

    if (aiCustomInstructions.instruction2) {
        suggestionKeys += `        * '"secondary"': "${aiCustomInstructions.instruction2}"\n`;
        exampleKeys += `        "secondary": "Traducci칩n generada seg칰n la instrucci칩n 2."\n`;
    }
    if (aiCustomInstructions.instruction3) {
        const instruction3_full = `${aiCustomInstructions.instruction3}, y adem치s debe cumplir ESTRICTAMENTE las pautas t칠cnicas (m치x. ${qaSettings.charsPerLineLimit} caracteres por l칤nea, CPS < ${qaSettings.cpsLimit}).`;
        suggestionKeys += `        * '"tertiary"': "${instruction3_full}"\n`;
        exampleKeys += `        "tertiary": "Traducci칩n generada seg칰n la instrucci칩n 3."\n`;
    }

    // 2. Construimos el prompt final usando las piezas din치micas.
    const finalPrompt = `Act as an expert audiovisual translation assistant for subtitling. I will provide you with the content of an SRT file.

Your sole output must be a code file in JSON format, with no explanations before or after the code block.

The JSON must be an array of objects. Each object must correspond to a subtitle and have the following exact structure:

1.  A key '"index"' (number).
2.  A key '"ai_suggestions"' (object). Inside this object, there should ONLY be the following keys, each with a translation that follows its specific instruction:
${suggestionKeys}
3.  A key '"context_notes"' (text). Here you should explain idioms, cultural references, etc.

**Example of the required structure for one object:**
{
  "index": 1,
  "ai_suggestions": {
${exampleKeys}
  },
  "context_notes": "<b>Explanation:</b> Notes and link here."
}

Now, analyze the following SRT content and generate the complete JSON:

[SRT_CONTENT_PLACEHOLDER]`;

    const srtContent = reconstructOriginalSrt(srtEntries);
    const fullPrompt = finalPrompt.replace('[SRT_CONTENT_PLACEHOLDER]', srtContent);

    navigator.clipboard.writeText(fullPrompt).then(() => {
        showMessage(translations[currentLanguage]['prompt_copied_success']);
    }).catch(err => {
        console.error('Error al copiar el prompt: ', err);
    });
}
        /**
         * Pega el contenido del portapapeles en el 치rea de texto del contexto.
         */
        async function pasteJsonFromClipboard() {
            try {
                const text = await navigator.clipboard.readText();
                const contextPasteArea = document.getElementById('contextPasteArea');
                contextPasteArea.value = text;
                // Disparamos el evento 'input' para que se active la validaci칩n
                contextPasteArea.dispatchEvent(new Event('input', { bubbles: true }));
            } catch (err) {
                console.error('Error al pegar desde el portapapeles: ', err);
                showMessage(translations[currentLanguage]['clipboard_paste_error']);
            }
        }

        /**
         * Valida en tiempo real el contenido del 치rea de texto JSON.
         */
        function validateJsonInTextarea() {
            const textarea = document.getElementById('contextPasteArea');
            const statusDiv = document.getElementById('jsonValidationStatus');
            const text = textarea.value.trim();
            const t = translations[currentLanguage];

            if (!text) {
                statusDiv.innerHTML = '';
                return;
            }

            try {
                JSON.parse(text);
                statusDiv.innerHTML = `
                    <span class="flex items-center text-green-600">
                        <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>
                        ${t['json_valid']}
                    </span>`;
            } catch (error) {
                statusDiv.innerHTML = `
                    <span class="flex items-center text-red-600">
                        <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>
                        ${t['json_invalid']}
                    </span>`;
            }
        }

function updateContextPanel(entryIndex) {
    const contextImportView = document.getElementById('contextImportView');
    const contextDisplayView = document.getElementById('contextDisplayView');
    const t = translations[currentLanguage]; // Clave: obtiene las traducciones del idioma actual

    if (srtEntries.some(e => e.context)) {
        contextImportView.classList.add('hidden');
        contextDisplayView.classList.remove('hidden');

        const entry = srtEntries[entryIndex];
        // CORRECCI칍N: Se usan las claves de traducci칩n (ej: t['context_notes_title'])
        let contentHTML = `
            <div class="flex justify-between items-center mb-4 pb-2 border-b">
                <h4 class="font-bold text-md">${t['context_notes_title']}</h4>
                <div class="flex items-center gap-2">
                    <button class="btn btn-primary text-xs" onclick="preTranslateAll()" title="${t['pretranslate_all_title']}">${t['pretranslate_all_btn']}</button>
                    <button class="btn btn-secondary text-xs" onclick="resetContext()" data-i18n="reset_context">${t['reset_context']}</button>
                </div>
            </div>`;

        if (entry && entry.context) {
            const suggestions = entry.context.ai_suggestions;
            
            contentHTML += `<div class="space-y-3 mb-4">`;

            const getStatsString = (text, duration) => {
                if (!text) return '';
                const lines = text.split('\n');
                const line1Length = lines[0] ? countCharactersWithoutTags(lines[0]) : 0;
                const line2Length = lines.length > 1 && lines[1] ? countCharactersWithoutTags(lines[1]) : 0;
                const textForCps = text.replace(/\n/g, '');
                const cps = calculateCPS(textForCps, duration);
                return `(L1: ${line1Length} | L2: ${line2Length} | CPS: ${cps})`;
            };

            const createSuggestionHTML = (suggestionKey, titleKey) => {
                const text = suggestions[suggestionKey];
                if (!text) return '';
                
                const stats = getStatsString(text, entry.durationMs);
                // CORRECCI칍N: El t칤tulo tambi칠n se obtiene de las traducciones (t[titleKey])
                return `
                    <div>
                        <div class="flex justify-between items-center text-sm font-semibold">
                            <span>${t[titleKey]} <span class="font-mono text-gray-500 ml-2">${stats}</span></span>
                            <button class="btn btn-secondary p-1" title="Insertar sugerencia" onclick="insertAiSuggestion(${entryIndex}, '${suggestionKey}')">
                                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"></path></svg>
                            </button>
                        </div>
                        <p class="bg-gray-100 p-2 rounded-md italic text-sm mt-1">"${text.replace(/\n/g, '<br>')}"</p>
                    </div>`;
            };
            
            // CORRECCI칍N: Se pasan las claves de traducci칩n en lugar de texto fijo
            contentHTML += createSuggestionHTML('primary', 'instruction_1');
            contentHTML += createSuggestionHTML('secondary', 'instruction_2');
            contentHTML += createSuggestionHTML('tertiary', 'instruction_3');
            
            contentHTML += `</div>`;
            
            const urlRegex = /(https?:\/\/[^\s<]+)/g;
            const formattedNotes = entry.context.context_notes.replace(urlRegex, '<a href="$1" target="_blank" class="text-blue-600 hover:underline">$1</a>');
            contentHTML += `
                <div class="border-t pt-2">
                    <div class="prose prose-sm max-w-none">${formattedNotes}</div>
                </div>`;

        } else {
            contentHTML += `<p class="text-gray-500">${t['no_context_available']}</p>`;
        }
        contextDisplayView.innerHTML = contentHTML;

    } else {
        contextImportView.classList.remove('hidden');
        contextDisplayView.classList.add('hidden');
    }
}


        /**
         * Adjusts the height of a textarea to fit its content.
         * If the translation textarea is empty, it matches the height of the original textarea.
         * @param {HTMLTextAreaElement} textarea The textarea element (translation).
         * @param {HTMLElement} [originalElement] The original element (original text pre) for height comparison.
         */
        function autoResizeTextarea(textarea, originalElement) {
            textarea.style.height = 'auto';
            if (textarea.innerHTML.trim() === '' && originalElement) {
                // If textarea is empty, set its height to match the original element's scroll height
                textarea.style.height = originalElement.scrollHeight + 'px';
            } else {
                // Otherwise, let it expand to its own content
                textarea.style.height = textarea.scrollHeight + 'px';
            }
        }

        /**
         * Updates the character count and CPS for a specific textarea, including QA checks.
         * @param {HTMLElement} editorDiv The contenteditable div element.
         * @param {number} originalLength The length of the original string segment.
         * @param {number} durationMs The duration of the subtitle in milliseconds.
         */
        function updateSubtitleStats(editorDiv, originalLength, durationMs) {
            const entryIndex = parseInt(editorDiv.dataset.entryIndex);
            const charCountSpan = document.getElementById(`charCount-${entryIndex}`);
            const cpsSpan = document.getElementById(`cps-${entryIndex}`);
            const lineCharCountsDiv = document.getElementById(`lineCharCounts-${entryIndex}`);
            const translationLength = countCharactersWithoutTags(editorDiv.innerHTML);
            const t = translations[currentLanguage];

            if (charCountSpan) {
                charCountSpan.textContent = `${t.char_count_original}${originalLength}${t.char_units} | ${t.char_count_translation}${translationLength}${t.char_units}`;
            }
            
            if (cpsSpan) {
                const currentCPS = calculateCPS(editorDiv.innerHTML, durationMs);
                cpsSpan.textContent = `${currentCPS}${t.cps}`;
                // QA Check for CPS
                if (currentCPS > qaSettings.cpsLimit) {
                    cpsSpan.classList.add('qa-error');
                } else {
                    cpsSpan.classList.remove('qa-error');
                }
            }

            if (lineCharCountsDiv) {
                const lines = editorDiv.innerText.split('\n');
                lineCharCountsDiv.innerHTML = ''; // Clear previous counts
                lines.forEach((line, i) => {
                    const lineLength = countCharactersWithoutTags(line);
                    const lineSpan = document.createElement('span');
                    lineSpan.textContent = `L${i + 1}: ${lineLength}`;
                    // QA Check for chars per line
                    if (lineLength > qaSettings.charsPerLineLimit) {
                        lineSpan.classList.add('qa-error');
                    }
                    if (i > 0) lineCharCountsDiv.append(document.createTextNode(', '));
                    lineCharCountsDiv.appendChild(lineSpan);
                });
            }
// --- INICIO: L칍GICA DE LA BARRA DE PROGRESO CPS ---
            const currentCPS = calculateCPS(editorDiv.innerHTML, durationMs);
            const cpsLimit = qaSettings.cpsLimit;
            
            // 1. Calcula el 'porcentaje de llenado' en relaci칩n con el l칤mite
            const fillPercentage = (currentCPS / (cpsLimit * 1.5)) * 100; // Multiplica por 1.5 para que el 100% no sature la barra
            
            // 2. Calcula la posici칩n del l칤mite (ej. 20 CPS)
            const limitPosition = (cpsLimit / (cpsLimit * 1.5)) * 100;

            const barFill = document.getElementById(`cpsBarFill-${entryIndex}`);
            const barLimit = document.getElementById(`cpsBarLimit-${entryIndex}`);
            
            if (barFill && barLimit) {
                // Posiciona el l칤mite
                barLimit.style.left = `${Math.min(limitPosition, 100)}%`;
                
                // Actualiza el relleno
                barFill.style.width = `${Math.min(fillPercentage, 100)}%`;
                
                // Asigna color (Verde si est치 por debajo, Rojo si est치 por encima)
                if (currentCPS > cpsLimit) {
                    barFill.style.backgroundColor = '#ef4444'; // Rojo (utilizando un color Tailwind predefinido)
                } else {
                    barFill.style.backgroundColor = '#22c55e'; // Verde
                }
            }
            // --- FIN: L칍GICA DE LA BARRA DE PROGRESO CPS ---
        }

        /**
         * Configures the editable state of a translation entry (editable/read-only).
         * @param {number} entryIndex The index of the SRT entry.
         * @param {boolean} isEditable True to make it editable, false for read-only.
         */
        function setTranslationEditableState(entryIndex, isEditable) {
            const translationEditor = document.getElementById(`translation-${entryIndex}`);
            const validateButton = document.getElementById(`validateBtn-${entryIndex}`);
            const editButton = document.getElementById(`editBtn-${entryIndex}`);
            const checkIcon = document.getElementById(`checkIcon-${entryIndex}`);
            const translationUnit = document.getElementById(`translation-unit-${entryIndex}`); // Get the parent unit

            if (!translationEditor || !validateButton || !editButton || !checkIcon || !translationUnit) {
                console.error(`Elements not found for index ${entryIndex}`);
                return;
            }

            translationEditor.contentEditable = isEditable;
            if (!isEditable) {
                translationUnit.classList.remove('translation-unit-active'); // Remove active highlight on validate

                // Update translation status and words when segment is validated
                const entry = srtEntries[entryIndex];
                entry.isTranslated = translationEditor.innerText.trim() !== '';
                entry.wordCountTranslation = countWords(translationEditor.innerText);
                entry.charCountTranslation = countCharactersWithoutTags(translationEditor.innerHTML);
                entry.cpsTranslation = calculateCPS(translationEditor.innerHTML, entry.durationMs);

                updateStatsDisplay(); // Update stats
                addOrUpdateTMEntry(entry.original, entry.translation); // Add/Update TM
            } else {
                translationUnit.classList.add('translation-unit-active'); // Add active highlight on edit/focus
            }

            validateButton.style.display = isEditable ? 'inline-block' : 'none';
            editButton.style.display = isEditable ? 'none' : 'inline-block';
            checkIcon.style.display = isEditable ? 'none' : 'inline-block';

            if (isEditable) {
                translationEditor.focus();
            }
        }

        /**
         * Applies a style command (like 'bold' or 'italic') to the current selection.
         * @param {string} command The command to execute.
         */
        function formatText(command) {
            document.execCommand(command, false, null);
        }

        /**
         * Applies glossary term highlighting to a given text segment.
         * Collects terms that were successfully highlighted.
         * @param {string} text The original text to highlight.
         * @returns {{html: string, foundTerms: Set<string>}} Object with HTML string and set of found terms.
         */
        function applyGlossaryHighlightToText(text) {
            let highlightedHtml = text;
            const currentFoundTerms = new Set(); // Terms found in *this specific* segment

            if (!glossarySourceLanguage) {
                return { html: text, foundTerms: currentFoundTerms };
            }

            const sortedGlossary = [...glossary].sort((a, b) => b.srcTerm.length - a.srcTerm.length);

            sortedGlossary.forEach(glossaryEntry => {
                if (glossarySourceLanguage && glossaryEntry.srcTerm) {
                    const term = glossaryEntry.srcTerm;
                    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b(${escapedTerm})\\b`, 'gi'); 

                    if (highlightedHtml.match(regex)) {
                        highlightedHtml = highlightedHtml.replace(regex, (match, p1) => {
                            currentFoundTerms.add(term);
                            return `<span class="glossary-highlight">${p1}</span>`;
                        });
                    }
                }
            });
            return { html: highlightedHtml, foundTerms: currentFoundTerms };
        }

        /**
         * Updates highlighting in the glossary table based on terms found in the editor.
         */
        function updateGlossaryTableHighlights() {
            renderGlossary();
        }

function dismissLineBreakTooltip(event) {
            event.stopPropagation(); // Evita que otros clics se disparen
            localStorage.setItem('lineBreakTooltipDismissed', 'true');
            const tooltips = document.querySelectorAll('.line-break-tooltip');
            tooltips.forEach(tooltip => {
                tooltip.style.display = 'none'; // Oculta todas las instancias inmediatamente
            });
        }

function renderTranslations(entries, activeIndexToPreserve = null, preserveScroll = false) {
            translationsContainer.innerHTML = '';
            termsFoundInActiveSegment.clear();
           const t = translations[currentLanguage];
            const tooltipDismissed = localStorage.getItem('lineBreakTooltipDismissed') === 'true';
            let lineBreakTooltipHTML = '';
            if (!tooltipDismissed) {
                lineBreakTooltipHTML = `
                    <div class="line-break-tooltip relative flex items-center bg-blue-100 border border-blue-300 text-blue-800 text-xs px-2 py-1 rounded-md mr-2">
                        <span data-i18n="linebreak_tooltip_text">${t.linebreak_tooltip_text}</span>
                        <button onclick="dismissLineBreakTooltip(event)" class="ml-2 text-blue-800 hover:text-blue-900 font-bold text-lg leading-none">&times;</button>
                    </div>
                `;
            }

clearSubtitleRegions();            

if (entries.length === 0) {
                translationsContainer.innerHTML = `<div data-i18n="no_translations" id="initialMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md">${t.no_translations}</div>`;
                saveSrtButton.disabled = true;
                saveProjectBtn.disabled = true;
                statsContainer.classList.add('hidden');
                return;
            }

            entries.forEach((entry, entryIndex) => {
                const translationUnit = document.createElement('div');
                translationUnit.id = `translation-unit-${entryIndex}`;
                translationUnit.className = 'translation-unit-bg p-2 rounded-lg shadow-sm border border-gray-200 mb-4';

                let startTime, endTime;
if (useFrameTimecode) {
    startTime = formatFrameTime(entry.startTimeMs, projectFPS);
    endTime = formatFrameTime(entry.endTimeMs, projectFPS);
} else {
    [startTime, endTime] = entry.timecodes.split(' --> ');
}
                const durationInSeconds = (entry.durationMs / 1000).toFixed(3);

                translationUnit.innerHTML = `
                    <div class="text-md font-bold mb-2">${entry.index}</div>
                    
                    <div class="flex flex-wrap items-center justify-between gap-x-4 gap-y-2 mb-3">
                        
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium" data-i18n="entry_time">${t.entry_time}</label>
                            <div class="flex items-center">
                                <input type="text" id="startTime-${entryIndex}" value="${startTime}" onchange="handleTimecodeChange(${entryIndex}, true, this)" class="w-32 p-1 rounded-md border-2 border-gray-100 shadow-sm text-sm">
                                <div class="flex items-center gap-1 ml-2">
                                    <button class="btn btn-secondary p-1" onclick="nudgeTimecode(${entryIndex}, true, 1)">
                                        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd"></path></svg>
                                    </button>
                                    <button class="btn btn-secondary p-1" onclick="nudgeTimecode(${entryIndex}, true, -1)">
                                        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
                                    </button>
                                </div>
                                </div>
                        </div>

                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium" data-i18n="exit_time">${t.exit_time}</label>
                            <div class="flex items-center">
                                <input type="text" id="endTime-${entryIndex}" value="${endTime}" onchange="handleTimecodeChange(${entryIndex}, false, this)" class="w-32 p-1 rounded-md border-2 border-gray-100 shadow-sm text-sm">
                                <div class="flex items-center gap-1 ml-2">
                                    <button class="btn btn-secondary p-1" onclick="nudgeTimecode(${entryIndex}, false, 1)">
                                        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd"></path></svg>
                                    </button>
                                    <button class="btn btn-secondary p-1" onclick="nudgeTimecode(${entryIndex}, false, -1)">
                                        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
                                    </button>
                                </div>
                                </div>
                        </div>

                        <div class="flex items-center gap-2 ml-auto">
                            <span class="text-sm font-semibold" title="Duraci칩n del subt칤tulo"><span data-i18n="duration_label">${t.duration_label}</span> <span id="duration-${entryIndex}">${durationInSeconds}s</span></span>
                            <div class="flex items-center gap-1">
                                <button class="btn btn-secondary p-1" onclick="nudgeVideo(-1)" title="${t.rewind_frame_tooltip}">
                                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M8.445 14.832A1 1 0 0010 14.002V5.998a1 1 0 00-1.555-.832L3.62 9.168a1 1 0 000 1.664l4.825 4.001zM14.445 14.832A1 1 0 0016 14.002V5.998a1 1 0 00-1.555-.832L9.62 9.168a1 1 0 000 1.664l4.825 4.001z"></path></svg>
                                </button>
                                <button class="btn btn-secondary p-1" onclick="jumpToCurrentSubtitleTime(${entryIndex})" title="${t.play_segment_tooltip}">
                                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8.002v3.996a1 1 0 001.555.832l3.223-1.998a1 1 0 000-1.664L9.555 7.168z" clip-rule="evenodd"></path></svg>
                                </button>
                                <button class="btn btn-secondary p-1" onclick="nudgeVideo(1)" title="${t.forward_frame_tooltip}">
                                   <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M5.555 5.168A1 1 0 004 5.998v8.004a1 1 0 001.555.832L10.38 10.832a1 1 0 000-1.664L5.555 5.168zM11.555 5.168A1 1 0 0010 5.998v8.004a1 1 0 001.555.832L16.38 10.832a1 1 0 000-1.664l-4.825-4.001z"></path></svg>
                                </button>
<div class="flex items-center gap-1 ml-2 border-l pl-2">
    <button class="btn btn-secondary p-0 w-12 h-6 flex items-center justify-center" onclick="mergeWithNext(${entryIndex})" title="${t.merge_next_tooltip}">
         
    </button>
    <button class="btn btn-secondary p-0 w-12 h-6 flex items-center justify-center" onclick="splitSubtitle(${entryIndex})" title="${t.split_tooltip}">
         
    </button>
    <button class="btn btn-secondary p-0 w-8 h-6 flex items-center justify-center" onclick="confirmDeleteSubtitle(${entryIndex})" title="${t.delete_tooltip}">
        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.75 1A2.75 2.75 0 006 3.75v.443c-.795.077-1.58.22-2.365.468a.75.75 0 10.23 1.482l.149-.022.841 10.518A2.75 2.75 0 007.596 19h4.807a2.75 2.75 0 002.742-2.53l.841-10.52.149.023a.75.75 0 00.23-1.482A41.03 41.03 0 0014 4.193v-.443A2.75 2.75 0 0011.25 1h-2.5zM10 4c.84 0 1.673.025 2.5.075V3.75c0-.69-.56-1.25-1.25-1.25h-2.5c-.69 0-1.25.56-1.25 1.25v.325C8.327 4.025 9.16 4 10 4zM8.58 7.72a.75.75 0 00-1.5.06l.3 7.5a.75.75 0 101.5-.06l-.3-7.5zm4.34.06a.75.75 0 10-1.5-.06l-.3 7.5a.75.75 0 101.5.06l.3-7.5z" clip-rule="evenodd" /></svg>
    </button>
</div>                </div>
                        </div>
                    </div>
                    
                    <div class="translation-row mb-2">
                        <div class="original-col">
                            <label class="block text-sm font-medium mb-1" data-i18n="original_text">${t.original_text}</label>
                            <pre id="original-pre-${entryIndex}" class="subtitle-display-code p-1 rounded-md text-base overflow-auto max-h-24">${entry.original}</pre>
                        </div>
                        <div class="translation-col">
                            <div class="flex justify-between items-center">
                                <label class="block text-sm font-medium" data-i18n="translation_text">${t.translation_text}</label>
                                <span id="glossary-match-${entryIndex}" class="hidden flex items-center gap-1 text-xs font-semibold text-black bg-yellow-300 px-2 py-0.5 rounded-md truncate"></span>
                            </div>
                            <div id="translation-${entryIndex}" class="subtitle-editor mt-1 block w-full focus:ring-blue-500 focus:border-blue-500 text-base" contenteditable="true" data-entry-index="${entryIndex}" data-original-length="${entry.charCountOriginal}" data-duration-ms="${entry.durationMs}">${entry.translation}</div>
<div id="cpsBarContainer-${entryIndex}" class="cps-bar-container">
                                <div id="cpsBarFill-${entryIndex}" class="cps-bar-fill"></div>
                                <div id="cpsBarLimit-${entryIndex}" class="cps-bar-limit-marker"></div>
                            </div>
                            </div>
                            </div>
                    </div>
                    <div class="flex items-center justify-end mt-1 w-full">
    <div class="flex items-center space-x-2">
        <div class="flex items-center text-sm font-semibold">
    <span id="charCount-${entryIndex}"></span>
    &nbsp;<span class="text-black">|</span>&nbsp;
    <span id="cps-${entryIndex}"></span>
    &nbsp;<span class="text-black">|</span>&nbsp;
    <div id="lineCharCounts-${entryIndex}"></div>
</div>
        ${lineBreakTooltipHTML}
                            <button class="btn btn-secondary text-xs p-1" onclick="formatText('bold')"><b class="font-bold">B</b></button>
                            <button class="btn btn-secondary text-xs p-1" onclick="formatText('italic')"><i class="italic">I</i></button>
                            <svg id="checkIcon-${entryIndex}" class="check-icon text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                            
                            <button title="${t.validate_all_previous_tooltip}" onclick="validateUpTo(${entryIndex})" class="btn btn-secondary text-xs" data-i18n="validate_all_previous">${t.validate_all_previous}</button>
                            <button id="validateBtn-${entryIndex}" class="btn btn-primary text-xs" data-entry-index="${entryIndex}" data-i18n="validate">${t.validate}</button>
                            <button id="editBtn-${entryIndex}" class="btn btn-secondary text-xs" data-entry-index="${entryIndex}" style="display: none;" data-i18n="edit">${t.edit}</button>
                        </div>
                    </div>
                `;
                
                const translationEditor = translationUnit.querySelector(`#translation-${entryIndex}`);
                const originalColPre = translationUnit.querySelector(`#original-pre-${entryIndex}`);
                const validateButton = translationUnit.querySelector(`#validateBtn-${entryIndex}`);
                const editButton = translationUnit.querySelector(`#editBtn-${entryIndex}`);
                const checkIcon = translationUnit.querySelector(`#checkIcon-${entryIndex}`);


                if (entry.isTranslated) {
                    translationEditor.contentEditable = false;
                    validateButton.style.display = 'none';
                    // Ocultamos tambi칠n el nuevo bot칩n si el subt칤tulo ya est치 validado
                    translationUnit.querySelector('[onclick^="validateUpTo"]').style.display = 'none';
                    editButton.style.display = 'inline-block';
                    checkIcon.style.display = 'inline-block';
                }

        // 九 INICIO DEL BLOQUE FINAL 九

                let oldValue = entry.translation;

                translationEditor.addEventListener('input', (event) => {
                    if (isApplyingState) return;
                    clearTimeout(debounceTimeout);

                    const currentEntry = srtEntries[entryIndex];
                    currentEntry.translation = event.target.innerHTML;
                    currentEntry.wordCountTranslation = countWords(event.target.innerText);
                    currentEntry.charCountTranslation = countCharactersWithoutTags(event.target.innerHTML);
                    currentEntry.cpsTranslation = calculateCPS(event.target.innerHTML, currentEntry.durationMs);
                    autoResizeTextarea(event.target, originalColPre);
                    updateSubtitleStats(event.target, currentEntry.charCountOriginal, currentEntry.durationMs);
                    updateStatsDisplay();
                    updateSubtitlePreview();

// --- INICIO C칍DIGO A칌ADIDO ---
                    // Actualizar el contenido de la regi칩n en tiempo real
                    if (wsRegions) {
                        const region = wsRegions.getRegions().find(r => r.id === currentEntry.regionId);
                        if (region) {
                            const content = region.element?.querySelector('.region-content');
                            if (content) {
                                // Reutilizamos la l칩gica para generar el contenido de 4 l칤neas
                                const line1 = `#${currentEntry.index}`;
                                const originalPreview = currentEntry.original.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                                const line2 = originalPreview.substring(0, 40) + (originalPreview.length > 40 ? '...' : '');
                                let line3 = '';
                                if (currentEntry.translation) {
                                    const translationPreview = currentEntry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                                    line3 = translationPreview.split('\n').join(' ').substring(0, 40) + (translationPreview.length > 40 ? '...' : '');
                                }
                                let line4 = '---';
                                if (currentEntry.translation) {
                                     const translationTextClean = currentEntry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                                     const transLines = translationTextClean.split('\n');
                                     const transL1 = transLines[0] ? countCharactersWithoutTags(transLines[0]) : 0;
                                     const transL2 = transLines.length > 1 && transLines[1] ? countCharactersWithoutTags(transLines[1]) : 0;
                                     const transCPS = calculateCPS(translationTextClean.replace(/\n/g, ''), currentEntry.durationMs);
                                     line4 = `CPS: ${transCPS} | L1: ${transL1}${transLines.length > 1 ? ` / L2: ${transL2}` : ''}`;
                                }

                                content.innerHTML = `
                                    <div class="region-line region-line1">${line1}</div>
                                    <div class="region-line region-line2">${line2}</div>
                                    <div class="region-line region-line3">${line3}&nbsp;</div>
                                    <div class="region-line region-line4">${line4}</div>
                                `;
                            }
                        }
                    }
                    // --- FIN C칍DIGO A칌ADIDO ---

                    debounceTimeout = setTimeout(() => {
                        const newValue = event.target.innerHTML;
                        saveState(entryIndex, oldValue, newValue);
                        oldValue = newValue;
                    }, 1000);
                });

translationEditor.addEventListener('keydown', (event) => {
                    if (event.isSimulated) {
                        return;
                    }

                    if (event.key === 'Enter') {
                        if (!event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey) {
                            Object.defineProperty(event, 'shiftKey', { get: () => true });
                            event.preventDefault();
                            setTimeout(() => {
                                moveToNextEditableCell(event.currentTarget);
                            }, 0);
                            return;
                        }
                    }

                    // --- Comprobaci칩n de atajos de EDICI칍N y NAVEGACI칍N ---
                    const triggeredAction = Object.keys(shortcuts).find(action => {
                        const localActions = [
                            'validateAndNext', 'goToNext', 'goToPrevious', // Se a침aden de nuevo aqu칤
                            'insertTM1', 'insertTM2', 'insertTM3', 'insertTM4', 'insertTM5', 
                            'insertGloss1', 'insertGloss2', 'insertGloss3', 'insertGloss4', 'insertGloss5', 
                            'bold', 'italic',
                            'jumpToTime',
                            'playSegment',
                            'playSegmentLoop',
                            'playPause',
                            'seekForward',
                            'seekBackward',
                            'seekForwardFast',
                            'seekBackwardFast'
                            
                        ];
                        if (!localActions.includes(action)) return false;

                        const shortcut = shortcuts[action];
                        const keyMatch = (shortcut.key === ' ' && event.code === 'Space') || (shortcut.key.toLowerCase() === event.key.toLowerCase());
                        return keyMatch &&
                               shortcut.ctrlKey === event.ctrlKey &&
                               shortcut.metaKey === event.metaKey &&
                               shortcut.altKey === event.altKey &&
                               shortcut.shiftKey === event.shiftKey;
                    });

                    if (triggeredAction) {
                        event.preventDefault();
                        switch (triggeredAction) {
                            case 'validateAndNext':
    setTranslationEditableState(entryIndex, false);
    goToNextTranslation(entryIndex, true);
    break;
                            // Se a침aden los casos de navegaci칩n de nuevo
                            case 'goToNext':
                                goToNextTranslation(entryIndex);
                                break;
                            case 'goToPrevious':
                                goToPreviousTranslation(entryIndex);
                                break;
                            case 'bold':
                                formatText('bold');
                                break;
                            case 'italic':
                                formatText('italic');
                                break;
                            case 'jumpToTime':
                            case 'playSegment':
                                jumpToCurrentSubtitleTime(entryIndex);
                                break;
                            case 'playSegmentLoop':
                                playSubtitleLoop(entryIndex);
                                break;
                            case 'playPause':
                                if (videoPlayer.paused) videoPlayer.play();
                                else videoPlayer.pause();
                                break;
                            case 'seekForward':
                                videoPlayer.currentTime += 3;
                                break;
                            case 'seekBackward':
                                videoPlayer.currentTime -= 3;
                                break;
                            case 'seekForwardFast':
                                videoPlayer.currentTime += 5;
                                break;
                            case 'seekBackwardFast':
                                videoPlayer.currentTime -= 5;
                                break;
                            case 'insertTM1':
                                tmSearch(srtEntries[entryIndex].original); // <--- A칌ADIR ESTO
                                if (currentTMLatestSearchResults.length > 0) document.execCommand('insertHTML', false, currentTMLatestSearchResults[0].tgtText);
                                break;
                            case 'insertTM2':
                                tmSearch(srtEntries[entryIndex].original); // <--- A칌ADIR ESTO
                                if (currentTMLatestSearchResults.length > 1) document.execCommand('insertHTML', false, currentTMLatestSearchResults[1].tgtText);
                                break;
                            case 'insertTM3':
                                tmSearch(srtEntries[entryIndex].original); // <--- A칌ADIR ESTO
                                if (currentTMLatestSearchResults.length > 2) document.execCommand('insertHTML', false, currentTMLatestSearchResults[2].tgtText);
                                break;
                            case 'insertTM4':
                                tmSearch(srtEntries[entryIndex].original); // <--- A칌ADIR ESTO
                                if (currentTMLatestSearchResults.length > 3) document.execCommand('insertHTML', false, currentTMLatestSearchResults[3].tgtText);
                                break;
                            case 'insertTM5':
                                tmSearch(srtEntries[entryIndex].original); // <--- A칌ADIR ESTO
                                if (currentTMLatestSearchResults.length > 4) document.execCommand('insertHTML', false, currentTMLatestSearchResults[4].tgtText);
                                break;
                           
                            default:
                                // El if de 'insertTM' ya no es necesario aqu칤, pero dejamos el de 'insertGloss'
                                if (triggeredAction.startsWith('insertGloss')) {
                                    const index = parseInt(triggeredAction.replace('insertGloss', '')) - 1;
                                    if (currentGlossaryLatestResults.length > index) {
                                        document.execCommand('insertHTML', false, currentGlossaryLatestResults[index].tgtTerm);
                                    }
                                }
                                break;
                        }
                        return;
                    }
                          
                    // --- L칩gica para atajos de documentaci칩n ---
                    const triggeredDocAction = shortcuts.docResources.find(res => {
                        if (!res.shortcut) return false;
                        const sc = res.shortcut;
                        const keyMatch = (sc.key === ' ' && event.code === 'Space') || (sc.key.toLowerCase() === event.key.toLowerCase());
                        return keyMatch &&
                               sc.ctrlKey === event.ctrlKey &&
                               sc.metaKey === event.metaKey &&
                               sc.altKey === event.altKey &&
                               sc.shiftKey === event.shiftKey;
                    });

                    if (triggeredDocAction) {
                        event.preventDefault();
                        const selectedText = window.getSelection().toString().trim();
                        const resourceUrl = triggeredDocAction.url;

                        if (selectedText && resourceUrl && resourceUrl.includes('{word}')) {
                            const finalUrl = resourceUrl.replace('{word}', encodeURIComponent(selectedText));
                            window.open(finalUrl, '_blank');
                        }
                    }
                });

                translationEditor.addEventListener('focus', (event) => {
                    oldValue = translationEditor.innerHTML;
                    document.querySelectorAll('.translation-unit-active').forEach(unit => unit.classList.remove('translation-unit-active'));
                    translationUnit.classList.add('translation-unit-active');
                    termsFoundInActiveSegment.clear();
                    if (glossarySourceLanguage && glossary.length > 0) {
                        const highlightResult = applyGlossaryHighlightToText(entry.original);
                        originalColPre.innerHTML = highlightResult.html;
                        highlightResult.foundTerms.forEach(term => termsFoundInActiveSegment.add(term));
                    }

                    const glossaryMatchContainer = document.getElementById(`glossary-match-${entryIndex}`);
                    glossaryMatchContainer.innerHTML = '';
                    glossaryMatchContainer.title = '';
                    glossaryMatchContainer.classList.add('hidden');

                    if (termsFoundInActiveSegment.size > 0) {
                        let hintText = '';
                        let fullHintText = '';

                        termsFoundInActiveSegment.forEach(foundTerm => {
                            const glossaryEntry = glossary.find(g => g.srcTerm === foundTerm);
                            if (glossaryEntry) {
                                const part = `${glossaryEntry.srcTerm} -> ${glossaryEntry.tgtTerm}`;
                                hintText += part + ' | ';
                                fullHintText += part + ' | ';
                            }
                        });

                        if (hintText) {
                            glossaryMatchContainer.innerHTML = `
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg>
                                <span>${hintText.slice(0, -3)}</span>
                            `;
                            glossaryMatchContainer.title = `Glosario: ${fullHintText.slice(0, -3)}`;
                            glossaryMatchContainer.classList.remove('hidden');
                        }
                    }
                    updateGlossaryTableHighlights();
                    autoResizeTextarea(event.target, originalColPre);
                    event.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    updateNotesPanel(entryIndex);
                    tmSearch(srtEntries[entryIndex].original);
                    updateContextPanel(entryIndex);
                });

                translationEditor.addEventListener('blur', () => {
                    originalColPre.textContent = entry.original;
                    termsFoundInActiveSegment.clear();
                    document.getElementById(`glossary-match-${entryIndex}`).classList.add('hidden');
                    document.getElementById(`glossary-match-${entryIndex}`).title = '';
                    updateGlossaryTableHighlights();
                    tmSearch();
                });
                
                // 九 FIN DEL BLOQUE FINAL 九

                validateButton.addEventListener('click', () => {
                    setTranslationEditableState(entryIndex, false);
                    goToNextTranslation(entryIndex);
                });

                editButton.addEventListener('click', () => setTranslationEditableState(entryIndex, true));

                translationsContainer.appendChild(translationUnit);
                updateSubtitleStats(translationEditor, entry.charCountOriginal, entry.durationMs);
addSubtitleRegion(entry);
            });
            
            saveSrtButton.disabled = false;
            saveProjectBtn.disabled = false;
            statsContainer.classList.remove('hidden');
plannerContainer.classList.remove('hidden');
            updateStatsDisplay();
            setupIntersectionObserver();

            if (!preserveScroll) {
                if (activeIndexToPreserve !== null && activeIndexToPreserve < srtEntries.length) {
                    navigateToTranslation(activeIndexToPreserve);
                } else {
                    const firstEditableSegment = getFirstEditableSegment();
                    if (firstEditableSegment) {
                        navigateToTranslation(firstEditableSegment.entryIndex);
                    }
                }
            }
        }

 /**
         * Valida el subt칤tulo actual y todos los anteriores que no est칠n ya validados.
         * @param {number} entryIndex - El 칤ndice del subt칤tulo actual.
         */
        function validateUpTo(entryIndex) {
            showLoadingOverlay('Validando subt칤tulos...'); // Muestra un mensaje de carga
            
            // Usamos un timeout para que la interfaz de carga se muestre antes de empezar el proceso
            setTimeout(() => {
                for (let i = 0; i <= entryIndex; i++) {
                    // Solo validamos si no est치 ya validado para ser m치s eficientes
                    if (!srtEntries[i].isTranslated) {
                        setTranslationEditableState(i, false);
                    }
                }
                
                // Una vez terminado, salta al siguiente subt칤tulo pendiente
                goToNextTranslation(entryIndex, false);
                hideLoadingOverlay(); // Oculta el mensaje de carga
            }, 50); // Un peque침o retardo de 50ms es suficiente
        }


function updateTranslations() {
    // Primero, actualizamos la tabla del glosario para que muestre los nuevos t칠rminos.
    renderGlossary();

    // Luego, recorremos cada subt칤tulo para ver si necesita una actualizaci칩n visual.
    srtEntries.forEach((entry, entryIndex) => {
        const originalColPre = document.getElementById(`original-pre-${entryIndex}`);
        if (!originalColPre) return; // Si el subt칤tulo no est치 en pantalla, no hacemos nada.

        // La principal raz칩n para refrescar es aplicar el resaltado del nuevo
        // t칠rmino del glosario en el subt칤tulo que est칠 activo.
        if (lastActiveSubtitleIndex === entryIndex) {
            const highlightResult = applyGlossaryHighlightToText(entry.original);
            originalColPre.innerHTML = highlightResult.html;
        }
    });

    // Finalmente, actualizamos las estad칤sticas generales (contador de palabras, etc.).
    updateStatsDisplay();
}


  /**
         * Updates the display of translation progress and word counts.
         */
        function updateStatsDisplay() {
            const t = translations[currentLanguage];
            let totalSegments = srtEntries.length;
            let translatedSegments = srtEntries.filter(e => e.isTranslated).length;
            let totalWordsOriginal = srtEntries.reduce((acc, e) => acc + e.wordCountOriginal, 0);
            let totalWordsTranslated = srtEntries.reduce((acc, e) => acc + e.wordCountTranslation, 0);

            const percentage = totalSegments > 0 ? ((translatedSegments / totalSegments) * 100).toFixed(0) : 0;
            
            segmentsProgress.textContent = t.segments_progress_text.replace('{0}', translatedSegments).replace('{1}', totalSegments).replace('{2}', percentage);
            wordsTranslated.textContent = t.words_translated_text.replace('{0}', totalWordsTranslated);
            wordsTotal.textContent = t.words_total_text.replace('{0}', totalWordsOriginal);
            wordsRemaining.textContent = t.words_remaining_text.replace('{0}', totalWordsOriginal - totalWordsTranslated);

            const qaErrors = calculateAllQaErrors();
            if (qaErrors.length > 0) {
                qaErrorStats.textContent = t.qa_errors_found.replace('{0}', qaErrors.length);
                qaErrorStats.className = 'qa-error clickable';
            } else {
                qaErrorStats.textContent = t.qa_no_errors;
                qaErrorStats.className = 'qa-success';
            }

const statusBar = document.getElementById('statusBar');
            if (statusBar) {
                // Obtenemos el texto de cada span
                const progressText = segmentsProgress.textContent;
                const translatedText = wordsTranslated.textContent;
                const totalText = wordsTotal.textContent;
                const remainingText = wordsRemaining.textContent;
                const qaText = qaErrorStats.textContent;
                const isQaClickable = qaErrorStats.classList.contains('clickable'); // Verificamos si hay errores

                // Determinamos las clases CSS para el texto QA
                const qaClasses = isQaClickable ? 'qa-error' : 'qa-success'; // Usa las clases existentes

                // Creamos el HTML para el texto QA
                let qaHtml = '';
                if (isQaClickable) {
                    // Si hay errores (clickable), usa un span con ID y clases
                    qaHtml = `<span id="statusBarQaLink" class="cursor-pointer underline ${qaClasses}">${qaText}</span>`;
                } else {
                    // Si no hay errores, usa un span solo con las clases de estilo
                    qaHtml = `<span class="${qaClasses}">${qaText}</span>`;
                }

                // Combinamos todo en el innerHTML, a침adiendo el espacio antes de qaHtml
                statusBar.innerHTML = `${progressText} | ${translatedText} / ${totalText} | ${remainingText} |&nbsp; ${qaHtml}`; //

                // Si a침adimos el span clickable, le a침adimos el listener AHORA
                if (isQaClickable) {
                    const statusBarQaLink = document.getElementById('statusBarQaLink');
                    if (statusBarQaLink) {
                        statusBarQaLink.addEventListener('click', () => {
                            // Reutilizamos la l칩gica del listener original de qaErrorStats
                            if (calculateAllQaErrors().length > 0) {
                                renderQaErrorList();
                                qaErrorListModal.classList.remove('hidden');
                            }
                        });
                    }
                }
            }
        }


        /**
         * Gets the index of the currently focused translation textarea.
         * @returns {{entryIndex: number} | null} The object with index, or null.
         */
        function getCurrentFocusedIndex() {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.classList.contains('subtitle-editor')) {
                return {
                    entryIndex: parseInt(activeElement.dataset.entryIndex)
                };
            }
            return null;
        }

        /**
         * Finds the first editable segment.
         * @returns {{entryIndex: number} | null} The object with index, or null.
         */
       function getFirstEditableSegment() {
    // Recorremos todos los subt칤tulos buscando el primero que no est칠 validado.
    for (let i = 0; i < srtEntries.length; i++) {
        // Si encontramos uno que NO est치 traducido (`isTranslated` es false)...
        if (!srtEntries[i].isTranslated) {
            // ...devolvemos su 칤ndice para que el programa salte directamente a 칠l.
            return { entryIndex: i };
        }
    }

    // Si el bucle termina y no hemos encontrado ninguno sin traducir
    // (es decir, todos est치n validados), no devolvemos nada (null).
    return null;
}


        /**
         * Navigates to and focuses a specific translation field.
         * @param {number} entryIndex The index of the SRT entry.
         */
   function navigateToTranslation(entryIndex) {
    const targetEditor = document.getElementById(`translation-${entryIndex}`);
    if (targetEditor) {
        const currentlyFocusedEditor = document.activeElement;
        if (currentlyFocusedEditor && currentlyFocusedEditor.classList.contains('subtitle-editor') && currentlyFocusedEditor !== targetEditor) {
            currentlyFocusedEditor.blur();
        }
        setTranslationEditableState(entryIndex, true);
        targetEditor.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
       
        // --- MODIFIED BLOCK ---
        if (videoPlayer.src && srtEntries[entryIndex]) {
            // Set the video time to the start of the focused subtitle, but DO NOT play.
            videoPlayer.currentTime = srtEntries[entryIndex].startTimeMs / 1000;
        }
        // --- END MODIFIED BLOCK ---
    }
}

        /**
         * Moves focus to the next translation field.
         * @param {number} currentEntryIndex The current index of the SRT entry.
         */
        function goToNextTranslation(currentEntryIndex, autoPlayNext = false) {
            if (srtEntries.length === 0) return;

            let nextEntryIndex = currentEntryIndex + 1;

            if (nextEntryIndex < srtEntries.length) {
                // Esto enfoca, hace scroll y ajusta el tiempo del v칤deo
                navigateToTranslation(nextEntryIndex);
                
                // Si la orden fue "validar y seguir", reproducimos el segmento
                if (autoPlayNext) {
                    jumpToCurrentSubtitleTime(nextEntryIndex);
                }
            } else {
                showMessage(errorMessages[currentLanguage]['reached_last']);
            }
        }

        /**
         * Moves focus to the previous translation field.
         * @param {number} currentEntryIndex The current index of the SRT entry.
         */
        function goToPreviousTranslation(currentEntryIndex) {
            if (srtEntries.length === 0) return;

            let prevEntryIndex = currentEntryIndex - 1;

            if (prevEntryIndex >= 0) {
                navigateToTranslation(prevEntryIndex);
            } else {
                showMessage(errorMessages[currentLanguage]['reached_first']);
            }
        }

function setupIntersectionObserver() {
    const options = {
        root: document.getElementById('editorMainContent'),
        rootMargin: '-50% 0px -50% 0px', // Elige el elemento que est치 en el centro
        threshold: 0
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                // Cuando un subt칤tulo entra en el centro de la vista,
                // guardamos su 칤ndice como el 칰ltimo activo.
                lastActiveSubtitleIndex = parseInt(entry.target.querySelector('.subtitle-editor').dataset.entryIndex, 10);
            }
        });
    }, options);

    // Hacemos que el observador vigile cada uno de los subt칤tulos
    document.querySelectorAll('.translation-unit-bg').forEach(unit => {
        observer.observe(unit);
    });
}

// --- INICIO DEL C칍DIGO A A칌ADIR ---

        // --- Undo/Redo Logic ---

        /**
         * Actualiza el estado de los botones Deshacer/Rehacer (activado/desactivado).
         */
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn && redoBtn) {
                undoBtn.disabled = historyStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }
        }

       /**
         * Guarda el estado de un cambio de texto en el historial. // <- Texto modificado
         * @param {number} entryIndex - El 칤ndice del subt칤tulo modificado.
         * @param {string} oldValue - El contenido ANTES del cambio.
         * @param {string} newValue - El contenido DESPU칄S del cambio.
         */
        function saveState(entryIndex, oldValue, newValue) {
            // A칌ADIR ESTA L칈NEA ->
            if (isApplyingState) return; // No guardar estados mientras se deshace/rehace
            // Si el valor no ha cambiado, no guardamos nada.
            if (oldValue === newValue) return;

            // A칌ADIR type: 'text' ->
            historyStack.push({ type: 'text', entryIndex, oldValue, newValue });
            redoStack = []; // Un nuevo cambio borra el historial de "rehacer"
            updateUndoRedoButtons();
        }

        /**
         * Deshace la 칰ltima acci칩n del historial.
         */
        function undo() {
            if (historyStack.length === 0) return;

isApplyingState = true;

            const lastAction = historyStack.pop();
            const { entryIndex, oldValue, newValue } = lastAction;

            // Guardamos la acci칩n inversa en el historial de "rehacer"
            redoStack.push(lastAction);

            // Aplicamos el estado anterior
            const entry = srtEntries[entryIndex];
            const editor = document.getElementById(`translation-${entryIndex}`);
            if (entry && editor) {
                entry.translation = oldValue;
                editor.innerHTML = oldValue;
                editor.dispatchEvent(new Event('input', { bubbles: true })); // Para actualizar estad칤sticas
            }

            updateUndoRedoButtons();
isApplyingState = false;
        }

        /**
         * Rehace la 칰ltima acci칩n deshecha.
         */
        function redo() {
            if (redoStack.length === 0) return;
isApplyingState = true; 

            const lastUndo = redoStack.pop();
            const { entryIndex, oldValue, newValue } = lastUndo;

            // Devolvemos la acci칩n al historial principal
            historyStack.push(lastUndo);

            // Aplicamos el estado posterior
            const entry = srtEntries[entryIndex];
            const editor = document.getElementById(`translation-${entryIndex}`);
            if (entry && editor) {
                entry.translation = newValue;
                editor.innerHTML = newValue;
                editor.dispatchEvent(new Event('input', { bubbles: true })); // Para actualizar estad칤sticas
            }

            updateUndoRedoButtons();
isApplyingState = false;
        }
        // --- FIN DEL C칍DIGO A A칌ADIR ---

        // --- Event Handlers ---

// --- INICIO: L칍GICA PARA IMPORTAR SRT TRADUCIDO ---

translatedSrtFile.addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    // 1. Validar que ya existe un proyecto cargado con un original
    if (srtEntries.length === 0) {
        showMessage(translations[currentLanguage]['error_no_original_srt']);
        event.target.value = ''; // Resetear el input para permitir reintentar
        return;
    }

    showLoadingOverlay(translations[currentLanguage]['loading_file']);

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const content = e.target.result;
            // Reutilizamos la funci칩n de parseo existente para leer el nuevo archivo
            const translatedEntries = parseSrtContent(content);
            
            mergeTranslatedEntries(translatedEntries);
            
        } catch (error) {
            console.error("Error importando traducci칩n:", error);
            showMessage(`${errorMessages[currentLanguage]['error_reading_file']} ${error.message}`);
        } finally {
            hideLoadingOverlay();
            event.target.value = ''; // Resetear input
        }
    };
    reader.readAsText(file);
});

/**
 * Fusiona los subt칤tulos de un segundo archivo SRT en la columna de traducci칩n.
 * Mantiene la sincronizaci칩n por 칤ndice (1 con 1, 2 con 2, etc).
 */
function mergeTranslatedEntries(newEntries) {
    // 1. Guardar estado actual para el sistema de Deshacer (Undo)
    // Usamos JSON.parse/stringify para una copia profunda segura
    const oldState = JSON.parse(JSON.stringify(srtEntries));

    let mergedCount = 0;
    // Solo iteramos hasta el l칤mite del archivo m치s corto para evitar errores
    const limit = Math.min(srtEntries.length, newEntries.length);

    // 2. Bucle de fusi칩n
    for (let i = 0; i < limit; i++) {
        const originalEntry = srtEntries[i];
        const translatedEntry = newEntries[i];

        // IMPORTANTE: parseSrtContent pone el texto en .original.
        // Nosotros queremos coger ese texto y ponerlo en .translation del proyecto actual.
        const textToImport = translatedEntry.original.trim();

        if (textToImport) {
            originalEntry.translation = textToImport;
            
            // Actualizamos todas las estad칤sticas asociadas
            originalEntry.isTranslated = true;
            originalEntry.wordCountTranslation = countWords(textToImport);
            originalEntry.charCountTranslation = countCharactersWithoutTags(textToImport);
            originalEntry.cpsTranslation = calculateCPS(textToImport, originalEntry.durationMs);
            
            mergedCount++;
        }
    }

    // 3. Guardar en el historial de deshacer usando tu funci칩n existente
    const newState = JSON.parse(JSON.stringify(srtEntries));
    saveStructuralState(oldState, newState);

    // 4. Renderizar la interfaz actualizada
    renderTranslations(srtEntries, 0, true); // true = mantener scroll si es posible
    updateStatsDisplay();

    // 5. Mensajes de feedback al usuario
    if (srtEntries.length !== newEntries.length) {
        const warningMsg = translations[currentLanguage]['translation_mismatch_warning']
            .replace('{0}', newEntries.length)
            .replace('{1}', srtEntries.length);
        showMessage(warningMsg);
    } else {
        showMessage(translations[currentLanguage]['translation_imported_success'].replace('{0}', mergedCount));
    }
}
// --- FIN: L칍GICA PARA IMPORTAR SRT TRADUCIDO ---

        srtFile.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                await processFile(file);
            }
        });

        saveSrtButton.addEventListener('click', () => {
            if (srtEntries.length === 0) {
                showMessage(errorMessages[currentLanguage]['no_translations_to_save']);
                return;
            }
            fileNameInput.value = currentFileName.replace(/\.srt$/i, '') + '_trad.srt';
            saveSrtModal.classList.remove('hidden');
            fileNameInput.focus();
        });

        cancelSaveBtn.addEventListener('click', () => {
            saveSrtModal.classList.add('hidden');
        });

        confirmSaveBtn.addEventListener('click', () => {
            const filename = fileNameInput.value;
            if (!filename) {
                showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                return;
            }
            showLoadingOverlay(errorMessages[currentLanguage]['saving_file']);
            try {
                const updatedSrtContent = reconstructSrt(srtEntries);
                const blob = new Blob([updatedSrtContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename.endsWith('.srt') ? filename : filename + '.srt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showMessage(errorMessages[currentLanguage]['file_saved_successfully']);
            } catch (error) {
                showMessage(`${errorMessages[currentLanguage]['error_saving_file']} ${error.message}`);
                console.error("Error saving file:", error);
            } finally {
                hideLoadingOverlay();
                saveSrtModal.classList.add('hidden');
            }
        });

        async function processFile(file) {
            currentFileName = file.name;
            videoFileName = null; // Reset video file name when a new SRT is loaded
            showLoadingOverlay(errorMessages[currentLanguage]['loading_file']);

           
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        srtEntries = parseSrtContent(content);
 historyStack = [];
                    redoStack = [];
                    updateUndoRedoButtons();
                        renderTranslations(srtEntries);
                        runFullQaCheck();
                        updateStatsDisplay();
                        resolve();
                    } catch (error) {
                        showMessage(`${errorMessages[currentLanguage]['error_reading_file']} ${error.message}`);
                        console.error("Error parsing file:", error);
                        translationsContainer.innerHTML = `<div class="text-center text-red-500 p-4 border border-red-300 rounded-md">${errorMessages[currentLanguage]['file_processing_error']}</div>`;
                        saveSrtButton.disabled = true;
                        saveProjectBtn.disabled = true;
                        statsContainer.classList.add('hidden');
                        resolve();
                    } finally {
                        hideLoadingOverlay();
                    }
                };
                reader.onerror = () => {
                    showMessage(errorMessages[currentLanguage]['error_reading_file'] + (file.name || ''));
                    saveSrtButton.disabled = true;
                    saveProjectBtn.disabled = true;
                    statsContainer.classList.add('hidden');
                    hideLoadingOverlay();
                    resolve();
                };
                reader.readAsText(file);
            });
        }

        
      function showMessage(msg) {
            // Limpia cualquier temporizador anterior
            clearTimeout(messageTimeout);
            
            messageText.textContent = msg;

            // 仇 CORRECCI칍N: Quitamos la clase 'hidden' para que el contenedor exista
            messageBox.classList.remove('hidden'); 
            
            // Hacemos visible el mensaje, iniciando la transici칩n de "fade in"
            setTimeout(() => {
                messageBox.classList.add('is-visible');
            }, 10); // Un peque침o retardo para asegurar que la animaci칩n se ejecute

            // Configuramos un nuevo temporizador para ocultarlo
            messageTimeout = setTimeout(() => {
                // Quitamos la clase, iniciando la transici칩n de "fade out"
                messageBox.classList.remove('is-visible');
                 // Esperamos a que la animaci칩n de salida termine para volver a ocultarlo
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, 300); // Coincide con la duraci칩n de la transici칩n en CSS
            }, 3000); // El mensaje estar치 visible por 3 segundos
        }

        // --- Keyboard Shortcuts Modal ---
        shortcutsBtn.addEventListener('click', () => {
            renderShortcutsModal();
            shortcutsModal.classList.remove('hidden');
        });

        shortcutsCloseBtn.addEventListener('click', () => {
            window.removeEventListener('keydown', recordShortcutHandler, true); // Use correct handler
            recordingAction = null;
            shortcutsModal.classList.add('hidden');
        });

        function formatShortcut(shortcut) {
            let parts = [];
            if (shortcut.ctrlKey) parts.push('Ctrl');
            if (shortcut.metaKey) parts.push('Cmd');

            
            if (shortcut.altKey) {
                // Si el perfil es 'mac', usa "Option". Si no, usa "Alt".
                const altKeyName = activeProfile === 'mac' ? 'Option' : 'Alt';
                parts.push(altKeyName);
            }
            

            if (shortcut.shiftKey) parts.push('Shift');
            
            let keyName = shortcut.key;
            if (keyName === ' ') keyName = 'Space';
            
            parts.push(keyName.charAt(0).toUpperCase() + keyName.slice(1));
            return parts.join(' + ');
        }

      function renderShortcutsModal() {
            shortcutsList.innerHTML = '';
            const t = translations[currentLanguage];
            const activeShortcuts = shortcutProfiles[activeProfile];

            for (const action in activeShortcuts) {
                if (action === 'docResources') continue;

                const shortcut = activeShortcuts[action];
                const row = document.createElement('div');
                row.className = 'flex justify-between items-center p-2 border-b';
                
                const description = t[shortcut.descriptionKey] || shortcut.descriptionKey;
                
                let shortcutControlsHTML = `
                    <span id="shortcut-display-${action}" class="shortcut-input font-mono">${formatShortcut(shortcut)}</span>
                    <button class="btn btn-secondary text-sm" data-action="${action}" data-i18n="edit_shortcut_btn">${t.edit_shortcut_btn}</button>
                `;

                if (action === 'playSegmentLoop') {
                    shortcutControlsHTML = `
                        <input type="number" min="1" value="${shortcut.loopCount || 3}" onchange="updateLoopCount(this.value)" class="w-16 p-1 border border-gray-300 rounded-md text-center">
                        ${shortcutControlsHTML}
                    `;
                }

                row.innerHTML = `
                    <span>${description}</span>
                    <div class="flex items-center gap-2">
                        ${shortcutControlsHTML}
                    </div>
                `;
                shortcutsList.appendChild(row);
            }

            // ... (El c칩digo para la secci칩n "Productive Documentation" no cambia, por lo que se omite por brevedad) ...
            const docSection = document.createElement('div');
            docSection.className = 'mt-6 pt-4 border-t';
            docSection.innerHTML = `<h3 class="text-lg font-bold mb-3" data-i18n="productive_documentation">${t.productive_documentation}</h3>`;
            activeShortcuts.docResources.forEach((resource, index) => {
                const row = document.createElement('div');
                row.className = 'flex justify-between items-center p-2 gap-4';
                const urlInput = document.createElement('input');
                urlInput.type = 'text';
                urlInput.className = 'w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white';
                urlInput.placeholder = t.doc_resource_placeholder;
                urlInput.value = resource.url;
                urlInput.oninput = (e) => {
                    shortcutProfiles[activeProfile].docResources[index].url = e.target.value;
                    saveShortcuts();
                };
                const shortcutContainer = document.createElement('div');
                shortcutContainer.className = 'flex items-center gap-2';
                const shortcutDisplay = document.createElement('span');
                shortcutDisplay.id = `shortcut-display-doc_${index}`;
                shortcutDisplay.className = 'shortcut-input font-mono';
                shortcutDisplay.textContent = resource.shortcut ? formatShortcut(resource.shortcut) : '...';
                const editButton = document.createElement('button');
                editButton.className = 'btn btn-secondary text-sm';
                editButton.dataset.action = `doc_${index}`;
                editButton.textContent = t.edit_shortcut_btn;
                shortcutContainer.appendChild(shortcutDisplay);
                shortcutContainer.appendChild(editButton);
                row.appendChild(urlInput);
                row.appendChild(shortcutContainer);
                docSection.appendChild(row);
            });
            shortcutsList.appendChild(docSection);

            shortcutsList.querySelectorAll('button[data-action]').forEach(button => {
                button.addEventListener('click', () => startRecording(button.dataset.action));
            });

            // L칩gica para el selector de perfil
            const profileSelector = document.getElementById('shortcutProfileSelector');
            profileSelector.value = activeProfile;
            profileSelector.onchange = (e) => {
                activeProfile = e.target.value;
                localStorage.setItem('shortcutProfile', activeProfile); // Guardar preferencia
                shortcuts = { ...shortcutProfiles[activeProfile] }; // Actualizar atajos activos
                renderShortcutsModal(); // Volver a renderizar el modal con el nuevo perfil
            };
        }
        let recordingAction = null;
        const recordShortcutHandler = (e) => {
            if (!recordingAction) return;
        
            e.preventDefault();
            e.stopPropagation();
        
            const modifierKeys = ['Control', 'Alt', 'Shift', 'Meta'];
            if (modifierKeys.includes(e.key)) {
                return; 
            }
        
            window.removeEventListener('keydown', recordShortcutHandler, true);
        
            const newShortcut = {
                key: e.key === ' ' ? ' ' : e.key.toLowerCase(),
                ctrlKey: e.ctrlKey,
                altKey: e.altKey,
                shiftKey: e.shiftKey,
metaKey: e.metaKey
            };
        
            // Check for conflicts
            let conflict = Object.keys(shortcuts).some(action => {
                if (action === 'docResources' || action === recordingAction) return false;
                const sc = shortcuts[action];
                return sc.key === newShortcut.key && sc.ctrlKey === newShortcut.ctrlKey && sc.altKey === newShortcut.altKey && sc.shiftKey === newShortcut.shiftKey;
            });

            if (!conflict) {
                conflict = shortcuts.docResources.some((res, i) => {
                    const actionId = `doc_${i}`;
                    if (!res.shortcut || actionId === recordingAction) return false;
                    const sc = res.shortcut;
                    return sc.key === newShortcut.key && sc.ctrlKey === newShortcut.ctrlKey && sc.altKey === newShortcut.altKey && sc.shiftKey === newShortcut.shiftKey;
                });
            }

            if (conflict) {
                showMessage(errorMessages[currentLanguage].shortcut_conflict);
            } else {
                if (recordingAction.startsWith('doc_')) {
                    // It's a documentation shortcut
                    const index = parseInt(recordingAction.split('_')[1]);
                    shortcuts.docResources[index].shortcut = newShortcut;
                } else {
                    // It's a regular application shortcut
                   shortcutProfiles[activeProfile][recordingAction] = { ...shortcutProfiles[activeProfile][recordingAction], ...newShortcut };
                }
                saveShortcuts();
            }
        
            recordingAction = null;
            renderShortcutsModal();
        };

        function startRecording(action) {
            // Clear any previous recording state
            window.removeEventListener('keydown', recordShortcutHandler, true);
            document.querySelectorAll('.shortcut-input.recording').forEach(el => {
                const prevAction = el.id.replace('shortcut-display-', '');
                let shortcutToFormat;
                if (prevAction.startsWith('doc_')) {
                    const index = parseInt(prevAction.split('_')[1]);
                    shortcutToFormat = shortcuts.docResources[index].shortcut;
                } else {
                    shortcutToFormat = shortcuts[prevAction];
                }
                el.textContent = shortcutToFormat ? formatShortcut(shortcutToFormat) : '...';
            });

            recordingAction = action;
            const displayEl = document.getElementById(`shortcut-display-${action}`);
            displayEl.classList.add('recording');
            displayEl.textContent = translations[currentLanguage].recording_shortcut_text;
            
            window.addEventListener('keydown', recordShortcutHandler, true);
        }

        async function saveShortcuts() {
            try {
                await db.settings.put({ key: 'shortcutProfiles', value: shortcutProfiles });
            } catch (error) {
                console.error("Failed to save shortcuts:", error);
            }
        }

async function loadShortcuts() {
            // 1. Define el perfil base de Windows/Linux
            const windowsProfile = {
                validateAndNext: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'enter', descriptionKey: 'shortcut_desc_validateAndNext' },
                goToNext: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'arrowdown', descriptionKey: 'shortcut_desc_goToNext' },
                goToPrevious: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'arrowup', descriptionKey: 'shortcut_desc_goToPrevious' },
                 insertTM1: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '1', descriptionKey: 'shortcut_desc_insertTM1' },
                insertTM2: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '2', descriptionKey: 'shortcut_desc_insertTM2' },
                insertTM3: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '3', descriptionKey: 'shortcut_desc_insertTM3' },
                insertTM4: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '4', descriptionKey: 'shortcut_desc_insertTM4' },
                insertTM5: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '5', descriptionKey: 'shortcut_desc_insertTM5' },
                insertGloss1: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '1', descriptionKey: 'shortcut_desc_insertGloss1' },
                insertGloss2: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '2', descriptionKey: 'shortcut_desc_insertGloss2' },
                insertGloss3: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '3', descriptionKey: 'shortcut_desc_insertGloss3' },
                insertGloss4: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '4', descriptionKey: 'shortcut_desc_insertGloss4' },
                insertGloss5: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '5', descriptionKey: 'shortcut_desc_insertGloss5' },
                jumpToTime: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'j', descriptionKey: 'shortcut_desc_jumpToTime' },
                playSegment: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: ' ', descriptionKey: 'shortcut_desc_playSegment' },
                playPause: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '0', descriptionKey: 'shortcut_desc_playPause' },
                playSegmentLoop: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'l', descriptionKey: 'shortcut_desc_playSegmentLoop', loopCount: 3 },
                seekForward: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: true, key: 'arrowright', descriptionKey: 'shortcut_desc_seekForward' },
                seekBackward: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: true, key: 'arrowleft', descriptionKey: 'shortcut_desc_seekBackward' },
                seekForwardFast: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: true, key: 'arrowright', descriptionKey: 'shortcut_desc_seekForwardFast' },
                seekBackwardFast: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: true, key: 'arrowleft', descriptionKey: 'shortcut_desc_seekBackwardFast' },
                bold: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'b', descriptionKey: 'shortcut_desc_bold' },
                italic: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'i', descriptionKey: 'shortcut_desc_italic' },
        docResources: Array.from({ length: 5 }, () => ({ url: '', shortcut: null }))
            };

 // 2. Crea el perfil de Mac a partir del de Windows
            // Esta copia asegura que el perfil de Mac tenga todos los atajos definidos
            const macProfile = JSON.parse(JSON.stringify(windowsProfile));

            // 3. Carga los perfiles guardados si existen
            try {
                const savedProfiles = await db.settings.get('shortcutProfiles');
                shortcutProfiles.windows = savedProfiles?.value?.windows || windowsProfile;
                shortcutProfiles.mac = savedProfiles?.value?.mac || macProfile;
            } catch (e) {
                console.error("No se pudieron cargar los perfiles de atajos, usando valores por defecto.", e);
                shortcutProfiles.windows = windowsProfile;
                shortcutProfiles.mac = macProfile;
            }

            // 4. Carga y activa el perfil preferido del usuario
            activeProfile = localStorage.getItem('shortcutProfile') || (navigator.platform.toUpperCase().indexOf('MAC') >= 0 ? 'mac' : 'windows');
            shortcuts = { ...shortcutProfiles[activeProfile] };
        }
        
        restoreShortcutsBtn.addEventListener('click', async () => {
            shortcuts = JSON.parse(JSON.stringify(defaultShortcuts)); // Deep copy
            // Re-initialize docResources
            shortcuts.docResources = [];
            for (let i = 0; i < 5; i++) {
                shortcuts.docResources.push({ url: '', shortcut: null });
            }
            await saveShortcuts();
            renderShortcutsModal();
        });

        exportShortcutsBtn.addEventListener('click', () => {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(shortcuts, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "subpanda_shortcuts.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        });

        importShortcutsInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedShortcuts = JSON.parse(e.target.result);
                    if (typeof importedShortcuts === 'object' && importedShortcuts !== null) {
                        shortcuts = { ...defaultShortcuts, ...importedShortcuts };
                        await loadShortcuts(); // Re-run load to ensure docResources is validated
                        await saveShortcuts();
                        renderShortcutsModal();
                    } else {
                        throw new Error("Invalid format");
                    }
                } catch (err) {
                    showMessage(errorMessages[currentLanguage].shortcut_import_error);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        });

  setupPanel('findReplacePanel', 'findReplaceBtn', () => {
            findInput.focus();
        });
        

        findNextBtn.addEventListener('click', () => findAndNavigate(true));
        findPrevBtn.addEventListener('click', () => findAndNavigate(false));
        replaceBtn.addEventListener('click', replaceCurrentMatch);
        replaceAllBtn.addEventListener('click', replaceAllMatches);

        function findAndNavigate(forward = true) {
            const query = findInput.value;
            if (!query) {
                showMessage(errorMessages[currentLanguage]['no_find_query']);
                return;
            }

            findState.query = query;
            findState.caseSensitive = caseSensitiveCheckbox.checked;
            findState.useRegex = regexCheckbox.checked;

            let regex;
            try {
                regex = findState.useRegex ? new RegExp(findState.query, findState.caseSensitive ? '' : 'i') : null;
            } catch (e) {
                showMessage(`Error de expresi칩n regular: ${e.message}`);
                return;
            }

            let startEntryIndex = 0;
            let startMatchIndex = 0;

            if (findState.lastFound) {
                startEntryIndex = findState.lastFound.entryIndex;
                startMatchIndex = forward ? findState.lastFound.matchEnd : findState.lastFound.matchStart - 1;
            } else {
                if (!forward) {
                    startEntryIndex = srtEntries.length - 1;
                    startMatchIndex = Infinity;
                }
            }

            let found = false;
            let currentEntryIndex = startEntryIndex;
            const totalEntries = srtEntries.length;

            for (let i = 0; i < totalEntries; i++) {
                const entry = srtEntries[currentEntryIndex];
                const text = entry.translation;
                let match;

                if (findState.useRegex) {
                    regex.lastIndex = 0;
                    if (forward) {
                        let searchFrom = (currentEntryIndex === startEntryIndex) ? startMatchIndex : 0;
                        const subText = text.substring(searchFrom);
                        match = regex.exec(subText);
                        if (match) {
                            match.index += searchFrom;
                        }
                    } else {
                        let allMatches = [];
                        let tempRegex = new RegExp(regex.source, regex.flags.includes('g') ? regex.flags : regex.flags + 'g');
                        let tempMatch;
                        while((tempMatch = tempRegex.exec(text)) !== null) {
                            allMatches.push(tempMatch);
                        }
                        let searchUntil = (currentEntryIndex === startEntryIndex) ? startMatchIndex : text.length;
                        match = allMatches.reverse().find(m => m.index < searchUntil);
                    }
                } else {
                    const searchText = findState.caseSensitive ? text : text.toLowerCase();
                    const queryLower = findState.caseSensitive ? findState.query : findState.query.toLowerCase();

                    if (forward) {
                        let searchFrom = (currentEntryIndex === startEntryIndex) ? startMatchIndex : 0;
                        const foundIndex = searchText.indexOf(queryLower, searchFrom);
                        if (foundIndex !== -1) {
                            match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                        }
                    } else {
                        let searchUntil = (currentEntryIndex === startEntryIndex) ? startMatchIndex : text.length;
                        const foundIndex = searchText.lastIndexOf(queryLower, searchUntil);
                        if (foundIndex !== -1) {
                            match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                        }
                    }
                }

                if (match) {
                    findState.lastFound = {
                        entryIndex: currentEntryIndex,
                        matchStart: match.index,
                        matchEnd: match.index + match[0].length,
                    };
                    navigateToTranslation(currentEntryIndex);
                    const targetEditor = document.getElementById(`translation-${currentEntryIndex}`);
                    if (targetEditor) {
                        const range = document.createRange();
                        const sel = window.getSelection();
                        range.setStart(targetEditor.firstChild, findState.lastFound.matchStart);
                        range.setEnd(targetEditor.firstChild, findState.lastFound.matchEnd);
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                    found = true;
                    return;
                }

                currentEntryIndex = (currentEntryIndex + (forward ? 1 : -1) + totalEntries) % totalEntries;
            }

            if (!found) {
                showMessage(errorMessages[currentLanguage]['no_match_found']);
                findState.lastFound = null;
            }
        }


    function replaceCurrentMatch() {
            const replaceWith = replaceInput.value; // <-- L칈NEA A칌ADIDA: Ahora s칤 lee el texto de reemplazo

            if (!findState.lastFound || !findState.query) {
                showMessage(errorMessages[currentLanguage]['no_match_found']);
                return;
            }

            const { entryIndex, matchStart, matchEnd } = findState.lastFound;
            const entry = srtEntries[entryIndex];
            const targetEditor = document.getElementById(`translation-${entryIndex}`);

            if (!entry || !targetEditor) return; // Comprobaci칩n de seguridad

            let originalText = entry.translation;
            let replacedText;

            // Esta l칩gica ahora usa 'replaceWith' para construir el nuevo texto
            if (findState.useRegex) {
                const regex = new RegExp(findState.query, findState.caseSensitive ? '' : 'i');
                replacedText = originalText.substring(0, matchStart) +
                               originalText.substring(matchStart, matchEnd).replace(regex, replaceWith) +
                               originalText.substring(matchEnd);
            } else {
                replacedText = originalText.substring(0, matchStart) +
                               replaceWith +
                               originalText.substring(matchEnd);
            }

            // MEJORA: Actualizamos los datos y la interfaz directamente sin recargar toda la lista
            entry.translation = replacedText;
            targetEditor.innerHTML = replacedText;
            targetEditor.dispatchEvent(new Event('input', { bubbles: true })); // Esto recalcula las estad칤sticas (CPS, etc.)

            // Buscamos autom치ticamente la siguiente coincidencia
            findAndNavigate(true);
        }

        function replaceAllMatches() {
            const query = findInput.value;
            const replaceWith = replaceInput.value;
            if (!query) {
                showMessage(errorMessages[currentLanguage]['no_find_query']);
                return;
            }

            let replacedCount = 0;
            let regex;
            
            // 仇 CORRECCI칍N: Se ha arreglado la creaci칩n de la expresi칩n regular
            try {
                if (regexCheckbox.checked) {
                    // Si el usuario escribe una expresi칩n regular, la usamos tal cual
                    regex = new RegExp(query, (caseSensitiveCheckbox.checked ? 'g' : 'ig'));
                } else {
                    // Si es texto normal, escapamos caracteres especiales para que no den error
                    const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    regex = new RegExp(escapedQuery, (caseSensitiveCheckbox.checked ? 'g' : 'ig'));
                }
            } catch (e) {
                showMessage(`Error de expresi칩n regular: ${e.message}`);
                return;
            }

            srtEntries.forEach(entry => {
                let originalTranslation = entry.translation;
                
                // Contamos las coincidencias antes de reemplazar
                const matches = originalTranslation.match(regex);
                if (matches) {
                    replacedCount += matches.length;
                }

                // Realizamos el reemplazo
                const newTranslation = originalTranslation.replace(regex, replaceWith);

                if (originalTranslation !== newTranslation) {
                    entry.translation = newTranslation;
                }
            });

            if (replacedCount > 0) {
                // MEJORA: Actualizamos la interfaz de forma m치s eficiente
                const scrollPosition = document.getElementById('editorMainContent').scrollTop;
                const activeIndex = getCurrentFocusedIndex()?.entryIndex ?? 0;
                renderTranslations(srtEntries, activeIndex, true);
                document.getElementById('editorMainContent').scrollTop = scrollPosition;
                updateStatsDisplay();
                showMessage(translations[currentLanguage]['replacements_made'].replace('{0}', replacedCount));
            } else {
                showMessage(errorMessages[currentLanguage]['no_match_found']);
            }

            findState.lastFound = null;
        }

       function setLanguage(lang) {
    // --- INICIO DE LA L칍GICA A칌ADIDA ---
    // 1. Antes de cambiar el idioma, generamos el prompt por defecto del idioma ACTUAL (el viejo).
    const oldDefaultPrompt = translations[currentLanguage]['ai_default_instruction_1']
        .replace('{0}', qaSettings.charsPerLineLimit)
        .replace('{1}', qaSettings.cpsLimit);
    
    // 2. Comprobamos si el usuario est치 usando (o dej칩) el prompt por defecto sin modificar.
    const isUsingDefaultPrompt = (aiCustomInstructions.instruction1 === oldDefaultPrompt);
    // --- FIN DE LA PRIMERA PARTE ---

    currentLanguage = lang;
    
    langEsBtn.classList.toggle('active', lang === 'es');
    langEnBtn.classList.toggle('active', lang === 'en');

    // --- INICIO DE LA SEGUNDA PARTE ---
    // 3. Si estaba usando el prompt por defecto, lo actualizamos al del NUEVO idioma.
    if (isUsingDefaultPrompt) {
        const newDefaultPrompt = translations[currentLanguage]['ai_default_instruction_1']
            .replace('{0}', qaSettings.charsPerLineLimit)
            .replace('{1}', qaSettings.cpsLimit);
        aiCustomInstructions.instruction1 = newDefaultPrompt;
        saveAiCustomInstructions(); // Guardamos el cambio para que persista.
    }
    // --- FIN DE LA L칍GICA A칌ADIDA ---
    
    const t = translations[lang];
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (t[key]) el.textContent = t[key];
    });
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if (t[key]) el.placeholder = t[key];
    });

    document.querySelectorAll('[data-i18n-title]').forEach(el => {
        const key = el.getAttribute('data-i18n-title');
        if (t[key]) el.title = t[key];
    });
    
    if (srtEntries.length > 0) {
        const activeIndex = getCurrentFocusedIndex()?.entryIndex ?? lastActiveSubtitleIndex;
        renderTranslations(srtEntries, activeIndex, true);
    } else {
         const initialMessageElement = document.getElementById('initialMessage');
        if (initialMessageElement) initialMessageElement.textContent = t.no_translations;
    }
    renderGlossary();
    tmSearch();

    // --- INICIO DE LA CORRECCI칍N ---
    // Esta l칤nea fuerza la actualizaci칩n del panel de la IA con el nuevo idioma.
    // Comprueba si hay datos de contexto antes de intentar redibujar el panel.
    if (srtEntries.some(e => e.context)) {
        updateContextPanel(lastActiveSubtitleIndex);
    }
    // --- FIN DE LA CORRECCI칍N ---

// Actualizar t칤tulos de botones din치micamente
    document.getElementById('zoomOutBtn').title = t['zoom_out'];
    document.getElementById('zoomInBtn').title = t['zoom_in'];
    // Actualiza el t칤tulo del bot칩n de bloqueo seg칰n su estado actual
    lockWaveformBtn.title = isWaveformLocked ? t['unlock_waveform'] : t['lock_waveform'];
followPlaybackBtn.title = isFollowPlaybackActive ? t['follow_playback_off'] : t['follow_playback_on'];
}


        // --- Terminology Sidebar Logic ---
        function setupPanel(panelId, buttonId, openCallback) {
            const panel = document.getElementById(panelId);
            const button = document.getElementById(buttonId);
            const closeButton = panel.querySelector('button[id^="close"]');
            const resetButton = panel.querySelector('.reset-panel-btn');

            button.addEventListener('click', () => {
                openFloatingPanel(panel, button, openCallback);
            });

            closeButton.addEventListener('click', () => {
                closeFloatingPanel(panel, button);
            });
            
            resetButton.addEventListener('click', (e) => {
                e.stopPropagation();
                resetPanelPosition(panel);
            });
        }

        function populateIsoLanguagesDatalist() {
            isoLanguagesDatalist.innerHTML = '';
            isoLanguagesData.forEach(lang => {
                const option = document.createElement('option');
                option.value = lang.code;
                option.textContent = lang.name;
                isoLanguagesDatalist.appendChild(option);
            });
        }

        function resetGlossary() {
            glossary = [];
            glossarySourceLanguage = '';
            glossaryTargetLanguage = '';
            
            // Resetear valores de inputs
            if (configSrcLang) configSrcLang.value = 'en-US';
            if (configTgtLang) configTgtLang.value = 'es-ES';
            if (srcTermInput) srcTermInput.value = "";
            if (tgtTermInput) tgtTermInput.value = "";
            if (searchTermInput) searchTermInput.value = "";

            // FORZAR el cambio de vista: Mostrar configuraci칩n, Ocultar editor
            if (terminologyLanguageConfigSection && terminologyEditorSection) {
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyLanguageConfigSection.classList.remove('hidden'); // Asegurar visibilidad
                
                terminologyEditorSection.style.display = 'none';
                terminologyEditorSection.classList.add('hidden'); // Asegurar ocultamiento
            }
            renderGlossary();
        }

        function showLanguageConfigSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection) {
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }
        }

        function showGlossaryEditorSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection && displaySrcLang && displayTgtLang) {
                terminologyLanguageConfigSection.style.display = 'none';
                terminologyEditorSection.style.display = 'block';
                displaySrcLang.value = glossarySourceLanguage;
                displayTgtLang.value = glossaryTargetLanguage;
                renderGlossary();
            }
        }

        function confirmGlossaryLanguages() {
            const srcLang = configSrcLang ? configSrcLang.value.trim() : '';
            const tgtLang = configTgtLang ? configTgtLang.value.trim() : '';
            if (!srcLang || !tgtLang) {
                showMessage(errorMessages[currentLanguage]['lang_config_required']);
                return;
            }
            glossarySourceLanguage = srcLang;
            glossaryTargetLanguage = tgtLang;
            showGlossaryEditorSection();
            renderTranslations(srtEntries);
        }

        function addTerm() {
            const srcTerm = srcTermInput ? srcTermInput.value.trim() : '';
            const tgtTerm = tgtTermInput ? tgtTermInput.value.trim() : '';
            if (!srcTerm || !tgtTerm) {
                showMessage(errorMessages[currentLanguage]['both_terms_required']);
                return;
            }

            const t = translations[currentLanguage];

            if (editingTermIndex !== -1) {
                // --- MODO EDICI칍N ---
                // 1. Actualizar el t칠rmino existente
                glossary[editingTermIndex].srcTerm = srcTerm;
                glossary[editingTermIndex].tgtTerm = tgtTerm;

                // 2. Resetear el estado de edici칩n
                editingTermIndex = -1;

                // 3. Cambiar el bot칩n de nuevo a "A침adir"
                const addBtn = document.querySelector('button[onclick="addTerm()"]');
                addBtn.textContent = t.add_button;

            } else {
                // --- MODO A칌ADIR (L칩gica original) ---
                glossary.push({
                    srcLang: glossarySourceLanguage,
                    srcTerm: srcTerm,
                    tgtLang: glossaryTargetLanguage,
                    tgtTerm: tgtTerm
                });
            }

            // L칩gica de limpieza (com칰n para ambos modos)
            if (srcTermInput) srcTermInput.value = "";
            if (tgtTermInput) tgtTermInput.value = "";
            
            updateTranslations();
        }
        function editTerm(index) {
            const entry = glossary[index];
            if (!entry) return;

            // 1. Rellenar los campos de entrada
            srcTermInput.value = entry.srcTerm;
            tgtTermInput.value = entry.tgtTerm;

            // 2. Guardar el 칤ndice que estamos editando
            editingTermIndex = index;

            // 3. Cambiar el texto del bot칩n "A침adir" a "Guardar cambios"
            const addBtn = document.querySelector('button[onclick="addTerm()"]');
            const t = translations[currentLanguage];
            addBtn.textContent = t.save_changes_btn;

            // 4. (Opcional) Asegurarse de que el acorde칩n est칠 abierto y visible
            if (addTermContent.classList.contains('collapsed')) {
                addTermHeader.click(); // Simula un clic para abrirlo
            }
            // 5. (Opcional) Mover la vista al formulario de edici칩n
            addTermHeader.scrollIntoView({ behavior: 'smooth', block: 'center' });
            srcTermInput.focus();
        }
        function deleteTerm(index) {
            const t = translations[currentLanguage];
            // --- A칌ADIR ESTE BLOQUE ---
            if (index === editingTermIndex) {
                // Si eliminamos el t칠rmino que estamos editando, reseteamos el formulario
                editingTermIndex = -1;
                srcTermInput.value = "";
                tgtTermInput.value = "";
                const addBtn = document.querySelector('button[onclick="addTerm()"]');
                addBtn.textContent = translations[currentLanguage].add_button;
            } else if (index < editingTermIndex) {
                // Si eliminamos un t칠rmino anterior, el 칤ndice de edici칩n debe disminuir
                editingTermIndex--;
            }
            // --- FIN DEL BLOQUE A칌ADIDO ---
            glossary.splice(index, 1);
            // Llamamos a la nueva funci칩n, que ya se encarga de todo.
            updateTranslations();
        }
// --- A칌ADIR TODA ESTA NUEVA FUNCI칍N ---
        /**
         * Carga un t칠rmino existente en los campos de entrada para su edici칩n.
         * @param {number} index - El 칤ndice del t칠rmino en el array 'glossary'.
         */
        function editTerm(index) {
            const entry = glossary[index];
            if (!entry) return;

            // 1. Rellenar los campos de entrada
            srcTermInput.value = entry.srcTerm;
            tgtTermInput.value = entry.tgtTerm;

            // 2. Guardar el 칤ndice que estamos editando
            editingTermIndex = index;

            // 3. Cambiar el texto del bot칩n "A침adir" a "Guardar cambios"
            const addBtn = document.querySelector('button[onclick="addTerm()"]');
            const t = translations[currentLanguage];
            addBtn.textContent = t.save_changes_btn;

            // 4. (Opcional) Asegurarse de que el acorde칩n est칠 abierto y visible
            if (addTermContent.classList.contains('collapsed')) {
                addTermHeader.click(); // Simula un clic para abrirlo
            }
            // 5. (Opcional) Mover la vista al formulario de edici칩n
            addTermHeader.scrollIntoView({ behavior: 'smooth', block: 'center' });
            srcTermInput.focus();
        }
        // --- FIN DE LA NUEVA FUNCI칍N ---

        function deleteTerm(index) {
            // --- A칌ADIR ESTE BLOQUE ---
            if (index === editingTermIndex) {
                // Si eliminamos el t칠rmino que estamos editando, reseteamos el formulario
                editingTermIndex = -1;
                srcTermInput.value = "";
                tgtTermInput.value = "";
                const addBtn = document.querySelector('button[onclick="addTerm()"]');
                addBtn.textContent = translations[currentLanguage].add_button;
            } else if (index < editingTermIndex) {
                // Si eliminamos un t칠rmino anterior, el 칤ndice de edici칩n debe disminuir
                editingTermIndex--;
            }
            // --- FIN DEL BLOQUE A칌ADIDO ---
    glossary.splice(index, 1);
    // Llamamos a la nueva funci칩n, que ya se encarga de todo.
    updateTranslations();
}

        function renderGlossary() {
            if (!glossaryTableBody) return;
            const search = searchTermInput ? searchTermInput.value.toLowerCase() : '';
            glossaryTableBody.innerHTML = "";
            const t = translations[currentLanguage];
            const filteredGlossary = glossary.filter(entry =>
                (entry.srcTerm && entry.srcTerm.toLowerCase().includes(search)) ||
                (entry.tgtTerm && entry.tgtTerm.toLowerCase().includes(search))
            );
            const highlightedTerms = [];
            const otherTerms = [];
            filteredGlossary.forEach(entry => {
                if (entry.srcTerm && termsFoundInActiveSegment.has(entry.srcTerm)) {
                    highlightedTerms.push(entry);
                } else {
                    otherTerms.push(entry);
                }
            });
            currentGlossaryLatestResults = [...highlightedTerms, ...otherTerms.sort((a, b) => a.srcTerm.localeCompare(b.srcTerm))];
            
            const renderRow = (entry) => {
                 const row = document.createElement("tr");
                if (highlightedTerms.includes(entry)) {
                    row.classList.add('glossary-row-highlight');
                }
                const originalIndex = glossary.indexOf(entry);
                row.innerHTML = `
                    <td>${entry.srcTerm}</td>
                    <td>${entry.tgtTerm}</td>
                    <td class="flex gap-1">
                        <button class="btn btn-secondary text-xs" onclick="editTerm(${originalIndex})" data-i18n="edit_button">${t.edit_button}</button>
                        <button class="btn btn-destructive text-xs" onclick="deleteTerm(${originalIndex})" data-i18n="delete_button">${t.delete_button}</button>
                    </td>
                `;
                glossaryTableBody.appendChild(row);
            };

            currentGlossaryLatestResults.forEach(renderRow);
        }

// --- FUNCIONES DE EXPORTACI칍N TMX (RECUPERANDO LA VERSI칍N OLD COMPATIBLE TAO) ---

/**
 * Funci칩n auxiliar para escapar caracteres especiales para el formato XML/TMX.
 * Esto asegura que el TMX sea v치lido y convierte los saltos de l칤nea a <br/>.
 * @param {string} text El texto a sanear.
 * @returns {string} El texto saneado.
 */
function sanitizeForXML(text) {
    if (!text) return '';
    
    // 1. Normalizaci칩n de saltos de l칤nea de contenido editable a <br/>
    text = text.replace(/<\/div>\s*<div>/gi, '<br/>'); // Divs internos a <br/>
    text = text.replace(/<div[^>]*>/gi, '').replace(/<\/div>/gi, ''); // Eliminar divs restantes
    text = text.replace(/<br\s*\/?>/gi, '<br/>'); // Br a <br/>
    text = text.replace(/<[^>]+>/g, ''); // Eliminar otras etiquetas HTML
    text = text.trim();
    
    // 2. Escapar caracteres XML est치ndar
    return text.replace(/&/g, '&amp;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;')
               .replace(/"/g, '&quot;')
               .replace(/'/g, '&apos;');
}


/**
 * Exporta la Memoria de Traducci칩n (TM) al formato TMX 1.4 compatible.
 */
function exportTMX() {
    // Nota: Asume la existencia de las variables globales 'translationMemory', 'sourceLang', 'targetLang', 'fileNameInput', 'errorMessages' y 'translations'.
    
    if (!translationMemory || translationMemory.length === 0) {
        showMessage(errorMessages[currentLanguage]['no_tm_to_save'] || "No hay Memoria de Traducci칩n para guardar.");
        return;
    }
    
    const srcLangCode = sourceLang || 'en-US';
    const tgtLangCode = targetLang || 'es-ES';

    // 1. Construir el Encabezado TMX
    const tmxHeader = `<?xml version="1.0" encoding="UTF-8"?>
<tmx version="1.4">
  <header datatype="plaintext" segtype="sentence"
    adminlang="en-us" srclang="${srcLangCode}"
    o-tmf="none" creationtool="subpandaTM" creationtoolversion="1.0">
  </header>
  <body>`;
    
    // 2. Construir el Cuerpo TMX (Unidades de Traducci칩n)
    const tmxBody = translationMemory.map(entry => {
        // Usar sanitizeForXML para limpiar y escapar el texto, convirtiendo saltos de l칤nea a <br/>
        let sourceText = sanitizeForXML(entry.source); 
        let targetText = sanitizeForXML(entry.target); 

        return `    <tu>
      <tuv xml:lang="${srcLangCode}">
        <seg>${sourceText}</seg>
      </tuv>
      <tuv xml:lang="${tgtLangCode}">
        <seg>${targetText}</seg>
      </tuv>
    </tu>`;
    }).join('\n');

    // 3. Construir el Pie de P치gina TMX
    const tmxFooter = `
  </body>
</tmx>`;
    
    const tmxContent = tmxHeader + tmxBody + tmxFooter;

    // 4. L칩gica para guardar el archivo
    const baseFilename = (fileNameInput.value.trim() || 'TranslationMemory'); 
    const filename = baseFilename.endsWith('.tmx') ? baseFilename : baseFilename + '.tmx';

    try {
        const blob = new Blob([tmxContent], { type: 'text/xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", url);
        downloadAnchorNode.setAttribute("download", filename);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        document.body.removeChild(downloadAnchorNode);
        URL.revokeObjectURL(url);
        
        showMessage(translations[currentLanguage]['file_saved_successfully_tmx'] || "Archivo TMX guardado correctamente.");
    } catch (error) {
        showMessage(errorMessages[currentLanguage]['error_saving_file'] || `Error al guardar el archivo: ${error.message}`);
        console.error("Error saving TMX file:", error);
    }
}

// --- FIN: FUNCIONES DE EXPORTACI칍N TMX ---

        function generateTBX() {
            const xml = [`<?xml version="1.0" encoding="UTF-8"?><martif type="TBX" xml:lang="${glossarySourceLanguage}"><text><body>`];
            glossary.forEach(entry => {
                xml.push(`<termEntry><LangSet xml:lang="${entry.srcLang}"><tig><term>${entry.srcTerm}</term></tig></LangSet><LangSet xml:lang="${entry.tgtLang}"><tig><term>${entry.tgtTerm}</term></tig></LangSet></termEntry>`);
            });
            xml.push(`</body></text></martif>`);
            return xml.join("\n");
        }

        /**
         * Opens a modal to ask for a filename before downloading the TBX file.
         */
        function downloadTBX() {
            if (glossary.length === 0 && (!glossarySourceLanguage || !glossaryTargetLanguage)) {
                showMessage(errorMessages[currentLanguage]['cannot_download_empty_or_unconfigured_glossary']);
                return;
            }
            fileNameInputTbx.value = 'glossary.tbx';
            saveTbxModal.classList.remove('hidden');
            fileNameInputTbx.focus();
        }

        function loadTBX() {
            if (!tbxFileInput) return;
            tbxFileInput.click();
            tbxFileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                showLoadingOverlay(errorMessages[currentLanguage]['loading_file']);
                try {
                    const reader = new FileReader();
                    await new Promise((resolve, reject) => {
                        reader.onload = () => {
                            try {
                                const parser = new DOMParser();
                                const xmlDoc = parser.parseFromString(reader.result, "application/xml");
                                if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                                    throw new Error("Invalid XML/TBX format: " + xmlDoc.getElementsByTagName("parsererror")[0].textContent);
                                }
                                if (xmlDoc.getElementsByTagName("tu").length > 0) {
                                    showTMInternalMessage(errorMessages[currentLanguage]['tbx_file_expected_tmx_found'], true);
                                    reject(new Error("Attempted to load TMX into Glossary."));
                                    return;
                                }
                                const entries = xmlDoc.getElementsByTagName("termEntry");
                                glossary = [];
                                let firstEntryLangs = { src: '', tgt: '' };
                                if (entries.length > 0) {
                                    const firstSets = entries[0].getElementsByTagName("LangSet");
                                    if (firstSets.length >= 2) {
                                        firstEntryLangs.src = firstSets[0].getAttribute("xml:lang");
                                        firstEntryLangs.tgt = firstSets[1].getAttribute("xml:lang");
                                    }
                                }
                                for (let entry of entries) {
                                    const sets = entry.getElementsByTagName("LangSet");
                                    if (sets.length >= 2) {
                                        const lang1 = sets[0].getAttribute("xml:lang");
                                        const term1 = sets[0].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                                        const lang2 = sets[1].getAttribute("xml:lang");
                                        const term2 = sets[1].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                                        glossary.push({ srcLang: lang1, srcTerm: term1, tgtLang: lang2, tgtTerm: term2 });
                                    }
                                }
                                if (glossary.length > 0 && firstEntryLangs.src && firstEntryLangs.tgt) {
                                    glossarySourceLanguage = firstEntryLangs.src;
                                    glossaryTargetLanguage = firstEntryLangs.tgt;
                                } else if (glossary.length === 0) {
                                    showMessage(errorMessages[currentLanguage]['error_loading_tbx_file']);
                                }
                                showGlossaryEditorSection();
                                updateTranslations();
                                resolve();
                            } catch (error) {
                                reject(error);
                            }
                        };
                        reader.onerror = reject;
                        reader.readAsText(file);
                    });
                } catch (error) {
                    console.error("Error loading TBX file:", error);
                    if (!error.message.includes("Attempted to load TMX")) {
                        showMessage(errorMessages[currentLanguage]['error_loading_tbx_file']);
                    }
                    resetGlossary();
                } finally {
                    hideLoadingOverlay();
                }
            };
        }

        // --- Translation Memory (TM) Logic ---
        function levenshteinDistance(a, b) {
            const an = a.length, bn = b.length;
            if (an === 0) return bn;
            if (bn === 0) return an;
            const matrix = Array(bn + 1).fill(null).map(() => Array(an + 1).fill(null));
            for (let i = 0; i <= an; i++) matrix[0][i] = i;
            for (let i = 0; i <= bn; i++) matrix[i][0] = i;
            for (let i = 1; i <= bn; i++) {
                for (let j = 1; j <= an; j++) {
                    const cost = a[j - 1] === b[i - 1] ? 0 : 1;
                    matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + cost);
                }
            }
            return matrix[bn][an];
        }

        function calculateSimilarity(s1, s2) {
            if (!s1 || !s2) return 0;
            const longerLength = Math.max(s1.length, s2.length);
            if (longerLength === 0) return 100;
            const distance = levenshteinDistance(s1, s2);
            return ((longerLength - distance) / longerLength) * 100;
        }
        
        function renderDiff(tmText, originalText) {
            const dmp = new diff_match_patch();
            const diffs = dmp.diff_main(tmText, originalText);
            dmp.diff_cleanupSemantic(diffs);

            return diffs.map(([op, text]) => {
                const safeText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '&para;<br>');
                switch (op) {
                    case DIFF_INSERT: return `<span class="diff-insertion">${safeText}</span>`;
                    case DIFF_DELETE: return `<span class="diff-deletion">${safeText}</span>`;
                    case DIFF_EQUAL: return safeText;
                }
            }).join('');
        }

        function showTMInternalMessage(msg, isError = false) {
            if (tmInternalMessage) {
                tmInternalMessage.textContent = msg;
                tmInternalMessage.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'border-red-500', 'bg-blue-100', 'text-blue-800', 'border-blue-500');
                tmInternalMessage.classList.add(isError ? 'bg-red-100' : 'bg-blue-100', isError ? 'text-red-800' : 'text-blue-800', isError ? 'border-red-500' : 'border-blue-500');
                tmInternalMessage.classList.remove('hidden');
            }
        }

        function hideTMInternalMessage() {
            if (tmInternalMessage) {
                tmInternalMessage.classList.add('hidden');
                tmInternalMessage.textContent = '';
            }
        }

        function resetTM() {
            translationMemory = [];
            tmSourceLanguage = ''; // Asegurar que se borra el idioma detectado
            tmTargetLanguage = '';
            
            if (tmSearchInput) tmSearchInput.value = '';
            renderTMSearchResults([]);
            
            // FORZAR el cambio de vista: Mostrar configuraci칩n, Ocultar editor
            if (tmLanguageConfigSection && tmEditorSection) {
                tmLanguageConfigSection.style.display = 'block';
                tmLanguageConfigSection.classList.remove('hidden');

                tmEditorSection.style.display = 'none';
                tmEditorSection.classList.add('hidden');
                
                if (tmConfigSrcLang) tmConfigSrcLang.value = 'en-US';
                if (tmConfigTgtLang) tmConfigTgtLang.value = 'es-ES';
                hideTMInternalMessage();
            }
        }

        function showTMLanguageConfigSection() {
            if (tmLanguageConfigSection && tmEditorSection) {
                tmLanguageConfigSection.style.display = 'block';
                tmEditorSection.style.display = 'none';
                if (tmConfigSrcLang) tmConfigSrcLang.value = 'en-US';
                if (tmConfigTgtLang) tmConfigTgtLang.value = 'es-ES';
                hideTMInternalMessage();
            }
        }

        function showTMEditorSection() {
            if (tmLanguageConfigSection && tmEditorSection && displayTmSrcLang && displayTmTgtLang) {
                tmLanguageConfigSection.style.display = 'none';
                tmEditorSection.style.display = 'block';
                displayTmSrcLang.value = tmSourceLanguage;
                displayTmTgtLang.value = tmTargetLanguage;
                tmSearch();
                hideTMInternalMessage();
            }
        }

        function confirmTMLanguages() {
            const srcLang = tmConfigSrcLang ? tmConfigSrcLang.value.trim() : '';
            const tgtLang = tmConfigTgtLang ? tmConfigTgtLang.value.trim() : '';
            if (!srcLang || !tgtLang) {
                showTMInternalMessage(errorMessages[currentLanguage]['lang_config_required'], true);
                return;
            }
            tmSourceLanguage = srcLang;
            tmTargetLanguage = tgtLang;
            showTMEditorSection();
        }

        
async function loadTMX(file) {
            showLoadingOverlay(errorMessages[currentLanguage]['loading_file']);
            hideTMInternalMessage();

            // Helper function to unescape XML special characters back to HTML.
            const unescapeXml = (safe) => {
                if (typeof safe !== 'string') return '';
                // The order matters for correctness
                return safe.replace(/&lt;/g, '<')
                           .replace(/&gt;/g, '>')
                           .replace(/&apos;/g, '\'')
                           .replace(/&quot;/g, '"')
                           .replace(/&amp;/g, '&');
            };

            try {
                const reader = new FileReader();
                await new Promise((resolve, reject) => {
                    reader.onload = () => {
                        try {
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(reader.result, "application/xml");
                            const parserError = xmlDoc.getElementsByTagName("parsererror");

                            if (parserError.length > 0) {
                                console.error("Parser Error:", parserError[0].textContent);
                                throw new Error("The file contains invalid XML and could not be parsed.");
                            }
                            
                            if (xmlDoc.getElementsByTagName("termEntry").length > 0) {
                                showTMInternalMessage(errorMessages[currentLanguage]['tmx_file_expected_tbx_found'], true);
                                reject(new Error("Attempted to load TBX into Translation Memory."));
                                return;
                            }
                            
                            const tuElements = xmlDoc.getElementsByTagName("tu");
                            let newTM = [];
                            
                            const header = xmlDoc.getElementsByTagName("header")[0];
                            let detectedSrcLang = header ? header.getAttribute('srclang') : '';
                            let detectedTgtLang = ''; // Target language is not a standard header attribute

                            for (let tu of tuElements) {
                                const tuvElements = tu.getElementsByTagName("tuv");
                                if (tuvElements.length >= 2) {
                                    const srcTuv = tuvElements[0], tgtTuv = tuvElements[1];
                                    const srcLang = srcTuv.getAttribute("xml:lang"), tgtLang = tgtTuv.getAttribute("xml:lang");
                                    
                                    const srcSeg = srcTuv.getElementsByTagName("seg")[0]?.textContent || '';
                                    const tgtSeg = tgtTuv.getElementsByTagName("seg")[0]?.textContent || '';

                                    const unescapedSrcText = unescapeXml(srcSeg);
                                    const unescapedTgtText = unescapeXml(tgtSeg);

                                    newTM.push({
                                        srcLang,
                                        srcText: unescapedSrcText,
                                        tgtLang,
                                        tgtText: unescapedTgtText,
                                        srcWordCount: countWords(unescapedSrcText),
                                        tgtWordCount: countWords(unescapedTgtText)
                                    });
                                    
                                    if (!detectedSrcLang) detectedSrcLang = srcLang;
                                    if (!detectedTgtLang) detectedTgtLang = tgtLang;
                                }
                            }
                            
                            translationMemory = newTM;
                            tmSourceLanguage = detectedSrcLang || (tmConfigSrcLang ? tmConfigSrcLang.value : 'en-US');
                            tmTargetLanguage = detectedTgtLang || (tmConfigTgtLang ? tmConfigTgtLang.value : 'es-ES');
                            
                            showTMInternalMessage(`TMX loaded successfully with ${translationMemory.length} translation units.`);
                            showTMEditorSection();
                            tmSearch();
                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            } catch (error) {
                console.error("Error loading TMX file:", error);
                if (!error.message.includes("Attempted to load TBX")) {
                    showTMInternalMessage(`${errorMessages[currentLanguage]['error_loading_tmx_file']} - ${error.message}`, true);
                }
                resetTM();
            } finally {
                hideLoadingOverlay();
            }
        }



function generateTMX() {
            if (translationMemory.length === 0) {
                showTMInternalMessage(errorMessages[currentLanguage]['cannot_download_empty_tm'], true);
                return null;
            }

            // Helper function to escape characters that are special in XML.
            const escapeXml = (unsafe) => {
                if (typeof unsafe !== 'string') return '';
                return unsafe.replace(/[<>&'"]/g, (c) => {
                    switch (c) {
                        case '<': return '&lt;';
                        case '>': return '&gt;';
                        case '&': return '&amp;';
                        case '\'': return '&apos;';
                        case '"': return '&quot;';
                    }
                });
            };
            
            // Generate a UTC timestamp as required by the TMX standard for creationdate
            const creationDate = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');

            // A more compliant TMX header
            const header = `<?xml version="1.0" encoding="UTF-8"?>\n<tmx version="1.4">\n  <header\n    creationtool="subpandaTM"\n    creationtoolversion="1.0"\n    segtype="sentence"\n    o-tmf="subpandaTM"\n    adminlang="en-US"\n    srclang="${escapeXml(tmSourceLanguage || 'en-US')}"\n    datatype="unknown"\n    creationdate="${creationDate}"\n  >\n  </header>\n  <body>`;
            
            const xml = [header];
            
            translationMemory.forEach(entry => {
                const safeSrcText = escapeXml(entry.srcText);
                const safeTgtText = escapeXml(entry.tgtText);
                
                // Using template literals for better readability and ensuring no extra whitespace
                const tu = `    <tu creationdate="${creationDate}">\n      <tuv xml:lang="${escapeXml(entry.srcLang)}">\n        <seg>${safeSrcText}</seg>\n      </tuv>\n      <tuv xml:lang="${escapeXml(entry.tgtLang)}">\n        <seg>${safeTgtText}</seg>\n      </tuv>\n    </tu>`;
                xml.push(tu);
            });

            xml.push(`  </body>\n</tmx>`);
            // The .join('\n') ensures proper line breaks for readability
            return xml.join('\n');
        }
        /**
         * Opens a modal to ask for a filename before downloading the TMX file.
         */
        function downloadTMX() {
            if (translationMemory.length === 0) {
                showMessage(errorMessages[currentLanguage]['cannot_download_empty_tm']);
                return;
            }
            fileNameInputTmx.value = 'translation_memory.tmx';
            saveTmxModal.classList.remove('hidden');
            fileNameInputTmx.focus();
        }

        function addOrUpdateTMEntry(original, translation) {
            if (!original || !translation || !tmSourceLanguage || !tmTargetLanguage) return;
            const existingIndex = translationMemory.findIndex(e => e.srcText === original && e.srcLang === tmSourceLanguage && e.tgtLang === tmTargetLanguage);
            if (existingIndex !== -1) {
                translationMemory[existingIndex].tgtText = translation;
                translationMemory[existingIndex].tgtWordCount = countWords(translation);
            } else {
                translationMemory.push({ srcLang: tmSourceLanguage, srcText: original, tgtLang: tmTargetLanguage, tgtText: translation, srcWordCount: countWords(original), tgtWordCount: countWords(translation) });
            }
            tmSearch();
        }

        function findBestTMMatch(sourceSegmentText) {
            if (translationMemory.length === 0 || !sourceSegmentText.trim() || !tmSourceLanguage || !tmTargetLanguage) return null;
            let bestMatch = null, highestScore = 0;
            const MIN_FUZZY_THRESHOLD = 70;
            translationMemory.forEach(entry => {
                if (entry.srcLang === tmSourceLanguage && entry.tgtLang === tmTargetLanguage && entry.srcText.trim()) {
                    const score = calculateSimilarity(sourceSegmentText, entry.srcText);
                    if (score >= MIN_FUZZY_THRESHOLD && score > highestScore) {
                        highestScore = score;
                        bestMatch = { ...entry, score: score.toFixed(0) };
                    }
                }
            });
            return bestMatch;
        }

        function tmSearch(activeSegmentOriginalText = null) {
            const query = tmSearchInput ? tmSearchInput.value.toLowerCase().trim() : '';
            if (!activeSegmentOriginalText) {
                const currentFocused = getCurrentFocusedIndex();
                if (currentFocused && srtEntries[currentFocused.entryIndex]) {
                    activeSegmentOriginalText = srtEntries[currentFocused.entryIndex].original;
                }
            }

            const filteredTM = translationMemory.filter(entry => {
                if (query) {
                    return (entry.srcText && entry.srcText.toLowerCase().includes(query)) || (entry.tgtText && entry.tgtText.toLowerCase().includes(query));
                }
                return true;
            });

            let resultsToRender = filteredTM.map(entry => {
                let score = 0;
                let diffHtml = entry.srcText;
                if (activeSegmentOriginalText) {
                    score = calculateSimilarity(activeSegmentOriginalText, entry.srcText);
                    diffHtml = renderDiff(entry.srcText, activeSegmentOriginalText);
                } else if (query) {
                    score = calculateSimilarity(query, entry.srcText);
                }
                return { ...entry, score: score.toFixed(0), diffHtml: diffHtml };
            });

            resultsToRender.sort((a, b) => b.score - a.score);

            const MIN_FUZZY_THRESHOLD = 70;
            resultsToRender.forEach((result, index) => {
                result.isBestMatch = index === 0 && result.score >= MIN_FUZZY_THRESHOLD;
            });

            currentTMLatestSearchResults = resultsToRender;
            renderTMSearchResults(resultsToRender);
        }

        function renderTMSearchResults(results) {
            if (!tmSearchResultsTableBody) return;
            const t = translations[currentLanguage];
            tmSearchResultsTableBody.innerHTML = '';
            if (results.length === 0) {
                if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.remove('hidden');
                return;
            } 
            if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.add('hidden');
            
            hideTMInternalMessage();
            results.forEach(entry => {
                const row = document.createElement('tr');
                if (entry.isBestMatch) row.classList.add('tm-best-match-highlight');
                
                const originalContent = (entry.diffHtml || entry.srcText).replace(/\n/g, '<br>');
                const translationContent = entry.tgtText.replace(/\n/g, '<br>');

                row.innerHTML = `<td>${entry.score}%</td><td class="align-top">${originalContent}</td><td class="align-top">${translationContent}</td>`;
                
                row.addEventListener('click', () => {
                    const currentFocused = getCurrentFocusedIndex();
                    if (currentFocused) {
                        const targetEditor = document.getElementById(`translation-${currentFocused.entryIndex}`);
                        if (targetEditor && targetEditor.contentEditable === 'true') {
                            targetEditor.innerHTML = entry.tgtText;
                            const event = new Event('input', { bubbles: true });
                            targetEditor.dispatchEvent(event);
                        }
                    }
                });
                tmSearchResultsTableBody.appendChild(row);
            });
        }

        function showLoadingOverlay(message) {
            if (loadingMessage && loadingOverlay) {
                loadingMessage.textContent = message;
                loadingOverlay.classList.remove('hidden');
            }
        }

        function hideLoadingOverlay() {
            if (loadingOverlay) {
                loadingOverlay.classList.add('hidden');
            }
        }

        if (dropArea) {
            dropArea.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.add('border-blue-500');
            });
            dropArea.addEventListener('dragleave', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-blue-500');
            });
            dropArea.addEventListener('drop', async (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-blue-500');
                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    const fileToProcess = Array.from(files).find(file => file.name.toLowerCase().endsWith('.srt') || file.name.toLowerCase().endsWith('.subpanda'));
                    if (fileToProcess.name.toLowerCase().endsWith('.srt')) {
                        await processFile(fileToProcess);
                    } else if (fileToProcess.name.toLowerCase().endsWith('.subpanda')) {
                        await loadProject({ target: { files: [fileToProcess] } });
                    } else {
                         showMessage('Por favor, suelta un archivo .srt o .subpanda v치lido.');
                    }
                }
            });
        }

        if (addTermHeader && addTermContent && addTermAccordionIcon) {
            addTermHeader.addEventListener('click', () => {
                const isCollapsed = addTermContent.classList.contains('collapsed');
                if (isCollapsed) {
                    addTermContent.classList.remove('collapsed');
                    addTermContent.classList.add('expanded');
                    addTermAccordionIcon.classList.remove('rotated');
                } else {
                    addTermContent.classList.remove('expanded');
                    addTermContent.classList.add('collapsed');
                    addTermAccordionIcon.classList.add('rotated');
                }
            });
        }

        if (statsAccordionHeader && statsAccordionContent && statsAccordionIcon) {
            statsAccordionHeader.addEventListener('click', () => {
                const isCollapsed = statsAccordionContent.classList.contains('collapsed');
                if (isCollapsed) {
                    statsAccordionContent.classList.remove('collapsed');
                    statsAccordionContent.classList.add('expanded');
                    statsAccordionIcon.classList.remove('rotated');
                } else {
                    statsAccordionContent.classList.remove('expanded');
                    statsAccordionContent.classList.add('collapsed');
                    statsAccordionIcon.classList.add('rotated');
                }
            });
        }

        videoFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                videoFileName = file.name; // Store video file name
                const videoURL = URL.createObjectURL(file);
                videoPlayer.src = videoURL;
                wavesurfer.load(videoURL);
                document.getElementById('waveform').classList.remove('hidden');
                videoPlayer.controls = true;
                videoPlayer.load();
                     
                document.getElementById('videoLogoPlaceholder').classList.add('hidden');
        
                const loadVideoBtnSpan = document.querySelector('#loadVideoBtn span');
                if (loadVideoBtnSpan) {
                    loadVideoBtnSpan.textContent = translations[currentLanguage]['change_video'];
                }
            } else {
                showMessage(errorMessages[currentLanguage]['video_load_error']);
            }
        });

        /**
         * Jumps the video player to the start time of the specified subtitle and plays until the end time.
         * @param {number} entryIndex The index of the SRT entry to play.
         */
        function jumpToCurrentSubtitleTime(entryIndex) {
            if (srtEntries[entryIndex] && videoPlayer.src) {
                const entry = srtEntries[entryIndex];
                // CORRECCI칍N: Quitamos el "- 200". Ahora se detiene justo al final.
                const stopTime = entry.endTimeMs / 1000; 
                videoPlayer.currentTime = entry.startTimeMs / 1000;
                videoPlayer.play();

                if (timeUpdateListener) {
                    videoPlayer.removeEventListener('timeupdate', timeUpdateListener);
                }

                timeUpdateListener = () => {
                    // CORRECCI칍N: El listener ahora tambi칠n se detiene si el v칤deo se pausa
                    // por cualquier otro motivo (ej. el usuario le da a la pausa).
                    if (videoPlayer.currentTime >= stopTime || videoPlayer.paused) {
                        videoPlayer.pause(); // Pausa
                        videoPlayer.removeEventListener('timeupdate', timeUpdateListener);
                        timeUpdateListener = null;
                    }
                };
                
                videoPlayer.addEventListener('timeupdate', timeUpdateListener);

// Centra la vista de la onda en la regi칩n (A칌ADIDO)
                 if (wsRegions) {
                     const region = wsRegions.getRegions().find(r => r.id === entry.regionId);
                     if (region) {
                         // Centrar la regi칩n en la vista de la onda
                         const duration = wavesurfer.getDuration();
                         const regionCenter = (region.start + region.end) / 2;
                         // Opcional: un peque침o zoom si es necesario
                         // wavesurfer.zoom(Number(document.getElementById('zoom-slider')?.value || 100));
         }
                 }
             }
        } // Fin de jumpToCurrentSubtitleTime
       
/**
 * Gestiona el resaltado y scroll autom치tico durante la reproducci칩n si el seguimiento est치 activo.
 */
function handlePlaybackTracking() {
    if (!isFollowPlaybackActive || !videoPlayer.src || srtEntries.length === 0 || !wsRegions) {
        // Si la funci칩n est치 desactivada o no hay nada que seguir, limpiamos resaltados
        clearPlaybackHighlights();
        return;
    }

    const currentTime = videoPlayer.currentTime;
    let activeEntryIndex = -1;
    let activeEntry = null;

    // Encuentra el subt칤tulo activo (igual que en updateSubtitlePreview)
    for (let i = 0; i < srtEntries.length; i++) {
        const entry = srtEntries[i];
        const startTime = entry.startTimeMs / 1000;
        const endTime = entry.endTimeMs / 1000;
        if (currentTime >= startTime && currentTime < endTime) { // Usamos < endTime para evitar solapamientos
            activeEntryIndex = i;
            activeEntry = entry;
            break;
        }
    }

    // Si NO encontramos un subt칤tulo activo
    if (activeEntryIndex === -1) {
        clearPlaybackHighlights();
        currentlyTrackedRegionId = null;
        currentlyTrackedEditorIndex = -1;
// --- INICIO C칍DIGO A칌ADIDO ---
        // Limpiar la clase activa si no hay ning칰n subt칤tulo en reproducci칩n
        if (lastFocusedEditorUnitIndex !== -1) {
            const prevUnit = document.getElementById(`translation-unit-${lastFocusedEditorUnitIndex}`);
            if (prevUnit) prevUnit.classList.remove('translation-unit-active');
            lastFocusedEditorUnitIndex = -1;
        }
        // --- FIN C칍DIGO A칌ADIDO ---
        return;
    }

    // Si el subt칤tulo activo es el MISMO que ya est치bamos siguiendo, no hacemos nada m치s
    if (currentlyTrackedEditorIndex === activeEntryIndex) {
        return;
    }

    // --- HEMOS ENCONTRADO UN NUEVO SUBT칈TULO ACTIVO ---

    // 1. Limpia los resaltados anteriores
    clearPlaybackHighlights();

    // 2. Resalta la nueva regi칩n en la onda
    const activeRegion = wsRegions.getRegions().find(r => r.id === activeEntry.regionId);
    if (activeRegion && activeRegion.element) {
        activeRegion.element.classList.add('region-playback-active');
        currentlyTrackedRegionId = activeEntry.regionId; // Guarda el ID actual
    }

    // 3. Haz scroll y activa el foco en el editor
        const editorUnit = document.getElementById(`translation-unit-${activeEntryIndex}`);
        if (editorUnit) {
            // --- INICIO C칍DIGO A칌ADIDO ---
            // Busca el div editable DENTRO de la unidad del subt칤tulo
            const editorDiv = editorUnit.querySelector(`div[contenteditable="true"][data-entry-index="${activeEntryIndex}"]`);
            // --- FIN C칍DIGO A칌ADIDO ---

            // Solo hacemos scroll si el elemento no est치 ya visible en el centro
            const rect = editorUnit.getBoundingClientRect();
            // CORRECCI칍N: Aseg칰rate de que parentElement.parentElement existe
            const parentContainer = document.getElementById('editorMainContent'); // Usar ID es m치s seguro
            const parentRect = parentContainer ? parentContainer.getBoundingClientRect() : null;
            const isVisible = parentRect && rect.top >= parentRect.top && rect.bottom <= parentRect.bottom;


            if (!isVisible) {
                 editorUnit.scrollIntoView({ behavior: 'smooth', block: 'center' });
                 // --- C칍DIGO A칌ADIDO (Focus despu칠s del scroll) ---
                 // A침adimos un peque침o retardo para asegurar que el scroll ha terminado
                 // antes de intentar poner el foco, especialmente con 'smooth' scroll.
                 if (editorDiv) {
// --- INICIO C칍DIGO A칌ADIDO ---
                // Limpiar la clase del anterior subt칤tulo con foco si existe
                if (lastFocusedEditorUnitIndex !== -1 && lastFocusedEditorUnitIndex !== activeEntryIndex) {
                    const prevUnit = document.getElementById(`translation-unit-${lastFocusedEditorUnitIndex}`);
                    if (prevUnit) prevUnit.classList.remove('translation-unit-active');
                }
                // A침adir la clase al actual
                if (editorUnit) editorUnit.classList.add('translation-unit-active');
                lastFocusedEditorUnitIndex = activeEntryIndex; // Actualizar
                // --- FIN C칍DIGO A칌ADIDO ---
                    setTimeout(() => editorDiv.focus(), 300); // 300ms de retardo
                 }
                 // --- FIN C칍DIGO A칌ADIDO ---
            } else {
                // --- C칍DIGO A칌ADIDO (Focus si ya es visible) ---
                 // Si ya estaba visible, ponemos el foco directamente
                 if (editorDiv && document.activeElement !== editorDiv) {
// --- INICIO C칍DIGO A칌ADIDO ---
                // Limpiar la clase del anterior subt칤tulo con foco si existe
                if (lastFocusedEditorUnitIndex !== -1 && lastFocusedEditorUnitIndex !== activeEntryIndex) {
                    const prevUnit = document.getElementById(`translation-unit-${lastFocusedEditorUnitIndex}`);
                    if (prevUnit) prevUnit.classList.remove('translation-unit-active');
                }
                // A침adir la clase al actual
                if (editorUnit) editorUnit.classList.add('translation-unit-active');
                lastFocusedEditorUnitIndex = activeEntryIndex; // Actualizar
                // --- FIN C칍DIGO A칌ADIDO ---
                     editorDiv.focus();
                 }
                 // --- FIN C칍DIGO A칌ADIDO ---
            }

            currentlyTrackedEditorIndex = activeEntryIndex; // Guarda el 칤ndice actual
        }
    }

/**
 * Limpia los resaltados visuales aplicados por handlePlaybackTracking.
 */
function clearPlaybackHighlights() {
    // Limpiar regi칩n de la onda
    if (currentlyTrackedRegionId && wsRegions) {
        const previousRegion = wsRegions.getRegions().find(r => r.id === currentlyTrackedRegionId);
        if (previousRegion && previousRegion.element) {
            previousRegion.element.classList.remove('region-playback-active');
        }
    }
    // Limpiar editor (si a침adiste una clase espec칤fica)
    // if (currentlyTrackedEditorIndex !== -1) {
    //     const previousEditorUnit = document.getElementById(`translation-unit-${currentlyTrackedEditorIndex}`);
    //     if (previousEditorUnit) {
    //         previousEditorUnit.classList.remove('playback-active');
    //     }
    // }
}
 
        /**
         * Updates the subtitle preview overlay based on the video's current time and user selection.
         */
        function updateSubtitlePreview() {
            if (!videoPlayer.src || srtEntries.length === 0) {
                subtitlePreviewText.innerHTML = '';
                return;
            }



            const currentTime = videoPlayer.currentTime;
            let activeSubtitle = null;

            for (const entry of srtEntries) {
                const startTime = entry.startTimeMs / 1000;
                const endTime = entry.endTimeMs / 1000;
                if (currentTime >= startTime && currentTime <= endTime) {
                    activeSubtitle = entry;
                    break;
                }
            }

            if (activeSubtitle) {
                let textToShow = '';
                if (previewSource === 'translation') {
                    textToShow = activeSubtitle.translation.trim() || activeSubtitle.original;
                } else {
                    textToShow = activeSubtitle.original;
                }
                subtitlePreviewText.innerHTML = textToShow;
            } else {
                subtitlePreviewText.innerHTML = '';
            }
        }
        
// A칌ADE ESTAS DOS FUNCIONES NUEVAS
/**
 * Actualiza el tama침o de la fuente de los subt칤tulos en la vista previa.
 * @param {number} newSize - El nuevo tama침o de la fuente en p칤xeles.
 */
// C칍DIGO CORREGIDO
function updateFontSize(newSize) {
    if (newSize < 10 || newSize > 60) return;

    subtitleFontSize = newSize;
    fontSizeDisplay.textContent = `${subtitleFontSize}px`;
    document.documentElement.style.setProperty('--user-font-size', `${subtitleFontSize}px`);

    // --- L칍GICA A칌ADIDA ---
    // Si estamos en pantalla completa, actualiza el tama침o directamente.
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
    if (isFullscreen) {
        const fullscreenSize = subtitleFontSize + 26;
        subtitlePreviewText.style.fontSize = `${fullscreenSize}px`;
    }
}

/**
 * Establece la fuente de texto para la vista previa (original o traducci칩n).
 * @param {string} source - Puede ser 'original' o 'translation'.
 */
function setPreviewSource(source) {
    previewSource = source;

    // Actualiza la clase 'active' en los botones
    setPreviewOriginal.classList.toggle('active', source === 'original');
    setPreviewTranslation.classList.toggle('active', source === 'translation');

    // Refresca la vista previa inmediatamente
    updateSubtitlePreview();
}

function toggleFullscreen() {
    // Comprueba si ya estamos en modo pantalla completa
    if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
        // Si no lo estamos, solicita la pantalla completa para el CONTENEDOR
        if (videoPlayerWrapper.requestFullscreen) {
            videoPlayerWrapper.requestFullscreen();
        } else if (videoPlayerWrapper.webkitRequestFullscreen) { /* Safari */
            videoPlayerWrapper.webkitRequestFullscreen();
        } else if (videoPlayerWrapper.msRequestFullscreen) { /* IE11 */
            videoPlayerWrapper.msRequestFullscreen();
        }
    } else {
        // Si ya estamos en pantalla completa, salimos
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen();
        }
    }
}

function goToSubtitleByNumber() {
    if (srtEntries.length === 0) return;
    const targetIndex = parseInt(goToSubtitleInput.value, 10);
    if (isNaN(targetIndex) || targetIndex < 1 || targetIndex > srtEntries.length) {
        showMessage(`Por favor, introduce un n칰mero entre 1 y ${srtEntries.length}.`);
        return;
    }
    // El usuario introduce el 칤ndice 1, pero en el array es el 0.
    navigateToTranslation(targetIndex - 1);
}

/**
 * Navega al subt칤tulo m치s cercano a un timecode espec칤fico.
 */
function goToSubtitleByTimecode() {
    if (srtEntries.length === 0 || !videoPlayer.src) return;
    try {
        let targetTimeMs;
if (useFrameTimecode) {
    targetTimeMs = parseFrameTime(goToTimecodeInput.value, projectFPS);
} else {
    targetTimeMs = parseTime(goToTimecodeInput.value);
}
        videoPlayer.currentTime = targetTimeMs / 1000;

        // Buscamos el subt칤tulo cuyo inicio es m치s cercano (pero no posterior) al tiempo introducido.
        let foundIndex = 0;
        for (let i = 0; i < srtEntries.length; i++) {
            if (srtEntries[i].startTimeMs <= targetTimeMs) {
                foundIndex = i;
            } else {
                break;
            }
        }
        navigateToTranslation(foundIndex);
    } catch (error) {
        showMessage("El formato del timecode no es v치lido. Usa HH:MM:SS,ms");
    }
}

// --- START: Subtitle Structural Editing & Undo/Redo Logic ---

        function saveStructuralState(oldState, newState) {
            // A칌ADIR ESTA L칈NEA ->
            if (isApplyingState) return;
            historyStack.push({ type: 'structural', oldState, newState });
            redoStack = []; // Un nuevo cambio borra el historial de "rehacer"
            updateUndoRedoButtons();
        }



        /** <- A칌ADIR ESTE BLOQUE COMPLETO ->
         * Guarda el estado de un cambio de tiempo en el historial.
         * @param {number} entryIndex - El 칤ndice del subt칤tulo modificado.
         * @param {object} oldValue - {startTimeMs, endTimeMs} ANTES del cambio.
         * @param {object} newValue - {startTimeMs, endTimeMs} DESPU칄S del cambio.
         */
        function saveTimeChange(entryIndex, oldValue, newValue) {
            if (isApplyingState) return;
            // No guardar si los tiempos no han cambiado realmente
            if (oldValue.startTimeMs === newValue.startTimeMs && oldValue.endTimeMs === newValue.endTimeMs) return;

            historyStack.push({ type: 'timeChange', entryIndex, oldValue, newValue });
            redoStack = [];
            updateUndoRedoButtons();
        }
        // <- FIN DEL BLOQUE A칌ADIDO ->

        
        /**
         * Deshace la 칰ltima acci칩n del historial (textual o estructural).
         */
        function undo() {
            if (historyStack.length === 0) return;

            isApplyingState = true;
            const lastAction = historyStack.pop();
            redoStack.push(lastAction); // Guardamos la acci칩n en la pila de "rehacer"

            if (lastAction.type === 'structural') {
                // Si es un cambio estructural, restauramos toda la lista de subt칤tulos
                srtEntries = JSON.parse(JSON.stringify(lastAction.oldState));
                renderTranslations(srtEntries, 0, true);
           } else if (lastAction.type === 'timeChange') { // <-- CORREGIDO
            // --- NUEVO: Manejar deshacer cambio de tiempo ---
            const { entryIndex, oldValue } = lastAction; // <-- CORREGIDO
            const entry = srtEntries[entryIndex];
            if (entry) {
                entry.startTimeMs = oldValue.startTimeMs;
                entry.endTimeMs = oldValue.endTimeMs;
                updateEntryTimes(entryIndex); // Actualiza UI y regi칩n de la onda
            }
        } else { // <-- MODIFICAR: Este 'else' ahora solo maneja 'text'
            // Manejar cambio de texto
            const { entryIndex, newValue } = lastUndo;
            const entry = srtEntries[entryIndex];
            const editor = document.getElementById(`translation-${entryIndex}`);
                if (entry && editor) {
                    entry.translation = newValue; // <-- CORREGIDO
                    editor.innerHTML = newValue;  // <-- CORREGIDO
                    editor.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }

            updateUndoRedoButtons();
            isApplyingState = false;
        }

        /**
         * Rehace la 칰ltima acci칩n deshecha (textual o estructural).
         */
        function redo() {
            if (redoStack.length === 0) return;
            isApplyingState = true;
            const lastUndo = redoStack.pop();
            historyStack.push(lastUndo); // Devolvemos la acci칩n al historial principal

            if (lastUndo.type === 'structural') {
                // Si es un cambio estructural, aplicamos el nuevo estado
                srtEntries = JSON.parse(JSON.stringify(lastUndo.newState));
                renderTranslations(srtEntries, 0, true);
            } else {
                // Si es un cambio de texto, aplicamos el nuevo texto
                const { entryIndex, newValue } = lastUndo;
                const entry = srtEntries[entryIndex];
                const editor = document.getElementById(`translation-${entryIndex}`);
                if (entry && editor) {
                    entry.translation = newValue;
                    editor.innerHTML = newValue;
                    editor.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }

            updateUndoRedoButtons();
            isApplyingState = false;
        }


        /**
         * Vuelve a numerar los 칤ndices de los subt칤tulos despu칠s de una modificaci칩n (a침adir/eliminar).
         * @param {number} startIndex - El 칤ndice del array a partir del cual empezar a renumerar.
         */
        function renumberSubtitles(startIndex = 0) {
            for (let i = startIndex; i < srtEntries.length; i++) {
                srtEntries[i].index = i + 1;
            }
        }

        /**
         * Fusiona un subt칤tulo con el siguiente.
         * @param {number} entryIndex - El 칤ndice del subt칤tulo actual.
         */
        function mergeWithNext(entryIndex) {
            if (entryIndex >= srtEntries.length - 1) return; // No se puede fusionar el 칰ltimo

            const oldState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado PREVIO

            const currentEntry = srtEntries[entryIndex];
            const nextEntry = srtEntries[entryIndex + 1];

            currentEntry.original += `\n${nextEntry.original}`;
            currentEntry.translation += `<br>${nextEntry.translation}`;
            currentEntry.endTimeMs = nextEntry.endTimeMs;
            currentEntry.durationMs = currentEntry.endTimeMs - currentEntry.startTimeMs;
            currentEntry.timecodes = `${formatTime(currentEntry.startTimeMs)} --> ${formatTime(currentEntry.endTimeMs)}`;

            srtEntries.splice(entryIndex + 1, 1);
            renumberSubtitles(entryIndex + 1);
            
            const newState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado POSTERIOR
            saveStructuralState(oldState, newState); // Registrar en el historial

            renderTranslations(srtEntries, entryIndex, true);
        }

        /**
         * Separa un subt칤tulo en dos en la posici칩n del cursor.
         * @param {number} entryIndex - El 칤ndice del subt칤tulo a separar.
         */
        /**
         * Separa un subt칤tulo en dos en la posici칩n del cursor.
         * @param {number} entryIndex - El 칤ndice del subt칤tulo a separar.
         */
        function splitSubtitle(entryIndex) {
            const editor = document.getElementById(`translation-${entryIndex}`);
            const selection = window.getSelection();
            if (!editor || !selection.rangeCount > 0) return;

            const range = selection.getRangeAt(0);
            const splitPoint = range.startOffset;
            const textContent = editor.innerText;

            if (splitPoint === 0 || splitPoint === textContent.length) {
                showMessage("Coloca el cursor en el punto donde quieres separar el subt칤tulo.");
                return;
            }
            
            const oldState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado PREVIO

            // --- INICIO DE LA MODIFICACI칍N ---

            // 1. Calculamos el hueco de 2 fotogramas
            const frameDurationMs = Math.round(1000 / projectFPS);
            const gapMs = frameDurationMs * 2;

            const currentEntry = srtEntries[entryIndex];
            const firstPartTranslation = editor.innerHTML.substring(0, splitPoint);
            const secondPartTranslation = editor.innerHTML.substring(splitPoint);

            const splitRatio = splitPoint / textContent.length;
            const originalSplitPoint = Math.round(currentEntry.original.length * splitRatio);
            const firstPartOriginal = currentEntry.original.substring(0, originalSplitPoint).trim();
            const secondPartOriginal = currentEntry.original.substring(originalSplitPoint).trim();

            // 2. Calculamos los nuevos tiempos
            const midPointTimeMs = currentEntry.startTimeMs + Math.round(currentEntry.durationMs * splitRatio);
            
            // El primer subt칤tulo termina en el punto de corte
            const firstPartEndTimeMs = midPointTimeMs;
            
            // El segundo subt칤tulo empieza DESPU칄S del hueco
            let secondPartStartTimeMs = midPointTimeMs + gapMs;

            // Guardamos el tiempo final original
            const originalEndTimeMs = currentEntry.endTimeMs;

            // 3. Comprobaci칩n de seguridad:
            // Si el hueco de 2 fotogramas es tan grande que "come" todo el segundo subt칤tulo...
            if (secondPartStartTimeMs >= originalEndTimeMs) {
                // ...lo forzamos a tener una duraci칩n m칤nima (ej. 1 fotograma)
                secondPartStartTimeMs = originalEndTimeMs - frameDurationMs;
                // Y nos aseguramos de que el primero no se solape
                if (firstPartEndTimeMs >= secondPartStartTimeMs) {
                    firstPartEndTimeMs = secondPartStartTimeMs - 1; // Dejamos 1ms de separaci칩n
                }
            }

            // 4. Creamos y actualizamos los subt칤tulos con los tiempos corregidos

            const newEntry = { 
                ...currentEntry, 
                index: currentEntry.index + 1, 
                original: secondPartOriginal, 
                translation: secondPartTranslation, 
                startTimeMs: secondPartStartTimeMs,         // <--- MODIFICADO
                endTimeMs: originalEndTimeMs,               // <--- MODIFICADO (usa el final original)
                durationMs: originalEndTimeMs - secondPartStartTimeMs, // <--- MODIFICADO
                timecodes: `${formatTime(secondPartStartTimeMs)} --> ${formatTime(originalEndTimeMs)}` // <--- MODIFICADO
            };
            
            delete newEntry.regionId; // (Esto es de tu correcci칩n anterior, y est치 perfecto)

            currentEntry.original = firstPartOriginal;
            currentEntry.translation = firstPartTranslation;
            currentEntry.endTimeMs = firstPartEndTimeMs;        // <--- MODIFICADO
            currentEntry.durationMs = currentEntry.endTimeMs - currentEntry.startTimeMs;
            currentEntry.timecodes = `${formatTime(currentEntry.startTimeMs)} --> ${formatTime(firstPartEndTimeMs)}`; // <--- MODIFICADO
            
            // --- FIN DE LA MODIFICACI칍N ---

            srtEntries.splice(entryIndex + 1, 0, newEntry);
            renumberSubtitles(entryIndex + 1);
            
            const newState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado POSTERIOR
            saveStructuralState(oldState, newState); // Registrar en el historial

            renderTranslations(srtEntries, entryIndex + 1, true);
        }

        /**
         * Muestra un di치logo de confirmaci칩n antes de eliminar un subt칤tulo.
         * @param {number} entryIndex - El 칤ndice del subt칤tulo a eliminar.
         */
        function confirmDeleteSubtitle(entryIndex) {
            // Usamos la clave del objeto de traducciones para el mensaje
            if (confirm(translations[currentLanguage]['delete_subtitle_confirm'])) {
                deleteSubtitle(entryIndex);
            }
        }
        
        /**
         * Elimina un subt칤tulo del proyecto.
         * @param {number} entryIndex - El 칤ndice del subt칤tulo a eliminar.
         */
        function deleteSubtitle(entryIndex) {
            const oldState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado PREVIO
            
            srtEntries.splice(entryIndex, 1);
            renumberSubtitles(entryIndex);
            
            const newState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado POSTERIOR
            saveStructuralState(oldState, newState); // Registrar en el historial
            
            const newIndexToFocus = Math.min(entryIndex, srtEntries.length - 1);
            renderTranslations(srtEntries, newIndexToFocus, true);
        }
        
        // --- END: Subtitle Structural Editing & Undo/Redo Logic ---
        // --- Backup and Restore Functions ---
        function getProjectState() {
            if (srtEntries.length === 0) return null;
            return {
                fileName: currentFileName, srtEntries: srtEntries,
                glossary: { data: glossary, sourceLang: glossarySourceLanguage, targetLang: glossaryTargetLanguage },
                translationMemory: { data: translationMemory, sourceLang: tmSourceLanguage, targetLang: tmTargetLanguage },
                qaSettings: qaSettings, lastModified: new Date(),
 sessionPlan: sessionPlan
            };
        }

        async function saveBackup() {
            const projectState = getProjectState();
            if (!projectState) {
                backupBtn.classList.remove('animate-pulse-yellow');
                return;
            }
            try {
                await db.projects.put({ id: 1, ...projectState });
                backupBtn.classList.add('animate-pulse-yellow');
            } catch (error) {
                console.error('Error saving backup to IndexedDB:', error);
            }
        }
        
        function restoreProject(backupData) {
            currentFileName = backupData.fileName;
            srtEntries = backupData.srtEntries;
            glossary = backupData.glossary.data || [];
            glossarySourceLanguage = backupData.glossary.sourceLang;
            glossaryTargetLanguage = backupData.glossary.targetLang;
            translationMemory = backupData.translationMemory.data || [];
            tmSourceLanguage = backupData.translationMemory.sourceLang;
            tmTargetLanguage = backupData.translationMemory.targetLang;
            qaSettings = backupData.qaSettings || { cpsLimit: 20, charsPerLineLimit: 42 };
            
            renderTranslations(srtEntries);
            showGlossaryEditorSection();
            showTMEditorSection();
            
            showMessage(errorMessages[currentLanguage]['project_restored_message']);
        }

        // --- QA Functions ---
        function runFullQaCheck() {
            srtEntries.forEach((entry, index) => {
                const editorDiv = document.getElementById(`translation-${index}`);
                if (editorDiv) {
                    updateSubtitleStats(editorDiv, entry.charCountOriginal, entry.durationMs);
                }
            });
            updateStatsDisplay();
        }

        function calculateAllQaErrors() {
            const errors = [];
            srtEntries.forEach((entry, index) => {
                const errorTypes = new Set();
                const currentCPS = calculateCPS(entry.translation, entry.durationMs);
                if (currentCPS > qaSettings.cpsLimit) {
                    errorTypes.add('CPS');
                }
                const lines = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '').split('\n');
                lines.forEach(line => {
                    if (countCharactersWithoutTags(line) > qaSettings.charsPerLineLimit) {
                        errorTypes.add('Line length');
                    }
                });

                if (errorTypes.size > 0) {
                    errors.push({
                        index: index,
                        subtitleIndex: entry.index,
                        text: entry.translation.replace(/<[^>]+>/g, ' ').substring(0, 50) + '...',
                        errors: Array.from(errorTypes)
                    });
                }
            });
            return errors;
        }

        function renderQaErrorList() {
            const errors = calculateAllQaErrors();
            qaErrorListContainer.innerHTML = '';
            const t = translations[currentLanguage];
            if (errors.length === 0) {
                qaErrorListContainer.textContent = t.qa_no_errors;
                return;
            }
            
            errors.forEach(error => {
                const errorItem = document.createElement('div');
                errorItem.className = 'qa-error-item';
                errorItem.dataset.entryIndex = error.index;
                errorItem.innerHTML = `
                    <div class="font-bold">Subtitle #${error.subtitleIndex} <span class="text-red-500">(${error.errors.join(', ')})</span></div>
                    <div class="text-sm text-gray-600">${error.text}</div>
                `;
                qaErrorListContainer.appendChild(errorItem);
            });
        }

        // --- Project Save/Load Functions ---
async function saveProject(filename) {
            if (srtEntries.length === 0) {
                showMessage(errorMessages[currentLanguage]['no_project_to_save']);
                return;
            }
            showLoadingOverlay(translations[currentLanguage]['saving_file']);

            const projectData = {
                version: '1.0',
                srtEntries,
                glossary,
                glossarySourceLanguage,
                glossaryTargetLanguage,
                translationMemory,
                tmSourceLanguage,
                tmTargetLanguage,
                qaSettings,
                videoFileName,
                sessionPlan,
                currentLanguage
            };

            try {
                const zip = new JSZip();
                zip.file("project.json", JSON.stringify(projectData, null, 2));

                const content = await zip.generateAsync({ type: "blob" });
                
                const a = document.createElement("a");
                const url = URL.createObjectURL(content);
                a.href = url;
                a.download = filename.endsWith('.subpanda') ? filename : filename + '.subpanda'; // <-- L칈NEA MODIFICADA
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(url);
                a.remove();
                
                showMessage('Proyecto guardado con 칠xito.');
                
                // --- L칍GICA A칌ADIDA ---
                if (typeof afterSaveAction === 'function') {
                    afterSaveAction();
                    afterSaveAction = null; // Resetea la acci칩n
                }
                // --- FIN DE L칍GICA A칌ADIDA ---

            } catch (error) {
                console.error("Error saving project:", error);
                showMessage('Error al guardar el proyecto.');
                afterSaveAction = null; // Resetea tambi칠n en caso de error
            } finally {
                hideLoadingOverlay();
            }
        }
        async function loadProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoadingOverlay(translations[currentLanguage]['loading_file']);
            try {
                const zip = await JSZip.loadAsync(file);
                const projectJsonFile = zip.file("project.json");

                if (!projectJsonFile) {
                    throw new Error("Archivo de proyecto inv치lido: no se encontr칩 project.json.");
                }

                const projectData = JSON.parse(await projectJsonFile.async("string"));
                
currentFileName = file.name;

 historyStack = [];
                    redoStack = [];
                    updateUndoRedoButtons();

                restoreProjectState(projectData);

                showMessage(errorMessages[currentLanguage]['project_loaded_success']);
                
                if (projectData.videoFileName) {
                    reselectVideoInfo.textContent = translations[currentLanguage]['reselect_video_prompt'].replace('{0}', projectData.videoFileName);
                    reselectVideoModal.classList.remove('hidden');
                }

            } catch (error) {
                console.error("Error loading project:", error);
                showMessage(`${errorMessages[currentLanguage]['error_loading_project']}: ${error.message}`);
            } finally {
                hideLoadingOverlay();
                event.target.value = ''; // Reset file input
            }
        }

        function restoreProjectState(data) {
            srtEntries = data.srtEntries || [];
            glossary = data.glossary || [];
            glossarySourceLanguage = data.glossarySourceLanguage || '';
            glossaryTargetLanguage = data.glossaryTargetLanguage || '';
            translationMemory = data.translationMemory || [];
            tmSourceLanguage = data.tmSourceLanguage || '';
            tmTargetLanguage = data.tmTargetLanguage || '';
            qaSettings = data.qaSettings || { cpsLimit: 20, charsPerLineLimit: 42 };
            videoFileName = data.videoFileName || null;
sessionPlan = data.sessionPlan || [];

            setLanguage(data.currentLanguage || 'es');
            
            renderTranslations(srtEntries);

renderPlanner();
            
            if (glossarySourceLanguage) {
                showGlossaryEditorSection();
            } else {
                showLanguageConfigSection();
            }

            if (tmSourceLanguage) {
                showTMEditorSection();
            } else {
                showTMLanguageConfigSection();
            }
        }

        function resetApplicationState() {
            srtEntries = [];
            currentFileName = 'subtitles.srt';
            videoFileName = null;
            
historyStack = [];
            redoStack = [];
            updateUndoRedoButtons();

            resetGlossary();
            resetTM();
            
            videoPlayer.pause();
            videoPlayer.src = '';
if (wavesurfer) {
                wavesurfer.empty();
clearSubtitleRegions();
                document.getElementById('waveform').classList.add('hidden');
            }
sessionPlan = []; // <-- A칌ADIR ESTA L칈NEA
if (document.getElementById('plannerContainer')) { 
    document.getElementById('plannerContainer').classList.add('hidden');
    document.getElementById('sessionResults').innerHTML = '';
}
            document.getElementById('videoLogoPlaceholder').classList.remove('hidden');
            const loadVideoBtnSpan = document.querySelector('#loadVideoBtn span');
            if (loadVideoBtnSpan) {
                loadVideoBtnSpan.textContent = translations[currentLanguage]['load_video'];
            }
            
            renderTranslations([]);
            updateStatsDisplay();
            
            confirmNewProjectModal.classList.add('hidden');
        }

/**
 * Borra todos los datos de la aplicaci칩n (LocalStorage e IndexedDB)
 * y recarga la p치gina para empezar desde cero.
 */
function resetApplicationCache() {
    const t = translations[currentLanguage];
    const confirmation = confirm(t['reset_app_confirm']);

    if (confirmation) {
        try {
            // Borra todo el LocalStorage (ajustes de IA, atajos, etc.)
            localStorage.clear();

            // Borra la base de datos IndexedDB (proyectos y backups)
            db.delete().then(() => {
                showMessage(t['reset_app_success']);
                // Espera un segundo para que el usuario vea el mensaje y recarga la p치gina.
                setTimeout(() => {
                    location.reload();
                }, 1000);
            }).catch(err => {
                console.error("Error al borrar la base de datos:", err);
                showMessage(t['reset_db_error']);
            });

        } catch (error) {
            console.error("Error al resetear el almacenamiento:", error);
            showMessage(t['reset_storage_error']);
        }
    }
}

// --- START: PLANNER LOGIC ---

let sessionPlan = [];
let activeSessionIndex = -1;
let timerInterval = null;
let sessionStartTime = 0;

function calculateSessions() {
    const t = translations[currentLanguage]; // Obtenemos el diccionario del idioma actual

    if (srtEntries.length === 0) {
        showMessage(t['planner_load_srt_warning']); // Usamos la traducci칩n
        return;
    }

    const numSessions = parseInt(document.getElementById('sessionCount').value, 10);
    const method = document.getElementById('divisionMethod').value;

    sessionPlan = [];
    activeSessionIndex = -1;
    clearInterval(timerInterval);

    const totalSubs = srtEntries.length;
    const totalDuration = srtEntries[totalSubs - 1].endTimeMs;
    const totalWords = srtEntries.reduce((sum, entry) => sum + entry.wordCountOriginal, 0);

    let lastIndex = 0;

    for (let i = 1; i <= numSessions; i++) {
        let session = {
            id: i,
            startSub: 0,
            endSub: 0,
            text: '',
            isCompleted: false,
            elapsedTime: 0
        };

        session.startSub = lastIndex + 1;

        if (method === 'subtitles') {
            const subsPerSession = Math.ceil(totalSubs / numSessions);
            session.endSub = Math.min(i * subsPerSession, totalSubs);
            session.text = t['planner_session_subs'].replace('{0}', session.startSub).replace('{1}', session.endSub);
        } 
        else if (method === 'time') {
            const timePerSession = totalDuration / numSessions;
            const sessionEndTime = i * timePerSession;
            const endEntry = srtEntries.find(entry => entry.startTimeMs >= sessionEndTime) || srtEntries[totalSubs - 1];
            session.endSub = endEntry.index;
            if (i === numSessions) session.endSub = totalSubs;

            const startTimeMs = Math.round((i - 1) * timePerSession);
            const endTimeMs = Math.round(sessionEndTime);
            const startTimeStr = formatTime(startTimeMs);
            const endTimeStr = formatTime(endTimeMs);
            session.text = t['planner_session_time'].replace('{0}', startTimeStr).replace('{1}', endTimeStr).replace('{2}', session.endSub);
        }
        else if (method === 'words') {
            const wordsPerSession = totalWords / numSessions;
            let currentWords = 0;
            let endSubIndex = lastIndex;
            for (let j = lastIndex; j < totalSubs; j++) {
                currentWords += srtEntries[j].wordCountOriginal;
                if ((j > lastIndex && currentWords > (wordsPerSession * 0.8)) || j === totalSubs - 1) {
                     endSubIndex = j;
                     if (i === numSessions) {
                         endSubIndex = totalSubs -1;
                     }
                     break;
                }
            }
             session.endSub = endSubIndex + 1;
             if (i === numSessions) session.endSub = totalSubs;
             const approxWords = Math.round(wordsPerSession);
             session.text = t['planner_session_words'].replace('{0}', session.startSub).replace('{1}', session.endSub).replace('{2}', approxWords);
        }

        lastIndex = session.endSub;
        sessionPlan.push(session);
    }

// --- INICIO DEL BLOQUE A A칌ADIR ---
// A침adimos el 칤tem fijo de Revisi칩n / QA al final del plan
sessionPlan.push({
    id: numSessions + 1,
    startSub: null, // No tiene subt칤tulo de inicio
    endSub: null,
    text: t['planner_session_qa'],
    isCompleted: false,
    elapsedTime: 0
});
// --- FIN DEL BLOQUE A A칌ADIR ---

    renderPlanner();
}

function renderPlanner() {
    const resultsContainer = document.getElementById('sessionResults');
    resultsContainer.innerHTML = '';

    sessionPlan.forEach((session, index) => {
        const row = document.createElement('div');
        row.className = 'session-row';
        if (session.isCompleted) row.classList.add('completed');
        if (index === activeSessionIndex) row.classList.add('active');

        row.innerHTML = `
            <input type="checkbox" class="session-checkbox form-checkbox h-5 w-5 text-blue-600" data-index="${index}" ${session.isCompleted ? 'checked' : ''}>
            <div class="session-text">${session.text}</div>
            <div class="session-time" id="time-${index}">${formatElapsedTime(session.elapsedTime)}</div>
            <button class="btn btn-secondary text-xs" id="timer-btn-${index}" data-index="${index}">郊</button>
            <button class="btn btn-secondary text-xs" id="reset-btn-${index}" data-index="${index}"></button>
        `;
        resultsContainer.appendChild(row);
    });

    // Add event listeners
    resultsContainer.querySelectorAll('.session-checkbox').forEach(cb => {
        cb.addEventListener('change', (e) => {
            const index = parseInt(e.target.dataset.index, 10);
            sessionPlan[index].isCompleted = e.target.checked;
            if (e.target.checked) pauseTimer();
            renderPlanner();
        });
    });

    resultsContainer.querySelectorAll('.session-row').forEach(row => {
    row.addEventListener('click', (e) => {
        if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') {
            const index = parseInt(e.target.closest('.session-row').querySelector('.session-checkbox').dataset.index, 10);

            // Solo navegamos si la sesi칩n tiene un subt칤tulo de inicio definido
            if (sessionPlan[index] && sessionPlan[index].startSub) {
                navigateToTranslation(sessionPlan[index].startSub - 1);
            }
        } // <-- ESTA ES LA LLAVE QUE SE HA MOVIDO A SU SITIO CORRECTO
    });
});

     resultsContainer.querySelectorAll('[id^=timer-btn-]').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(e.target.dataset.index, 10);

            if (activeSessionIndex === index && timerInterval) {
                pauseTimer();
            } else {
                startTimer(index);
            }
        });
    });

    resultsContainer.querySelectorAll('[id^=reset-btn-]').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(e.target.dataset.index, 10);
            resetTimer(index);
        });
    });
}

function startTimer(index) {
    clearInterval(timerInterval);
    activeSessionIndex = index;
    sessionStartTime = Date.now() - sessionPlan[index].elapsedTime;

    timerInterval = setInterval(updateTimerDisplay, 1000);
    renderPlanner(); // Re-render to show active state and button text change
    document.getElementById(`timer-btn-${index}`).textContent = '仇뛱롘';
}

function pauseTimer() {
    if (activeSessionIndex === -1) return;
    clearInterval(timerInterval);
    timerInterval = null;
    sessionPlan[activeSessionIndex].elapsedTime = Date.now() - sessionStartTime;
    document.getElementById(`timer-btn-${activeSessionIndex}`).textContent = '郊';
}

function resetTimer(index) {
    if(activeSessionIndex === index) pauseTimer();
    sessionPlan[index].elapsedTime = 0;
    document.getElementById(`time-${index}`).textContent = '00:00:00';
}

function updateTimerDisplay() {
    const elapsedTime = Date.now() - sessionStartTime;
    document.getElementById(`time-${activeSessionIndex}`).textContent = formatElapsedTime(elapsedTime);
}

function formatElapsedTime(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

// --- END: PLANNER LOGIC ---

        // --- START: Floating Panel Logic (Drag, Resize, and Close) ---
        function closeFloatingPanel(panel, triggerButton) {
            panel.classList.remove('is-visible');
             if (triggerButton) {
                triggerButton.classList.remove('btn-active');
            }
        }

        function openFloatingPanel(panelToOpen, triggerButton, callback) {
            if (panelToOpen.classList.contains('is-visible')) {
                closeFloatingPanel(panelToOpen, triggerButton);
                return;
            }
            
            panelToOpen.classList.add('is-visible');
            
                 if (triggerButton) {
                triggerButton.classList.add('btn-active');
            }

            if (callback) {
                callback();
            }
        }
        
        function resetPanelPosition(panel) {
            // Remove inline styles set by dragging/resizing
            panel.style.left = '';
            panel.style.top = '';
            panel.style.width = '';
            panel.style.height = '';
            panel.style.right = '';
            panel.style.bottom = '';
            panel.style.transform = '';
            
            // Remove the moved data attribute
            delete panel.dataset.moved;
            
            // Re-apply visibility to ensure it's positioned correctly by CSS
            panel.classList.remove('is-visible');
            setTimeout(() => panel.classList.add('is-visible'), 10);
        }

        function makePanelDraggable(panel) {
            const header = panel.querySelector('.sidebar-header');
            let isDragging = false;
            let offsetX, offsetY;

            header.addEventListener('mousedown', (e) => {
                // Ignore clicks on buttons inside the header
                if (e.target.closest('button')) return;
                
                isDragging = true;
                panel.dataset.moved = 'true'; // Mark as moved
                
                const rect = panel.getBoundingClientRect();
                panel.style.left = `${rect.left}px`;
                panel.style.top = `${rect.top}px`;
                panel.style.right = 'auto';
                panel.style.bottom = 'auto';
                
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                
                panel.style.transition = 'none';
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'move';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                let newX = e.clientX - offsetX;
                let newY = e.clientY - offsetY;

                panel.style.left = `${newX}px`;
                panel.style.top = `${newY}px`;
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    panel.style.transition = ''; // Restore transitions
                    document.body.style.userSelect = '';
                    document.body.style.cursor = '';
                }
            });
        }
        
        function makePanelResizable(panel) {
            const resizers = document.createElement('div');
            resizers.innerHTML = `
                <div class="panel-resizer top-left"></div> <div class="panel-resizer top"></div> <div class="panel-resizer top-right"></div>
                <div class="panel-resizer left"></div>                                       <div class="panel-resizer right"></div>
                <div class="panel-resizer bottom-left"></div> <div class="panel-resizer bottom"></div> <div class="panel-resizer bottom-right"></div>
            `;
            panel.appendChild(resizers);
            
            let originalWidth, originalHeight, originalX, originalY, originalMouseX, originalMouseY;

            resizers.querySelectorAll('.panel-resizer').forEach(resizer => {
                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    panel.dataset.moved = 'true';
                    originalWidth = panel.offsetWidth;
                    originalHeight = panel.offsetHeight;
                    originalX = panel.offsetLeft;
                    originalY = panel.offsetTop;
                    originalMouseX = e.pageX;
                    originalMouseY = e.pageY;

                    const mouseMoveHandler = (e) => {
                        const dx = e.pageX - originalMouseX;
                        const dy = e.pageY - originalMouseY;

                        if (resizer.classList.contains('right')) {
                            panel.style.width = `${originalWidth + dx}px`;
                        } else if (resizer.classList.contains('left')) {
                            panel.style.width = `${originalWidth - dx}px`;
                            panel.style.left = `${originalX + dx}px`;
                        }

                        if (resizer.classList.contains('bottom')) {
                            panel.style.height = `${originalHeight + dy}px`;
                        } else if (resizer.classList.contains('top')) {
                            panel.style.height = `${originalHeight - dy}px`;
                            panel.style.top = `${originalY + dy}px`;
                        }
                        
                        // Handle corners
                        if (resizer.classList.contains('bottom-right')) {
                           panel.style.width = `${originalWidth + dx}px`;
                           panel.style.height = `${originalHeight + dy}px`;
                        } else if (resizer.classList.contains('bottom-left')) {
                           panel.style.width = `${originalWidth - dx}px`;
                           panel.style.left = `${originalX + dx}px`;
                           panel.style.height = `${originalHeight + dy}px`;
                        } else if (resizer.classList.contains('top-right')) {
                           panel.style.width = `${originalWidth + dx}px`;
                           panel.style.height = `${originalHeight - dy}px`;
                           panel.style.top = `${originalY + dy}px`;
                        } else if (resizer.classList.contains('top-left')) {
                           panel.style.width = `${originalWidth - dx}px`;
                           panel.style.left = `${originalX + dx}px`;
                           panel.style.height = `${originalHeight - dy}px`;
                           panel.style.top = `${originalY + dy}px`;
                        }
                    };

                    const mouseUpHandler = () => {
                        document.removeEventListener('mousemove', mouseMoveHandler);
                        document.removeEventListener('mouseup', mouseUpHandler);
                    };

                    document.addEventListener('mousemove', mouseMoveHandler);
                    document.addEventListener('mouseup', mouseUpHandler);
                });
            });
        }
        // --- END: Floating Panel Logic ---


        // --- Initialization on page load ---
        document.addEventListener('DOMContentLoaded', async () => {
            await loadShortcuts();
loadAiCustomInstructions();
            populateIsoLanguagesDatalist();
            setLanguage('es'); 
            resetApplicationState();

            // Initialize floating panels
            const terminologyPanel = document.getElementById('terminologySidebar');
            const tmPanel = document.getElementById('translationMemorySidebar');
            
            makePanelDraggable(terminologyPanel);
            makePanelResizable(terminologyPanel);
            makePanelDraggable(tmPanel);
            makePanelResizable(tmPanel);

const contextPanel = document.getElementById('contextSidebar');
makePanelDraggable(contextPanel);
makePanelResizable(contextPanel);
makePanelDraggable(goToSubtitlePanel);
makePanelResizable(goToSubtitlePanel);
           makePanelDraggable(findReplacePanel);
            makePanelResizable(findReplacePanel);

// --- Inicializaci칩n del Panel de Notas ---
setupPanel('notesSidebar', 'notesBtn');
makePanelDraggable(notesSidebar);
makePanelResizable(notesSidebar);

function saveAndCalcNote(num, value) {
    if (activeNoteSubtitleIndex !== -1 && srtEntries[activeNoteSubtitleIndex]) {
        // 1. Guardar
        srtEntries[activeNoteSubtitleIndex][`note${num}`] = value;
        // 2. Calcular estad칤sticas visuales
        updateSingleNoteStats(num);
    }
}

noteArea1.addEventListener('input', (e) => saveAndCalcNote(1, e.target.value));
noteArea2.addEventListener('input', (e) => saveAndCalcNote(2, e.target.value));
noteArea3.addEventListener('input', (e) => saveAndCalcNote(3, e.target.value));

// --- INICIO: Inicializaci칩n de WaveSurfer ---
            const waveformContainer = document.getElementById('waveform');
            const videoPlayer = document.getElementById('videoPlayer'); // Ya tienes esta variable
            
           wavesurfer = WaveSurfer.create({
                container: waveformContainer,
                media: videoPlayer,
                waveColor: '#A8DBA8',
                progressColor: '#3B8686',
                cursorColor: '#FFD700',
                cursorWidth: 2,
                barWidth: 3,
                barRadius: 3,
                barGap: 2,
                height: 96,
                responsive: true,
                minPxPerSec: 100,
                plugins: [
                    WaveSurfer.Regions.create(),
                ]
            });

            wsRegions = wavesurfer.plugins[0];

             wavesurfer.on('ready', () => {
                 document.getElementById('waveform').classList.remove('hidden');
waveformControls.classList.remove('hidden');
                 // A칌ADIDO: Solo renderiza si hay subt칤tulos cargados
                 if (srtEntries && srtEntries.length > 0) {
                     renderTranslations(srtEntries, lastActiveSubtitleIndex, true); // Renderiza subt칤tulos Y regiones
                 }
             });
            wavesurfer.on('error', (err) => {
                 console.error('WaveSurfer error:', err);
                 // MODIFICADO: Mensaje m치s gen칠rico o quitarlo si no se carga video
                 // showMessage("Error con la onda de sonido.");
             });
              // Listener para cuando una regi칩n se mueve o redimensiona
             wsRegions.on('region-updated', (region) => {
                 const entryIndex = srtEntries.findIndex(e => e.regionId === region.id);
                 if (entryIndex !== -1) {
                     const entry = srtEntries[entryIndex];
                     const newStartTimeMs = Math.round(region.start * 1000);
                     const newEndTimeMs = Math.round(region.end * 1000);

                     // Comprueba si los tiempos realmente cambiaron para evitar bucles infinitos
                     if (entry.startTimeMs !== newStartTimeMs || entry.endTimeMs !== newEndTimeMs) {
                         // Guarda el estado ANTES de modificar los datos
if (!isApplyingState) { // Solo guarda si no estamos deshaciendo/rehaciendo
                        const oldTimes = { startTimeMs: entry.startTimeMs, endTimeMs: entry.endTimeMs };
                        const newTimes = { startTimeMs: newStartTimeMs, endTimeMs: newEndTimeMs };
                        saveTimeChange(entryIndex, oldTimes, newTimes);
                    }
                         entry.startTimeMs = newStartTimeMs;
                         entry.endTimeMs = newEndTimeMs;
                         updateEntryTimes(entryIndex); // Actualiza la tabla y la propia regi칩n
                     }
                 }
             });
              // Listener para clic en una regi칩n
             wsRegions.on('region-clicked', (region, e) => {
                 e.stopPropagation(); // Evita que el clic se propague al contenedor de la onda
                 const entryIndex = srtEntries.findIndex(e => e.regionId === region.id);
                 if (entryIndex !== -1) {
                      wavesurfer.setTime(region.start); // Va al inicio de la regi칩n
                      navigateToTranslation(entryIndex); // Activa el subt칤tulo en la lista
                 }
             });

// --- A칌ADIR ESTE BLOQUE ---
const plannerContainer = document.getElementById('plannerContainer');
const plannerAccordionHeader = document.getElementById('plannerAccordionHeader');
const plannerAccordionContent = document.getElementById('plannerAccordionContent');
const plannerAccordionIcon = plannerAccordionHeader.querySelector('.accordion-icon');
const calculateSessionsBtn = document.getElementById('calculateSessionsBtn');
 const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);


plannerAccordionHeader.addEventListener('click', () => {
    const isCollapsed = plannerAccordionContent.classList.contains('collapsed');
    plannerAccordionContent.classList.toggle('collapsed', !isCollapsed);
    plannerAccordionContent.classList.toggle('expanded', isCollapsed);
    plannerAccordionIcon.classList.toggle('rotated', isCollapsed);
});
calculateSessionsBtn.addEventListener('click', calculateSessions);
// --- FIN DEL BLOQUE A A칌ADIR ---
            
            // Setup panel buttons
            setupPanel('terminologySidebar', 'terminologyBtn', () => {
                 if (!glossarySourceLanguage || !glossaryTargetLanguage) {
                    showLanguageConfigSection();
                } else {
                    showGlossaryEditorSection();
                }
            });
            setupPanel('translationMemorySidebar', 'tmBtn', () => {
                if (!tmSourceLanguage || !tmTargetLanguage) {
                    showTMLanguageConfigSection();
                } else {
                    showTMEditorSection();
                    tmSearch();
                }
            });
setupPanel('contextSidebar', 'contextBtn');
setupPanel('goToSubtitlePanel', 'goToSubtitleBtn');
goToSubtitleActionBtn.addEventListener('click', goToSubtitleByNumber);
goToTimecodeActionBtn.addEventListener('click', goToSubtitleByTimecode);

            if (saveSrtButton) saveSrtButton.disabled = true;
            if (statsContainer) statsContainer.classList.add('hidden');
            if (addTermContent) addTermContent.classList.add('collapsed');
            if (statsAccordionContent) statsAccordionContent.classList.add('collapsed');
            
videoPlayer.addEventListener('timeupdate', () => {
    updateSubtitlePreview(); // Actualiza el texto de vista previa
    handlePlaybackTracking(); // Gestiona el resaltado/scroll autom치tico
});

            // Inicializa los nuevos controles del reproductor
updateFontSize(subtitleFontSize);
setPreviewSource('translation'); // Establece el estado inicial

// Event listeners para los nuevos botones
setPreviewOriginal.addEventListener('click', () => setPreviewSource('original'));
setPreviewTranslation.addEventListener('click', () => setPreviewSource('translation'));
increaseFontSize.addEventListener('click', () => updateFontSize(subtitleFontSize + 2));
decreaseFontSize.addEventListener('click', () => updateFontSize(subtitleFontSize - 2));

// Event listener para nuestro bot칩n de pantalla completa
customFullscreenBtn.addEventListener('click', toggleFullscreen);

// Detecta cualquier cambio en el estado de la pantalla completa
document.addEventListener('fullscreenchange', handleFullscreenClass);
document.addEventListener('webkitfullscreenchange', handleFullscreenClass);
document.addEventListener('mozfullscreenchange', handleFullscreenClass);
document.addEventListener('MSFullscreenChange', handleFullscreenClass);

function handleFullscreenClass() {
    // Comprueba si hay alg칰n elemento en pantalla completa
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
    
    // A침ade o quita la clase .is-fullscreen del contenedor del v칤deo
    videoPlayerWrapper.classList.toggle('is-fullscreen', isFullscreen);
}

// Event listener para cambiar el icono cuando cambia el estado de la pantalla completa
function handleFullscreenChange() {
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);

    fullscreenEnterChar.classList.toggle('hidden', isFullscreen);
    fullscreenExitChar.classList.toggle('hidden', !isFullscreen);

    // --- L칍GICA A칌ADIDA ---
    if (isFullscreen) {
        // Al entrar en pantalla completa, calculamos y forzamos el nuevo tama침o.
        const newSize = subtitleFontSize + 26;
        subtitlePreviewText.style.fontSize = `${newSize}px`;
    } else {
        // Al salir, limpiamos el estilo para que vuelva a usar la regla normal.
        subtitlePreviewText.style.fontSize = ''; 
    }
}
// 2. "Escuchamos" todas las versiones del evento que usan los navegadores.
document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
document.addEventListener('mozfullscreenchange', handleFullscreenChange);
document.addEventListener('MSFullscreenChange', handleFullscreenChange);          
            // Language switcher events
            langEsBtn.addEventListener('click', () => setLanguage('es'));
            langEnBtn.addEventListener('click', () => setLanguage('en'));

            // Resizer logic
            const horizontalResizer = document.getElementById('horizontal-resizer');
            const videoSection = document.querySelector('.video-player-section');
            let isHorizontalResizing = false;
            horizontalResizer.addEventListener('mousedown', () => { isHorizontalResizing = true; document.body.style.cursor = 'col-resize'; });
            document.addEventListener('mousemove', (e) => { if (isHorizontalResizing) { const container = document.querySelector('.main-app-content'); const newVideoWidthPercent = ((e.clientX - container.getBoundingClientRect().left) / container.offsetWidth) * 100; if (newVideoWidthPercent > 20 && newVideoWidthPercent < 80) videoSection.style.flexBasis = `${newVideoWidthPercent}%`; } });
            document.addEventListener('mouseup', () => { isHorizontalResizing = false; document.body.style.cursor = ''; });
            
            // Backup Initialization
            try {
                const backup = await db.projects.get(1);
                if (backup) backupBtn.classList.add('animate-pulse-yellow');
            } catch (error) {
                console.error('Error checking initial backup:', error);
            }
            setInterval(saveBackup, 300000);

            backupBtn.addEventListener('click', async () => {
                const backup = await db.projects.get(1);
                if (backup) {
                    backupFileName.textContent = backup.fileName;
                    backupLastModified.textContent = new Date(backup.lastModified).toLocaleString();
                    backupFoundView.classList.remove('hidden');
                    noBackupFoundView.classList.add('hidden');
                } else {
                    backupFoundView.classList.add('hidden');
                    noBackupFoundView.classList.remove('hidden');
                }
                backupModal.classList.remove('hidden');
            });
            closeBackupModalBtn.addEventListener('click', () => backupModal.classList.add('hidden'));

confirmRestoreBtn.addEventListener('click', async () => {
                // Mensaje de confirmaci칩n a침adido
                if (confirm(translations[currentLanguage]['confirm_restore_message'])) {
                    const backup = await db.projects.get(1);
                    if (backup) {
                        restoreProject(backup);
                        backupModal.classList.add('hidden');
                    }
                }
            });
      
            deleteBackupBtn.addEventListener('click', async () => {
                if (confirm(errorMessages[currentLanguage]['backup_deleted_confirmation'])) {
                    await db.projects.delete(1);
                    backupBtn.classList.remove('animate-pulse-yellow');
                    backupModal.classList.add('hidden');
                    showMessage(errorMessages[currentLanguage]['backup_deleted_message']);
                }
            });
            exportSrtFromBackupBtn.addEventListener('click', async () => {
                const backup = await db.projects.get(1);
                if (!backup) { showMessage(errorMessages[currentLanguage]['no_backup_to_export']); return; }
                try {
                    const srtContent = reconstructSrt(backup.srtEntries);
                    const newFileName = `${backup.fileName.replace(/\.srt$/i, '')}_recuperado_${new Date().toISOString().slice(0, 10)}.srt`;
                    const blob = new Blob([srtContent], { type: 'text/plain;charset=utf-8' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = newFileName;
                    a.click();
                    URL.revokeObjectURL(a.href);
                    showMessage(`${errorMessages[currentLanguage]['backup_export_success']}: "${newFileName}"`);
                } catch (error) {
                    showMessage(`${errorMessages[currentLanguage]['backup_export_error']}${error.message}`);
                }
            });

            // QA Modal Initialization
            qaBtn.addEventListener('click', () => {
                qaCpsLimitInput.value = qaSettings.cpsLimit;
                qaCharsPerLineLimitInput.value = qaSettings.charsPerLineLimit;
                qaModal.classList.remove('hidden');
            });
            closeQaModalBtn.addEventListener('click', () => qaModal.classList.add('hidden'));
            saveQaSettingsBtn.addEventListener('click', () => {
    // 1. Generamos el texto de la 'antigua' instrucci칩n por defecto para comparar.
    const oldDefaultInstruction = translations[currentLanguage]['ai_default_instruction_1']
        .replace('{0}', qaSettings.charsPerLineLimit)
        .replace('{1}', qaSettings.cpsLimit);

    // 2. Comprobamos si la instrucci칩n actual es la que est치 por defecto.
    const isUsingDefault = (aiCustomInstructions.instruction1 === oldDefaultInstruction);

    // 3. Actualizamos los ajustes de QA con los nuevos valores de los campos.
    qaSettings.cpsLimit = parseInt(qaCpsLimitInput.value, 10) || qaSettings.cpsLimit;
    qaSettings.charsPerLineLimit = parseInt(qaCharsPerLineLimitInput.value, 10) || qaSettings.charsPerLineLimit;

    // 4. Si se estaba usando la instrucci칩n por defecto, la regeneramos y la guardamos.
    if (isUsingDefault) {
        const newDefaultInstruction = translations[currentLanguage]['ai_default_instruction_1']
            .replace('{0}', qaSettings.charsPerLineLimit)
            .replace('{1}', qaSettings.cpsLimit);

        aiCustomInstructions.instruction1 = newDefaultInstruction;
        saveAiCustomInstructions(); // Guardamos el cambio en la configuraci칩n de la IA
    }

    // 5. Ejecutamos el chequeo de QA y cerramos la ventana.
    runFullQaCheck();
    qaModal.classList.add('hidden');
});

            // QA Error List Modal Initialization
            qaErrorStats.addEventListener('click', () => {
                if (calculateAllQaErrors().length > 0) {
                    renderQaErrorList();
                    qaErrorListModal.classList.remove('hidden');
                }
            });
            closeQaErrorListModalBtn.addEventListener('click', () => qaErrorListModal.classList.add('hidden'));
            qaErrorListContainer.addEventListener('click', (event) => {
                const errorItem = event.target.closest('.qa-error-item');
                if (errorItem) {
                    navigateToTranslation(parseInt(errorItem.dataset.entryIndex, 10));
                    qaErrorListModal.classList.add('hidden');
                }
            });

            // Event listeners for TBX/TMX modals
            cancelSaveTbxBtn.addEventListener('click', () => {
                saveTbxModal.classList.add('hidden');
            });

            confirmSaveTbxBtn.addEventListener('click', () => {
                const filename = fileNameInputTbx.value;
                if (!filename) {
                    showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                    return;
                }
                showLoadingOverlay(errorMessages[currentLanguage]['saving_file']);
                try {
                    const tbxContent = generateTBX();
                    const blob = new Blob([tbxContent], { type: "application/xml" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = filename.endsWith('.tbx') ? filename : filename + '.tbx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showMessage(errorMessages[currentLanguage]['file_saved_successfully_tbx']);
                } catch (error) {
                    showMessage(`${errorMessages[currentLanguage]['error_saving_file']} ${error.message}`);
                    console.error("Error downloading TBX:", error);
                } finally {
                    hideLoadingOverlay();
                    saveTbxModal.classList.add('hidden');
                }
            });

            cancelSaveTmxBtn.addEventListener('click', () => {
                saveTmxModal.classList.add('hidden');
            });

            confirmSaveTmxBtn.addEventListener('click', () => {
                const filename = fileNameInputTmx.value;
                if (!filename) {
                    showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                    return;
                }
                showLoadingOverlay(errorMessages[currentLanguage]['saving_file']);
                try {
                    const tmxContent = generateTMX();
                    if (!tmxContent) return;
                    const blob = new Blob([tmxContent], { type: "application/xml" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = filename.endsWith('.tmx') ? filename : filename + '.tmx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showMessage(errorMessages[currentLanguage]['file_saved_successfully_tmx']);
                } catch (error) {
                    showMessage(`${errorMessages[currentLanguage]['error_saving_file']} ${error.message}`);
                    console.error("Error downloading TMX:", error);
                } finally {
                    hideLoadingOverlay();
                    saveTmxModal.classList.add('hidden');
                }
            });

            // Project Save/Load Listeners
            newProjectBtn.addEventListener('click', () => {
                if (srtEntries.length > 0) {
                    confirmNewProjectModal.classList.remove('hidden');
                } else {
                    resetApplicationState();
                }
            });

// --- Timecode Modal Listeners ---
            const timecodeModal = document.getElementById('timecodeModal');
            const timecodeSettingsBtn = document.getElementById('timecodeSettingsBtn');
            const closeTimecodeModalBtn = document.getElementById('closeTimecodeModalBtn');
            const saveTimecodeSettingsBtn = document.getElementById('saveTimecodeSettingsBtn');
            const projectFpsInput = document.getElementById('projectFpsInput');
            const useFrameTimecodeToggle = document.getElementById('useFrameTimecodeToggle');

            timecodeSettingsBtn.addEventListener('click', () => {
                // Cargar valores actuales en el modal
                projectFpsInput.value = projectFPS;
                useFrameTimecodeToggle.checked = useFrameTimecode;
                timecodeModal.classList.remove('hidden');
            });

            closeTimecodeModalBtn.addEventListener('click', () => {
                timecodeModal.classList.add('hidden');
            });

            saveTimecodeSettingsBtn.addEventListener('click', () => {
                // Guardar nuevos valores
                const newFPS = parseFloat(projectFpsInput.value);
                projectFPS = isNaN(newFPS) || newFPS <= 0 ? 25 : newFPS;
                useFrameTimecode = useFrameTimecodeToggle.checked;

                // Actualizar el placeholder del panel "Ir a..."
                if (useFrameTimecode) {
                    goToTimecodeInput.value = formatFrameTime(0, projectFPS);
                } else {
                    goToTimecodeInput.value = formatTime(0);
                }
                
                // Refrescar la lista de traducci칩n para mostrar el nuevo formato
                renderTranslations(srtEntries, lastActiveSubtitleIndex, true);
                
                timecodeModal.classList.add('hidden');
            });

// --- L칩gica de importaci칩n de contexto ---
const contextFileInput = document.getElementById('contextFileInput');
const importFromPasteBtn = document.getElementById('importFromPasteBtn');
const contextPasteArea = document.getElementById('contextPasteArea');

contextFileInput.addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    showLoadingOverlay(translations[currentLanguage]['loading_file']);
    try {
        const content = await file.text();
        const parsedContext = JSON.parse(content);
        processAndApplyContext(parsedContext);
    } catch (error) {
        showMessage(`Error: ${error.message}`);
        console.error(error);
    } finally {
        hideLoadingOverlay();
        event.target.value = ''; // Resetea el input
    }
});

importFromPasteBtn.addEventListener('click', () => {
    const content = contextPasteArea.value;
    if (!content.trim()) {
        showMessage("El 치rea de texto est치 vac칤a.");
        return;
    }
    showLoadingOverlay("Procesando contexto...");
    try {
        const parsedContext = JSON.parse(content);
        processAndApplyContext(parsedContext);
    } catch (error) {
        showMessage(`Error en el JSON: ${error.message}`);
        console.error(error);
    } finally {
        hideLoadingOverlay();
    }
});

    saveProjectBtn.addEventListener('click', () => {
                if (srtEntries.length === 0) {
                    showMessage(errorMessages[currentLanguage]['no_project_to_save']);
                    return;
                }
                // Sugiere un nombre de archivo basado en el SRT actual
                projectFileNameInput.value = currentFileName.replace(/\.[^/.]+$/, '');
                saveProjectModal.classList.remove('hidden');
                projectFileNameInput.focus();
            });

 confirmSaveProjectBtn.addEventListener('click', () => {
                const filename = projectFileNameInput.value.trim();
                if (!filename) {
                    showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                    return;
                }
                saveProject(filename); // Llama a la funci칩n de guardado con el nuevo nombre
                saveProjectModal.classList.add('hidden');
            });

            cancelSaveProjectBtn.addEventListener('click', () => {
                saveProjectModal.classList.add('hidden');
                afterSaveAction = null; // Cancela cualquier acci칩n pendiente
            });

            projectFile.addEventListener('change', loadProject);
resetAppBtn.addEventListener('click', resetApplicationCache);            

            // TMX File Input Listener
            tmFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    loadTMX(file);
                }
                event.target.value = ''; // Reset input
            });

            // New Project Confirmation Modal Listeners
            cancelNewProjectBtn.addEventListener('click', () => {
                confirmNewProjectModal.classList.add('hidden');
            });
            continueWithoutSavingBtn.addEventListener('click', () => {
                resetApplicationState();
            });
saveAndContinueBtn.addEventListener('click', () => {
                confirmNewProjectModal.classList.add('hidden');
                // Define la acci칩n a ejecutar despu칠s de guardar
                afterSaveAction = resetApplicationState;
                // Dispara el clic en el bot칩n de guardar para abrir el modal
                saveProjectBtn.click();
            });

const copyPromptBtn = document.getElementById('copyPromptBtn');
const pasteJsonBtn = document.getElementById('pasteJsonBtn');

copyPromptBtn.addEventListener('click', copyAIPrompt);
pasteJsonBtn.addEventListener('click', pasteJsonFromClipboard);
contextPasteArea.addEventListener('input', validateJsonInTextarea);


      reselectVideoInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
              if (file) {
        videoFileName = file.name;
        const videoURL = URL.createObjectURL(file); // <-- CORREGIDO: Creada ANTES
        videoPlayer.src = videoURL; // <-- CORREGIDO: Mover src aqu칤 tambi칠n
        wavesurfer.load(videoURL); // <-- Ahora videoURL existe
        document.getElementById('waveform').classList.remove('hidden');
        videoPlayer.controls = true;
                    videoPlayer.load();
                                
                    document.getElementById('videoLogoPlaceholder').classList.add('hidden');
            
                    const loadVideoBtnSpan = document.querySelector('#loadVideoBtn span');
                    if (loadVideoBtnSpan) {
                        loadVideoBtnSpan.textContent = translations[currentLanguage]['change_video'];
                    }
                    reselectVideoModal.classList.add('hidden');
                }
            });

            skipReselectVideoBtn.addEventListener('click', () => {
                reselectVideoModal.classList.add('hidden');
            });

          // --- CORRECCI칍N: L칩gica completa de modales y botones de Nuevo Glosario/TM ---

            // 1. Conectar botones de apertura (Nuevo Glosario / Nueva TM)
            const newGlossaryBtn = document.getElementById('newGlossaryBtn');
            if (newGlossaryBtn) {
                newGlossaryBtn.addEventListener('click', showConfirmResetGlossary);
            }

            const newTmBtn = document.getElementById('newTmBtn');
            if (newTmBtn) {
                newTmBtn.addEventListener('click', showConfirmResetTm);
            }

            // 2. Conectar botones de "Continuar" en los modales (Acci칩n de borrado)
            // Usamos .onclick para garantizar que la funci칩n se ejecute sin duplicar listeners
            if (confirmResetGlossaryBtn) {
                confirmResetGlossaryBtn.onclick = function() {
                    resetGlossary();
                    confirmResetGlossaryModal.classList.add('hidden');
                };
            }

            if (confirmResetTmBtn) {
                confirmResetTmBtn.onclick = function() {
                    resetTM();
                    confirmResetTmModal.classList.add('hidden');
                };
            }

            // 3. Conectar botones de "Cancelar"
            if (cancelResetGlossaryBtn) {
                cancelResetGlossaryBtn.addEventListener('click', () => {
                    confirmResetGlossaryModal.classList.add('hidden');
                });
            }

            if (cancelResetTmBtn) {
                cancelResetTmBtn.addEventListener('click', () => {
                    confirmResetTmModal.classList.add('hidden');
                });
            }
            // ---------------------------------------------------------------------

        // Funciones para mostrar los modales de confirmaci칩n
        function showConfirmResetGlossary() {
            if (glossary.length === 0) {
                resetGlossary();
                return;
            }
            confirmResetGlossaryModal.classList.remove('hidden');
        }

       function showConfirmResetTm() {
            if (translationMemory.length === 0) {
                resetTM();
                return;
            }
            confirmResetTmModal.classList.remove('hidden');
        }

// --- L칩gica para el modal de Ajustes de IA ---
const aiSettingsModal = document.getElementById('aiSettingsModal');
const aiSettingsBtn = document.getElementById('aiSettingsBtn');
const closeAiSettingsModalBtn = document.getElementById('closeAiSettingsModalBtn');
const saveAiSettingsBtn = document.getElementById('saveAiSettingsBtn');
const aiInstruction1 = document.getElementById('aiInstruction1');
const aiInstruction2 = document.getElementById('aiInstruction2');
const aiInstruction3 = document.getElementById('aiInstruction3');

aiSettingsBtn.addEventListener('click', () => {
    // Carga las instrucciones actuales en los campos de texto
    aiInstruction1.value = aiCustomInstructions.instruction1;
    aiInstruction2.value = aiCustomInstructions.instruction2;
    aiInstruction3.value = aiCustomInstructions.instruction3;
    aiSettingsModal.classList.remove('hidden');
});

closeAiSettingsModalBtn.addEventListener('click', () => {
    aiSettingsModal.classList.add('hidden');
});

saveAiSettingsBtn.addEventListener('click', () => {
    const defaultInstruction = translations[currentLanguage]['ai_default_instruction_1']
        .replace('{0}', qaSettings.charsPerLineLimit)
        .replace('{1}', qaSettings.cpsLimit);

    // Guarda los nuevos valores
    aiCustomInstructions.instruction1 = aiInstruction1.value.trim() || defaultInstruction;
    aiCustomInstructions.instruction2 = aiInstruction2.value.trim();
    aiCustomInstructions.instruction3 = aiInstruction3.value.trim();
    saveAiCustomInstructions();
    aiSettingsModal.classList.add('hidden');
    showMessage("Ajustes de la IA guardados.");
});

if (contextHelpHeader && contextHelpContent) {
                contextHelpHeader.addEventListener('click', () => {
                    const isCollapsed = contextHelpContent.classList.contains('collapsed');
                    const icon = contextHelpHeader.querySelector('.accordion-icon');
                    if (isCollapsed) {
                        contextHelpContent.classList.remove('collapsed');
                        contextHelpContent.classList.add('expanded');
                        if (icon) icon.classList.add('rotated');
                    } else {
                        contextHelpContent.classList.remove('expanded');
                        contextHelpContent.classList.add('collapsed');
                        if (icon) icon.classList.remove('rotated');
                    }
                });
            }

// --- INICIO: Listeners para la botonera de la onda ---
        lockWaveformBtn.addEventListener('click', toggleWaveformLock);
        zoomInBtn.addEventListener('click', () => zoomWaveform(1));
        zoomOutBtn.addEventListener('click', () => zoomWaveform(-1));
        // --- FIN: Listeners para la botonera de la onda ---

// --- INICIO: Listener para bot칩n de seguimiento ---
followPlaybackBtn.addEventListener('click', () => {
    isFollowPlaybackActive = !isFollowPlaybackActive;
    followPlaybackBtn.classList.toggle('active', isFollowPlaybackActive); // Usa la clase 'active' gen칠rica
    followPlaybackBtn.title = isFollowPlaybackActive
        ? translations[currentLanguage]['follow_playback_off']
        : translations[currentLanguage]['follow_playback_on'];

    // Si se acaba de desactivar, limpia los resaltados
    if (!isFollowPlaybackActive) {
        clearPlaybackHighlights();
        currentlyTrackedRegionId = null;
        currentlyTrackedEditorIndex = -1;
    } else {
         handlePlaybackTracking(); // Intenta resaltar inmediatamente si se activa
    }
});
// --- FIN: Listener para bot칩n de seguimiento ---

const statusBar = document.getElementById('statusBar');
    const toggleStatusBarBtn = document.getElementById('toggleStatusBarBtn');

// --- INICIO: MODIFICAR ESTE BLOQUE (L칩gica de la Barra de Estado) ---
        if (statusBar && toggleStatusBarBtn) {
            // Comprueba el estado guardado al cargar la p치gina
            const savedState = localStorage.getItem('statusBarVisible') === 'true';
            let textKey = 'show_status_bar_btn'; // Texto por defecto

            if (savedState) {
                statusBar.classList.add('is-visible');
                document.body.classList.add('status-bar-visible'); // Mantenemos esto por si acaso, aunque no afecte visualmente ahora
                textKey = 'hide_status_bar_btn'; // Texto si est치 visible
            }
            // Establecemos el atributo i18n para que se actualice con el idioma
            const buttonSpan = toggleStatusBarBtn.querySelector('span'); // Guardamos el span en una variable
            if (buttonSpan) { // Comprobamos si el span existe
                 buttonSpan.setAttribute('data-i18n', textKey);
                 // A침adimos esta l칤nea para asegurar que el texto se actualice al cargar
                 buttonSpan.textContent = translations[currentLanguage][textKey];
            }


            // Listener del bot칩n
            toggleStatusBarBtn.addEventListener('click', () => {
                // A침adimos un console.log para depurar
                console.log("Bot칩n de barra de estado pulsado. Estado actual:", statusBar.classList.contains('is-visible'));

                const isVisible = statusBar.classList.toggle('is-visible');
                document.body.classList.toggle('status-bar-visible', isVisible);

                // Actualiza el texto del bot칩n y el atributo i18n
                const newTextKey = isVisible ? 'hide_status_bar_btn' : 'show_status_bar_btn';
                if (buttonSpan) { // Usamos la variable guardada
                    buttonSpan.textContent = translations[currentLanguage][newTextKey];
                    buttonSpan.setAttribute('data-i18n', newTextKey);
                }

                // Guardar el estado en el navegador
                localStorage.setItem('statusBarVisible', isVisible);

                // A침adimos otro console.log para ver el estado despu칠s del toggle
                console.log("Nuevo estado:", isVisible);
            });
        } else {
             // A침adimos un log si los elementos no se encuentran
             console.error("Error: No se encontr칩 statusBar o toggleStatusBarBtn.");
        }
        // --- FIN: MODIFICAR ESTE BLOQUE ---

// --- INICIO: NUEVO ESCUCHA GLOBAL DE ATAJOS DE TECLADO ---
document.addEventListener('keydown', (event) => {
    const activeElement = document.activeElement;
    const isTypingInInput = activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable;

    // --- L칩gica para Atajos de Documentaci칩n ---
    const triggeredDocAction = shortcuts.docResources.find(res => {
        if (!res.shortcut) return false;
        const sc = res.shortcut;
        const keyMatch = (sc.key === ' ' && event.code === 'Space') || (sc.key.toLowerCase() === event.key.toLowerCase());
        return keyMatch &&
               sc.ctrlKey === event.ctrlKey &&
               sc.metaKey === event.metaKey &&
               sc.altKey === event.altKey &&
               sc.shiftKey === event.shiftKey;
    });

    if (triggeredDocAction) {
        event.preventDefault();
        const selectedText = window.getSelection().toString().trim();
        const resourceUrl = triggeredDocAction.url;
        if (selectedText && resourceUrl && resourceUrl.includes('{word}')) {
            const finalUrl = resourceUrl.replace('{word}', encodeURIComponent(selectedText));
            window.open(finalUrl, '_blank');
        }
        return;
    }
    
    if (isTypingInInput) {
        return;
    }

    // --- L칩gica para Atajos Globales (SOLO V칈DEO) ---
    const globalActions = [
        'jumpToTime', 'playSegment', 'playSegmentLoop', 'playPause', 
        'seekForward', 'seekBackward', 'seekForwardFast', 'seekBackwardFast'
    ];
    
    const triggeredGlobalAction = Object.keys(shortcuts).find(action => {
        if (!globalActions.includes(action)) return false;
        const shortcut = shortcuts[action];
        const keyMatch = (shortcut.key === ' ' && event.code === 'Space') || (shortcut.key.toLowerCase() === event.key.toLowerCase());
        return keyMatch &&
               shortcut.ctrlKey === event.ctrlKey &&
               shortcut.metaKey === event.metaKey &&
               shortcut.altKey === event.altKey &&
               shortcut.shiftKey === event.shiftKey;
    });

    if (triggeredGlobalAction) {
        event.preventDefault();
        switch (triggeredGlobalAction) {
            case 'jumpToTime':
            case 'playSegment':
                jumpToCurrentSubtitleTime(lastActiveSubtitleIndex);
                break;
            case 'playSegmentLoop':
                playSubtitleLoop(lastActiveSubtitleIndex);
                break;
            case 'playPause':
                if (videoPlayer.paused) videoPlayer.play();
                else videoPlayer.pause();
                break;
            case 'seekForward':
                videoPlayer.currentTime += 3;
                break;
            case 'seekBackward':
                videoPlayer.currentTime -= 3;
                break;
            case 'seekForwardFast':
                videoPlayer.currentTime += 5;
                break;
            case 'seekBackwardFast':
                videoPlayer.currentTime -= 5;
                break;
        }
    }
});
// --- FIN: NUEVO ESCUCHA GLOBAL DE ATAJOS DE TECLADO ---
   
followPlaybackBtn.title = translations[currentLanguage]['follow_playback_on'];
    });
   

// --- L칩gica del Modo Oscuro ---
            const themeToggleBtn = document.getElementById('themeToggleBtn');
            const iconMoon = document.getElementById('icon-moon');
            const iconSun = document.getElementById('icon-sun');
            const htmlElement = document.documentElement;

            // 1. Revisar preferencia guardada
            if (localStorage.getItem('theme') === 'dark' || 
               (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                htmlElement.classList.add('dark');
                iconMoon.classList.add('hidden');
                iconSun.classList.remove('hidden');
            } else {
                htmlElement.classList.remove('dark');
                iconMoon.classList.remove('hidden');
                iconSun.classList.add('hidden');
            }

            // 2. Acci칩n del bot칩n
            themeToggleBtn.addEventListener('click', () => {
                if (htmlElement.classList.contains('dark')) {
                    htmlElement.classList.remove('dark');
                    localStorage.setItem('theme', 'light');
                    iconMoon.classList.remove('hidden');
                    iconSun.classList.add('hidden');
                } else {
                    htmlElement.classList.add('dark');
                    localStorage.setItem('theme', 'dark');
                    iconMoon.classList.add('hidden');
                    iconSun.classList.remove('hidden');
                }
            });

</script>
<div id="statusBar"></div>
</body>
</html>
