<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">subpandaTM</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    <script src="https://unpkg.com/dexie@latest/dist/dexie.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/7.7.5/plugins/regions.min.js"></script>
    <style>
        /* General styles for body and font */
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: #f3f4f6;
            color: #202020;
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-y: auto;
        }

        /* Ensures preformatted text respects line breaks and doesn't overflow */
        pre {
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Style for the check icon (SVG) */
        .check-icon {
            display: none;
            margin-left: 8px;
            vertical-align: middle;
            width: 20px;
            height: 20px;
            color: #22c55e;
        }

#statsContainer {
            display: none !important; /* Oculta el div de estadísticas permanentemente */
        }

        /* Estilo del contenedor principal de la barra */
.cps-bar-container {
    width: 100%;
    height: 6px; /* Altura fina */
    background-color: #e5e7eb; /* Fondo gris claro */
    border-radius: 3px;
    margin-top: 5px; /* Separación del editor */
    position: relative;
    overflow: hidden; /* Asegura que la barra de llenado no se salga */
}

/* Estilo de la barra de llenado */
.cps-bar-fill {
    height: 100%;
    width: 0; /* Inicialmente a 0 */
    background-color: #22c55e; /* Verde por debajo del límite */
    transition: width 0.1s ease-out, background-color 0.3s ease; /* Transición suave */
}

/* Estilo del indicador de límite (la 'línea') */
.cps-bar-limit-marker {
    position: absolute;
    top: 0;
    width: 2px; /* Ancho de la línea de límite */
    height: 100%;
    background-color: #075BA2; /* Color de la línea de límite */
    z-index: 10; /* Asegura que esté por encima del relleno */
    box-shadow: 0 0 2px rgba(0, 0, 0, 0.2);
    /* Se posicionará dinámicamente con JavaScript */
}

/* --- ESTILOS PARA LAS REGIONES DE WAVESURFER (MODIFICADO v2) --- */
        #waveform ::part(region) {
            z-index: 10;
            overflow: visible !important;
            background-color: rgba(7, 91, 162, 0.7);
            border-left: 1px solid rgba(7, 91, 162, 0.9);
            border-right: 1px solid rgba(7, 91, 162, 0.9);
            transition: background-color 0.15s ease;
font-size: small;
    color: #fff !important;
    padding: 10px;
        }
        #waveform ::part(region):hover {
            background-color: rgba(6, 78, 138, 0.8);
        }
        #waveform ::part(region-handle-left),
        #waveform ::part(region-handle-right) {
            background-color: rgba(7, 91, 162, 0.9);
            width: 5px;
            cursor: ew-resize;
        }
        .region-content {
            position: absolute;
            top: -65px; /* Ajustado para 4 líneas */
            left: 0;
            width: 100%;
            font-size: 8px;
            line-height: 1.3; /* Espaciado entre líneas */
            color: #fff;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 3px 6px; /* Padding reducido verticalmente */
            border-radius: 3px;
            pointer-events: none;
            box-sizing: border-box;
            overflow: hidden; /* Oculta el desbordamiento general */
        }
        .region-content .region-line {
            white-space: nowrap; /* Evita que el texto salte de línea */
            overflow: hidden; /* Oculta el texto que se sale */
            text-overflow: ellipsis; /* Añade puntos suspensivos (...) */
            margin-bottom: 1px; /* Pequeño espacio entre líneas */
        }
        .region-content .region-line:last-child {
            margin-bottom: 0; /* Sin margen inferior en la última línea */
        }
        .region-content .region-line1 { /* Número */
            font-weight: bold;
            color: #E0E0E0; /* Blanco un poco más tenue */
        }
        .region-content .region-line2 { /* Original */
            color: #A0A0A0; /* Grisáceo para diferenciar */
        }
        .region-content .region-line3 { /* Traducción */
            color: #FFFFFF; /* Blanco brillante */
            min-height: 1.3em; /* Asegura altura mínima aunque esté vacío */
        }
        .region-content .region-line4 { /* Stats */
            color: #facc15; /* Amarillo para stats */
            font-family: monospace; /* Fuente monoespaciada para stats */
        }
        /* --- FIN ESTILOS REGIONES --- */

/* --- INICIO: ESTILOS PARA ONDA BLOQUEADA --- */
        #waveform.is-locked ::part(region) {
            opacity: 0.4 !important; /* Más transparente */
            transition: opacity 0.3s ease; /* Transición para la opacidad */
        }

        /* Oculta el icono de candado que no corresponda */
        #lockWaveformBtn .lock-icon-open.hidden,
        #lockWaveformBtn .lock-icon-closed.hidden {
            display: none;
        }
        /* --- FIN: ESTILOS PARA ONDA BLOQUEADA --- */

/* --- INICIO: ESTILO PARA REGIÓN ACTIVA EN SEGUIMIENTO --- */
        #waveform ::part(region.region-playback-active) {
            background-color: rgba(255, 165, 0, 0.6) !important; /* Naranja semi-transparente */
            border-left: 2px solid rgba(255, 140, 0, 0.9);
            border-right: 2px solid rgba(255, 140, 0, 0.9);
            transition: background-color 0.1s ease-out, border-color 0.1s ease-out;
        }
        /* --- FIN: ESTILO PARA REGIÓN ACTIVA --- */

/* --- INICIO: ESTILOS PARA SUBTÍTULO ACTIVO EN EDITOR --- */
        /* Estilo para el div editable cuando tiene el foco */
        .translation-editor-wrapper div[contenteditable="true"]:focus {
            border-color: #333 !important; /* Borde más oscuro */
            box-shadow: 0 0 0 1px #333; /* Opcional: una sombra sutil para realzar */
        }

        /* Estilo para la unidad completa del subtítulo cuando un editor interno tiene el foco */
        .translation-unit-active {
            background-color: #ffffff !important; 
            transition: background-color 0.2s ease-in-out; /* Transición suave */
        }
        /* --- FIN: ESTILOS PARA SUBTÍTULO ACTIVO EN EDITOR --- */

        /* --- UNIFIED BUTTON STYLES --- */
        .btn {
            padding: 0.25rem 0.75rem; /* Reduced padding */
            font-size: 0.875rem; /* Smaller font size */
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid transparent;
            white-space: nowrap;
        }
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Primary button style */
        .btn-primary {
            background-color: #075BA2;
            color: white;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #064f8a;
        }

        /* Secondary button style */
        .btn-secondary {
            background-color: #e5e7eb;
            color: #1f2937;
            border-color: #d1d5db;
        }

       .btn-secondary:hover:not(:disabled) {
            background-color: #d1d5db; /* Gris claro al pasar el ratón */
        }

        /* AÑADIR ESTA REGLA: Mantener azul en hover si está activo */
        .btn-secondary.active:hover:not(:disabled) {
            background-color: #064f8a; /* Un azul ligeramente más oscuro que el activo, opcional */
            /* O si prefieres que NO cambie NADA al hacer hover cuando está activo: */
            /* background-color: #075BA2 !important; /* Mantiene el azul primario */
        }

/* Active style for toggle buttons */
.btn-secondary.active {
    background-color: #075BA2;
    color: white;
    font-weight: 700;
}

        /* Destructive button style */
        .btn-destructive {
            background-color: #ef4444;
            color: white;
        }
        .btn-destructive:hover:not(:disabled) {
            background-color: #dc2626;
        }
        
        /* Language button style */
        .btn-lang {
            background-color: #f3f4f6;
            color: #4b5563;
            padding: 0.25rem 0.75rem;
        }
        .btn-lang.active {
            background-color: #075BA2;
            color: white;
            font-weight: 700;
        }

.btn-active {
            background-color: #075BA2 !important; /* Mismo azul que el primario */
            color: white !important; /* Forzamos el color blanco */
            font-weight: 700 !important; /* Forzamos la negrita */
        }




        /* Specific styles for code display fields (original, translation) */
        .subtitle-display-code {
            background-color: #e3e3e3;
            border: 1px solid #000;
            color: #202020;
        }
        .subtitle-editor {
            background-color: #ffffff;
            color: #000000;
            min-height: 50px;
            border: 1px solid #d1d5db;
            padding: 0.5rem;
            border-radius: 0.375rem;
        }
        .subtitle-editor[contenteditable="false"] {
            background-color: #f3f4f6;
        }

        /* Background of translation units */
        .translation-unit-bg {
            background-color: #f8f8f8;
            border-color: #e5e7eb;
        }

        /* 2-column layout classes */
        .translation-row {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        @media (min-width: 768px) {
            .translation-row {
                flex-direction: row;
            }
            .original-col, .translation-col {
                flex: 1;
            }
        }

        /* Modal (pop-up) styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            width: 500px;
        }
        #shortcutsModal .modal-content,
        #findReplaceModal .modal-content {
            width: 650px;
            max-width: 95%;
        }
        .shortcut-icon {
            display: inline-block;
            width: 1em;
            height: 1em;
            vertical-align: middle;
            margin: 0 4px;
        }
        .shortcut-input {
            border: 1px solid #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: #f9f9f9;
            cursor: pointer;
            text-align: center;
            min-width: 120px;
            display: inline-block;
        }
        .shortcut-input.recording {
            background-color: #fffbe6;
            border-color: #facc15;
        }

        /* --- START: Floating Panel Styles --- */
        .floating-panel {
            position: fixed;
            width: 480px;
            min-width: 350px;
            max-width: 80vw;
            height: 75vh;
            min-height: 300px;
            background-color: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 950;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Changed from 'hidden' to allow resizers to be placed outside */
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

        #terminologySidebar {
            top: auto;
            right: auto;
            bottom: 20px;
            left: 20px;
            transform-origin: bottom left;
        }

        #translationMemorySidebar {
            top: auto;
            right: 20px;
            bottom: 20px;
            left: auto;
            transform-origin: bottom right;
        }

        .floating-panel.is-visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        
        .floating-panel .sidebar-header {
            cursor: move;
            background-color: #f9fafb;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e5e7eb;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .floating-panel .sidebar-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .panel-resizer {
            position: absolute;
            background: transparent;
        }
        .panel-resizer.top { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .panel-resizer.bottom { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .panel-resizer.left { top: 0; bottom: 0; left: -5px; width: 10px; cursor: ew-resize; }
        .panel-resizer.right { top: 0; bottom: 0; right: -5px; width: 10px; cursor: ew-resize; }
        .panel-resizer.top-left { top: -5px; left: -5px; width: 10px; height: 10px; cursor: nwse-resize; z-index: 1; }
        .panel-resizer.top-right { top: -5px; right: -5px; width: 10px; height: 10px; cursor: nesw-resize; z-index: 1; }
        .panel-resizer.bottom-left { bottom: -5px; left: -5px; width: 10px; height: 10px; cursor: nesw-resize; z-index: 1; }
        .panel-resizer.bottom-right { bottom: -5px; right: -5px; width: 10px; height: 10px; cursor: nwse-resize; z-index: 1; }
        
        /* --- END: Floating Panel Styles --- */


        /* Glossary/TM specific styles */
        .glossary-input-group input, .glossary-input-group select,
        .tm-input-group input, .tm-input-group select,
        .qa-input-group input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9rem;
            margin-top: 4px;
            color: #202020;
            background-color: #fff;
        }
        .glossary-info-box, .tm-info-box {
            background-color: #f0f8ff;
            border: 1px solid #d0e8f8;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            color: #333;
        }
        .glossary-highlight {
            background-color: #ffcc00;
            padding: 0 2px;
            border-radius: 3px;
        }
        .glossary-row-highlight {
            background-color: #ffcc00 !important;
            transition: background-color 0.3s ease;
        }

        /* Active translation unit highlight */
        .translation-unit-active {
            border: 2px solid #075BA2;
            box-shadow: 0 0 0 3px rgba(7, 91, 162, 0.25);
        }

        /* Loading Overlay Styles */
        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1001; font-size: 1.2rem; color: #333;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db;
            border-radius: 50%; width: 40px; height: 40px;
            animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Accordion styles */
        .accordion-item { border: 1px solid #e5e7eb; border-radius: 0.5rem; overflow: hidden; margin-bottom: 1rem; }
        .accordion-header { display: flex; align-items: center; justify-content: space-between; cursor: pointer; padding: 0.75rem 1rem; background-color: #f9fafb; border-bottom: 1px solid #e5e7eb; user-select: none; }
        .accordion-header:hover { background-color: #f3f4f6; color: #075BA2; }
        .accordion-icon { transition: transform 0.3s ease; }
        .accordion-icon.rotated { transform: rotate(180deg); }
        .accordion-content { overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; padding: 0 1rem; }
        .accordion-content.collapsed { max-height: 0; padding-top: 0; padding-bottom: 0; }
        .accordion-content.expanded { max-height: 500px; padding-top: 1rem; padding-bottom: 1rem; }

        /* TM Table styles */
        .tm-table {
            table-layout: fixed;
            width: 100%;
        }
        .tm-table th:nth-child(1), .tm-table td:nth-child(1) { width: 15%; text-align: center; }
        .tm-table th:nth-child(2), .tm-table td:nth-child(2),
        .tm-table th:nth-child(3), .tm-table td:nth-child(3) {
            width: 42.5%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        .tm-best-match-highlight { background-color: #d1fae5 !important; border-color: #10b981 !important; border-width: 2px; box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.25); }
        
        /* Diff styles */
        .diff-deletion { background-color: #fdd; text-decoration: line-through; }
        .diff-insertion { background-color: #dfd; }

        /* QA Error Styles */
        .qa-error { color: #ef4444; font-weight: 700; }
        .qa-success { color: #22c55e; font-weight: 700; }
        #qaErrorStats.clickable { cursor: pointer; text-decoration: underline; }
        .qa-error-item { padding: 0.5rem; border-bottom: 1px solid #e5e7eb; cursor: pointer; transition: background-color 0.2s; }
        .qa-error-item:hover { background-color: #f3f4f6; }
        #qaErrorListContainer { max-height: 60vh; overflow-y: auto; }

        /* Header styles */
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 900;
            flex-wrap: wrap;
        }
        .header-main-actions {
            display: flex;
            flex-grow: 1;
            justify-content: center;
            gap: 0.5rem; /* Reduced gap for smaller buttons */
            flex-wrap: wrap;
        }
        .header-lang-switcher {
            display: flex;
            gap: 0.5rem;
        }

        /* Main content area */
        .main-app-content { display: flex; flex-direction: column; flex-grow: 1; padding: 1rem; gap: 1rem; }
        .editor-and-sidebars-wrapper { display: flex; flex-direction: column; flex-grow: 1; gap: 1rem; min-height: 0;}
        #horizontal-resizer { width: 10px; height: auto; cursor: col-resize; background-color: #e5e7eb; border-left: 1px solid #d1d5db; border-right: 1px solid #d1d5db; }
        #horizontal-resizer:hover { background-color: #d1d5db; }

        @media (min-width: 1024px) {
            .main-app-content { flex-direction: row; align-items: stretch; gap: 0; }
            .video-player-section { flex-shrink: 0; flex-basis: 33%; position: sticky; top: 60px; align-self: flex-start; 
max-height: calc(100vh - 80px); /* Altura máxima = 100% de la pantalla menos el header y un margen */
    overflow-y: auto; /* Muestra la barra de scroll vertical solo si es necesario */
    padding-right: 0.5rem; /* Pequeño espacio para que la barra no se pegue al contenido */
}
            .right-panel-content { 
                flex-grow: 1; 
                display: flex; 
                flex-direction: column; 
                gap: 0;
                overflow: hidden; /* ADDED to contain the scrolling child */
                min-height: 0;
            }
            .editor-and-sidebars-wrapper { flex-direction: column; flex-grow: 1; display: flex; }
            /* Let the editor grow to fill the available space */
            .editor-main-content { flex-grow: 1; overflow-y: auto; }
            /* Hide the old sidebar container and its resizer */
            .sidebars-container, #vertical-resizer { display: none; }
        }

        /* Video player styles */
        #videoPlayerContainer { width: 100%; background-color: #000; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem; gap: 1rem; }
        #videoPlayerWrapper { position: relative; width: 100%; line-height: 0; background-color: #000; border-radius: 0.5rem; min-height: 250px; }
        #videoPlayer { width: 100%; height: auto; max-height: calc(50vh - 105px); border-radius: 0.5rem; object-fit: contain; background-color: #000; }
        #subtitlePreviewOverlay { position: absolute; bottom: 10%; left: 0; right: 0; padding: 1rem; text-align: center; pointer-events: none; transition: opacity 0.3s ease; }
        #subtitlePreviewText { font-weight: 500; font-size: var(--user-font-size); color: white; padding: 0.10em 0.10em; background-color: rgba(0, 0, 0, 0.4); border-radius: 0.25rem; line-height: 1.4; text-shadow: 0px 0px 3px rgba(0,0,0,1); white-space: pre-wrap; }
        #videoFileInput { display: none; }

        /* Animation for Restore button */
        @keyframes pulse-yellow { 0%, 100% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.7); } 50% { box-shadow: 0 0 0 8px rgba(250, 204, 21, 0); } }
        .animate-pulse-yellow { animation: pulse-yellow 2s infinite; }

/* --- START: Fullscreen Video Controls & Subtitles --- */

/* Muestra la barra de controles en hover O en pantalla completa (con prefijos de compatibilidad) */
#videoPlayerWrapper:hover #videoControlsBar,
#videoPlayerWrapper:-webkit-full-screen #videoControlsBar,
#videoPlayerWrapper:-moz-full-screen #videoControlsBar,
#videoPlayerWrapper:fullscreen #videoControlsBar {
    opacity: 1;
}

/* Ajusta la posición de los subtítulos en pantalla completa para que no choquen con los controles */
#videoPlayerWrapper:-webkit-full-screen #subtitlePreviewOverlay,
#videoPlayerWrapper:-moz-full-screen #subtitlePreviewOverlay,
#videoPlayerWrapper:fullscreen #subtitlePreviewOverlay {
    bottom: 8%; 
}

/* Anula la restricción de altura del vídeo SÓLO en pantalla completa */
#videoPlayerWrapper.is-fullscreen #videoPlayer {
    width: 100% !important;
    height: 100% !important;
    max-height: 100% !important;
    object-fit: contain; 
}

/* --- END: Fullscreen Video Controls & Subtitles --- */

/* --- START: Custom Video Controls Styles --- */


        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #4a5568;
            border-radius: 5px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -4px; /* Center thumb on track */
        }
        input[type=range]:focus::-webkit-slider-runnable-track {
            background: #2d3748;
        }

          .volume-control {
            position: relative;
            /* Añadimos padding para crear un "puente" para el hover */
            padding-bottom: 0.5rem;
            margin-bottom: -0.5rem; /* Compensamos el padding para no mover otros elementos */
        }

        .volume-slider-container {
            position: absolute;
            /* Ajustamos la posición para que quede justo encima del botón */
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(17, 24, 39, 0.75);
            padding: 1rem 0.75rem;
            border-radius: 0.75rem;
            display: none;
        }

        .volume-control:hover .volume-slider-container {
            display: block;
        }

        #volumeBar {
            -webkit-appearance: slider-vertical;
            writing-mode: bt-lr;
            background-color: transparent;
            width: 15px;
            height: 96px;
        }

video::-webkit-media-controls-fullscreen-button {
    display: none;
}
video::-moz-fullscreen-button {
    display: none !important; /* Mantenemos esto con !important por si acaso */
    opacity: 0 !important;    /* Lo hacemos totalmente transparente */
    width: 0 !important;     /* Forzamos a que no tenga anchura */
    pointer-events: none;    /* Desactivamos cualquier clic sobre él */
}

video::-ms-fullscreen-button {
    display: none;
}

        /* --- END: Custom Video Controls Styles --- */

#customFullscreenBtn span {
    font-size: 28px;      /* Tamaño grande para el carácter */
    line-height: 1;       /* Centrado vertical perfecto */
}

/* --- START: Vertical Size Control Styles --- */
.size-control {
    position: relative;
    padding-bottom: 0.5rem;
    margin-bottom: -0.5rem;
}

.size-slider-container {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(17, 24, 39, 0.75);
    padding: 1rem 0.75rem;
    border-radius: 0.75rem;
    display: none;
}

.size-control:hover .size-slider-container {
    display: block;
}

#subtitleFontSize {
    -webkit-appearance: slider-vertical;
    writing-mode: bt-lr;
    background-color: transparent;
    width: 15px;
    height: 96px;
    cursor: pointer;
}

#subtitleFontSize::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 16px;
    width: 16px;
    border-radius: 50%;
    background: #ffffff;
    cursor: pointer;
    margin-top: 0;
    margin-left: -4px;
}

/* Estilos para el manejador en Firefox */
#volumeBar::-moz-range-thumb,
#subtitleFontSize::-moz-range-thumb {
    height: 16px;
    width: 16px;
    border-radius: 50%;
    background: #ffffff;
    cursor: pointer;
    border: none; /* Importante para evitar estilos por defecto */
}

/* Estilos para la pista en Firefox (opcional pero recomendado) */
#volumeBar::-moz-range-track,
#subtitleFontSize::-moz-range-track {
  background: #4a5568;
  border-radius: 5px;
  width: 8px;
}

/* --- START: Subtitle Source Control Styles --- */
.source-control {
    position: relative;
    padding-bottom: 0.5rem;
    margin-bottom: -0.5rem; /* Puente para el hover */
}

.source-options-container {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(17, 24, 39, 0.75);
    padding: 0.5rem;
    border-radius: 0.75rem;
    display: none; /* Oculto por defecto */
    flex-direction: column;
    gap: 0.25rem;
    width: 120px; /* Ancho fijo para el menú */
}

.source-control:hover .source-options-container {
    display: flex; /* Se muestra al hacer hover */
}

.source-option {
    background-color: transparent;
    color: white;
    padding: 0.5rem;
    border-radius: 0.5rem;
    text-align: center;
    font-size: 0.875rem;
    width: 100%;
    transition: background-color 0.2s ease;
}

.source-option:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.source-option.active {
    background-color: #075BA2; /* Color primario para la opción activa */
    font-weight: 700;
}
/* --- END: Subtitle Source Control Styles --- */

/* --- Planner Styles --- */
.session-row {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.5rem;
    border-radius: 0.5rem;
    border: 1px solid #e5e7eb;
    transition: background-color 0.2s;
    cursor: pointer;
}
.session-row:hover {
    background-color: #f9fafb;
}
.session-row.completed {
    background-color: #f0fdf4; /* green-50 */
}
.session-row.completed .session-text {
    text-decoration: line-through;
    color: #6b7280;
}
.session-row.active {
    border-color: #075BA2;
    box-shadow: 0 0 0 2px rgba(7, 91, 162, 0.2);
}
.session-text {
    flex-grow: 1;
    font-size: 0.875rem;
}
.session-time {
    font-family: monospace;
    font-weight: 600;
    background-color: #e5e7eb;
    padding: 0.1rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.9rem;
}

#sessionResults {
    max-height: 250px; /* Altura máxima para la lista antes de que aparezca el scroll */
    overflow-y: auto; /* Muestra el scroll vertical solo si la lista es más alta que max-height */
    padding-right: 0.25rem; /* Espacio para la barra de scroll */
}

#videoPlayerContainer {
    flex-shrink: 0;
}

/* --- END: Planner Styles --- */

/* --- Notificaciones (Toast) --- */
        #messageBox {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: auto;
            max-width: 350px;
            z-index: 2000;
            transition: opacity 0.3s ease-in-out; /* Solo transicionamos la opacidad */
            opacity: 0; /* Por defecto, es invisible */
            pointer-events: none; /* Evita que se pueda hacer clic cuando está invisible */
        }
        #messageBox.is-visible {
            opacity: 1;
            pointer-events: auto; /* Permite interacción cuando es visible */
        }
        #messageBox .modal-content {
            padding: 1rem 1.5rem;
            text-align: center;
        }
        #messageClose {
            display: none;
        }

/* --- INICIO: CÓDIGO PARA LA BARRA DE CONTROLES ADAPTABLE (DEFINITIVO) --- */

#videoPlayerWrapper {
    container-type: inline-size;
    container-name: video-wrapper;
}

@container video-wrapper (max-width: 480px) {
    #videoControlsBar .btn {
        font-size: 0.75rem;
        padding: 0.2rem 0.5rem;
    }
    #videoControlsRight {
        gap: 0.5rem;
    }
    #fontSizeDisplay {
        width: 2.75rem;
    }
    #videoControlsLeft span {
        display: none;
    }
    #videoControlsLeft::after {
        content: '🎥';
        font-size: 1.25rem;
        line-height: 1;
    }

    /* --- ÚLTIMO AJUSTE DE ALINEACIÓN --- */
    #setPreviewOriginal,
    #setPreviewTranslation {
        color: transparent;
        position: relative;
        width: 2rem;   /* Igualamos al ancho de los otros botones (w-8) */
        height: 2rem;  /* Igualamos a la altura de los otros botones (h-8) */
        padding-top: 0;
        padding-bottom: 0;
    }
    #setPreviewOriginal::after {
        content: 'O';
        font-size: 0.75rem;
        color: black;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
    #setPreviewTranslation::after {
        content: 'T';
        font-size: 0.75rem;
        color: white;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
}
/* --- FIN: CÓDIGO PARA LA BARRA DE CONTROLES ADAPTABLE --- */

/* --- INICIO: AÑADIR ESTE BLOQUE DE CSS --- */
        #statusBar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30px; /* Altura de la barra */
            background-color: #ffffff;
            border-top: 1px solid #d1d5db; /* Borde superior sutil */
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.05); /* Sombra ligera */
            z-index: 980; /* Encima del contenido, debajo de modales */
            padding: 0 1rem; /* Espaciado horizontal */
            display: flex;
            align-items: center;
            justify-content: center; /* Para contenido futuro */
            font-size: 0.875rem;
            color: #374151; /* Color de texto gris oscuro */
            transition: transform 0.3s ease-in-out;
            transform: translateY(100%); /* Oculto por defecto (movido hacia abajo) */
        }
        #statusBar.is-visible {
            transform: translateY(0); /* Visible (en su posición original) */
        }


/* --- FIN: AÑADIR ESTE BLOQUE DE CSS --- */

    </style>
</head>
<body class="bg-gray-100">
    <header class="app-header">
        <div class="header-main-actions">
            <div class="relative group">
                <button class="btn btn-primary inline-flex items-center">
                    <span data-i18n="project_menu">Proyecto</span>
                    <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </button>
                <div class="absolute z-10 -left-2 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform-gpu group-hover:scale-100 scale-95">
                    <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="options-menu">
                        <button id="newProjectBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
                            <span data-i18n="new_project">Nuevo proyecto</span>
                        </button>
                        <label for="projectFile" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 cursor-pointer" role="menuitem">
                            <span data-i18n="load_project">Cargar proyecto</span>
                            <input type="file" id="projectFile" accept=".subpanda" class="hidden">
                        </label>
                        <button id="saveProjectBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 disabled:text-gray-400" role="menuitem" disabled>
                            <span data-i18n="save_project">Guardar proyecto</span>
                        </button>
<div class="border-t border-gray-100"></div>
 <button id="backupBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
        <span data-i18n="backup_btn">Copia de seguridad</span>
    </button>
<div class="border-t border-gray-100"></div>
<button id="resetAppBtn" class="block w-full text-left px-4 py-2 text-sm text-red-700 hover:bg-red-50 hover:text-red-900" role="menuitem">
    <span data-i18n="reset_app_btn">Resetear aplicación</span>
</button>
                    </div>
                </div>
            </div>
            
            <label for="srtFile" class="btn btn-secondary">
                <span data-i18n="import_srt">Importar .srt</span>
                <input type="file" id="srtFile" accept=".srt" class="hidden">
            </label>
            <button id="saveSrt" class="btn btn-secondary" disabled>
                <span data-i18n="export_srt">Exportar .srt</span>
            </button>
<div class="relative group">
    <button class="btn btn-secondary inline-flex items-center">
        <span data-i18n="tools_menu">Herramientas</span>
        <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
    </button>
    <div class="absolute z-10 -left-2 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform-gpu group-hover:scale-100 scale-95">
        <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="options-menu">
 <button id="undoBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 disabled:text-gray-400" role="menuitem" disabled>
            <span data-i18n="undo_btn">Deshacer</span>
        </button>
        <button id="redoBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 disabled:text-gray-400" role="menuitem" disabled>
            <span data-i18n="redo_btn">Rehacer</span>
        </button>
        <div class="border-t border-gray-200"></div>
            <button id="findReplaceBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
                <span data-i18n="find_replace_btn">Buscar y reemplazar</span>
            </button>
            <button id="shortcutsBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
                <span data-i18n="shortcuts_btn">Atajos</span>
            </button>
<button id="goToSubtitleBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
        <span data-i18n="go_to_subtitle_menu">Ir a...</span>
    </button>
<button id="timecodeSettingsBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
    <span data-i18n="timecode_settings_btn">Ajustes de Timecode</span>
</button>
<button id="toggleStatusBarBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900" role="menuitem">
                <span data-i18n="show_status_bar_btn">Mostrar barra de estado</span>
            </button>
        </div>
    </div>
</div>
                        <button id="qaBtn" class="btn btn-secondary">
                <span data-i18n="qa_btn">QA</span>
            </button>
            <button id="contextBtn" class="btn btn-secondary">
    <span data-i18n="context_btn">IA</span>
</button>

            <button id="terminologyBtn" class="btn btn-secondary">
                <span data-i18n="terminology_btn">Terminología</span>
            </button>
            <button id="tmBtn" class="btn btn-secondary">
                <span data-i18n="tm_btn">Memoria de traducción</span>
            </button>
        </div>
        <div class="header-lang-switcher">
            <button id="lang-es" class="btn btn-lang active">ES</button>
            <button id="lang-en" class="btn btn-lang">EN</button>
        </div>
    </header>

    <div class="main-app-content">
       <div class="video-player-section flex flex-col items-center justify-center p-4">

    <div id="videoPlayerContainer" class="w-full">
        <div id="videoPlayerWrapper" class="relative bg-black rounded-lg group">
            <div id="videoControlsBar" class="absolute top-0 left-0 right-0 z-10 w-full flex justify-between items-center p-2 bg-black bg-opacity-50 transition-opacity duration-300 opacity-0 group-hover:opacity-100">
        
        <label for="videoFileInput" id="videoControlsLeft" class="btn btn-primary py-2">
            <span data-i18n="load_video">Cargar vídeo</span>
            <input type="file" id="videoFileInput" accept="video/*" class="hidden">
        </label>
    
        <div id="videoControlsRight" class="flex items-center gap-4">
            <div class="flex items-center gap-1 p-1 bg-gray-700 rounded-md">
                <button id="setPreviewOriginal" class="btn py-2 btn-secondary" data-i18n="original_text_option">Original</button>
                <button id="setPreviewTranslation" class="btn py-2 btn-secondary" data-i18n="translation_text_option">Traducción</button>
            </div>
            <div class="flex items-center gap-2 text-white">
                <button id="decreaseFontSize" class="btn btn-secondary w-8 h-8 flex items-center justify-center text-lg">-</button>
                <span id="fontSizeDisplay" class="font-semibold text-sm w-12 text-center">22px</span>
                <button id="increaseFontSize" class="btn btn-secondary w-8 h-8 flex items-center justify-center text-lg">+</button>
                <button id="customFullscreenBtn" class="btn btn-secondary w-8 h-8 flex items-center justify-center">
                    <span id="fullscreen-enter-char">⛶</span>
                    <span id="fullscreen-exit-char" class="hidden">⤡</span>
                </button>
            </div>
        </div>
    </div>
    <video id="videoPlayer" class="w-full h-auto rounded-lg"></video>
    
            <div id="videoLogoPlaceholder" class="absolute inset-0 flex items-center justify-center pointer-events-none">
                <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/subpandatm-logo.png" alt="subpandaTM Logo" class="h-24 w-auto opacity-75">
            </div>
    
            <div id="subtitlePreviewOverlay">
                <span id="subtitlePreviewText"></span>
            </div>
        </div>
    </div>
    
    <div id="waveform" class="bg-white p-4 rounded-lg shadow-xl w-full mt-4 hidden">
        </div>
        <div id="waveformControls" class="w-full bg-gray-50 p-2 rounded-b-lg shadow-lg flex justify-center items-center gap-3 -mt-1 hidden">
            <button id="lockWaveformBtn" class="btn btn-secondary" title="Bloquear/Desbloquear onda">
                <svg class="lock-icon-open w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5V6.75a4.5 4.5 0 1 0-9 0v3.75m.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" />
                </svg>
                <svg class="lock-icon-closed hidden w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 10.5V6.75a4.5 4.5 0 1 0-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" />
                </svg>
            </button>
<button id="followPlaybackBtn" class="btn btn-secondary">
        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M2.036 12.322a1.012 1.012 0 0 1 0-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178Z" />
          <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
        </svg>
    </button>
            <button id="zoomOutBtn" class="btn btn-secondary" data-i18n-title="zoom_out">
                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607ZM7.5 10.5h6" /> </svg>
            </button>
            <button id="zoomInBtn" class="btn btn-secondary" data-i18n-title="zoom_in">
                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607ZM10.5 7.5v3m0 0v3m0-3h3m-3 0h-3" />
                </svg>
            </button>
        </div>
                <div id="statsContainer" class="bg-white p-4 rounded-lg shadow-xl w-full mt-4 hidden">
                    <div class="accordion-item">
                        <div class="accordion-header" id="statsAccordionHeader">
                            <h3 class="text-lg font-bold" data-i18n="translation_stats_title">Estadísticas</h3>
                            <svg class="w-5 h-5 accordion-icon rotated" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </div>
                        <div class="accordion-content collapsed" id="statsAccordionContent">
                            <div class="bg-gray-100 p-3 rounded-md shadow-sm text-sm text-center space-y-1">
                                <p><span id="segmentsProgress"></span></p>
                                <p><span id="wordsTranslated"></span> / <span id="wordsTotal"></span></p>
                                <p><span id="wordsRemaining"></span></p>
                                <p id="qaErrorStats"></p>
                            </div>
                        </div>
                    </div>
                </div>
    <div id="plannerContainer" class="bg-white p-4 rounded-lg shadow-xl w-full mt-4 hidden">
        <div class="accordion-item">
            <div class="accordion-header" id="plannerAccordionHeader">
                <h3 class="text-lg font-bold" data-i18n="planner_title">Planificador</h3>
                <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </div>
            <div class="accordion-content collapsed" id="plannerAccordionContent">
                <div class="flex flex-col sm:flex-row items-center gap-2 p-2 bg-gray-50 rounded-lg">
        <div class="flex items-center gap-2 flex-shrink-0">
            <label for="sessionCount" class="text-sm font-medium" data-i18n="planner_divide_in">Dividir en:</label>
            <input type="number" id="sessionCount" value="3" min="1" class="w-16 p-1 border border-gray-300 rounded-md text-center">
            <label for="sessionCount" class="text-sm font-medium" data-i18n="planner_sessions">sesiones</label>
        </div>
        <div class="flex-grow w-full">
            <select id="divisionMethod" class="w-full p-1.5 border border-gray-300 rounded-md text-sm">
                <option value="subtitles" data-i18n="planner_method_subs">Por número de subtítulos</option>
                <option value="words" data-i18n="planner_method_words">Por número de palabras</option>
                <option value="time" data-i18n="planner_method_time">Por tiempo</option>
            </select>
        </div>
        <button id="calculateSessionsBtn" class="btn btn-primary w-full sm:w-auto" data-i1admin="planner_calculate">Calcular</button>
    </div>
                <div id="sessionResults" class="mt-4 space-y-2">
                    </div>
            </div>
        </div>
    </div>

</div> <div id="horizontal-resizer"></div>

        <div class="right-panel-content">
            <div class="editor-and-sidebars-wrapper" id="editorAndSidebarsWrapper">
                <div class="editor-main-content space-y-4 pr-2" id="editorMainContent">
                    <div id="translationsContainer">
                        <div data-i18n="no_translations" id="initialMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md">
                           Importa un archivo .srt y un vídeo para empezar a trabajar. Si lo deseas, puedes trabajar con una memoria de traducción TMX y un glosario TBX, que puedes importar o crear desde cero.
                        </div>
                    </div>
                </div>

                <div id="vertical-resizer"></div>

                <div class="sidebars-container">
                </div>
            </div>
        </div>
    </div>

    <div id="terminologySidebar" class="floating-panel">
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="terminology_sidebar_title">Terminología</h3>
            <div class="flex items-center">
                <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posición y tamaño">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
                </button>
                <button id="closeTerminologySidebarBtn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>
        <div class="sidebar-content">
            <div id="terminologyLanguageConfigSection" class="space-y-4">
                <h4 class="text-md font-semibold mb-2" data-i18n="config_lang_title">Configurar idiomas del glosario</h4>
                <div class="glossary-info-box mb-4">
                    <p data-i18n="config_lang_info"></p>
                </div>
                <div class="flex flex-col space-y-2 mb-4">
                    <div class="glossary-input-group">
                        <label for="configSrcLang" data-i18n="source_language">Idioma de origen:</label>
                        <input id="configSrcLang" list="isoLanguages" value="en-US" class="block w-full rounded-md" />
                    </div>
                    <div class="glossary-input-group">
                        <label for="configTgtLang" data-i18n="target_language">Idioma de destino:</label>
                        <input id="configTgtLang" list="isoLanguages" value="es-ES" class="block w-full rounded-md" />
                    </div>
                    <button onclick="confirmGlossaryLanguages()" data-i18n="confirm_languages" class="btn btn-primary w-full">Confirmar idiomas</button>
                </div>
            </div>

            <div id="terminologyEditorSection" style="display:none;">
                <div class="flex flex-col sm:flex-row gap-2 mb-4">
                    <button onclick="loadTBX()" data-i18n="import_tbx" class="btn btn-secondary flex-1 text-sm">Importar TBX</button>
                    <input type="file" id="tbxFileInput" accept=".xml,.tbx" class="hidden" />
                    <button onclick="downloadTBX()" data-i18n="download_tbx" class="btn btn-secondary flex-1 text-sm">Descargar TBX</button>
                    <button onclick="showConfirmResetGlossary()" data-i18n="new_glossary" class="btn btn-secondary flex-1 text-sm">Nuevo glosario</button>
                </div>
                <h4 class="text-md font-semibold mb-2" data-i18n="current_lang_title">Idiomas actuales del glosario</h4>
                <div class="flex space-x-2 mb-4">
                    <div class="glossary-input-group flex-1">
                        <label data-i18n="source_language">Idioma de origen:</label>
                        <input id="displaySrcLang" disabled class="block w-full rounded-md" />
                    </div>
                    <div class="glossary-input-group flex-1">
                        <label data-i18n="target_language">Idioma de destino:</label>
                        <input id="displayTgtLang" disabled class="block w-full rounded-md" />
                    </div>
                </div>
                <div class="accordion-item">
                    <div class="accordion-header" id="addTermHeader">
                        <h4 class="text-md font-semibold m-0" data-i18n="add_term_title">Añadir término</h4>
                        <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </div>
                    <div class="accordion-content collapsed" id="addTermContent">
                        <div class="flex flex-col space-y-2 mb-4">
                            <div class="glossary-input-group">
                                <label for="srcTerm" data-i18n="term">Término:</label>
                                <input id="srcTerm" class="block w-full rounded-md" />
                            </div>
                            <div class="glossary-input-group">
                                <label for="tgtTerm" data-i18n="translation">Traducción:</label>
                                <input id="tgtTerm" class="block w-full rounded-md" />
                            </div>
                            <button onclick="addTerm()" data-i18n="add_button" class="btn btn-primary w-full">Añadir</button>
                        </div>
                    </div>
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="search_title">Buscar</h4>
                <div class="mb-4">
                    <input id="searchTerm" data-i18n-placeholder="search_placeholder" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white" oninput="renderGlossary()" />
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="glossary_list_title">Glosario</h4>
                <div class="overflow-x-auto">
                    <table class="w-full">
                        <thead>
                            <tr>
                                <th data-i18n="source_term_col">Término de origen</th>
                                <th data-i18n="target_term_col">Término de destino</th>
                                <th data-i18n="actions_col">Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="glossaryTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
        <datalist id="isoLanguages"></datalist>
    </div>

    <div id="translationMemorySidebar" class="floating-panel">
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="tm_sidebar_title">Memoria de traducción</h3>
            <div class="flex items-center">
                <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posición y tamaño">
                   <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
                </button>
                <button id="closeTranslationMemorySidebarBtn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>
        <div class="sidebar-content">
            <div id="tmInternalMessage" class="tm-info-box mb-4 hidden"></div>
            <div id="tmLanguageConfigSection" class="space-y-4">
                <h4 class="text-md font-semibold mb-2" data-i18n="tm_config_lang_title">Configurar idiomas de la TM</h4>
                <div class="tm-info-box mb-4">
                    <p data-i18n="tm_config_lang_info"></p>
                </div>
                <div class="flex flex-col space-y-2 mb-4">
                    <div class="tm-input-group">
                        <label for="tmConfigSrcLang" data-i18n="source_language">Idioma de origen:</label>
                        <input id="tmConfigSrcLang" list="isoLanguages" value="en-US" class="block w-full rounded-md" />
                    </div>
                    <div class="tm-input-group">
                        <label for="tmConfigTgtLang" data-i18n="target_language">Idioma de destino:</label>
                        <input id="tmConfigTgtLang" list="isoLanguages" value="es-ES" class="block w-full rounded-md" />
                    </div>
                    <button onclick="confirmTMLanguages()" data-i18n="confirm_languages" class="btn btn-primary w-full">Confirmar idiomas</button>
                </div>
            </div>

            <div id="tmEditorSection" style="display:none;">
                <div class="flex flex-col sm:flex-row gap-2 mb-4">
                    <button onclick="showConfirmResetTm()" data-i18n="new_tm" class="btn btn-secondary flex-1 text-sm">Nueva TM</button>
                    <label for="tmFileInput" class="btn btn-secondary flex-1 text-sm text-center">
                        <span data-i18n="import_tmx">Importar TMX</span>
                        <input type="file" id="tmFileInput" accept=".xml,.tmx" class="hidden" />
                    </label>
                    <button onclick="downloadTMX()" data-i18n="download_tmx" class="btn btn-secondary flex-1 text-sm">Descargar TMX</button>
                </div>
                <h4 class="text-md font-semibold mb-2" data-i18n="current_tm_lang_title">Idiomas actuales de la TM</h4>
                <div class="flex space-x-2 mb-4">
                    <div class="tm-input-group flex-1">
                        <label data-i18n="source_language">Idioma de origen:</label>
                        <input id="displayTmSrcLang" disabled class="block w-full rounded-md" />
                    </div>
                    <div class="tm-input-group flex-1">
                        <label data-i18n="target_language">Idioma de destino:</label>
                        <input id="displayTmTgtLang" disabled class="block w-full rounded-md" />
                    </div>
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="tm_search_title">Buscar en TM</h4>
                <div class="mb-4">
                    <input id="tmSearchInput" data-i18n-placeholder="tm_search_placeholder" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white" oninput="tmSearch()" />
                </div>
                <h4 class="text-md font-semibold mt-4 mb-2" data-i18n="tm_search_results_title">Resultados de búsqueda en TM</h4>
                <div class="overflow-x-auto mb-4">
                    <table class="tm-table w-full">
                        <thead>
                            <tr>
                                <th data-i18n="tm_score_col">%</th>
                                <th data-i18n="tm_original_col">Original</th>
                                <th data-i18n="tm_translation_col">Traducción</th>
                            </tr>
                        </thead>
                        <tbody id="tmSearchResultsTableBody"></tbody>
                    </table>
                </div>
                <div data-i18n="tm_no_match_found" id="tmNoMatchFoundMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md hidden">
                    No se encontraron coincidencias en la TM.
                </div>
            </div>
        </div>
    </div>

    <div id="messageBox" class="modal hidden">
        <div class="modal-content">
            <p id="messageText" class="text-lg font-semibold mb-4"></p>
            <button id="messageClose" class="btn btn-primary w-full" data-i18n="ok">OK</button>
        </div>
    </div>
    
    <div id="shortcutsModal" class="modal hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 data-i18n="shortcuts_title" class="text-xl font-bold">Atajos de teclado</h2>
                <div class="flex gap-2">
                    <label for="importShortcutsInput" class="btn btn-secondary text-sm" data-i18n="import_shortcuts_btn">Importar</label>
                    <input type="file" id="importShortcutsInput" class="hidden" accept=".json">
                    <button id="exportShortcutsBtn" class="btn btn-secondary text-sm" data-i18n="export_shortcuts_btn">Exportar</button>
                </div>
<div class="flex items-center gap-2">
                    <label for="shortcutProfileSelector" class="text-sm font-medium">Perfil:</label>
                    <select id="shortcutProfileSelector" class="text-sm rounded-md border-gray-300 shadow-sm">
                        <option value="windows">Windows / Linux</option>
                        <option value="mac">macOS</option>
                    </select>
                </div>
            </div>
            <div id="shortcutsList" class="space-y-2 max-h-[60vh] overflow-y-auto pr-2">
                </div>
            <div class="flex justify-between items-center mt-6">
                <button id="restoreShortcutsBtn" class="btn btn-destructive" data-i18n="restore_defaults_btn">Restaurar valores por defecto</button>
                <button id="shortcutsCloseBtn" class="btn btn-primary" data-i18n="close_btn">Cerrar</button>
            </div>
        </div>
    </div>

<div id="findReplacePanel" class="floating-panel" style="width: 600px; height: auto;">
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="find_replace_title">Buscar y reemplazar</h3>
            <div class="flex items-center">
                <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posición y tamaño">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
                </button>
                <button id="closeFindReplacePanelBtn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>
        <div class="sidebar-content p-4">
            <div class="space-y-4">
                <div>
                    <label for="findInput" data-i18n="find_label" class="block text-sm font-medium mb-1">Buscar:</label>
                    <input type="text" id="findInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div>
                    <label for="replaceInput" data-i18n="replace_label" class="block text-sm font-medium mb-1">Reemplazar con:</label>
                    <input type="text" id="replaceInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex items-center space-x-4">
                    <label class="flex items-center">
                        <input type="checkbox" id="caseSensitiveCheckbox" class="mr-2 rounded">
                        <span data-i18n="case_sensitive">Distinguir mayúsculas y minúsculas</span>
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" id="regexCheckbox" class="mr-2 rounded">
                        <span data-i18n="regular_expression">Expresión regular</span>
                    </label>
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="findPrevBtn" class="btn btn-secondary" data-i18n="find_prev">Buscar anterior</button>
                    <button id="findNextBtn" class="btn btn-secondary" data-i18n="find_next">Buscar siguiente</button>
                    <button id="replaceBtn" class="btn btn-primary" data-i18n="replace">Reemplazar</button>
                    <button id="replaceAllBtn" class="btn btn-destructive" data-i18n="replace_all">Reemplazar todo</button>
                </div>
            </div>
        </div>
    </div>

    <div id="saveSrtModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_srt_title" class="text-xl font-bold mb-4">Exportar Archivo SRT</h2>
            <div class="space-y-4">
                <div>
                    <label for="fileNameInput" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="fileNameInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>
    <div id="saveTbxModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_tbx_title" class="text-xl font-bold mb-4">Exportar Archivo TBX</h2>
            <div class="space-y-4">
                <div>
                    <label for="fileNameInputTbx" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="fileNameInputTbx" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveTbxBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveTbxBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>

    <div id="saveTmxModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_tmx_title" class="text-xl font-bold mb-4">Exportar Archivo TMX</h2>
            <div class="space-y-4">
                <div>
                    <label for="fileNameInputTmx" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="fileNameInputTmx" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveTmxBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveTmxBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>
    <div id="backupModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="backup_modal_title" class="text-xl font-bold mb-4">Copia de Seguridad</h2>
            <div id="backupFoundView">
                <div id="backupInfo" class="bg-gray-100 p-4 rounded-md mb-4">
                    <p data-i18n="restore_backup_info"></p>
                    <p><strong><span data-i18n="file_label"></span></strong> <span id="backupFileName"></span></p>
                    <p><strong><span data-i18n="last_modified_label"></span></strong> <span id="backupLastModified"></span></p>
                </div>
                <div class="flex justify-end space-x-2 flex-wrap gap-2">
                    <button data-i18n="export_srt_btn" id="exportSrtFromBackupBtn" class="btn btn-primary">Exportar SRT</button>
                    <button data-i18n="delete_backup_btn" id="deleteBackupBtn" class="btn btn-destructive">Borrar Backup</button>
                    <button data-i18n="restore_btn" id="confirmRestoreBtn" class="btn btn-primary">Restaurar</button>
                </div>
            </div>
            <div id="noBackupFoundView" class="hidden">
                 <p data-i18n="no_backup_found_info"></p>
            </div>
            <button data-i18n="close_btn" id="closeBackupModalBtn" class="btn btn-secondary w-full mt-6">Cerrar</button>
        </div>
    </div>
    <div id="qaModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="qa_modal_title" class="text-xl font-bold mb-4">Configuración de QA</h2>
            <div class="space-y-4">
                <div class="qa-input-group">
                    <label for="qaCpsLimit" data-i18n="cps_limit_label" class="block text-sm font-medium mb-1">Límite de CPS:</label>
                    <input type="number" id="qaCpsLimit" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="qa-input-group">
                    <label for="qaCharsPerLineLimit" data-i18n="chars_per_line_limit_label" class="block text-sm font-medium mb-1">Límite de caracteres por línea:</label>
                    <input type="number" id="qaCharsPerLineLimit" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
            </div>
            <div class="flex justify-end space-x-2 mt-6">
                 <button id="closeQaModalBtn" class="btn btn-secondary" data-i18n="close_btn">Cerrar</button>
                <button id="saveQaSettingsBtn" class="btn btn-primary" data-i18n="save_and_apply_btn">Guardar y aplicar</button>
            </div>
        </div>
    </div>
    <div id="qaErrorListModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="qa_error_list_title" class="text-xl font-bold mb-4">Lista de Errores de QA</h2>
            <div id="qaErrorListContainer"></div>
            <button id="closeQaErrorListModalBtn" class="btn btn-secondary w-full mt-6" data-i18n="close_btn">Cerrar</button>
        </div>
    </div>
    <div id="reselectVideoModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="reselect_video_title" class="text-xl font-bold mb-4">Seleccionar vídeo</h2>
            <p data-i18n="reselect_video_info" id="reselectVideoInfo" class="mb-4"></p>
            <label for="reselectVideoInput" class="btn btn-primary w-full">
                <span data-i18n="load_video">Cargar vídeo</span>
                <input type="file" id="reselectVideoInput" accept="video/*" class="hidden">
            </label>
            <button id="skipReselectVideoBtn" class="btn btn-secondary w-full mt-2" data-i18n="skip_btn">Omitir</button>
        </div>
    </div>
<div id="saveProjectModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="save_project_title" class="text-xl font-bold mb-4">Guardar Proyecto</h2>
            <div class="space-y-4">
                <div>
                    <label for="projectFileNameInput" data-i18n="file_name_label" class="block text-sm font-medium mb-1">Nombre del archivo:</label>
                    <input type="text" id="projectFileNameInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                </div>
                <div class="flex justify-end space-x-2">
                    <button id="cancelSaveProjectBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                    <button id="confirmSaveProjectBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
                </div>
            </div>
        </div>
    </div>
    <div id="confirmNewProjectModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="confirm_new_project_title" class="text-xl font-bold mb-4">Crear nuevo proyecto</h2>
            <p data-i18n="confirm_new_project_message" class="mb-6">Tienes cambios sin guardar. ¿Quieres guardar el proyecto actual antes de continuar?</p>
            <div class="flex justify-end space-x-2">
                <button id="cancelNewProjectBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                <button id="continueWithoutSavingBtn" class="btn btn-destructive" data-i18n="continue_without_saving_btn">Continuar sin guardar</button>
                <button id="saveAndContinueBtn" class="btn btn-primary" data-i18n="save_and_continue_btn">Guardar y continuar</button>
            </div>
        </div>
    </div>

    <div id="confirmResetGlossaryModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="confirm_new_glossary_title" class="text-xl font-bold mb-4">Confirmar nuevo glosario</h2>
            <p data-i18n="confirm_new_glossary_message" class="mb-6">Solo puedes tener un glosario activo. Si continúas, se borrarán todos los datos del glosario actual. Para evitar perder tu trabajo, asegúrate de exportarlo primero como un archivo TBX.</p>
            <div class="flex justify-end space-x-2">
                <button id="cancelResetGlossaryBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                <button id="confirmResetGlossaryBtn" class="btn btn-destructive" data-i18n="continue_btn">Continuar</button>
            </div>
        </div>
    </div>

    <div id="confirmResetTmModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="confirm_new_tm_title" class="text-xl font-bold mb-4">Confirmar nueva TM</h2>
            <p data-i18n="confirm_new_tm_message" class="mb-6">Solo puedes tener una memoria de traducción (TM) activa. Si continúas, se borrarán todos los datos de la TM actual. Para evitar perder tu trabajo, asegúrate de exportarla primero como un archivo TMX.</p>
            <div class="flex justify-end space-x-2">
                <button id="cancelResetTmBtn" class="btn btn-secondary" data-i18n="cancel_btn">Cancelar</button>
                <button id="confirmResetTmBtn" class="btn btn-destructive" data-i18n="continue_btn">Continuar</button>
            </div>
        </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="loading-spinner"></div>
        <p id="loadingMessage"></p>
    </div>

    <div id="contextSidebar" class="floating-panel">
        <div class="sidebar-header">
            <h3 class="text-lg font-bold" data-i18n="context_sidebar_title">Contexto IA</h3>
            <div class="flex items-center">
                <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posición y tamaño">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
                </button>
                <button id="closeContextSidebarBtn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>
        <div class="sidebar-content p-4" id="contextSidebarContent">
            <div id="contextImportView">
                <h4 class="font-bold text-md mb-2" data-i18n="load_context_title">Cargar Contexto</h4>
                <div class="accordion-item mb-4">
    <div class="accordion-header" id="contextHelpHeader">
        <h4 class="text-md font-semibold m-0" data-i18n="context_help_title">¿Cómo funciona?</h4>
        <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
    </div>
    <div class="accordion-content collapsed" id="contextHelpContent">
        <div class="space-y-2 text-sm">
            <p data-i18n="context_help_intro"></p>
            <p data-i18n="context_help_format"></p>
        </div>
    </div>
</div>
                
                <div class="flex items-center gap-2 mb-1">
    <button id="copyPromptBtn" class="btn btn-primary flex-1" data-i18n="copy_prompt_btn"></button>
    <button id="pasteJsonBtn" class="btn btn-secondary" data-i18n="paste_json_btn"></button>
    <button id="aiSettingsBtn" class="btn btn-secondary p-2" title="Personalizar Prompt">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
    </button>
</div>
                <div id="jsonValidationStatus" class="text-xs h-5 mb-2"></div>
                
                <textarea id="contextPasteArea" class="w-full h-32 p-2 border rounded-md mb-2" data-i18n-placeholder="paste_json_placeholder"></textarea>
                <button id="importFromPasteBtn" class="btn btn-primary w-full mb-4" data-i18n="import_from_paste_btn"></button>
                
                <div class="text-center my-2 text-gray-500 font-semibold" data-i18n="or_divider"></div>
                
<label for="contextFileInput" class="btn btn-secondary w-full text-center cursor-pointer block">
                    <span data-i18n="import_from_file_btn"></span>
                    <input type="file" id="contextFileInput" accept=".json" class="hidden">
                </label>
            </div>

            <div id="contextDisplayView" class="hidden"></div>
        </div>
    </div>

<div id="aiSettingsModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="ai_settings_title" class="text-xl font-bold mb-4">Personalizar prompt de IA</h2>
            <p data-i18n="ai_settings_intro" class="text-sm text-gray-600 mb-4">
                Añade hasta tres instrucciones para la IA. La primera es obligatoria y viene con un texto por defecto que puedes modificar. Las pautas de QA se añadirán automáticamente.
            </p>
            <div class="space-y-3">
                <div>
                    <label for="aiInstruction1" class="block text-sm font-medium mb-1" data-i18n="ai_instruction_1_label">Instrucción 1 (Obligatoria):</label>
                    <textarea id="aiInstruction1" rows="3" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></textarea>
                </div>
                <div>
                    <label for="aiInstruction2" class="block text-sm font-medium mb-1" data-i18n="ai_instruction_2_label">Instrucción 2 (Opcional):</label>
                    <textarea id="aiInstruction2" rows="2" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></textarea>
                </div>
                <div>
                    <label for="aiInstruction3" class="block text-sm font-medium mb-1" data-i18n="ai_instruction_3_label">Instrucción 3 (Opcional):</label>
                    <textarea id="aiInstruction3" rows="2" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></textarea>
                </div>
            </div>
            <div class="flex justify-end space-x-2 mt-6">
                 <button id="closeAiSettingsModalBtn" class="btn btn-secondary" data-i18n="close_btn">Cerrar</button>
                <button id="saveAiSettingsBtn" class="btn btn-primary" data-i18n="save_btn">Guardar</button>
            </div>
        </div>
    </div>

<div id="timecodeModal" class="modal hidden">
        <div class="modal-content">
            <h2 data-i18n="timecode_modal_title" class="text-xl font-bold mb-4">Ajustes de Timecode</h2>
            <div class="space-y-4">
                
                <div class="qa-input-group">
                    <label for="projectFpsInput" data-i18n="project_fps_label" class="block text-sm font-medium mb-1">FPS del Proyecto:</label>
                    <select id="projectFpsInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                        <option value="23.976">23.976</option>
                        <option value="24">24</option>
                        <option value="25" selected>25</option>
                        <option value="29.97">29.97</option>
                        <option value="30">30</option>
                        <option value="50">50</option>
                        <option value="59.94">59.94</option>
                        <option value="60">60</option>
                        <option value="custom">Otro...</option>
                    </select>
                    <input type="number" id="projectFpsCustomInput" step="0.001" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white mt-2 hidden" placeholder="Escribe FPS personalizado">
                </div>
                
                <div class="glossary-info-box bg-blue-50 border-blue-200">
                    <p data-i18n="fps_recommendation_note" class="text-blue-700"></p>
                </div>
                <div class="flex items-center">
                    <input type="checkbox" id="useFrameTimecodeToggle" class="mr-2 rounded">
                    <label for="useFrameTimecodeToggle" data-i18n="show_frames_label" class="text-sm font-medium">Mostrar timecode en frames (ej. 00:00:10:05)</label>
                </div>
                <div class="glossary-info-box">
                    <p data-i18n="timecode_warning">Aviso: La exportación SRT siempre usará milisegundos por compatibilidad.</p>
                </div>
            </div>
            <div class="flex justify-end space-x-2 mt-6">
                 <button id="closeTimecodeModalBtn" class="btn btn-secondary" data-i18n="close_btn">Cerrar</button>
                <button id="saveTimecodeSettingsBtn" class="btn btn-primary" data-i18n="save_and_apply_btn">Guardar y aplicar</button>
            </div>
        </div>
    </div>

<div id="goToSubtitlePanel" class="floating-panel" style="width: 320px; height: auto;">
    <div class="sidebar-header">
        <h3 class="text-lg font-bold" data-i18n="go_to_subtitle_title">Ir a Subtítulo / TC</h3>
        <div class="flex items-center">
            <button class="reset-panel-btn text-gray-500 hover:text-gray-700 mr-2" title="Restaurar posición y tamaño">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20l6-6M20 4l-6 6"></path></svg>
            </button>
            <button id="closeGoToSubtitlePanelBtn" class="text-gray-500 hover:text-gray-700">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>
    <div class="sidebar-content p-4 space-y-4">
        <div>
            <label for="goToSubtitleInput" class="block text-sm font-medium mb-1" data-i18n="go_to_subtitle_label">Ir al subtítulo Nº:</label>
            <div class="flex gap-2">
                <input type="number" id="goToSubtitleInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white" min="1">
                <button id="goToSubtitleActionBtn" class="btn btn-primary" data-i18n="go_btn">Ir</button>
            </div>
        </div>
        <div>
            <label for="goToTimecodeInput" class="block text-sm font-medium mb-1" data-i18n="go_to_timecode_label">Ir al timecode:</label>
            <div class="flex gap-2">
                <input type="text" id="goToTimecodeInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 font-mono text-black bg-white" value="00:00:00,000" onfocus="this.select()">
                <button id="goToTimecodeActionBtn" class="btn btn-primary" data-i18n="go_btn">Ir</button>
            </div>
        </div>
    </div>
</div>


    <script>
        // --- IndexedDB Setup (Dexie.js) ---
        const db = new Dexie("subpandaTM_v2");
        db.version(1).stores({
            projects: '++id, fileName',
            settings: 'key' // Using 'key' as the primary key for settings objects
        });

        // Global variables
        let srtEntries = [];
        let currentFileName = 'subtitles.srt';
        let videoFileName = null;
let wavesurfer = null;
let wsRegions = null;
        let currentLanguage = 'es';
        let findState = { query: '', replace: '', caseSensitive: false, useRegex: false, lastFound: null };
        let previewSource = 'translation';
let subtitleFontSize = 20; // Tamaño de fuente inicial en píxeles
        let qaSettings = { cpsLimit: 20, charsPerLineLimit: 42 };
        let termsFoundInActiveSegment = new Set();
        let glossary = [];
        let glossarySourceLanguage = '';
        let glossaryTargetLanguage = '';
        let currentGlossaryLatestResults = [];
        let translationMemory = [];
        let tmSourceLanguage = '';
        let tmTargetLanguage = '';
        let tmBestMatchForActiveSegment = null;
        let currentTMLatestSearchResults = [];
        let timeUpdateListener = null;
let contextData = [];
let lastActiveSubtitleIndex = 0;
let afterSaveAction = null;
let messageTimeout = null;
let projectFPS = 25;
let useFrameTimecode = false;
let historyStack = [];
let redoStack = [];
let debounceTimeout = null;
let isApplyingState = false; 
let isWaveformLocked = false;
let currentWaveformZoom = 100; // Valor inicial (minPxPerSec)
const ZOOM_STEP = 20; // Cuánto zoom añadir/quitar cada vez
let isFollowPlaybackActive = false;
let currentlyTrackedRegionId = null;
let currentlyTrackedEditorIndex = -1;
let lastFocusedEditorUnitIndex = -1;
        
        const DIFF_DELETE = -1;
        const DIFF_INSERT = 1;
        const DIFF_EQUAL = 0;

        // DOM elements
        const srtFile = document.getElementById('srtFile');
        const saveSrtButton = document.getElementById('saveSrt');
        const translationsContainer = document.getElementById('translationsContainer');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageClose = document.getElementById('messageClose');
        const dropArea = document.querySelector('.main-app-content');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const videoPlayerContainer = document.getElementById('videoPlayerContainer');
        const videoPlayer = document.getElementById('videoPlayer');
        const videoFileInput = document.getElementById('videoFileInput');
        const subtitlePreviewText = document.getElementById('subtitlePreviewText');
const setPreviewOriginal = document.getElementById('setPreviewOriginal');
const setPreviewTranslation = document.getElementById('setPreviewTranslation');
const decreaseFontSize = document.getElementById('decreaseFontSize');
const increaseFontSize = document.getElementById('increaseFontSize');
const fontSizeDisplay = document.getElementById('fontSizeDisplay');
const videoPlayerWrapper = document.getElementById('videoPlayerWrapper');
const customFullscreenBtn = document.getElementById('customFullscreenBtn');
const fullscreenEnterChar = document.getElementById('fullscreen-enter-char');
const fullscreenExitChar = document.getElementById('fullscreen-exit-char');
                const statsContainer = document.getElementById('statsContainer');
        const segmentsProgress = document.getElementById('segmentsProgress');
        const wordsTranslated = document.getElementById('wordsTranslated');
        const wordsTotal = document.getElementById('wordsTotal');
        const wordsRemaining = document.getElementById('wordsRemaining');
        const qaErrorStats = document.getElementById('qaErrorStats');
        const statsAccordionHeader = document.getElementById('statsAccordionHeader');
        const statsAccordionContent = document.getElementById('statsAccordionContent');
        const statsAccordionIcon = statsAccordionHeader.querySelector('.accordion-icon');
        const shortcutsBtn = document.getElementById('shortcutsBtn');
        const shortcutsModal = document.getElementById('shortcutsModal');
        const shortcutsCloseBtn = document.getElementById('shortcutsCloseBtn');
        const findReplaceBtn = document.getElementById('findReplaceBtn');
        const findReplacePanel = document.getElementById('findReplacePanel');
        const closeFindReplacePanelBtn = document.getElementById('closeFindReplacePanelBtn');
        const findInput = document.getElementById('findInput');
        const replaceInput = document.getElementById('replaceInput');
        const caseSensitiveCheckbox = document.getElementById('caseSensitiveCheckbox');
        const regexCheckbox = document.getElementById('regexCheckbox');
        const findPrevBtn = document.getElementById('findPrevBtn');
        const findNextBtn = document.getElementById('findNextBtn');
        const replaceBtn = document.getElementById('replaceBtn');
        const replaceAllBtn = document.getElementById('replaceAllBtn');
        const findReplaceCloseBtn = document.getElementById('findReplaceCloseBtn');
        const saveSrtModal = document.getElementById('saveSrtModal');
        const fileNameInput = document.getElementById('fileNameInput');
        const confirmSaveBtn = document.getElementById('confirmSaveBtn');
        const cancelSaveBtn = document.getElementById('cancelSaveBtn');
        const backupBtn = document.getElementById('backupBtn');
        const backupModal = document.getElementById('backupModal');
        const backupFoundView = document.getElementById('backupFoundView');
        const noBackupFoundView = document.getElementById('noBackupFoundView');
        const backupFileName = document.getElementById('backupFileName');
        const backupLastModified = document.getElementById('backupLastModified');
        const closeBackupModalBtn = document.getElementById('closeBackupModalBtn');
        const exportSrtFromBackupBtn = document.getElementById('exportSrtFromBackupBtn');
        const deleteBackupBtn = document.getElementById('deleteBackupBtn');
        const confirmRestoreBtn = document.getElementById('confirmRestoreBtn');
        const qaBtn = document.getElementById('qaBtn');
        const qaModal = document.getElementById('qaModal');
        const qaCpsLimitInput = document.getElementById('qaCpsLimit');
        const qaCharsPerLineLimitInput = document.getElementById('qaCharsPerLineLimit');
        const saveQaSettingsBtn = document.getElementById('saveQaSettingsBtn');
        const closeQaModalBtn = document.getElementById('closeQaModalBtn');
        const qaErrorListModal = document.getElementById('qaErrorListModal');
        const qaErrorListContainer = document.getElementById('qaErrorListContainer');
        const closeQaErrorListModalBtn = document.getElementById('closeQaErrorListModalBtn');
        const terminologyBtn = document.getElementById('terminologyBtn');
        const terminologySidebar = document.getElementById('terminologySidebar');
        const closeTerminologySidebarBtn = document.getElementById('closeTerminologySidebarBtn');
        const terminologyLanguageConfigSection = document.getElementById('terminologyLanguageConfigSection');
        const terminologyEditorSection = document.getElementById('terminologyEditorSection');
        const configSrcLang = document.getElementById('configSrcLang');
        const configTgtLang = document.getElementById('configTgtLang');
        const displaySrcLang = document.getElementById('displaySrcLang');
        const displayTgtLang = document.getElementById('displayTgtLang');
        const srcTermInput = document.getElementById('srcTerm');
        const tgtTermInput = document.getElementById('tgtTerm');
        const searchTermInput = document.getElementById('searchTerm');
        const glossaryTableBody = document.getElementById('glossaryTableBody');
        const tbxFileInput = document.getElementById('tbxFileInput');
        const isoLanguagesDatalist = document.getElementById('isoLanguages');
        const addTermHeader = document.getElementById('addTermHeader');
        const addTermContent = addTermHeader.nextElementSibling;
        const addTermAccordionIcon = addTermHeader.querySelector('.accordion-icon');
        const tmBtn = document.getElementById('tmBtn');
        const translationMemorySidebar = document.getElementById('translationMemorySidebar');
        const closeTranslationMemorySidebarBtn = document.getElementById('closeTranslationMemorySidebarBtn');
        const tmFileInput = document.getElementById('tmFileInput');
        const tmSearchInput = document.getElementById('tmSearchInput');
        const tmSearchResultsTableBody = document.getElementById('tmSearchResultsTableBody');
        const tmNoMatchFoundMessage = document.getElementById('tmNoMatchFoundMessage');
        const tmLanguageConfigSection = document.getElementById('tmLanguageConfigSection');
        const tmEditorSection = document.getElementById('tmEditorSection');
        const tmConfigSrcLang = document.getElementById('tmConfigSrcLang');
        const tmConfigTgtLang = document.getElementById('tmConfigTgtLang');
        const displayTmSrcLang = document.getElementById('displayTmSrcLang');
        const displayTmTgtLang = document.getElementById('displayTmTgtLang');
        const tmInternalMessage = document.getElementById('tmInternalMessage');
        const langEsBtn = document.getElementById('lang-es');
        const langEnBtn = document.getElementById('lang-en');
        const shortcutsList = document.getElementById('shortcutsList');
        const exportShortcutsBtn = document.getElementById('exportShortcutsBtn');
        const importShortcutsInput = document.getElementById('importShortcutsInput');
        const restoreShortcutsBtn = document.getElementById('restoreShortcutsBtn');
        const saveTbxModal = document.getElementById('saveTbxModal');
        const fileNameInputTbx = document.getElementById('fileNameInputTbx');
        const confirmSaveTbxBtn = document.getElementById('confirmSaveTbxBtn');
        const cancelSaveTbxBtn = document.getElementById('cancelSaveTbxBtn');
        const saveTmxModal = document.getElementById('saveTmxModal');
        const fileNameInputTmx = document.getElementById('fileNameInputTmx');
        const confirmSaveTmxBtn = document.getElementById('confirmSaveTmxBtn');
        const cancelSaveTmxBtn = document.getElementById('cancelSaveTmxBtn');
        // Project elements
        const newProjectBtn = document.getElementById('newProjectBtn');
        const saveProjectBtn = document.getElementById('saveProjectBtn');
        const projectFile = document.getElementById('projectFile');
const resetAppBtn = document.getElementById('resetAppBtn');
        const reselectVideoModal = document.getElementById('reselectVideoModal');
        const reselectVideoInfo = document.getElementById('reselectVideoInfo');
        const reselectVideoInput = document.getElementById('reselectVideoInput');
        const skipReselectVideoBtn = document.getElementById('skipReselectVideoBtn');
        const confirmNewProjectModal = document.getElementById('confirmNewProjectModal');
        const cancelNewProjectBtn = document.getElementById('cancelNewProjectBtn');
        const continueWithoutSavingBtn = document.getElementById('continueWithoutSavingBtn');
        const saveAndContinueBtn = document.getElementById('saveAndContinueBtn');
        const saveProjectModal = document.getElementById('saveProjectModal');
const projectFileNameInput = document.getElementById('projectFileNameInput');
const confirmSaveProjectBtn = document.getElementById('confirmSaveProjectBtn');
const cancelSaveProjectBtn = document.getElementById('cancelSaveProjectBtn');
        const confirmResetGlossaryModal = document.getElementById('confirmResetGlossaryModal');
        const confirmResetGlossaryBtn = document.getElementById('confirmResetGlossaryBtn');
        const cancelResetGlossaryBtn = document.getElementById('cancelResetGlossaryBtn');
        const confirmResetTmModal = document.getElementById('confirmResetTmModal');
        const confirmResetTmBtn = document.getElementById('confirmResetTmBtn');
        const cancelResetTmBtn = document.getElementById('cancelResetTmBtn');

const contextBtn = document.getElementById('contextBtn');
const contextSidebar = document.getElementById('contextSidebar');
const closeContextSidebarBtn = document.getElementById('closeContextSidebarBtn');
const contextFile = document.getElementById('contextFile');
const goToSubtitleBtn = document.getElementById('goToSubtitleBtn');
const goToSubtitlePanel = document.getElementById('goToSubtitlePanel');
const closeGoToSubtitlePanelBtn = document.getElementById('closeGoToSubtitlePanelBtn');
const goToSubtitleInput = document.getElementById('goToSubtitleInput');
const goToSubtitleActionBtn = document.getElementById('goToSubtitleActionBtn');
const goToTimecodeInput = document.getElementById('goToTimecodeInput');
const goToTimecodeActionBtn = document.getElementById('goToTimecodeActionBtn');
const contextHelpHeader = document.getElementById('contextHelpHeader');
const contextHelpContent = document.getElementById('contextHelpContent');
// --- INICIO: Nuevos elementos DOM de la botonera ---
const waveformControls = document.getElementById('waveformControls');
const lockWaveformBtn = document.getElementById('lockWaveformBtn');
const zoomInBtn = document.getElementById('zoomInBtn');
const zoomOutBtn = document.getElementById('zoomOutBtn');
const lockIconOpen = document.querySelector('.lock-icon-open');
const lockIconClosed = document.querySelector('.lock-icon-closed');
const followPlaybackBtn = document.getElementById('followPlaybackBtn'); 
// --- FIN: Nuevos elementos DOM de la botonera ---

        // --- I18N & SHORTCUTS SETUP ---

        const translations = {
            'es': {
                'title': 'subpandaTM', 'import_srt': 'Importar .srt', 'export_srt': 'Exportar .srt', 'backup_btn': 'Copia de seguridad', 'qa_btn': 'QA', 'shortcuts_btn': 'Atajos', 'find_replace_btn': 'Buscar y reemplazar', 'terminology_btn': 'Terminología', 'tm_btn': 'Memoria de traducción', 'load_video': 'Cargar vídeo', 'change_video': 'Cambiar vídeo', 'preview_size': 'Tamaño:', 'preview_source': 'Mostrar:', 'translation_text_option': 'Traducción', 'original_text_option': 'Original', 'translation_stats_title': 'Estadísticas', 'segments_progress_text': '{0}/{1} subtítulos traducidos ({2}%)', 'words_translated_text': '{0} palabras traducidas', 'words_total_text': '{0} palabras originales totales', 'words_remaining_text': '{0} palabras pendientes', 'no_translations': 'Importa un archivo .srt y un vídeo para empezar a trabajar. Si lo deseas, puedes trabajar con una memoria de traducción TMX y un glosario TBX, que puedes importar o crear desde cero.', 'time_codes': 'Códigos de tiempo:', 'original_text': 'Original:', 'translation_text': 'Traducción:', 'validate': 'Validar', 'edit': 'Editar', 'char_count_original': 'Original: ', 'char_count_translation': 'Traducción: ', 'char_units': ' c', 'cps': ' CPS', 'ok': 'OK', 'close_btn': 'Cerrar', 'save_btn': 'Guardar', 'cancel_btn': 'Cancelar', 'shortcuts_title': 'Atajos de teclado',
                'shortcut_desc_validateAndNext': 'Validar traducción y pasar a la siguiente', 'shortcut_desc_goToNext': 'Ir al siguiente subtítulo', 'shortcut_desc_goToPrevious': 'Ir al subtítulo anterior', 'shortcut_desc_insertTM1': 'Insertar 1ª sugerencia de la MT', 'shortcut_desc_insertTM2': 'Insertar 2ª sugerencia de la MT', 'shortcut_desc_insertTM3': 'Insertar 3ª sugerencia de la MT', 'shortcut_desc_insertTM4': 'Insertar 4ª sugerencia de la MT', 'shortcut_desc_insertTM5': 'Insertar 5ª sugerencia de la MT', 'shortcut_desc_insertGloss1': 'Insertar 1er término del glosario', 'shortcut_desc_insertGloss2': 'Insertar 2º término del glosario', 'shortcut_desc_insertGloss3': 'Insertar 3er término del glosario', 'shortcut_desc_insertGloss4': 'Insertar 4º término del glosario', 'shortcut_desc_insertGloss5': 'Insertar 5º término del glosario', 'shortcut_desc_jumpToTime': 'Saltar al tiempo de inicio del subtítulo actual', 'shortcut_desc_playSegment': 'Reproducir el subtítulo actual', 'shortcut_desc_playPause': 'Reproducir/pausar vídeo', 'shortcut_desc_seekForward': 'Avanzar 3 segundos', 'shortcut_desc_seekBackward': 'Retroceder 3 segundos', 'shortcut_desc_seekForwardFast': 'Avanzar 5 segundos', 'shortcut_desc_seekBackwardFast': 'Retroceder 5 segundos', 'shortcut_desc_bold': 'Aplicar negrita', 'shortcut_desc_italic': 'Aplicar cursiva',
                'find_replace_title': 'Buscar y reemplazar', 'find_label': 'Buscar:', 'replace_label': 'Reemplazar con:', 'case_sensitive': 'Distinguir mayúsculas y minúsculas', 'regular_expression': 'Expresión regular', 'find_prev': 'Buscar anterior', 'find_next': 'Buscar siguiente', 'replace': 'Reemplazar', 'replace_all': 'Reemplazar todo', 'save_srt_title': 'Exportar Archivo SRT', 'save_tbx_title': 'Exportar Archivo TBX', 'save_tmx_title': 'Exportar Archivo TMX', 'file_name_label': 'Nombre del archivo:', 'backup_modal_title': 'Copia de Seguridad', 'restore_backup_info': 'Se ha encontrado una copia de seguridad de una sesión no guardada.', 'file_label': 'Archivo:', 'last_modified_label': 'Última modificación:', 'export_srt_btn': 'Exportar SRT', 'delete_backup_btn': 'Borrar Backup', 'restore_btn': 'Restaurar', 'no_backup_found_info': 'No se ha encontrado ninguna copia de seguridad automática.', 'qa_modal_title': 'Configuración de QA', 'cps_limit_label': 'Límite de CPS:', 'chars_per_line_limit_label': 'Límite de caracteres por línea:', 'save_and_apply_btn': 'Guardar y aplicar', 'qa_error_list_title': 'Lista de Errores de QA', 'qa_errors_found': '{0} errores de QA encontrados', 'qa_no_errors': 'No se han encontrado errores de QA.', 'terminology_sidebar_title': 'Terminología', 'config_lang_title': 'Configurar idiomas del glosario', 'config_lang_info': 'Define los idiomas de origen y destino de tu glosario. Es fundamental que el código ISO sea correcto. Tras configurar el idioma, podrás importar o crear un glosario desde cero.', 'source_language': 'Idioma de origen:', 'target_language': 'Idioma de destino:', 'confirm_languages': 'Confirmar idiomas', 'current_lang_title': 'Idiomas actuales del glosario', 'add_term_title': 'Añadir término', 'term': 'Término:', 'translation': 'Traducción:', 'add_button': 'Añadir', 'search_title': 'Buscar', 'search_placeholder': 'Buscar término...', 'import_tbx': 'Importar TBX', 'download_tbx': 'Descargar TBX', 'new_glossary': 'Nuevo glosario', 'glossary_list_title': 'Glosario', 'source_term_col': 'Término de origen', 'target_term_col': 'Término de destino', 'actions_col': 'Acciones', 'delete_button': 'Eliminar', 'tm_sidebar_title': 'Memoria de traducción', 'tm_config_lang_title': 'Configurar idiomas de la TM', 'tm_config_lang_info': 'Define los idiomas de origen y destino de tu memoria de traducción. Es fundamental que el código ISO sea correcto. Tras configurar el idioma, podrás importar o crear una memoria desde cero.', 'current_tm_lang_title': 'Idiomas actuales de la TM', 'new_tm': 'Nueva TM', 'import_tmx': 'Importar TMX', 'download_tmx': 'Descargar TMX', 'tm_search_title': 'Buscar en TM', 'tm_search_placeholder': 'Buscar en la memoria...', 'tm_search_results_title': 'Resultados de búsqueda en TM', 'tm_score_col': '%', 'tm_original_col': 'Original', 'tm_translation_col': 'Traducción', 'tm_no_match_found': 'No se encontraron coincidencias en la TM.',
                'import_shortcuts_btn': 'Importar', 'export_shortcuts_btn': 'Exportar', 'restore_defaults_btn': 'Restaurar valores por defecto', 'edit_shortcut_btn': 'Editar', 'recording_shortcut_text': 'Pulsar tecla...', 'project_menu': 'Proyecto', 'load_project': 'Cargar proyecto', 'save_project': 'Guardar proyecto', 'new_project': 'Nuevo proyecto', 'reselect_video_title': 'Seleccionar vídeo', 'reselect_video_info': 'Proyecto cargado. Para sincronizar el vídeo, por favor, selecciona el archivo de vídeo original:', 'reselect_video_prompt': 'Proyecto cargado. Por favor, selecciona el archivo de vídeo original: {0}', 'skip_btn': 'Omitir', 'confirm_new_project_title': 'Crear nuevo proyecto', 'confirm_new_project_message': 'Tienes cambios sin guardar. ¿Quieres guardar el proyecto actual antes de continuar?', 'continue_without_saving_btn': 'Continuar sin guardar',  'save_and_continue_btn': 'Guardar y continuar',
                'confirm_new_glossary_title': 'Confirmar nuevo glosario', 'confirm_new_glossary_message': 'Solo puedes tener un glosario activo. Si continúas, se borrarán todos los datos del glosario actual. Para evitar perder tu trabajo, asegúrate de exportarlo primero como un archivo TBX.','confirm_new_tm_title': 'Confirmar nueva TM','confirm_new_tm_message': 'Solo puedes tener una memoria de traducción (TM) activa. Si continúas, se borrarán todos los datos de la TM actual. Para evitar perder tu trabajo, asegúrate de exportarla primero como un archivo TMX.', 'continue_btn': 'Continuar',
                'productive_documentation': 'Documentación productiva', 'doc_resource_placeholder': 'Ej: https://dle.rae.es/{word}', 
'entry_time': 'Entrada:',
                'exit_time': 'Salida:',
                'duration_label': 'Duración:',
                'rewind_frame_tooltip': 'Retroceder 1 fotograma (40ms)',
                'play_segment_tooltip': 'Reproducir subtítulo',
                'forward_frame_tooltip': 'Avanzar 1 fotograma (40ms)',
'shortcut_desc_playSegmentLoop': 'Reproducir subtítulo actual en bucle',
'validate_all_previous': 'Validar ant.',
'validate_all_previous_tooltip': 'Validar este y todos los subtítulos anteriores',
'context_sidebar_title': 'Asistente de IA',
'context_btn': 'IA',
'import_context': 'Importar contexto',
'ai_translation_title': 'Sugerencia de la IA:',
'context_notes_title': 'Consultas:',
'pretranslate_all_btn': 'Pretraducir todo',
        'pretranslate_all_title': 'Rellena todos los subtítulos con la sugerencia principal de la IA',
        'instruction_1': 'Instrucción 1',
        'instruction_2': 'Instrucción 2',
        'instruction_3': 'Instrucción 3',
'no_context_available': 'No hay contexto disponible para este subtítulo.',
'load_context_title': 'Importar sugerencias de la IA',
'context_help_title': '¿Cómo funciona?',
'context_help_intro': 'Este asistente sirve para añadir propuestas o sugerencias de la IA que irán apareciendo en cada subtítulo a medida que vayas traduciendo. Puedes personalizar hasta 3 consultas que se irán mostrando a la vez, junto con aclaraciones sobre el contexto o problemas de traducción que detecte la IA que uses. ',
'context_help_format': 'Para usar esta característica, primero debes asegurarte de haber importado un archivo SRT. Si ya lo has importado, el siguiente paso es personalizar tus prompts en el icono de la rueda mecánica. Cuando hayas terminado de redactar tus prompts, solo tendrás que darle a "Copiar prompt" y pegar y enviar el texto copiado a la IA que hayas elegido (recomendamos Gemini Pro). La respuesta que obtendrás será un código JSON que debes copiar y pegar en el siguiente recuadro haciendo clic en "Pegar código". Si el código que hayas pegado está correcto, verás un aviso en color verde. En ese caso, haz clic en "Importar desde texto" y en adelante podrás usar las sugerencias de la IA para cada subtítulo en esta misma ventana.',
'paste_json_placeholder': 'Pega aquí el código JSON...',
'import_from_paste_btn': 'Importar desde texto',
'or_divider': 'o',
'import_from_file_btn': 'Importar desde archivo .json',
'reset_context': 'Cargar nuevo',
'copy_prompt_btn': 'Copiar prompt',
'paste_json_btn': 'Pegar código',
'json_valid': 'El código JSON es válido.',
'json_invalid': 'El código JSON es incorrecto.',
'prompt_copied_success': 'Prompt copiado al portapapeles.',
'clipboard_paste_error': 'No se ha podido pegar desde el portapapeles.',
'load_srt_first': 'Primero debes cargar un archivo SRT.',
'suggestion_primary': 'Traducción literal',
'suggestion_natural': 'Natural y fluida',
'suggestion_technical': 'Ajustada a CPS y CPL',
'tools_menu': 'Herramientas',
'go_to_subtitle_menu': 'Ir a...',
'go_to_subtitle_title': 'Ir a...',
'go_to_subtitle_label': 'Ir al subtítulo nº:',
'go_to_timecode_label': 'Ir al código de tiempo:',
'go_btn': 'Ir',
'ai_default_instruction_1': 'Traduce los subtítulos a español de España. Separa en dos líneas los subtítulos que tengan más de {0} caracteres. Procura que todos los subtítulos tengan menos de {1} caracteres por segundo.',
'reset_app_btn': 'Resetear aplicación',
'reset_app_confirm': '¿Estás seguro de que quieres resetear la aplicación? Se borrarán todos los proyectos, backups y ajustes guardados en este navegador. Esta acción no se puede deshacer.',
'reset_app_success': 'Aplicación reseteada. Recargando...',
'reset_db_error': 'Error al resetear la aplicación. Por favor, borra la caché del navegador manualmente.',
'reset_storage_error': 'Ha ocurrido un error durante el reseteo.',
'planner_title': 'Planificador',
'planner_divide_in': 'Dividir en:',
'planner_sessions': 'sesiones',
'planner_method_subs': 'Por número de subtítulos',
'planner_method_words': 'Por número de palabras',
'planner_method_time': 'Por tiempo',
'planner_calculate': 'Calcular',
'planner_load_srt_warning': 'Carga un archivo SRT para poder usar el planificador.',
'planner_session_subs': 'Subtítulos #{0} - #{1}',
'planner_session_time': 'Tiempo {0} - {1} (hasta Sub. #{2})',
'planner_session_words': 'Subtítulos #{0} - #{1} (~{2} palabras)',
'planner_words_label': 'palabras',
'planner_session_qa': 'Revisión / QA',
'save_project_title': 'Guardar proyecto',
                'confirm_restore_message': '¿Estás seguro de que quieres restaurar la copia de seguridad? Se perderá todo el trabajo no guardado en la sesión actual.',
'replacements_made': 'Se han hecho {0} reemplazos.',
'undo_btn': 'Deshacer',
'redo_btn': 'Rehacer',
'linebreak_tooltip_text': 'Salto de línea = Mayus + Enter',
'delete_subtitle_confirm': '¿Seguro que quieres eliminar este subtítulo? ', 
'merge_next_tooltip': 'Fusionar con el subtítulo siguiente',
    'split_tooltip': 'Separar subtítulo en la posición del cursor',
    'delete_tooltip': 'Eliminar subtítulo',
'lock_waveform': 'Bloquear onda',
'unlock_waveform': 'Desbloquear onda',
'zoom_out': 'Alejar zoom',
'zoom_in': 'Aumentar zoom',
'follow_playback_on': 'Activar seguimiento de reproducción',
'follow_playback_off': 'Desactivar seguimiento de reproducción',
'show_status_bar_btn': 'Mostrar estadísticas',
            'hide_status_bar_btn': 'Ocultar estadísticas',
'timecode_settings_btn': 'Ajustes de tiempo',
'timecode_modal_title': 'Ajustes de tiempo',
'project_fps_label': 'FPS del proyecto:',
'fps_recommendation_note': 'Sugerencia: Para una sincronización precisa, comprueba los FPS de tu archivo de vídeo en las propiedades y selecciona el mismo valor aquí.', 
'show_frames_label': 'Mostrar código de tiempo en frames (ej. 00:00:10:05)',
'timecode_warning': 'Aviso: La exportación SRT siempre usará milisegundos por compatibilidad.',
'timecode_format_error': 'El formato del código de tiempo noes válido. Usa HH:MM:SS:FF.',

            },
            'en': {
                'title': 'subpandaTM', 'import_srt': 'Import .srt', 'export_srt': 'Export .srt', 'backup_btn': 'Backup', 'qa_btn': 'QA', 'shortcuts_btn': 'Shortcuts', 'find_replace_btn': 'Find & Replace', 'terminology_btn': 'Terminology', 'tm_btn': 'Translation Memory', 'load_video': 'Load Video', 'change_video': 'Change Video', 'preview_size': 'Size:', 'preview_source': 'Show:', 'translation_text_option': 'Translation', 'original_text_option': 'Original', 'translation_stats_title': 'Statistics', 'segments_progress_text': '{0}/{1} subtitles translated ({2}%)', 'words_translated_text': '{0} words translated', 'words_total_text': '{0} total original words', 'words_remaining_text': '{0} words remaining', 'no_translations': 'Import an .srt file and a video to start working. If you wish, you can work with a TMX translation memory and a TBX glossary, which you can import or create from scratch.', 'time_codes': 'Time codes:', 'original_text': 'Original:', 'translation_text': 'Translation:', 'validate': 'Validate', 'edit': 'Edit', 'char_count_original': 'Original: ', 'char_count_translation': 'Translation: ', 'char_units': ' c', 'cps': ' CPS', 'ok': 'OK', 'close_btn': 'Close', 'save_btn': 'Save', 'cancel_btn': 'Cancel', 'shortcuts_title': 'Keyboard Shortcuts',
                'shortcut_desc_validateAndNext': 'Validate translation and move to next', 'shortcut_desc_goToNext': 'Go to next subtitle', 'shortcut_desc_goToPrevious': 'Go to previous subtitle', 'shortcut_desc_insertTM1': 'Insert 1st TM suggestion', 'shortcut_desc_insertTM2': 'Insert 2nd TM suggestion', 'shortcut_desc_insertTM3': 'Insert 3rd TM suggestion', 'shortcut_desc_insertTM4': 'Insert 4th TM suggestion', 'shortcut_desc_insertTM5': 'Insert 5th TM suggestion', 'shortcut_desc_insertGloss1': 'Insert 1st glossary term', 'shortcut_desc_insertGloss2': 'Insert 2nd glossary term', 'shortcut_desc_insertGloss3': 'Insert 3rd glossary term', 'shortcut_desc_insertGloss4': 'Insert 4th glossary term', 'shortcut_desc_insertGloss5': 'Insert 5th glossary term', 'shortcut_desc_jumpToTime': 'Jump to current subtitle start time', 'shortcut_desc_playSegment': 'Play current subtitle', 'shortcut_desc_playPause': 'Play/pause video', 'shortcut_desc_seekForward': 'Seek forward 3 seconds', 'shortcut_desc_seekBackward': 'Seek backward 3 seconds', 'shortcut_desc_seekForwardFast': 'Seek forward 5 seconds', 'shortcut_desc_seekBackwardFast': 'Seek backward 5 seconds', 'shortcut_desc_bold': 'Apply bold', 'shortcut_desc_italic': 'Apply italics',
                'find_replace_title': 'Find and Replace', 'find_label': 'Find:', 'replace_label': 'Replace with:', 'case_sensitive': 'Case sensitive', 'regular_expression': 'Regular expression', 'find_prev': 'Find previous', 'find_next': 'Find next', 'replace': 'Replace', 'replace_all': 'Replace all', 'save_srt_title': 'Export SRT File', 'save_tbx_title': 'Export TBX File', 'save_tmx_title': 'Export TMX File', 'file_name_label': 'File name:', 'backup_modal_title': 'Backup', 'restore_backup_info': 'A backup of an unsaved session has been found.', 'file_label': 'File:', 'last_modified_label': 'Last modified:', 'export_srt_btn': 'Export SRT', 'delete_backup_btn': 'Delete Backup', 'restore_btn': 'Restore', 'no_backup_found_info': 'No automatic backup has been found.', 'qa_modal_title': 'QA Settings', 'cps_limit_label': 'CPS Limit:', 'chars_per_line_limit_label': 'Characters per line limit:', 'save_and_apply_btn': 'Save and apply', 'qa_error_list_title': 'QA Error List', 'qa_errors_found': '{0} QA errors found', 'qa_no_errors': 'No QA errors found.', 'terminology_sidebar_title': 'Terminology', 'config_lang_title': 'Set up glossary languages', 'config_lang_info': 'Define the source and target languages for your glossary. The ISO code must be correct. After setting the language, you can import or create a glossary from scratch.', 'source_language': 'Source language:', 'target_language': 'Target language:', 'confirm_languages': 'Confirm languages', 'current_lang_title': 'Current glossary languages', 'add_term_title': 'Add term', 'term': 'Term:', 'translation': 'Translation:', 'add_button': 'Add', 'search_title': 'Search', 'search_placeholder': 'Search term...', 'import_tbx': 'Import TBX', 'download_tbx': 'Download TBX', 'new_glossary': 'New glossary', 'glossary_list_title': 'Glossary', 'source_term_col': 'Source term', 'target_term_col': 'Target term', 'actions_col': 'Actions', 'delete_button': 'Delete', 'tm_sidebar_title': 'Translation Memory', 'tm_config_lang_title': 'Set up TM languages', 'tm_config_lang_info': 'Define the source and target languages for your translation memory. The ISO code must be correct. After setting the language, you can import or create a memory from scratch.', 'current_tm_lang_title': 'Current TM languages', 'new_tm': 'New TM', 'import_tmx': 'Import TMX', 'download_tmx': 'Download TMX', 'tm_search_title': 'Search TM', 'tm_search_placeholder': 'Search in memory...', 'tm_search_results_title': 'TM Search Results', 'tm_score_col': '%', 'tm_original_col': 'Original', 'tm_translation_col': 'Translation', 'tm_no_match_found': 'No matches found in the TM.',
                'import_shortcuts_btn': 'Import', 'export_shortcuts_btn': 'Export', 'restore_defaults_btn': 'Restore Defaults', 'edit_shortcut_btn': 'Edit', 'recording_shortcut_text': 'Press key...',
                'project_menu': 'Project', 'load_project': 'Load project', 'save_project': 'Save project', 'new_project': 'New project', 'reselect_video_title': 'Select Video', 'reselect_video_info': 'Project loaded. To sync the video, please select the original video file:', 'reselect_video_prompt': 'Project loaded. Please select the original video file: {0}', 'skip_btn': 'Skip', 'confirm_new_project_title': 'Create new project', 'confirm_new_project_message': 'You have unsaved changes. Do you want to save the current project before continuing?',
                'continue_without_saving_btn': 'Continue without saving', 
                'save_and_continue_btn': 'Save and continue',
                'confirm_new_glossary_title': 'Confirm New Glossary',
                'confirm_new_glossary_message': 'You can only have one active glossary. If you continue, all data from the current glossary will be deleted. To avoid losing your work, make sure to export it as a TBX file first.',
                'confirm_new_tm_title': 'Confirm New TM',
                'confirm_new_tm_message': 'You can only have one active Translation Memory (TM). If you continue, all data from the current TM will be deleted. To avoid losing your work, make sure to export it as a TMX file first.',
                'continue_btn': 'Continue', 
                'productive_documentation': 'Productivity Documentation',
                'doc_resource_placeholder': 'E.g., https://www.wordreference.com/es/en/{word}',
'entry_time': 'Start:',
                'exit_time': 'End:',
                'duration_label': 'Duration:',
                'rewind_frame_tooltip': 'Rewind 1 frame (40ms)',
                'play_segment_tooltip': 'Play current subtitle',
                'forward_frame_tooltip': 'Forward 1 frame (40ms)',
'shortcut_desc_playSegmentLoop': 'Play current subtitle in a loop',
'validate_all_previous': 'Validate prev.',
'validate_all_previous_tooltip': 'Validate this and all previous subtitles',
'context_sidebar_title': 'AI Assistant',
'context_btn': 'AI',
'import_context': 'Import Context',
'ai_translation_title': 'AI Suggestion:',
'context_notes_title': 'Prompts:',
'pretranslate_all_btn': 'Pre-translate all',
        'pretranslate_all_title': 'Fill all subtitles with the main AI suggestion',
        'instruction_1': 'Prompt  1',
        'instruction_2': 'Prompt  2',
        'instruction_3': 'Prompt  3',
'no_context_available': 'No context available for this subtitle.',
'load_context_title': 'Import AI Suggestions',
'context_help_title': 'How does it work?',
'context_help_intro': 'This assistant helps you add AI-powered suggestions that appear alongside each subtitle as you translate. You can set up to three custom prompts to show at once, along with notes the AI detects about context or possible translation issues.',
'context_help_format': 'To get started, make sure you’ve imported an SRT file. If you have, click the gear icon to set up your prompts. When you’re happy with them, hit “Copy prompt”, then paste and send that text to your preferred AI (we recommend Gemini Pro). The AI will return a JSON code — just copy it, click “Paste code” below, and drop it in. If everything looks good, you’ll see a green confirmation. From there, click “Import from text”, and you’ll start seeing the AI’s suggestions for each subtitle right here in this window.',
'paste_json_placeholder': 'Paste the JSON code here...',
'import_from_paste_btn': 'Import from text',
'or_divider': 'or',
'import_from_file_btn': 'Import from .json file',
'reset_context': 'Load New',
'copy_prompt_btn': 'Copy prompt',
'paste_json_btn': 'Paste code',
'json_valid': 'Valid JSON code.',
'json_invalid': 'Incorrect JSON code.',
'prompt_copied_success': 'Prompt copied to clipboard.',
'clipboard_paste_error': 'Could not paste from clipboard.',
'load_srt_first': 'You must load an SRT file first.',
'suggestion_primary': 'Literal translation',
'suggestion_natural': 'Natural and fluent',
'suggestion_technical': 'Within the CPS and CPL guidelines',
'tools_menu': 'Tools',
'go_to_subtitle_menu': 'Go to...',
'go_to_subtitle_title': 'Go to...',
'go_to_subtitle_label': 'Go to subtitle #:',
'go_to_timecode_label': 'Go to timecode:',
'go_btn': 'Go',
'ai_default_instruction_1': 'Translate the subtitles to Spanish (Spain). Split subtitles longer than {0} characters into two lines. Try to keep all subtitles under {1} characters per second.',
'reset_app_btn': 'Reset Application',
'reset_app_confirm': 'Are you sure you want to reset the application? All saved projects, backups, and settings in this browser will be deleted. This action cannot be undone.',
'reset_app_success': 'Application reset. Reloading...',
'reset_db_error': 'Error resetting the database. Please clear your browser cache manually.',
'reset_storage_error': 'An error occurred during the reset.',
'planner_title': 'Planner',
'planner_divide_in': 'Divide into:',
'planner_sessions': 'sessions',
'planner_method_subs': 'By number of subtitles',
'planner_method_words': 'By number of words',
'planner_method_time': 'By time',
'planner_calculate': 'Calculate',
'planner_load_srt_warning': 'Load an SRT file to use the planner.',
'planner_session_subs': 'Subtitles #{0} - #{1}',
'planner_session_time': 'Time {0} - {1} (up to Sub #{2})',
'planner_session_words': 'Subtitles #{0} - #{1} (~{2} words)',
'planner_words_label': 'words',
'planner_session_qa': 'Review / QA',
'save_project_title': 'Save Project',
                'confirm_restore_message': 'Are you sure you want to restore the backup? All unsaved work in the current session will be lost.',
'replacements_made': '{0} replacements have been made.',
'undo_btn': 'Undo',
'redo_btn': 'Redo',
'linebreak_tooltip_text': 'Linebreak = Shift + Enter',
'ai_settings_title': 'Customize AI Prompt',
'ai_settings_intro': 'Add up to three instructions for the AI. The first is mandatory and comes with default text that you can modify. QA guidelines will be added automatically.',
'ai_instruction_1_label': 'Instruction 1 (Required):',
'ai_instruction_2_label': 'Instruction 2 (Optional):',
'ai_instruction_3_label': 'Instruction 3 (Optional):',
'delete_subtitle_confirm': 'Are you sure you want to delete this subtitle?',
'merge_next_tooltip': 'Merge with next subtitle',
    'split_tooltip': 'Split subtitle at cursor position',
    'delete_tooltip': 'Delete subtitle',
'lock_waveform': 'Lock waveform',
'unlock_waveform': 'Unlock waveform',
'zoom_out': 'Zoom out',
'zoom_in': 'Zoom in',
'follow_playback_on': 'Enable playback tracking',
'follow_playback_off': 'Disable playback tracking',
'show_status_bar_btn': 'Show statss bar',
            'hide_status_bar_btn': 'Hide stats bar',
'timecode_settings_btn': 'Timecode Settings',
'timecode_modal_title': 'Timecode Settings',
'project_fps_label': 'Project FPS:',
'fps_recommendation_note': "Tip: For accurate timing, check your video file's FPS (Right-click > Properties > Details) and select the same value here.", 
'show_frames_label': 'Show timecode in frames (e.g. 00:00:10:05)',
'timecode_warning': 'Note: SRT export will always use milliseconds for compatibility.',
'timecode_format_error': 'Invalid timecode format. Use HH:MM:SS:FF.',
            }
        };

        const errorMessages = {
            'es': {
                'error_reading_file': 'Error al leer o analizar archivo .srt: ', 'error_saving_file': 'Error al guardar archivo: ', 'file_saved_successfully': 'Archivo .srt guardado con éxito.', 'file_saved_successfully_tbx': 'Archivo TBX guardado con éxito.', 'file_saved_successfully_tmx': 'Archivo TMX guardado con éxito.', 'please_enter_filename': 'Por favor, introduce un nombre de archivo.', 'no_translations_to_save': 'No hay subtítulos para guardar. Carga un archivo .srt primero.', 'reached_last': 'Has llegado al último subtítulo.', 'reached_first': 'Ya estás en el primer subtítulo.', 'file_processing_error': '¡Error! No se pudo procesar el archivo. Asegúrate de que es un archivo .srt válido.', 'no_match_found': 'No se encontró ninguna coincidencia.', 'replaced_all': 'Todas las ocurrencias reemplazadas.', 'no_find_query': 'Por favor, introduce el texto a buscar.', 'loading_file': 'Cargando archivo...', 'saving_file': 'Guardando archivo...', 'video_load_error': 'Error al cargar el vídeo. Asegúrate de que el formato es compatible.', 'both_terms_required': 'Ambos términos son requeridos.', 'lang_config_required': 'Por favor, configura los idiomas de origen y destino para el glosario.', 'cannot_download_empty_or_unconfigured_glossary': 'No se puede descargar un glosario vacío o sin configurar.', 'error_loading_tbx_file': 'Error al cargar el archivo TBX. Asegúrate de que sea un XML/TBX válido.', 'tmx_file_expected_tbx_found': 'Este archivo parece ser una memoria de traducción (TMX). Por favor, usa la opción "Importar TMX" en el panel de Memoria de Traducción.', 'tbx_file_expected_tmx_found': 'Este archivo parece ser un glosario (TBX). Por favor, usa la opción "Importar TBX" en el panel de Terminología.', 'error_loading_tmx_file': 'Error al cargar el archivo TMX. Asegúrate de que sea un XML/TMX válido.', 'cannot_download_empty_tm': 'No se puede descargar una memoria de traducción vacía.', 'backup_deleted_confirmation': '¿Estás seguro de que quieres borrar permanentemente este backup? Esta acción no se puede deshacer.', 'backup_deleted_message': 'El backup ha sido borrado.', 'project_restored_message': 'Proyecto restaurado con éxito.', 'no_backup_to_export': 'No hay datos de backup disponibles para exportar.', 'backup_export_error': 'Error al exportar el SRT del backup: ', 'backup_export_success': 'El archivo ha sido exportado con éxito.',
                'shortcut_import_error': 'Error al importar los atajos. Asegúrate de que es un archivo JSON válido.', 'shortcut_conflict': 'Este atajo ya está en uso. Por favor, elige otro.',
                'project_loaded_success': 'Proyecto cargado con éxito.', 'error_loading_project': 'Error al cargar el proyecto', 'no_project_to_save': 'No hay ningún proyecto activo para guardar.'
            },
            'en': {
                'error_reading_file': 'Error reading or parsing .srt file: ', 'error_saving_file': 'Error saving file: ', 'file_saved_successfully': '.srt file saved successfully.', 'file_saved_successfully_tbx': 'TBX file saved successfully.', 'file_saved_successfully_tmx': 'TMX file saved successfully.', 'please_enter_filename': 'Please enter a filename.', 'no_translations_to_save': 'No subtitles to save. Load an .srt file first.', 'reached_last': 'You have reached the last subtitle.', 'reached_first': 'You are already at the first subtitle.', 'file_processing_error': 'Error! Could not process the file. Make sure it is a valid .srt file.', 'no_match_found': 'No match found.', 'replaced_all': 'All occurrences replaced.', 'no_find_query': 'Please enter text to search for.', 'loading_file': 'Loading file...', 'saving_file': 'Saving file...', 'video_load_error': 'Error loading video. Make sure the format is supported.', 'both_terms_required': 'Both terms are required.', 'lang_config_required': 'Please set up the source and target languages for the glossary.', 'cannot_download_empty_or_unconfigured_glossary': 'Cannot download an empty or unconfigured glossary.', 'error_loading_tbx_file': 'Error loading TBX file. Make sure it is a valid XML/TBX.', 'tmx_file_expected_tbx_found': 'This file appears to be a Translation Memory (TMX). Please use the "Import TMX" option in the Translation Memory panel.', 'tbx_file_expected_tmx_found': 'This file appears to be a Glossary (TBX). Please use the "Import TBX" option in the Terminology panel.', 'error_loading_tmx_file': 'Error loading TMX file. Make sure it is a valid XML/TMX.', 'cannot_download_empty_tm': 'Cannot download an empty translation memory.', 'backup_deleted_confirmation': 'Are you sure you want to permanently delete this backup? This action cannot be undone.', 'backup_deleted_message': 'The backup has been deleted.', 'project_restored_message': 'Project restored successfully.', 'no_backup_to_export': 'No backup data available to export.', 'backup_export_error': 'Error exporting SRT from backup: ', 'backup_export_success': 'File exported successfully.',
                'shortcut_import_error': 'Error importing shortcuts. Please ensure it is a valid JSON file.', 'shortcut_conflict': 'This shortcut is already in use. Please choose another one.',
                'project_loaded_success': 'Project loaded successfully.', 'error_loading_project': 'Error loading project', 'no_project_to_save': 'There is no active project to save.'
            }
        };

const AI_PROMPT_TEMPLATE = `Actúa como un asistente experto en traducción audiovisual para subtitulación. Te proporcionaré el contenido de un archivo SRT.

Tu única salida debe ser un archivo de código en formato JSON, sin ninguna explicación antes o después del bloque de código.

El JSON debe ser un array de objetos. Cada objeto debe corresponder a un subtítulo y tener la siguiente estructura exacta:

1.  Una clave '"index"' (número).
2.  Una clave '"ai_suggestions"' (objeto). Dentro de este objeto, debe haber tres claves:
    * '"primary"': Tu mejor traducción al español de España.
    * '"natural"': Una versión más coloquial o fluida.
    * '"technical"': Una versión optimizada para subtitulación (máx. 42 caracteres por línea, CPS < 20), usando '\\n' para los saltos de línea.
3.  Una clave '"context_notes"' (texto). Aquí debes explicar modismos, referencias culturales, etc., y añadir un enlace a una fuente fiable que respalde tus decisiones.

Asegúrate de que la clave '"context_notes"' esté al mismo nivel que '"index"' y '"ai_suggestions"', y NO dentro de '"ai_suggestions"'.

**Ejemplo de la estructura requerida para un objeto:**
{
  "index": 1,
  "ai_suggestions": {
    "primary": "Traducción principal aquí.",
    "natural": "Traducción natural aquí.",
    "technical": "Traducción técnica aquí."
  },
  "context_notes": "<b>Explicación:</b> Notas y enlace aquí. Fuente: https://www.ejemplo.com"
}

Ahora, analiza el siguiente contenido SRT y genera el JSON completo:

[SRT_CONTENT_PLACEHOLDER]`;

 let shortcutProfiles = {}; // contendrá los perfiles 'windows' y 'mac'
        let activeProfile = 'windows'; // perfil por defecto
        let shortcuts = {}; // se rellenará con el perfil activo
     
   // List of common ISO 639-1 language codes for the datalist
        const isoLanguagesData = [
          { code: "en", name: "English" }, { code: "en-US", name: "English (United States)" }, { code: "en-GB", name: "English (United Kingdom)" },
          { code: "es", name: "Español" }, { code: "es-AR", name: "Español (Argentina)" }, { code: "es-ES", name: "Español (España)" }, { code: "es-MX", name: "Español (México)" },
          { code: "fr", name: "Français" }, { code: "de", name: "Deutsch" }, { code: "it", name: "Italiano" }, { code: "pt", name: "Português" },
          { code: "ja", name: "日本語 (Japanese)" }, { code: "zh", name: "中文 (Chinese)" }, { code: "ar", name: "العربية (Arabic)" },
          { code: "ru", name: "Русский (Russian)" }, { code: "ko", name: "한국어 (Korean)" }, { code: "nl", name: "Nederlands" },
          { code: "sv", name: "Svenska" }, { code: "da", name: "Dansk" }, { code: "no", name: "Norsk" }, { code: "fi", "name": "Suomi" },
          { code: "tr", name: "Türkçe" }, { code: "pl", name: "Polski" }, { code: "cs", name: "Čeština" }, { code: "hu", name: "Magyar" },
          { code: "el", name: "Ελληνικά (Greek)" }, { code: "he", name: "עברית (Hebrew)" }, { code: "th", name: "ไทย (Thai)" },
          { code: "vi", name: "Tiếng Việt (Vietnamese)" }, { code: "id", name: "Bahasa Indonesia" }, { code: "ms", name: "Bahasa Melayu" },
          { code: "ca", name: "Català" }, { code: "eu", name: "Euskara" }, { code: "gl", name: "Galego" }, { code: "ro", name: "Română" },
          { code: "uk", name: "Українська (Ukrainian)" }, { code: "bg", name: "Български (Bulgarian)" }, { code: "hr", name: "Hrvatski" },
          { code: "sr", name: "Srpski" }, { code: "sk", name: "Slovenčina" }, { code: "sl", name: "Slovenščina" }, { code: "lt", name: "Lietuvių" },
          { code: "lv", name: "Latviešu" }, { code: "et", name: "Eesti" }, { code: "is", name: "Íslenska" }, { code: "ga", name: "Gaeilge" },
          { code: "mt", name: "Malti" },
        ];


        /**
         * Counts words in a given text string.
         * @param {string} text The text to count words from.
         * @returns {number} The number of words.
         */
        function countWords(text) {
            if (!text) return 0;
            // Trim leading/trailing whitespace and split by one or more whitespace characters
            const words = text.trim().split(/\s+/);
            // Filter out empty strings that might result from multiple spaces
            return words.filter(word => word.length > 0).length;
        }
        
        /**
         * Counts characters in a string, ignoring HTML tags.
         * @param {string} text The text to count.
         * @returns {number} The character count without tags.
         */
        function countCharactersWithoutTags(text) {
            if (!text) return 0;
            // Remove all HTML tags
            const noTags = text.replace(/<[^>]+>/g, '');
            // Convert entities like &nbsp; to space
            const cleanText = noTags.replace(/&nbsp;/gi, ' ');
            return cleanText.length;
        }

        /**
         * Converts milliseconds to SRT time format (HH:MM:SS,ms).
         * @param {number} ms Milliseconds.
         * @returns {string} Formatted time string.
         */
        function formatTime(ms) {
            const hours = Math.floor(ms / 3600000);
            ms %= 3600000;
            const minutes = Math.floor(ms / 60000);
            ms %= 60000;
            const seconds = Math.floor(ms / 1000);
            const milliseconds = ms % 1000;

            return [
                hours.toString().padStart(2, '0'),
                minutes.toString().padStart(2, '0'),
                seconds.toString().padStart(2, '0')
            ].join(':') + ',' + milliseconds.toString().padStart(3, '0');
        }

        /**
         * Converts SRT time format (HH:MM:SS,ms) to milliseconds.
         * @param {string} timeStr Time string in SRT format.
         * @returns {number} Milliseconds.
         */
        function parseTime(timeStr) {
            const parts = timeStr.split(',');
            const [h, m, s] = parts[0].split(':').map(Number);
            const ms = Number(parts[1]);
            return (h * 3600 + m * 60 + s) * 1000 + ms;
        }

/**
         * Convierte milisegundos a formato de frames (HH:MM:SS:FF).
         * @param {number} ms Milliseconds.
         * @param {number} fps Project FPS.
         * @returns {string} Formatted time string.
         */
        function formatFrameTime(ms, fps) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            const remainingMs = ms % 1000;
            const frames = Math.round((remainingMs / 1000) * fps);

            return [
                hours.toString().padStart(2, '0'),
                minutes.toString().padStart(2, '0'),
                seconds.toString().padStart(2, '0')
            ].join(':') + ':' + frames.toString().padStart(2, '0');
        }

        /**
         * Convierte formato de frames (HH:MM:SS:FF) a milisegundos.
         * @param {string} timeStr Time string in frame format.
         * @param {number} fps Project FPS.
         * @returns {number} Milliseconds.
         */
        function parseFrameTime(timeStr, fps) {
            const parts = timeStr.split(':');
            if (parts.length !== 4) throw new Error("Invalid frame time format");
            
            const [h, m, s, f] = parts.map(Number);
            let totalMs = 0;
            totalMs += h * 3600000;
            totalMs += m * 60000;
            totalMs += s * 1000;
            
            // Convierte los frames a los milisegundos más cercanos
            totalMs += Math.round((f / fps) * 1000);
            
            return totalMs;
        }

        /**
         * Calculates Characters Per Second (CPS) for a given text and duration.
         * @param {string} text The text of the subtitle.
         * @param {number} durationMs The duration of the subtitle in milliseconds.
         * @returns {number} CPS value.
         */
        function calculateCPS(text, durationMs) {
            if (durationMs <= 0) return 0;

            // Remove ALL HTML tags
            const noTags = text.replace(/<[^>]+>/g, '');

            // Replace &nbsp; entities with spaces
            const cleanText = noTags.replace(/&nbsp;/gi, ' ');

            // Divide by seconds
            return (cleanText.length / (durationMs / 1000)).toFixed(2);
        }

        /**
         * Parses the content of an SRT file.
         * @param {string} content The full content of the SRT file.
         * @returns {Array<Object>} An array of SRT entry objects.
         */
        function parseSrtContent(content) {
            const entries = [];
            const blocks = content.split(/\r?\n\r?\n/); // Split by double newline (CRLF or LF)

            blocks.forEach(block => {
                const lines = block.trim().split(/\r?\n/);
                if (lines.length >= 3) {
                    const index = parseInt(lines[0]);
                    const timecodes = lines[1];
                    const text = lines.slice(2).join('\n'); // Join remaining lines as text

                    const [startTimeStr, endTimeStr] = timecodes.split(' --> ');
                    const startTimeMs = parseTime(startTimeStr);
                    const endTimeMs = parseTime(endTimeStr);
                    const durationMs = endTimeMs - startTimeMs;
                    const charCountOriginal = countCharactersWithoutTags(text);

                    entries.push({
                        index: index,
                        timecodes: timecodes,
                        startTimeMs: startTimeMs,
                        endTimeMs: endTimeMs,
                        durationMs: durationMs,
                        original: text,
                        translation: '', // Initialize translation as empty
                        wordCountOriginal: countWords(text),
                        wordCountTranslation: 0,
                        isTranslated: false,
                        charCountOriginal: charCountOriginal,
                        charCountTranslation: 0,
                        cpsOriginal: calculateCPS(text, durationMs),
                        cpsTranslation: 0
                    });
                }
            });
            return entries;
        }

        /**
         * Reconstructs the content of an SRT file from an array of entries.
         * @param {Array<Object>} entries The array of subtitle objects.
         * @returns {string} The reconstructed SRT file content.
         */
            function reconstructSrt(entries) {
    let srtContent = '';
    entries.forEach(entry => {
        srtContent += `${entry.index}\n`;
        srtContent += `${entry.timecodes}\n`;

        let textToWrite = entry.translation || entry.original;

        // --- INICIO DEL NUEVO PROCESO DE LIMPIEZA INTELIGENTE ---

        // 1. Normalizamos los saltos de línea generados por el editor.
        // Reemplazamos los saltos de línea de <div> y <br> por el carácter estándar '\n'.
        textToWrite = textToWrite.replace(/<\/div>\s*<div>/gi, '\n');
        textToWrite = textToWrite.replace(/<br\s*\/?>/gi, '\n');

        // 2. Eliminamos TODAS las etiquetas HTML EXCEPTO <b> y <i>.
        // Esta es la parte clave. Usamos una expresión regular con "negative lookahead"
        // para decirle que ignore las etiquetas de formato que queremos conservar.
        textToWrite = textToWrite.replace(/<(?!(\/?b|\/?i))[^>]+>/gi, '');

        // 3. Limpiamos cualquier espacio en blanco extra al principio o al final.
        textToWrite = textToWrite.trim();
        
        // --- FIN DEL NUEVO PROCESO ---

        srtContent += `${textToWrite}\n\n`;
    });
    return srtContent.trim();
}

// --- INICIO: Funciones de Bloqueo y Zoom de Onda ---

/**
 * Alterna el estado de bloqueo de la onda de sonido.
 * Evita que las regiones se puedan arrastrar o redimensionar.
 */
function toggleWaveformLock() {
    isWaveformLocked = !isWaveformLocked;
    const waveformEl = document.getElementById('waveform');
    
    // Alternar estado visual
    waveformEl.classList.toggle('is-locked', isWaveformLocked);
    lockIconOpen.classList.toggle('hidden', isWaveformLocked);
    lockIconClosed.classList.toggle('hidden', !isWaveformLocked);
lockWaveformBtn.classList.toggle('active', isWaveformLocked);
lockWaveformBtn.title = isWaveformLocked ? translations[currentLanguage]['unlock_waveform'] : translations[currentLanguage]['lock_waveform'];

    // Deshabilitar/Habilitar drag y resize en TODAS las regiones
    if (wsRegions) {
        wsRegions.getRegions().forEach(region => {
            region.setOptions({
                drag: !isWaveformLocked,
                resize: !isWaveformLocked
            });
        });
    }
}

/**
 * Aplica zoom a la onda de sonido.
 * @param {number} direction - 1 para Zoom In, -1 para Zoom Out.
 */
function zoomWaveform(direction) {
    if (!wavesurfer) return;
    
    const newZoom = currentWaveformZoom + (direction * ZOOM_STEP);
    
    // Establecemos un límite mínimo de zoom para que no se "pierda"
    if (newZoom >= 20) { 
        currentWaveformZoom = newZoom;
        wavesurfer.zoom(currentWaveformZoom);
    }
}
// --- FIN: Funciones de Bloqueo y Zoom de Onda ---

// --- Funciones de Regiones de WaveSurfer (NUEVAS y MODIFICADAS) ---
        /** Limpia todas las regiones de subtítulos de la onda. */
        function clearSubtitleRegions() {
            if (wsRegions) {
                // Limpia solo regiones de subtítulos, preservando otras si las hubiera
                wsRegions.getRegions().forEach(region => {
                    if (region.id.startsWith('sub-')) { // Asume que los IDs de subtítulos empiezan con 'sub-'
                        region.remove();
                    }
                });
            }
        }

        /** Añade una región a WaveSurfer para un subtítulo específico. */
        function addSubtitleRegion(entry) {
            // No añade región si no hay plugin, los tiempos no son válidos o la duración es cero o negativa
            if (!wsRegions || entry.startTimeMs < 0 || entry.endTimeMs <= entry.startTimeMs) return;

            // Asegúrate de que el ID es único y estable
            if (!entry.regionId) {
                 entry.regionId = `sub-${entry.index}-${Date.now()}`; // Genera ID si no existe
            }

            // Evita añadir regiones duplicadas
            if (wsRegions.getRegions().some(r => r.id === entry.regionId)) {
                return;
            }

            try {
                const region = wsRegions.addRegion({
                    id: entry.regionId,
                    start: entry.startTimeMs / 1000, // Convertir ms a segundos
                    end: entry.endTimeMs / 1000,   // Convertir ms a segundos
                    color: 'rgba(7, 91, 162, 0.3)',
                    drag: !isWaveformLocked,
                    resize: !isWaveformLocked,
                    attributes: { // Añadir atributos para posible estilado o selección
                        'data-subtitle-index': entry.index
                    }
                });

              // --- INICIO: NUEVO BLOQUE para el formato de 4 líneas ---
                const content = document.createElement('div');
                content.className = 'region-content';

                // Línea 1: Número de subtítulo
                const line1 = `#${entry.index}`;

                // Línea 2: Texto original (preview)
                const originalPreview = entry.original.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                const line2 = originalPreview.substring(0, 40) + (originalPreview.length > 40 ? '...' : '');

                // Línea 3: Texto traducido (preview, o vacío)
                let line3 = '';
                if (entry.translation) {
                    const translationPreview = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                    line3 = translationPreview.split('\n').join(' ').substring(0, 40) + (translationPreview.length > 40 ? '...' : '');
                }

                // Línea 4: Estadísticas de la traducción
                let line4 = '---'; // Placeholder si no hay traducción
                if (entry.translation) {
                    const translationTextClean = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                    const transLines = translationTextClean.split('\n');
                    const transL1 = transLines[0] ? countCharactersWithoutTags(transLines[0]) : 0;
                    const transL2 = transLines.length > 1 && transLines[1] ? countCharactersWithoutTags(transLines[1]) : 0;
                    const transCPS = calculateCPS(translationTextClean.replace(/\n/g, ''), entry.durationMs);
                    line4 = `CPS: ${transCPS} | L1: ${transL1}${transLines.length > 1 ? ` / L2: ${transL2}` : ''}`;
                }

                content.innerHTML = `
                    <div class="region-line region-line1">${line1}</div>
                    <div class="region-line region-line2">${line2}</div>
                    <div class="region-line region-line3">${line3}&nbsp;</div> <div class="region-line region-line4">${line4}</div>
                `;
                // --- FIN: NUEVO BLOQUE ---
                // Pequeño timeout para asegurar que el elemento de la región se ha renderizado en el DOM
                setTimeout(() => {
                    const regionEl = region?.element; // Usa optional chaining por si region no está definida
                    if (regionEl && !regionEl.querySelector('.region-content')) { // Verifica que no se haya añadido ya
                        regionEl.appendChild(content);
                    }
                }, 50); // Un pequeño retardo podría ser necesario

            } catch (error) {
                console.error(`Error adding region for subtitle ${entry.index}:`, error, entry);
            }
        }

/** Actualiza una región existente si sus tiempos cambian en el editor. */
        function updateRegionIfNeeded(entryIndex) {
            if (!wsRegions) return;
            const entry = srtEntries[entryIndex];
            const region = wsRegions.getRegions().find(r => r.id === entry.regionId);

            if (region) {
                const newStart = entry.startTimeMs / 1000;
                const newEnd = entry.endTimeMs / 1000;

                if ((Math.abs(region.start - newStart) > 0.001 || Math.abs(region.end - newEnd) > 0.001) && newEnd > newStart) {
                    region.setOptions({ start: newStart, end: newEnd });

                    // Actualizar el contenido de la región también (CON LA NUEVA LÓGICA)
                    const content = region.element?.querySelector('.region-content');
                     if (content) {
                         // --- INICIO: NUEVO BLOQUE para el formato de 4 líneas ---
                         // Línea 1: Número de subtítulo
                         const line1 = `#${entry.index}`;

                         // Línea 2: Texto original (preview)
                         const originalPreview = entry.original.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                         const line2 = originalPreview.substring(0, 40) + (originalPreview.length > 40 ? '...' : '');

                         // Línea 3: Texto traducido (preview, o vacío)
                         let line3 = '';
                         if (entry.translation) {
                             const translationPreview = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                             line3 = translationPreview.split('\n').join(' ').substring(0, 40) + (translationPreview.length > 40 ? '...' : '');
                         }

                         // Línea 4: Estadísticas de la traducción
                         let line4 = '---'; // Placeholder si no hay traducción
                         if (entry.translation) {
                             const translationTextClean = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                             const transLines = translationTextClean.split('\n');
                             const transL1 = transLines[0] ? countCharactersWithoutTags(transLines[0]) : 0;
                             const transL2 = transLines.length > 1 && transLines[1] ? countCharactersWithoutTags(transLines[1]) : 0;
                             const transCPS = calculateCPS(translationTextClean.replace(/\n/g, ''), entry.durationMs);
                             line4 = `CPS: ${transCPS} | L1: ${transL1}${transLines.length > 1 ? ` / L2: ${transL2}` : ''}`;
                         }

                         content.innerHTML = `
                             <div class="region-line region-line1">${line1}</div>
                             <div class="region-line region-line2">${line2}</div>
                             <div class="region-line region-line3">${line3}&nbsp;</div> <div class="region-line region-line4">${line4}</div>
                         `;
                         // --- FIN: NUEVO BLOQUE ---
                     }
                } else if (newEnd <= newStart) {
                    region.remove();
                }
            } else if (entry.endTimeMs > entry.startTimeMs) {
                addSubtitleRegion(entry);
            }
        }

   // --- Funciones para Edición de Tiempos ---

        /**
         * Actualiza todos los datos y la interfaz de un subtítulo cuando su tiempo cambia.
         * @param {number} entryIndex - El índice del subtítulo a actualizar.
         */
        function updateEntryTimes(entryIndex) {
            const entry = srtEntries[entryIndex];

            // 1. Validar que el tiempo de fin no sea anterior al de inicio
            if (entry.endTimeMs < entry.startTimeMs) {
                entry.endTimeMs = entry.startTimeMs + 1; // Asegurar una duración mínima
            }

            // 2. Recalcular la duración
            entry.durationMs = entry.endTimeMs - entry.startTimeMs;

            // 3. Formatear las nuevas cadenas de tiempo
            let newStartTimeStr, newEndTimeStr;
if (useFrameTimecode) {
    newStartTimeStr = formatFrameTime(entry.startTimeMs, projectFPS);
    newEndTimeStr = formatFrameTime(entry.endTimeMs, projectFPS);
} else {
    newStartTimeStr = formatTime(entry.startTimeMs);
    newEndTimeStr = formatTime(entry.endTimeMs);
}

            // 4. Actualizar los elementos de la interfaz
            document.getElementById(`startTime-${entryIndex}`).value = newStartTimeStr;
            document.getElementById(`endTime-${entryIndex}`).value = newEndTimeStr;
            document.getElementById(`duration-${entryIndex}`).textContent = (entry.durationMs / 1000).toFixed(3) + 's';

            // 5. Recalcular y actualizar las estadísticas (CPS, etc.)
            const translationEditor = document.getElementById(`translation-${entryIndex}`);
            if (translationEditor) {
                updateSubtitleStats(translationEditor, entry.charCountOriginal, entry.durationMs);
            }
updateRegionIfNeeded(entryIndex);
        }

        /**
         * Maneja el cambio manual de un código de tiempo en un campo de input.
         * @param {number} entryIndex - El índice del subtítulo.
         * @param {boolean} isStartTime - True si es el campo de inicio, false si es el de fin.
         * @param {HTMLInputElement} inputElement - El propio campo de input.
         */
        function handleTimecodeChange(entryIndex, isStartTime, inputElement) {
    let newTimeMs;
    try {
        if (useFrameTimecode) {
            newTimeMs = parseFrameTime(inputElement.value, projectFPS);
        } else {
            newTimeMs = parseTime(inputElement.value);
        }
        const entry = srtEntries[entryIndex];

// --- INICIO: Guardar historial de tiempo ---
                const oldTimes = { startTimeMs: entry.startTimeMs, endTimeMs: entry.endTimeMs };
                const newTimes = { ...oldTimes };
                if (isStartTime) {
                    newTimes.startTimeMs = newTimeMs;
                } else {
                    newTimes.endTimeMs = newTimeMs;
                }
                saveTimeChange(entryIndex, oldTimes, newTimes);
                // --- FIN: Guardar historial de tiempo ---
                
                if (isStartTime) {
                    entry.startTimeMs = newTimeMs;
                } else {
                    entry.endTimeMs = newTimeMs;
                }
                
                updateEntryTimes(entryIndex);
           } catch (error) {
                // Si el formato es inválido, revertir al valor anterior
                console.error("Formato de tiempo inválido:", error);
                
                // --- INICIO DE LA VERSIÓN CORREGIDA ---
                const entry = srtEntries[entryIndex]; // Se declara solo UNA VEZ
                let oldTimeStr;
                
                if (useFrameTimecode) {
                    // Si estamos en modo frames, generamos el string de frames
                    oldTimeStr = isStartTime ? formatFrameTime(entry.startTimeMs, projectFPS) : formatFrameTime(entry.endTimeMs, projectFPS);
                } else {
                    // Si estamos en modo ms, usamos la lógica original
                    const [startTime, endTime] = entry.timecodes.split(' --> ');
                    oldTimeStr = isStartTime ? startTime : endTime;
                }
                
                inputElement.value = oldTimeStr; // Revertimos al valor correcto
                
                // Lógica para mostrar el mensaje de error (esto ya lo tenías bien)
                const errorKey = useFrameTimecode ? 'timecode_format_error' : 'time_format_error'; 
                const errorMsg = translations[currentLanguage][errorKey] || "Formato de tiempo inválido.";
                showMessage(errorMsg);
                // --- FIN DE LA VERSIÓN CORREGIDA ---
            }
        }

        /**
         * Ajusta el tiempo de entrada o salida en un fotograma (40ms).
         * @param {number} entryIndex - El índice del subtítulo.
         * @param {boolean} isStartTime - True si se ajusta el inicio, false si es el fin.
         * @param {number} direction - 1 para añadir tiempo, -1 para restar.
         */
        function nudgeTimecode(entryIndex, isStartTime, direction) {
            const entry = srtEntries[entryIndex];
const frameDurationMs = Math.round(1000 / projectFPS); // Duración de 1 frame

// --- INICIO: Guardar historial de tiempo ---
            const oldTimes = { startTimeMs: entry.startTimeMs, endTimeMs: entry.endTimeMs };
            const newTimes = { ...oldTimes };
            if (isStartTime) {
                newTimes.startTimeMs = oldTimes.startTimeMs + (direction * frameDurationMs);
            } else {
                newTimes.endTimeMs = oldTimes.endTimeMs + (direction * frameDurationMs);
            }
            saveTimeChange(entryIndex, oldTimes, newTimes);
            // --- FIN: Guardar historial de tiempo ---

            if (isStartTime) {
                entry.startTimeMs += direction * frameDurationMs;
            } else {
                entry.endTimeMs += direction * frameDurationMs;
            }

            updateEntryTimes(entryIndex);
        }

        /**
         * Avanza o retrocede el vídeo en un fotograma (40ms).
         * @param {number} direction - 1 para avanzar, -1 para retroceder.
         */
        function nudgeVideo(direction) {
            if (videoPlayer && videoPlayer.src) {
                const frameDurationSeconds = 0.040;
                videoPlayer.currentTime += direction * frameDurationSeconds;
            }
        }

/**
         * Reproduce el subtítulo actual en un bucle un número configurable de veces.
         * @param {number} entryIndex - El índice del subtítulo a reproducir.
         */
        function playSubtitleLoop(entryIndex) {
            if (!srtEntries[entryIndex] || !videoPlayer.src) return;

            const entry = srtEntries[entryIndex];
            const loopCount = shortcuts.playSegmentLoop.loopCount || 3;
            let currentLoop = 0;
            
            // Si ya hay un bucle en ejecución, lo cancelamos para empezar uno nuevo
            if (window.loopListener) {
                videoPlayer.removeEventListener('timeupdate', window.loopListener);
            }

            const playSegment = () => {
                if (currentLoop >= loopCount) {
                    videoPlayer.pause();
                    videoPlayer.removeEventListener('timeupdate', window.loopListener);
                    window.loopListener = null;
                    return;
                }
                
                currentLoop++;
                videoPlayer.currentTime = entry.startTimeMs / 1000;
                videoPlayer.play();
            };

            window.loopListener = () => {
                // Dejamos un pequeño margen para asegurar que no se salte el bucle
                if (videoPlayer.currentTime >= (entry.endTimeMs / 1000) - 0.1) {
                    playSegment();
                }
            };
            
            videoPlayer.addEventListener('timeupdate', window.loopListener);
            playSegment(); // Inicia el primer ciclo
        }

        /**
         * Actualiza el contador de bucles en el objeto de atajos y lo guarda.
         * @param {string} value - El nuevo valor del campo de entrada.
         */
        function updateLoopCount(value) {
            const count = parseInt(value, 10);
            if (count > 0) {
                shortcuts.playSegmentLoop.loopCount = count;
                saveShortcuts();
            }
        }

/**
 * Inserta la sugerencia de la IA en el editor del subtítulo activo.
 * @param {number} entryIndex - El índice del subtítulo.
 */
function insertAiSuggestion(entryIndex, suggestionType) {
    const entry = srtEntries[entryIndex];
    const editor = document.getElementById(`translation-${entryIndex}`);

    if (entry && entry.context && entry.context.ai_suggestions && editor) {
        const textToInsert = entry.context.ai_suggestions[suggestionType];
        if (textToInsert) {
            // Reemplazamos los saltos de línea \n del JSON por <br> para el editor HTML
            editor.innerHTML = textToInsert.replace(/\n/g, '<br>');
            // Disparamos el evento 'input' para que las estadísticas se actualicen
            editor.dispatchEvent(new Event('input', { bubbles: true }));
        }
    }
}

function processAndApplyContext(parsedContext) {
    if (!Array.isArray(parsedContext)) {
        throw new Error("El JSON no es un array válido.");
    }

    srtEntries.forEach(entry => delete entry.context); // Limpia contexto anterior

    let appliedCount = 0;
    parsedContext.forEach(ctx => {
        if (typeof ctx.index !== 'undefined' && ctx.ai_suggestions && ctx.context_notes) {
            const entry = srtEntries.find(e => e.index === ctx.index);
            if (entry) {
                entry.context = ctx;
                appliedCount++;
            }
        }
    });

    if (appliedCount > 0) {
        showMessage(`Contexto cargado y aplicado a ${appliedCount} subtítulos.`);
        const currentFocused = getCurrentFocusedIndex() || { entryIndex: 0 };
        updateContextPanel(currentFocused.entryIndex);
    } else {
        throw new Error("El formato del JSON es correcto, pero ningún índice coincidió con los subtítulos actuales.");
    }
}

function preTranslateAll() {
    let pretranslatedCount = 0;
    srtEntries.forEach(entry => {
        if (entry.context && entry.context.ai_suggestions && entry.context.ai_suggestions.primary) {
            if (!entry.translation.trim()) {
                entry.translation = entry.context.ai_suggestions.primary.replace(/\n/g, '<br>');
                pretranslatedCount++;
            }
        }
    });

    if (pretranslatedCount > 0) {
        renderTranslations(srtEntries, 0, true);
        showMessage(`${pretranslatedCount} subtítulos han sido pretraducidos.`);
    } else {
        showMessage("No se encontraron sugerencias para pretraducir o los campos ya estaban rellenos.");
    }
}

function resetContext() {
    // Borra los datos de contexto de todos los subtítulos
    srtEntries.forEach(entry => delete entry.context);

    // Llama a updateContextPanel. Como ya no hay datos, mostrará la vista de importación.
    const currentFocused = getCurrentFocusedIndex() || { entryIndex: 0 };
    updateContextPanel(currentFocused.entryIndex);
}


  function reconstructOriginalSrt(entries) {
            let srtContent = '';
            entries.forEach(entry => {
                srtContent += `${entry.index}\n`;
                srtContent += `${entry.timecodes}\n`;
                srtContent += `${entry.original}\n\n`;
            });
            return srtContent.trim();
        }

       


// Variable para guardar las instrucciones personalizadas del usuario
let aiCustomInstructions = { instruction1: "", instruction2: "", instruction3: "" };


/**
 * Guarda las instrucciones personalizadas de la IA en localStorage.
 */
function saveAiCustomInstructions() {
    localStorage.setItem('aiCustomInstructions', JSON.stringify(aiCustomInstructions));
}

/**
 * Carga las instrucciones personalizadas de la IA desde localStorage.
 */
function loadAiCustomInstructions() {
    const saved = localStorage.getItem('aiCustomInstructions');
    const defaultInstruction = translations[currentLanguage]['ai_default_instruction_1']
        .replace('{0}', qaSettings.charsPerLineLimit)
        .replace('{1}', qaSettings.cpsLimit);

    if (saved) {
        aiCustomInstructions = JSON.parse(saved);
    }
    // Si no hay instrucción 1 guardada, aplicamos la dinámica por defecto.
    if (!aiCustomInstructions.instruction1) {
        aiCustomInstructions.instruction1 = defaultInstruction;
    }
}

/**
 * Copia el prompt de la IA al portapapeles, incluyendo el SRT actual y las instrucciones personalizadas.
 */
function copyAIPrompt() {
    if (srtEntries.length === 0) {
        showMessage(translations[currentLanguage]['load_srt_first']);
        return;
    }

    // 1. Construimos dinámicamente la lista de claves y el ejemplo para el prompt.
    let suggestionKeys = `        * '"primary"': "${aiCustomInstructions.instruction1 || 'Una traducción literal y fiel al original.'}"\n`;
    let exampleKeys = `        "primary": "Traducción generada según la instrucción 1."\n`;

    if (aiCustomInstructions.instruction2) {
        suggestionKeys += `        * '"secondary"': "${aiCustomInstructions.instruction2}"\n`;
        exampleKeys += `        "secondary": "Traducción generada según la instrucción 2."\n`;
    }
    if (aiCustomInstructions.instruction3) {
        const instruction3_full = `${aiCustomInstructions.instruction3}, y además debe cumplir ESTRICTAMENTE las pautas técnicas (máx. ${qaSettings.charsPerLineLimit} caracteres por línea, CPS < ${qaSettings.cpsLimit}).`;
        suggestionKeys += `        * '"tertiary"': "${instruction3_full}"\n`;
        exampleKeys += `        "tertiary": "Traducción generada según la instrucción 3."\n`;
    }

    // 2. Construimos el prompt final usando las piezas dinámicas.
    const finalPrompt = `Act as an expert audiovisual translation assistant for subtitling. I will provide you with the content of an SRT file.

Your sole output must be a code file in JSON format, with no explanations before or after the code block.

The JSON must be an array of objects. Each object must correspond to a subtitle and have the following exact structure:

1.  A key '"index"' (number).
2.  A key '"ai_suggestions"' (object). Inside this object, there should ONLY be the following keys, each with a translation that follows its specific instruction:
${suggestionKeys}
3.  A key '"context_notes"' (text). Here you should explain idioms, cultural references, etc.

**Example of the required structure for one object:**
{
  "index": 1,
  "ai_suggestions": {
${exampleKeys}
  },
  "context_notes": "<b>Explanation:</b> Notes and link here."
}

Now, analyze the following SRT content and generate the complete JSON:

[SRT_CONTENT_PLACEHOLDER]`;

    const srtContent = reconstructOriginalSrt(srtEntries);
    const fullPrompt = finalPrompt.replace('[SRT_CONTENT_PLACEHOLDER]', srtContent);

    navigator.clipboard.writeText(fullPrompt).then(() => {
        showMessage(translations[currentLanguage]['prompt_copied_success']);
    }).catch(err => {
        console.error('Error al copiar el prompt: ', err);
    });
}
        /**
         * Pega el contenido del portapapeles en el área de texto del contexto.
         */
        async function pasteJsonFromClipboard() {
            try {
                const text = await navigator.clipboard.readText();
                const contextPasteArea = document.getElementById('contextPasteArea');
                contextPasteArea.value = text;
                // Disparamos el evento 'input' para que se active la validación
                contextPasteArea.dispatchEvent(new Event('input', { bubbles: true }));
            } catch (err) {
                console.error('Error al pegar desde el portapapeles: ', err);
                showMessage(translations[currentLanguage]['clipboard_paste_error']);
            }
        }

        /**
         * Valida en tiempo real el contenido del área de texto JSON.
         */
        function validateJsonInTextarea() {
            const textarea = document.getElementById('contextPasteArea');
            const statusDiv = document.getElementById('jsonValidationStatus');
            const text = textarea.value.trim();
            const t = translations[currentLanguage];

            if (!text) {
                statusDiv.innerHTML = '';
                return;
            }

            try {
                JSON.parse(text);
                statusDiv.innerHTML = `
                    <span class="flex items-center text-green-600">
                        <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>
                        ${t['json_valid']}
                    </span>`;
            } catch (error) {
                statusDiv.innerHTML = `
                    <span class="flex items-center text-red-600">
                        <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>
                        ${t['json_invalid']}
                    </span>`;
            }
        }

function updateContextPanel(entryIndex) {
    const contextImportView = document.getElementById('contextImportView');
    const contextDisplayView = document.getElementById('contextDisplayView');
    const t = translations[currentLanguage]; // Clave: obtiene las traducciones del idioma actual

    if (srtEntries.some(e => e.context)) {
        contextImportView.classList.add('hidden');
        contextDisplayView.classList.remove('hidden');

        const entry = srtEntries[entryIndex];
        // CORRECCIÓN: Se usan las claves de traducción (ej: t['context_notes_title'])
        let contentHTML = `
            <div class="flex justify-between items-center mb-4 pb-2 border-b">
                <h4 class="font-bold text-md">${t['context_notes_title']}</h4>
                <div class="flex items-center gap-2">
                    <button class="btn btn-primary text-xs" onclick="preTranslateAll()" title="${t['pretranslate_all_title']}">${t['pretranslate_all_btn']}</button>
                    <button class="btn btn-secondary text-xs" onclick="resetContext()" data-i18n="reset_context">${t['reset_context']}</button>
                </div>
            </div>`;

        if (entry && entry.context) {
            const suggestions = entry.context.ai_suggestions;
            
            contentHTML += `<div class="space-y-3 mb-4">`;

            const getStatsString = (text, duration) => {
                if (!text) return '';
                const lines = text.split('\n');
                const line1Length = lines[0] ? countCharactersWithoutTags(lines[0]) : 0;
                const line2Length = lines.length > 1 && lines[1] ? countCharactersWithoutTags(lines[1]) : 0;
                const textForCps = text.replace(/\n/g, '');
                const cps = calculateCPS(textForCps, duration);
                return `(L1: ${line1Length} | L2: ${line2Length} | CPS: ${cps})`;
            };

            const createSuggestionHTML = (suggestionKey, titleKey) => {
                const text = suggestions[suggestionKey];
                if (!text) return '';
                
                const stats = getStatsString(text, entry.durationMs);
                // CORRECCIÓN: El título también se obtiene de las traducciones (t[titleKey])
                return `
                    <div>
                        <div class="flex justify-between items-center text-sm font-semibold">
                            <span>${t[titleKey]} <span class="font-mono text-gray-500 ml-2">${stats}</span></span>
                            <button class="btn btn-secondary p-1" title="Insertar sugerencia" onclick="insertAiSuggestion(${entryIndex}, '${suggestionKey}')">
                                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"></path></svg>
                            </button>
                        </div>
                        <p class="bg-gray-100 p-2 rounded-md italic text-sm mt-1">"${text.replace(/\n/g, '<br>')}"</p>
                    </div>`;
            };
            
            // CORRECCIÓN: Se pasan las claves de traducción en lugar de texto fijo
            contentHTML += createSuggestionHTML('primary', 'instruction_1');
            contentHTML += createSuggestionHTML('secondary', 'instruction_2');
            contentHTML += createSuggestionHTML('tertiary', 'instruction_3');
            
            contentHTML += `</div>`;
            
            const urlRegex = /(https?:\/\/[^\s<]+)/g;
            const formattedNotes = entry.context.context_notes.replace(urlRegex, '<a href="$1" target="_blank" class="text-blue-600 hover:underline">$1</a>');
            contentHTML += `
                <div class="border-t pt-2">
                    <div class="prose prose-sm max-w-none">${formattedNotes}</div>
                </div>`;

        } else {
            contentHTML += `<p class="text-gray-500">${t['no_context_available']}</p>`;
        }
        contextDisplayView.innerHTML = contentHTML;

    } else {
        contextImportView.classList.remove('hidden');
        contextDisplayView.classList.add('hidden');
    }
}


        /**
         * Adjusts the height of a textarea to fit its content.
         * If the translation textarea is empty, it matches the height of the original textarea.
         * @param {HTMLTextAreaElement} textarea The textarea element (translation).
         * @param {HTMLElement} [originalElement] The original element (original text pre) for height comparison.
         */
        function autoResizeTextarea(textarea, originalElement) {
            textarea.style.height = 'auto';
            if (textarea.innerHTML.trim() === '' && originalElement) {
                // If textarea is empty, set its height to match the original element's scroll height
                textarea.style.height = originalElement.scrollHeight + 'px';
            } else {
                // Otherwise, let it expand to its own content
                textarea.style.height = textarea.scrollHeight + 'px';
            }
        }

        /**
         * Updates the character count and CPS for a specific textarea, including QA checks.
         * @param {HTMLElement} editorDiv The contenteditable div element.
         * @param {number} originalLength The length of the original string segment.
         * @param {number} durationMs The duration of the subtitle in milliseconds.
         */
        function updateSubtitleStats(editorDiv, originalLength, durationMs) {
            const entryIndex = parseInt(editorDiv.dataset.entryIndex);
            const charCountSpan = document.getElementById(`charCount-${entryIndex}`);
            const cpsSpan = document.getElementById(`cps-${entryIndex}`);
            const lineCharCountsDiv = document.getElementById(`lineCharCounts-${entryIndex}`);
            const translationLength = countCharactersWithoutTags(editorDiv.innerHTML);
            const t = translations[currentLanguage];

            if (charCountSpan) {
                charCountSpan.textContent = `${t.char_count_original}${originalLength}${t.char_units} | ${t.char_count_translation}${translationLength}${t.char_units}`;
            }
            
            if (cpsSpan) {
                const currentCPS = calculateCPS(editorDiv.innerHTML, durationMs);
                cpsSpan.textContent = `${currentCPS}${t.cps}`;
                // QA Check for CPS
                if (currentCPS > qaSettings.cpsLimit) {
                    cpsSpan.classList.add('qa-error');
                } else {
                    cpsSpan.classList.remove('qa-error');
                }
            }

            if (lineCharCountsDiv) {
                const lines = editorDiv.innerText.split('\n');
                lineCharCountsDiv.innerHTML = ''; // Clear previous counts
                lines.forEach((line, i) => {
                    const lineLength = countCharactersWithoutTags(line);
                    const lineSpan = document.createElement('span');
                    lineSpan.textContent = `L${i + 1}: ${lineLength}`;
                    // QA Check for chars per line
                    if (lineLength > qaSettings.charsPerLineLimit) {
                        lineSpan.classList.add('qa-error');
                    }
                    if (i > 0) lineCharCountsDiv.append(document.createTextNode(', '));
                    lineCharCountsDiv.appendChild(lineSpan);
                });
            }
// --- INICIO: LÓGICA DE LA BARRA DE PROGRESO CPS ---
            const currentCPS = calculateCPS(editorDiv.innerHTML, durationMs);
            const cpsLimit = qaSettings.cpsLimit;
            
            // 1. Calcula el 'porcentaje de llenado' en relación con el límite
            const fillPercentage = (currentCPS / (cpsLimit * 1.5)) * 100; // Multiplica por 1.5 para que el 100% no sature la barra
            
            // 2. Calcula la posición del límite (ej. 20 CPS)
            const limitPosition = (cpsLimit / (cpsLimit * 1.5)) * 100;

            const barFill = document.getElementById(`cpsBarFill-${entryIndex}`);
            const barLimit = document.getElementById(`cpsBarLimit-${entryIndex}`);
            
            if (barFill && barLimit) {
                // Posiciona el límite
                barLimit.style.left = `${Math.min(limitPosition, 100)}%`;
                
                // Actualiza el relleno
                barFill.style.width = `${Math.min(fillPercentage, 100)}%`;
                
                // Asigna color (Verde si está por debajo, Rojo si está por encima)
                if (currentCPS > cpsLimit) {
                    barFill.style.backgroundColor = '#ef4444'; // Rojo (utilizando un color Tailwind predefinido)
                } else {
                    barFill.style.backgroundColor = '#22c55e'; // Verde
                }
            }
            // --- FIN: LÓGICA DE LA BARRA DE PROGRESO CPS ---
        }

        /**
         * Configures the editable state of a translation entry (editable/read-only).
         * @param {number} entryIndex The index of the SRT entry.
         * @param {boolean} isEditable True to make it editable, false for read-only.
         */
        function setTranslationEditableState(entryIndex, isEditable) {
            const translationEditor = document.getElementById(`translation-${entryIndex}`);
            const validateButton = document.getElementById(`validateBtn-${entryIndex}`);
            const editButton = document.getElementById(`editBtn-${entryIndex}`);
            const checkIcon = document.getElementById(`checkIcon-${entryIndex}`);
            const translationUnit = document.getElementById(`translation-unit-${entryIndex}`); // Get the parent unit

            if (!translationEditor || !validateButton || !editButton || !checkIcon || !translationUnit) {
                console.error(`Elements not found for index ${entryIndex}`);
                return;
            }

            translationEditor.contentEditable = isEditable;
            if (!isEditable) {
                translationUnit.classList.remove('translation-unit-active'); // Remove active highlight on validate

                // Update translation status and words when segment is validated
                const entry = srtEntries[entryIndex];
                entry.isTranslated = translationEditor.innerText.trim() !== '';
                entry.wordCountTranslation = countWords(translationEditor.innerText);
                entry.charCountTranslation = countCharactersWithoutTags(translationEditor.innerHTML);
                entry.cpsTranslation = calculateCPS(translationEditor.innerHTML, entry.durationMs);

                updateStatsDisplay(); // Update stats
                addOrUpdateTMEntry(entry.original, entry.translation); // Add/Update TM
            } else {
                translationUnit.classList.add('translation-unit-active'); // Add active highlight on edit/focus
            }

            validateButton.style.display = isEditable ? 'inline-block' : 'none';
            editButton.style.display = isEditable ? 'none' : 'inline-block';
            checkIcon.style.display = isEditable ? 'none' : 'inline-block';

            if (isEditable) {
                translationEditor.focus();
            }
        }

        /**
         * Applies a style command (like 'bold' or 'italic') to the current selection.
         * @param {string} command The command to execute.
         */
        function formatText(command) {
            document.execCommand(command, false, null);
        }

        /**
         * Applies glossary term highlighting to a given text segment.
         * Collects terms that were successfully highlighted.
         * @param {string} text The original text to highlight.
         * @returns {{html: string, foundTerms: Set<string>}} Object with HTML string and set of found terms.
         */
        function applyGlossaryHighlightToText(text) {
            let highlightedHtml = text;
            const currentFoundTerms = new Set(); // Terms found in *this specific* segment

            if (!glossarySourceLanguage) {
                return { html: text, foundTerms: currentFoundTerms };
            }

            const sortedGlossary = [...glossary].sort((a, b) => b.srcTerm.length - a.srcTerm.length);

            sortedGlossary.forEach(glossaryEntry => {
                if (glossarySourceLanguage && glossaryEntry.srcTerm) {
                    const term = glossaryEntry.srcTerm;
                    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b(${escapedTerm})\\b`, 'gi'); 

                    if (highlightedHtml.match(regex)) {
                        highlightedHtml = highlightedHtml.replace(regex, (match, p1) => {
                            currentFoundTerms.add(term);
                            return `<span class="glossary-highlight">${p1}</span>`;
                        });
                    }
                }
            });
            return { html: highlightedHtml, foundTerms: currentFoundTerms };
        }

        /**
         * Updates highlighting in the glossary table based on terms found in the editor.
         */
        function updateGlossaryTableHighlights() {
            renderGlossary();
        }

function dismissLineBreakTooltip(event) {
            event.stopPropagation(); // Evita que otros clics se disparen
            localStorage.setItem('lineBreakTooltipDismissed', 'true');
            const tooltips = document.querySelectorAll('.line-break-tooltip');
            tooltips.forEach(tooltip => {
                tooltip.style.display = 'none'; // Oculta todas las instancias inmediatamente
            });
        }

function renderTranslations(entries, activeIndexToPreserve = null, preserveScroll = false) {
            translationsContainer.innerHTML = '';
            termsFoundInActiveSegment.clear();
           const t = translations[currentLanguage];
            const tooltipDismissed = localStorage.getItem('lineBreakTooltipDismissed') === 'true';
            let lineBreakTooltipHTML = '';
            if (!tooltipDismissed) {
                lineBreakTooltipHTML = `
                    <div class="line-break-tooltip relative flex items-center bg-blue-100 border border-blue-300 text-blue-800 text-xs px-2 py-1 rounded-md mr-2">
                        <span data-i18n="linebreak_tooltip_text">${t.linebreak_tooltip_text}</span>
                        <button onclick="dismissLineBreakTooltip(event)" class="ml-2 text-blue-800 hover:text-blue-900 font-bold text-lg leading-none">&times;</button>
                    </div>
                `;
            }

clearSubtitleRegions();            

if (entries.length === 0) {
                translationsContainer.innerHTML = `<div data-i18n="no_translations" id="initialMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md">${t.no_translations}</div>`;
                saveSrtButton.disabled = true;
                saveProjectBtn.disabled = true;
                statsContainer.classList.add('hidden');
                return;
            }

            entries.forEach((entry, entryIndex) => {
                const translationUnit = document.createElement('div');
                translationUnit.id = `translation-unit-${entryIndex}`;
                translationUnit.className = 'translation-unit-bg p-2 rounded-lg shadow-sm border border-gray-200 mb-4';

                let startTime, endTime;
if (useFrameTimecode) {
    startTime = formatFrameTime(entry.startTimeMs, projectFPS);
    endTime = formatFrameTime(entry.endTimeMs, projectFPS);
} else {
    [startTime, endTime] = entry.timecodes.split(' --> ');
}
                const durationInSeconds = (entry.durationMs / 1000).toFixed(3);

                translationUnit.innerHTML = `
                    <div class="text-md font-bold mb-2">${entry.index}</div>
                    
                    <div class="flex flex-wrap items-center justify-between gap-x-4 gap-y-2 mb-3">
                        
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium" data-i18n="entry_time">${t.entry_time}</label>
                            <div class="flex items-center">
                                <input type="text" id="startTime-${entryIndex}" value="${startTime}" onchange="handleTimecodeChange(${entryIndex}, true, this)" class="w-32 p-1 rounded-md border-2 border-gray-100 shadow-sm text-sm">
                                <div class="flex items-center gap-1 ml-2">
                                    <button class="btn btn-secondary p-1" onclick="nudgeTimecode(${entryIndex}, true, 1)">
                                        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd"></path></svg>
                                    </button>
                                    <button class="btn btn-secondary p-1" onclick="nudgeTimecode(${entryIndex}, true, -1)">
                                        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
                                    </button>
                                </div>
                                </div>
                        </div>

                        <div class="flex items-center gap-2">
                            <label class="text-sm font-medium" data-i18n="exit_time">${t.exit_time}</label>
                            <div class="flex items-center">
                                <input type="text" id="endTime-${entryIndex}" value="${endTime}" onchange="handleTimecodeChange(${entryIndex}, false, this)" class="w-32 p-1 rounded-md border-2 border-gray-100 shadow-sm text-sm">
                                <div class="flex items-center gap-1 ml-2">
                                    <button class="btn btn-secondary p-1" onclick="nudgeTimecode(${entryIndex}, false, 1)">
                                        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd"></path></svg>
                                    </button>
                                    <button class="btn btn-secondary p-1" onclick="nudgeTimecode(${entryIndex}, false, -1)">
                                        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
                                    </button>
                                </div>
                                </div>
                        </div>

                        <div class="flex items-center gap-2 ml-auto">
                            <span class="text-sm font-semibold" title="Duración del subtítulo"><span data-i18n="duration_label">${t.duration_label}</span> <span id="duration-${entryIndex}">${durationInSeconds}s</span></span>
                            <div class="flex items-center gap-1">
                                <button class="btn btn-secondary p-1" onclick="nudgeVideo(-1)" title="${t.rewind_frame_tooltip}">
                                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M8.445 14.832A1 1 0 0010 14.002V5.998a1 1 0 00-1.555-.832L3.62 9.168a1 1 0 000 1.664l4.825 4.001zM14.445 14.832A1 1 0 0016 14.002V5.998a1 1 0 00-1.555-.832L9.62 9.168a1 1 0 000 1.664l4.825 4.001z"></path></svg>
                                </button>
                                <button class="btn btn-secondary p-1" onclick="jumpToCurrentSubtitleTime(${entryIndex})" title="${t.play_segment_tooltip}">
                                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8.002v3.996a1 1 0 001.555.832l3.223-1.998a1 1 0 000-1.664L9.555 7.168z" clip-rule="evenodd"></path></svg>
                                </button>
                                <button class="btn btn-secondary p-1" onclick="nudgeVideo(1)" title="${t.forward_frame_tooltip}">
                                   <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M5.555 5.168A1 1 0 004 5.998v8.004a1 1 0 001.555.832L10.38 10.832a1 1 0 000-1.664L5.555 5.168zM11.555 5.168A1 1 0 0010 5.998v8.004a1 1 0 001.555.832L16.38 10.832a1 1 0 000-1.664l-4.825-4.001z"></path></svg>
                                </button>
<div class="flex items-center gap-1 ml-2 border-l pl-2">
    <button class="btn btn-secondary p-0 w-12 h-6 flex items-center justify-center" onclick="mergeWithNext(${entryIndex})" title="${t.merge_next_tooltip}">
        → ←
    </button>
    <button class="btn btn-secondary p-0 w-12 h-6 flex items-center justify-center" onclick="splitSubtitle(${entryIndex})" title="${t.split_tooltip}">
        ← →
    </button>
    <button class="btn btn-secondary p-0 w-8 h-6 flex items-center justify-center" onclick="confirmDeleteSubtitle(${entryIndex})" title="${t.delete_tooltip}">
        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.75 1A2.75 2.75 0 006 3.75v.443c-.795.077-1.58.22-2.365.468a.75.75 0 10.23 1.482l.149-.022.841 10.518A2.75 2.75 0 007.596 19h4.807a2.75 2.75 0 002.742-2.53l.841-10.52.149.023a.75.75 0 00.23-1.482A41.03 41.03 0 0014 4.193v-.443A2.75 2.75 0 0011.25 1h-2.5zM10 4c.84 0 1.673.025 2.5.075V3.75c0-.69-.56-1.25-1.25-1.25h-2.5c-.69 0-1.25.56-1.25 1.25v.325C8.327 4.025 9.16 4 10 4zM8.58 7.72a.75.75 0 00-1.5.06l.3 7.5a.75.75 0 101.5-.06l-.3-7.5zm4.34.06a.75.75 0 10-1.5-.06l-.3 7.5a.75.75 0 101.5.06l.3-7.5z" clip-rule="evenodd" /></svg>
    </button>
</div>                </div>
                        </div>
                    </div>
                    
                    <div class="translation-row mb-2">
                        <div class="original-col">
                            <label class="block text-sm font-medium mb-1" data-i18n="original_text">${t.original_text}</label>
                            <pre id="original-pre-${entryIndex}" class="subtitle-display-code p-1 rounded-md text-base overflow-auto max-h-24">${entry.original}</pre>
                        </div>
                        <div class="translation-col">
                            <div class="flex justify-between items-center">
                                <label class="block text-sm font-medium" data-i18n="translation_text">${t.translation_text}</label>
                                <span id="glossary-match-${entryIndex}" class="hidden flex items-center gap-1 text-xs font-semibold text-black bg-yellow-300 px-2 py-0.5 rounded-md truncate"></span>
                            </div>
                            <div id="translation-${entryIndex}" class="subtitle-editor mt-1 block w-full focus:ring-blue-500 focus:border-blue-500 text-base" contenteditable="true" data-entry-index="${entryIndex}" data-original-length="${entry.charCountOriginal}" data-duration-ms="${entry.durationMs}">${entry.translation}</div>
<div id="cpsBarContainer-${entryIndex}" class="cps-bar-container">
                                <div id="cpsBarFill-${entryIndex}" class="cps-bar-fill"></div>
                                <div id="cpsBarLimit-${entryIndex}" class="cps-bar-limit-marker"></div>
                            </div>
                            </div>
                            </div>
                    </div>
                    <div class="flex items-center justify-end mt-1 w-full">
    <div class="flex items-center space-x-2">
        <div class="flex items-center text-sm font-semibold">
    <span id="charCount-${entryIndex}"></span>
    &nbsp;<span class="text-black">|</span>&nbsp;
    <span id="cps-${entryIndex}"></span>
    &nbsp;<span class="text-black">|</span>&nbsp;
    <div id="lineCharCounts-${entryIndex}"></div>
</div>
        ${lineBreakTooltipHTML}
                            <button class="btn btn-secondary text-xs p-1" onclick="formatText('bold')"><b class="font-bold">B</b></button>
                            <button class="btn btn-secondary text-xs p-1" onclick="formatText('italic')"><i class="italic">I</i></button>
                            <svg id="checkIcon-${entryIndex}" class="check-icon text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                            
                            <button title="${t.validate_all_previous_tooltip}" onclick="validateUpTo(${entryIndex})" class="btn btn-secondary text-xs" data-i18n="validate_all_previous">${t.validate_all_previous}</button>
                            <button id="validateBtn-${entryIndex}" class="btn btn-primary text-xs" data-entry-index="${entryIndex}" data-i18n="validate">${t.validate}</button>
                            <button id="editBtn-${entryIndex}" class="btn btn-secondary text-xs" data-entry-index="${entryIndex}" style="display: none;" data-i18n="edit">${t.edit}</button>
                        </div>
                    </div>
                `;
                
                const translationEditor = translationUnit.querySelector(`#translation-${entryIndex}`);
                const originalColPre = translationUnit.querySelector(`#original-pre-${entryIndex}`);
                const validateButton = translationUnit.querySelector(`#validateBtn-${entryIndex}`);
                const editButton = translationUnit.querySelector(`#editBtn-${entryIndex}`);
                const checkIcon = translationUnit.querySelector(`#checkIcon-${entryIndex}`);


                if (entry.isTranslated) {
                    translationEditor.contentEditable = false;
                    validateButton.style.display = 'none';
                    // Ocultamos también el nuevo botón si el subtítulo ya está validado
                    translationUnit.querySelector('[onclick^="validateUpTo"]').style.display = 'none';
                    editButton.style.display = 'inline-block';
                    checkIcon.style.display = 'inline-block';
                }

        // ✅ INICIO DEL BLOQUE FINAL ✅

                let oldValue = entry.translation;

                translationEditor.addEventListener('input', (event) => {
                    if (isApplyingState) return;
                    clearTimeout(debounceTimeout);

                    const currentEntry = srtEntries[entryIndex];
                    currentEntry.translation = event.target.innerHTML;
                    currentEntry.wordCountTranslation = countWords(event.target.innerText);
                    currentEntry.charCountTranslation = countCharactersWithoutTags(event.target.innerHTML);
                    currentEntry.cpsTranslation = calculateCPS(event.target.innerHTML, currentEntry.durationMs);
                    autoResizeTextarea(event.target, originalColPre);
                    updateSubtitleStats(event.target, currentEntry.charCountOriginal, currentEntry.durationMs);
                    updateStatsDisplay();
                    updateSubtitlePreview();

// --- INICIO CÓDIGO AÑADIDO ---
                    // Actualizar el contenido de la región en tiempo real
                    if (wsRegions) {
                        const region = wsRegions.getRegions().find(r => r.id === currentEntry.regionId);
                        if (region) {
                            const content = region.element?.querySelector('.region-content');
                            if (content) {
                                // Reutilizamos la lógica para generar el contenido de 4 líneas
                                const line1 = `#${currentEntry.index}`;
                                const originalPreview = currentEntry.original.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                                const line2 = originalPreview.substring(0, 40) + (originalPreview.length > 40 ? '...' : '');
                                let line3 = '';
                                if (currentEntry.translation) {
                                    const translationPreview = currentEntry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                                    line3 = translationPreview.split('\n').join(' ').substring(0, 40) + (translationPreview.length > 40 ? '...' : '');
                                }
                                let line4 = '---';
                                if (currentEntry.translation) {
                                     const translationTextClean = currentEntry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '');
                                     const transLines = translationTextClean.split('\n');
                                     const transL1 = transLines[0] ? countCharactersWithoutTags(transLines[0]) : 0;
                                     const transL2 = transLines.length > 1 && transLines[1] ? countCharactersWithoutTags(transLines[1]) : 0;
                                     const transCPS = calculateCPS(translationTextClean.replace(/\n/g, ''), currentEntry.durationMs);
                                     line4 = `CPS: ${transCPS} | L1: ${transL1}${transLines.length > 1 ? ` / L2: ${transL2}` : ''}`;
                                }

                                content.innerHTML = `
                                    <div class="region-line region-line1">${line1}</div>
                                    <div class="region-line region-line2">${line2}</div>
                                    <div class="region-line region-line3">${line3}&nbsp;</div>
                                    <div class="region-line region-line4">${line4}</div>
                                `;
                            }
                        }
                    }
                    // --- FIN CÓDIGO AÑADIDO ---

                    debounceTimeout = setTimeout(() => {
                        const newValue = event.target.innerHTML;
                        saveState(entryIndex, oldValue, newValue);
                        oldValue = newValue;
                    }, 1000);
                });

translationEditor.addEventListener('keydown', (event) => {
                    if (event.isSimulated) {
                        return;
                    }

                    if (event.key === 'Enter') {
                        if (!event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey) {
                            Object.defineProperty(event, 'shiftKey', { get: () => true });
                            event.preventDefault();
                            setTimeout(() => {
                                moveToNextEditableCell(event.currentTarget);
                            }, 0);
                            return;
                        }
                    }

                    // --- Comprobación de atajos de EDICIÓN y NAVEGACIÓN ---
                    const triggeredAction = Object.keys(shortcuts).find(action => {
                        const localActions = [
                            'validateAndNext', 'goToNext', 'goToPrevious', // Se añaden de nuevo aquí
                            'insertTM1', 'insertTM2', 'insertTM3', 'insertTM4', 'insertTM5', 
                            'insertGloss1', 'insertGloss2', 'insertGloss3', 'insertGloss4', 'insertGloss5', 
                            'bold', 'italic',
                            'jumpToTime',
                            'playSegment',
                            'playSegmentLoop',
                            'playPause',
                            'seekForward',
                            'seekBackward',
                            'seekForwardFast',
                            'seekBackwardFast'
                            
                        ];
                        if (!localActions.includes(action)) return false;

                        const shortcut = shortcuts[action];
                        const keyMatch = (shortcut.key === ' ' && event.code === 'Space') || (shortcut.key.toLowerCase() === event.key.toLowerCase());
                        return keyMatch &&
                               shortcut.ctrlKey === event.ctrlKey &&
                               shortcut.metaKey === event.metaKey &&
                               shortcut.altKey === event.altKey &&
                               shortcut.shiftKey === event.shiftKey;
                    });

                    if (triggeredAction) {
                        event.preventDefault();
                        switch (triggeredAction) {
                            case 'validateAndNext':
    setTranslationEditableState(entryIndex, false);
    goToNextTranslation(entryIndex, true);
    break;
                            // Se añaden los casos de navegación de nuevo
                            case 'goToNext':
                                goToNextTranslation(entryIndex);
                                break;
                            case 'goToPrevious':
                                goToPreviousTranslation(entryIndex);
                                break;
                            case 'bold':
                                formatText('bold');
                                break;
                            case 'italic':
                                formatText('italic');
                                break;
                            case 'jumpToTime':
                            case 'playSegment':
                                jumpToCurrentSubtitleTime(entryIndex);
                                break;
                            case 'playSegmentLoop':
                                playSubtitleLoop(entryIndex);
                                break;
                            case 'playPause':
                                if (videoPlayer.paused) videoPlayer.play();
                                else videoPlayer.pause();
                                break;
                            case 'seekForward':
                                videoPlayer.currentTime += 3;
                                break;
                            case 'seekBackward':
                                videoPlayer.currentTime -= 3;
                                break;
                            case 'seekForwardFast':
                                videoPlayer.currentTime += 5;
                                break;
                            case 'seekBackwardFast':
                                videoPlayer.currentTime -= 5;
                                break;
                            case 'insertTM1':
                                tmSearch(srtEntries[entryIndex].original); // <--- AÑADIR ESTO
                                if (currentTMLatestSearchResults.length > 0) document.execCommand('insertHTML', false, currentTMLatestSearchResults[0].tgtText);
                                break;
                            case 'insertTM2':
                                tmSearch(srtEntries[entryIndex].original); // <--- AÑADIR ESTO
                                if (currentTMLatestSearchResults.length > 1) document.execCommand('insertHTML', false, currentTMLatestSearchResults[1].tgtText);
                                break;
                            case 'insertTM3':
                                tmSearch(srtEntries[entryIndex].original); // <--- AÑADIR ESTO
                                if (currentTMLatestSearchResults.length > 2) document.execCommand('insertHTML', false, currentTMLatestSearchResults[2].tgtText);
                                break;
                            case 'insertTM4':
                                tmSearch(srtEntries[entryIndex].original); // <--- AÑADIR ESTO
                                if (currentTMLatestSearchResults.length > 3) document.execCommand('insertHTML', false, currentTMLatestSearchResults[3].tgtText);
                                break;
                            case 'insertTM5':
                                tmSearch(srtEntries[entryIndex].original); // <--- AÑADIR ESTO
                                if (currentTMLatestSearchResults.length > 4) document.execCommand('insertHTML', false, currentTMLatestSearchResults[4].tgtText);
                                break;
                           
                            default:
                                // El if de 'insertTM' ya no es necesario aquí, pero dejamos el de 'insertGloss'
                                if (triggeredAction.startsWith('insertGloss')) {
                                    const index = parseInt(triggeredAction.replace('insertGloss', '')) - 1;
                                    if (currentGlossaryLatestResults.length > index) {
                                        document.execCommand('insertHTML', false, currentGlossaryLatestResults[index].tgtTerm);
                                    }
                                }
                                break;
                        }
                        return;
                    }
                          
                    // --- Lógica para atajos de documentación ---
                    const triggeredDocAction = shortcuts.docResources.find(res => {
                        if (!res.shortcut) return false;
                        const sc = res.shortcut;
                        const keyMatch = (sc.key === ' ' && event.code === 'Space') || (sc.key.toLowerCase() === event.key.toLowerCase());
                        return keyMatch &&
                               sc.ctrlKey === event.ctrlKey &&
                               sc.metaKey === event.metaKey &&
                               sc.altKey === event.altKey &&
                               sc.shiftKey === event.shiftKey;
                    });

                    if (triggeredDocAction) {
                        event.preventDefault();
                        const selectedText = window.getSelection().toString().trim();
                        const resourceUrl = triggeredDocAction.url;

                        if (selectedText && resourceUrl && resourceUrl.includes('{word}')) {
                            const finalUrl = resourceUrl.replace('{word}', encodeURIComponent(selectedText));
                            window.open(finalUrl, '_blank');
                        }
                    }
                });

                translationEditor.addEventListener('focus', (event) => {
                    oldValue = translationEditor.innerHTML;
                    document.querySelectorAll('.translation-unit-active').forEach(unit => unit.classList.remove('translation-unit-active'));
                    translationUnit.classList.add('translation-unit-active');
                    termsFoundInActiveSegment.clear();
                    if (glossarySourceLanguage && glossary.length > 0) {
                        const highlightResult = applyGlossaryHighlightToText(entry.original);
                        originalColPre.innerHTML = highlightResult.html;
                        highlightResult.foundTerms.forEach(term => termsFoundInActiveSegment.add(term));
                    }

                    const glossaryMatchContainer = document.getElementById(`glossary-match-${entryIndex}`);
                    glossaryMatchContainer.innerHTML = '';
                    glossaryMatchContainer.title = '';
                    glossaryMatchContainer.classList.add('hidden');

                    if (termsFoundInActiveSegment.size > 0) {
                        let hintText = '';
                        let fullHintText = '';

                        termsFoundInActiveSegment.forEach(foundTerm => {
                            const glossaryEntry = glossary.find(g => g.srcTerm === foundTerm);
                            if (glossaryEntry) {
                                const part = `${glossaryEntry.srcTerm} -> ${glossaryEntry.tgtTerm}`;
                                hintText += part + ' | ';
                                fullHintText += part + ' | ';
                            }
                        });

                        if (hintText) {
                            glossaryMatchContainer.innerHTML = `
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg>
                                <span>${hintText.slice(0, -3)}</span>
                            `;
                            glossaryMatchContainer.title = `Glosario: ${fullHintText.slice(0, -3)}`;
                            glossaryMatchContainer.classList.remove('hidden');
                        }
                    }
                    updateGlossaryTableHighlights();
                    autoResizeTextarea(event.target, originalColPre);
                    event.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    tmSearch(srtEntries[entryIndex].original);
                    updateContextPanel(entryIndex);
                });

                translationEditor.addEventListener('blur', () => {
                    originalColPre.textContent = entry.original;
                    termsFoundInActiveSegment.clear();
                    document.getElementById(`glossary-match-${entryIndex}`).classList.add('hidden');
                    document.getElementById(`glossary-match-${entryIndex}`).title = '';
                    updateGlossaryTableHighlights();
                    tmSearch();
                });
                
                // ✅ FIN DEL BLOQUE FINAL ✅

                validateButton.addEventListener('click', () => {
                    setTranslationEditableState(entryIndex, false);
                    goToNextTranslation(entryIndex);
                });

                editButton.addEventListener('click', () => setTranslationEditableState(entryIndex, true));

                translationsContainer.appendChild(translationUnit);
                updateSubtitleStats(translationEditor, entry.charCountOriginal, entry.durationMs);
addSubtitleRegion(entry);
            });
            
            saveSrtButton.disabled = false;
            saveProjectBtn.disabled = false;
            statsContainer.classList.remove('hidden');
plannerContainer.classList.remove('hidden');
            updateStatsDisplay();
            setupIntersectionObserver();

            if (!preserveScroll) {
                if (activeIndexToPreserve !== null && activeIndexToPreserve < srtEntries.length) {
                    navigateToTranslation(activeIndexToPreserve);
                } else {
                    const firstEditableSegment = getFirstEditableSegment();
                    if (firstEditableSegment) {
                        navigateToTranslation(firstEditableSegment.entryIndex);
                    }
                }
            }
        }

 /**
         * Valida el subtítulo actual y todos los anteriores que no estén ya validados.
         * @param {number} entryIndex - El índice del subtítulo actual.
         */
        function validateUpTo(entryIndex) {
            showLoadingOverlay('Validando subtítulos...'); // Muestra un mensaje de carga
            
            // Usamos un timeout para que la interfaz de carga se muestre antes de empezar el proceso
            setTimeout(() => {
                for (let i = 0; i <= entryIndex; i++) {
                    // Solo validamos si no está ya validado para ser más eficientes
                    if (!srtEntries[i].isTranslated) {
                        setTranslationEditableState(i, false);
                    }
                }
                
                // Una vez terminado, salta al siguiente subtítulo pendiente
                goToNextTranslation(entryIndex, false);
                hideLoadingOverlay(); // Oculta el mensaje de carga
            }, 50); // Un pequeño retardo de 50ms es suficiente
        }


function updateTranslations() {
    // Primero, actualizamos la tabla del glosario para que muestre los nuevos términos.
    renderGlossary();

    // Luego, recorremos cada subtítulo para ver si necesita una actualización visual.
    srtEntries.forEach((entry, entryIndex) => {
        const originalColPre = document.getElementById(`original-pre-${entryIndex}`);
        if (!originalColPre) return; // Si el subtítulo no está en pantalla, no hacemos nada.

        // La principal razón para refrescar es aplicar el resaltado del nuevo
        // término del glosario en el subtítulo que esté activo.
        if (lastActiveSubtitleIndex === entryIndex) {
            const highlightResult = applyGlossaryHighlightToText(entry.original);
            originalColPre.innerHTML = highlightResult.html;
        }
    });

    // Finalmente, actualizamos las estadísticas generales (contador de palabras, etc.).
    updateStatsDisplay();
}


  /**
         * Updates the display of translation progress and word counts.
         */
        function updateStatsDisplay() {
            const t = translations[currentLanguage];
            let totalSegments = srtEntries.length;
            let translatedSegments = srtEntries.filter(e => e.isTranslated).length;
            let totalWordsOriginal = srtEntries.reduce((acc, e) => acc + e.wordCountOriginal, 0);
            let totalWordsTranslated = srtEntries.reduce((acc, e) => acc + e.wordCountTranslation, 0);

            const percentage = totalSegments > 0 ? ((translatedSegments / totalSegments) * 100).toFixed(0) : 0;
            
            segmentsProgress.textContent = t.segments_progress_text.replace('{0}', translatedSegments).replace('{1}', totalSegments).replace('{2}', percentage);
            wordsTranslated.textContent = t.words_translated_text.replace('{0}', totalWordsTranslated);
            wordsTotal.textContent = t.words_total_text.replace('{0}', totalWordsOriginal);
            wordsRemaining.textContent = t.words_remaining_text.replace('{0}', totalWordsOriginal - totalWordsTranslated);

            const qaErrors = calculateAllQaErrors();
            if (qaErrors.length > 0) {
                qaErrorStats.textContent = t.qa_errors_found.replace('{0}', qaErrors.length);
                qaErrorStats.className = 'qa-error clickable';
            } else {
                qaErrorStats.textContent = t.qa_no_errors;
                qaErrorStats.className = 'qa-success';
            }

const statusBar = document.getElementById('statusBar');
            if (statusBar) {
                // Obtenemos el texto de cada span
                const progressText = segmentsProgress.textContent;
                const translatedText = wordsTranslated.textContent;
                const totalText = wordsTotal.textContent;
                const remainingText = wordsRemaining.textContent;
                const qaText = qaErrorStats.textContent;
                const isQaClickable = qaErrorStats.classList.contains('clickable'); // Verificamos si hay errores

                // Determinamos las clases CSS para el texto QA
                const qaClasses = isQaClickable ? 'qa-error' : 'qa-success'; // Usa las clases existentes

                // Creamos el HTML para el texto QA
                let qaHtml = '';
                if (isQaClickable) {
                    // Si hay errores (clickable), usa un span con ID y clases
                    qaHtml = `<span id="statusBarQaLink" class="cursor-pointer underline ${qaClasses}">${qaText}</span>`;
                } else {
                    // Si no hay errores, usa un span solo con las clases de estilo
                    qaHtml = `<span class="${qaClasses}">${qaText}</span>`;
                }

                // Combinamos todo en el innerHTML, añadiendo el espacio antes de qaHtml
                statusBar.innerHTML = `${progressText} | ${translatedText} / ${totalText} | ${remainingText} |&nbsp; ${qaHtml}`; //

                // Si añadimos el span clickable, le añadimos el listener AHORA
                if (isQaClickable) {
                    const statusBarQaLink = document.getElementById('statusBarQaLink');
                    if (statusBarQaLink) {
                        statusBarQaLink.addEventListener('click', () => {
                            // Reutilizamos la lógica del listener original de qaErrorStats
                            if (calculateAllQaErrors().length > 0) {
                                renderQaErrorList();
                                qaErrorListModal.classList.remove('hidden');
                            }
                        });
                    }
                }
            }
        }


        /**
         * Gets the index of the currently focused translation textarea.
         * @returns {{entryIndex: number} | null} The object with index, or null.
         */
        function getCurrentFocusedIndex() {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.classList.contains('subtitle-editor')) {
                return {
                    entryIndex: parseInt(activeElement.dataset.entryIndex)
                };
            }
            return null;
        }

        /**
         * Finds the first editable segment.
         * @returns {{entryIndex: number} | null} The object with index, or null.
         */
       function getFirstEditableSegment() {
    // Recorremos todos los subtítulos buscando el primero que no esté validado.
    for (let i = 0; i < srtEntries.length; i++) {
        // Si encontramos uno que NO está traducido (`isTranslated` es false)...
        if (!srtEntries[i].isTranslated) {
            // ...devolvemos su índice para que el programa salte directamente a él.
            return { entryIndex: i };
        }
    }

    // Si el bucle termina y no hemos encontrado ninguno sin traducir
    // (es decir, todos están validados), no devolvemos nada (null).
    return null;
}


        /**
         * Navigates to and focuses a specific translation field.
         * @param {number} entryIndex The index of the SRT entry.
         */
   function navigateToTranslation(entryIndex) {
    const targetEditor = document.getElementById(`translation-${entryIndex}`);
    if (targetEditor) {
        const currentlyFocusedEditor = document.activeElement;
        if (currentlyFocusedEditor && currentlyFocusedEditor.classList.contains('subtitle-editor') && currentlyFocusedEditor !== targetEditor) {
            currentlyFocusedEditor.blur();
        }
        setTranslationEditableState(entryIndex, true);
        targetEditor.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
       
        // --- MODIFIED BLOCK ---
        if (videoPlayer.src && srtEntries[entryIndex]) {
            // Set the video time to the start of the focused subtitle, but DO NOT play.
            videoPlayer.currentTime = srtEntries[entryIndex].startTimeMs / 1000;
        }
        // --- END MODIFIED BLOCK ---
    }
}

        /**
         * Moves focus to the next translation field.
         * @param {number} currentEntryIndex The current index of the SRT entry.
         */
        function goToNextTranslation(currentEntryIndex, autoPlayNext = false) {
            if (srtEntries.length === 0) return;

            let nextEntryIndex = currentEntryIndex + 1;

            if (nextEntryIndex < srtEntries.length) {
                // Esto enfoca, hace scroll y ajusta el tiempo del vídeo
                navigateToTranslation(nextEntryIndex);
                
                // Si la orden fue "validar y seguir", reproducimos el segmento
                if (autoPlayNext) {
                    jumpToCurrentSubtitleTime(nextEntryIndex);
                }
            } else {
                showMessage(errorMessages[currentLanguage]['reached_last']);
            }
        }

        /**
         * Moves focus to the previous translation field.
         * @param {number} currentEntryIndex The current index of the SRT entry.
         */
        function goToPreviousTranslation(currentEntryIndex) {
            if (srtEntries.length === 0) return;

            let prevEntryIndex = currentEntryIndex - 1;

            if (prevEntryIndex >= 0) {
                navigateToTranslation(prevEntryIndex);
            } else {
                showMessage(errorMessages[currentLanguage]['reached_first']);
            }
        }

function setupIntersectionObserver() {
    const options = {
        root: document.getElementById('editorMainContent'),
        rootMargin: '-50% 0px -50% 0px', // Elige el elemento que está en el centro
        threshold: 0
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                // Cuando un subtítulo entra en el centro de la vista,
                // guardamos su índice como el último activo.
                lastActiveSubtitleIndex = parseInt(entry.target.querySelector('.subtitle-editor').dataset.entryIndex, 10);
            }
        });
    }, options);

    // Hacemos que el observador vigile cada uno de los subtítulos
    document.querySelectorAll('.translation-unit-bg').forEach(unit => {
        observer.observe(unit);
    });
}

// --- INICIO DEL CÓDIGO A AÑADIR ---

        // --- Undo/Redo Logic ---

        /**
         * Actualiza el estado de los botones Deshacer/Rehacer (activado/desactivado).
         */
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn && redoBtn) {
                undoBtn.disabled = historyStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }
        }

       /**
         * Guarda el estado de un cambio de texto en el historial. // <- Texto modificado
         * @param {number} entryIndex - El índice del subtítulo modificado.
         * @param {string} oldValue - El contenido ANTES del cambio.
         * @param {string} newValue - El contenido DESPUÉS del cambio.
         */
        function saveState(entryIndex, oldValue, newValue) {
            // AÑADIR ESTA LÍNEA ->
            if (isApplyingState) return; // No guardar estados mientras se deshace/rehace
            // Si el valor no ha cambiado, no guardamos nada.
            if (oldValue === newValue) return;

            // AÑADIR type: 'text' ->
            historyStack.push({ type: 'text', entryIndex, oldValue, newValue });
            redoStack = []; // Un nuevo cambio borra el historial de "rehacer"
            updateUndoRedoButtons();
        }

        /**
         * Deshace la última acción del historial.
         */
        function undo() {
            if (historyStack.length === 0) return;

isApplyingState = true;

            const lastAction = historyStack.pop();
            const { entryIndex, oldValue, newValue } = lastAction;

            // Guardamos la acción inversa en el historial de "rehacer"
            redoStack.push(lastAction);

            // Aplicamos el estado anterior
            const entry = srtEntries[entryIndex];
            const editor = document.getElementById(`translation-${entryIndex}`);
            if (entry && editor) {
                entry.translation = oldValue;
                editor.innerHTML = oldValue;
                editor.dispatchEvent(new Event('input', { bubbles: true })); // Para actualizar estadísticas
            }

            updateUndoRedoButtons();
isApplyingState = false;
        }

        /**
         * Rehace la última acción deshecha.
         */
        function redo() {
            if (redoStack.length === 0) return;
isApplyingState = true; 

            const lastUndo = redoStack.pop();
            const { entryIndex, oldValue, newValue } = lastUndo;

            // Devolvemos la acción al historial principal
            historyStack.push(lastUndo);

            // Aplicamos el estado posterior
            const entry = srtEntries[entryIndex];
            const editor = document.getElementById(`translation-${entryIndex}`);
            if (entry && editor) {
                entry.translation = newValue;
                editor.innerHTML = newValue;
                editor.dispatchEvent(new Event('input', { bubbles: true })); // Para actualizar estadísticas
            }

            updateUndoRedoButtons();
isApplyingState = false;
        }
        // --- FIN DEL CÓDIGO A AÑADIR ---

        // --- Event Handlers ---

        srtFile.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                await processFile(file);
            }
        });

        saveSrtButton.addEventListener('click', () => {
            if (srtEntries.length === 0) {
                showMessage(errorMessages[currentLanguage]['no_translations_to_save']);
                return;
            }
            fileNameInput.value = currentFileName.replace(/\.srt$/i, '') + '_trad.srt';
            saveSrtModal.classList.remove('hidden');
            fileNameInput.focus();
        });

        cancelSaveBtn.addEventListener('click', () => {
            saveSrtModal.classList.add('hidden');
        });

        confirmSaveBtn.addEventListener('click', () => {
            const filename = fileNameInput.value;
            if (!filename) {
                showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                return;
            }
            showLoadingOverlay(errorMessages[currentLanguage]['saving_file']);
            try {
                const updatedSrtContent = reconstructSrt(srtEntries);
                const blob = new Blob([updatedSrtContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename.endsWith('.srt') ? filename : filename + '.srt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showMessage(errorMessages[currentLanguage]['file_saved_successfully']);
            } catch (error) {
                showMessage(`${errorMessages[currentLanguage]['error_saving_file']} ${error.message}`);
                console.error("Error saving file:", error);
            } finally {
                hideLoadingOverlay();
                saveSrtModal.classList.add('hidden');
            }
        });

        async function processFile(file) {
            currentFileName = file.name;
            videoFileName = null; // Reset video file name when a new SRT is loaded
            showLoadingOverlay(errorMessages[currentLanguage]['loading_file']);

           
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        srtEntries = parseSrtContent(content);
 historyStack = [];
                    redoStack = [];
                    updateUndoRedoButtons();
                        renderTranslations(srtEntries);
                        runFullQaCheck();
                        updateStatsDisplay();
                        resolve();
                    } catch (error) {
                        showMessage(`${errorMessages[currentLanguage]['error_reading_file']} ${error.message}`);
                        console.error("Error parsing file:", error);
                        translationsContainer.innerHTML = `<div class="text-center text-red-500 p-4 border border-red-300 rounded-md">${errorMessages[currentLanguage]['file_processing_error']}</div>`;
                        saveSrtButton.disabled = true;
                        saveProjectBtn.disabled = true;
                        statsContainer.classList.add('hidden');
                        resolve();
                    } finally {
                        hideLoadingOverlay();
                    }
                };
                reader.onerror = () => {
                    showMessage(errorMessages[currentLanguage]['error_reading_file'] + (file.name || ''));
                    saveSrtButton.disabled = true;
                    saveProjectBtn.disabled = true;
                    statsContainer.classList.add('hidden');
                    hideLoadingOverlay();
                    resolve();
                };
                reader.readAsText(file);
            });
        }

        
      function showMessage(msg) {
            // Limpia cualquier temporizador anterior
            clearTimeout(messageTimeout);
            
            messageText.textContent = msg;

            // ❗ CORRECCIÓN: Quitamos la clase 'hidden' para que el contenedor exista
            messageBox.classList.remove('hidden'); 
            
            // Hacemos visible el mensaje, iniciando la transición de "fade in"
            setTimeout(() => {
                messageBox.classList.add('is-visible');
            }, 10); // Un pequeño retardo para asegurar que la animación se ejecute

            // Configuramos un nuevo temporizador para ocultarlo
            messageTimeout = setTimeout(() => {
                // Quitamos la clase, iniciando la transición de "fade out"
                messageBox.classList.remove('is-visible');
                 // Esperamos a que la animación de salida termine para volver a ocultarlo
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, 300); // Coincide con la duración de la transición en CSS
            }, 3000); // El mensaje estará visible por 3 segundos
        }

        // --- Keyboard Shortcuts Modal ---
        shortcutsBtn.addEventListener('click', () => {
            renderShortcutsModal();
            shortcutsModal.classList.remove('hidden');
        });

        shortcutsCloseBtn.addEventListener('click', () => {
            window.removeEventListener('keydown', recordShortcutHandler, true); // Use correct handler
            recordingAction = null;
            shortcutsModal.classList.add('hidden');
        });

        function formatShortcut(shortcut) {
            let parts = [];
            if (shortcut.ctrlKey) parts.push('Ctrl');
            if (shortcut.metaKey) parts.push('Cmd');

            
            if (shortcut.altKey) {
                // Si el perfil es 'mac', usa "Option". Si no, usa "Alt".
                const altKeyName = activeProfile === 'mac' ? 'Option' : 'Alt';
                parts.push(altKeyName);
            }
            

            if (shortcut.shiftKey) parts.push('Shift');
            
            let keyName = shortcut.key;
            if (keyName === ' ') keyName = 'Space';
            
            parts.push(keyName.charAt(0).toUpperCase() + keyName.slice(1));
            return parts.join(' + ');
        }

      function renderShortcutsModal() {
            shortcutsList.innerHTML = '';
            const t = translations[currentLanguage];
            const activeShortcuts = shortcutProfiles[activeProfile];

            for (const action in activeShortcuts) {
                if (action === 'docResources') continue;

                const shortcut = activeShortcuts[action];
                const row = document.createElement('div');
                row.className = 'flex justify-between items-center p-2 border-b';
                
                const description = t[shortcut.descriptionKey] || shortcut.descriptionKey;
                
                let shortcutControlsHTML = `
                    <span id="shortcut-display-${action}" class="shortcut-input font-mono">${formatShortcut(shortcut)}</span>
                    <button class="btn btn-secondary text-sm" data-action="${action}" data-i18n="edit_shortcut_btn">${t.edit_shortcut_btn}</button>
                `;

                if (action === 'playSegmentLoop') {
                    shortcutControlsHTML = `
                        <input type="number" min="1" value="${shortcut.loopCount || 3}" onchange="updateLoopCount(this.value)" class="w-16 p-1 border border-gray-300 rounded-md text-center">
                        ${shortcutControlsHTML}
                    `;
                }

                row.innerHTML = `
                    <span>${description}</span>
                    <div class="flex items-center gap-2">
                        ${shortcutControlsHTML}
                    </div>
                `;
                shortcutsList.appendChild(row);
            }

            // ... (El código para la sección "Productive Documentation" no cambia, por lo que se omite por brevedad) ...
            const docSection = document.createElement('div');
            docSection.className = 'mt-6 pt-4 border-t';
            docSection.innerHTML = `<h3 class="text-lg font-bold mb-3" data-i18n="productive_documentation">${t.productive_documentation}</h3>`;
            activeShortcuts.docResources.forEach((resource, index) => {
                const row = document.createElement('div');
                row.className = 'flex justify-between items-center p-2 gap-4';
                const urlInput = document.createElement('input');
                urlInput.type = 'text';
                urlInput.className = 'w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white';
                urlInput.placeholder = t.doc_resource_placeholder;
                urlInput.value = resource.url;
                urlInput.oninput = (e) => {
                    shortcutProfiles[activeProfile].docResources[index].url = e.target.value;
                    saveShortcuts();
                };
                const shortcutContainer = document.createElement('div');
                shortcutContainer.className = 'flex items-center gap-2';
                const shortcutDisplay = document.createElement('span');
                shortcutDisplay.id = `shortcut-display-doc_${index}`;
                shortcutDisplay.className = 'shortcut-input font-mono';
                shortcutDisplay.textContent = resource.shortcut ? formatShortcut(resource.shortcut) : '...';
                const editButton = document.createElement('button');
                editButton.className = 'btn btn-secondary text-sm';
                editButton.dataset.action = `doc_${index}`;
                editButton.textContent = t.edit_shortcut_btn;
                shortcutContainer.appendChild(shortcutDisplay);
                shortcutContainer.appendChild(editButton);
                row.appendChild(urlInput);
                row.appendChild(shortcutContainer);
                docSection.appendChild(row);
            });
            shortcutsList.appendChild(docSection);

            shortcutsList.querySelectorAll('button[data-action]').forEach(button => {
                button.addEventListener('click', () => startRecording(button.dataset.action));
            });

            // Lógica para el selector de perfil
            const profileSelector = document.getElementById('shortcutProfileSelector');
            profileSelector.value = activeProfile;
            profileSelector.onchange = (e) => {
                activeProfile = e.target.value;
                localStorage.setItem('shortcutProfile', activeProfile); // Guardar preferencia
                shortcuts = { ...shortcutProfiles[activeProfile] }; // Actualizar atajos activos
                renderShortcutsModal(); // Volver a renderizar el modal con el nuevo perfil
            };
        }
        let recordingAction = null;
        const recordShortcutHandler = (e) => {
            if (!recordingAction) return;
        
            e.preventDefault();
            e.stopPropagation();
        
            const modifierKeys = ['Control', 'Alt', 'Shift', 'Meta'];
            if (modifierKeys.includes(e.key)) {
                return; 
            }
        
            window.removeEventListener('keydown', recordShortcutHandler, true);
        
            const newShortcut = {
                key: e.key === ' ' ? ' ' : e.key.toLowerCase(),
                ctrlKey: e.ctrlKey,
                altKey: e.altKey,
                shiftKey: e.shiftKey,
metaKey: e.metaKey
            };
        
            // Check for conflicts
            let conflict = Object.keys(shortcuts).some(action => {
                if (action === 'docResources' || action === recordingAction) return false;
                const sc = shortcuts[action];
                return sc.key === newShortcut.key && sc.ctrlKey === newShortcut.ctrlKey && sc.altKey === newShortcut.altKey && sc.shiftKey === newShortcut.shiftKey;
            });

            if (!conflict) {
                conflict = shortcuts.docResources.some((res, i) => {
                    const actionId = `doc_${i}`;
                    if (!res.shortcut || actionId === recordingAction) return false;
                    const sc = res.shortcut;
                    return sc.key === newShortcut.key && sc.ctrlKey === newShortcut.ctrlKey && sc.altKey === newShortcut.altKey && sc.shiftKey === newShortcut.shiftKey;
                });
            }

            if (conflict) {
                showMessage(errorMessages[currentLanguage].shortcut_conflict);
            } else {
                if (recordingAction.startsWith('doc_')) {
                    // It's a documentation shortcut
                    const index = parseInt(recordingAction.split('_')[1]);
                    shortcuts.docResources[index].shortcut = newShortcut;
                } else {
                    // It's a regular application shortcut
                   shortcutProfiles[activeProfile][recordingAction] = { ...shortcutProfiles[activeProfile][recordingAction], ...newShortcut };
                }
                saveShortcuts();
            }
        
            recordingAction = null;
            renderShortcutsModal();
        };

        function startRecording(action) {
            // Clear any previous recording state
            window.removeEventListener('keydown', recordShortcutHandler, true);
            document.querySelectorAll('.shortcut-input.recording').forEach(el => {
                const prevAction = el.id.replace('shortcut-display-', '');
                let shortcutToFormat;
                if (prevAction.startsWith('doc_')) {
                    const index = parseInt(prevAction.split('_')[1]);
                    shortcutToFormat = shortcuts.docResources[index].shortcut;
                } else {
                    shortcutToFormat = shortcuts[prevAction];
                }
                el.textContent = shortcutToFormat ? formatShortcut(shortcutToFormat) : '...';
            });

            recordingAction = action;
            const displayEl = document.getElementById(`shortcut-display-${action}`);
            displayEl.classList.add('recording');
            displayEl.textContent = translations[currentLanguage].recording_shortcut_text;
            
            window.addEventListener('keydown', recordShortcutHandler, true);
        }

        async function saveShortcuts() {
            try {
                await db.settings.put({ key: 'shortcutProfiles', value: shortcutProfiles });
            } catch (error) {
                console.error("Failed to save shortcuts:", error);
            }
        }

async function loadShortcuts() {
            // 1. Define el perfil base de Windows/Linux
            const windowsProfile = {
                validateAndNext: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'enter', descriptionKey: 'shortcut_desc_validateAndNext' },
                goToNext: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'arrowdown', descriptionKey: 'shortcut_desc_goToNext' },
                goToPrevious: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'arrowup', descriptionKey: 'shortcut_desc_goToPrevious' },
                 insertTM1: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '1', descriptionKey: 'shortcut_desc_insertTM1' },
                insertTM2: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '2', descriptionKey: 'shortcut_desc_insertTM2' },
                insertTM3: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '3', descriptionKey: 'shortcut_desc_insertTM3' },
                insertTM4: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '4', descriptionKey: 'shortcut_desc_insertTM4' },
                insertTM5: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: false, key: '5', descriptionKey: 'shortcut_desc_insertTM5' },
                insertGloss1: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '1', descriptionKey: 'shortcut_desc_insertGloss1' },
                insertGloss2: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '2', descriptionKey: 'shortcut_desc_insertGloss2' },
                insertGloss3: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '3', descriptionKey: 'shortcut_desc_insertGloss3' },
                insertGloss4: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '4', descriptionKey: 'shortcut_desc_insertGloss4' },
                insertGloss5: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '5', descriptionKey: 'shortcut_desc_insertGloss5' },
                jumpToTime: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'j', descriptionKey: 'shortcut_desc_jumpToTime' },
                playSegment: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: ' ', descriptionKey: 'shortcut_desc_playSegment' },
                playPause: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: '0', descriptionKey: 'shortcut_desc_playPause' },
                playSegmentLoop: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'l', descriptionKey: 'shortcut_desc_playSegmentLoop', loopCount: 3 },
                seekForward: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: true, key: 'arrowright', descriptionKey: 'shortcut_desc_seekForward' },
                seekBackward: { ctrlKey: false, metaKey: false, altKey: true, shiftKey: true, key: 'arrowleft', descriptionKey: 'shortcut_desc_seekBackward' },
                seekForwardFast: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: true, key: 'arrowright', descriptionKey: 'shortcut_desc_seekForwardFast' },
                seekBackwardFast: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: true, key: 'arrowleft', descriptionKey: 'shortcut_desc_seekBackwardFast' },
                bold: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'b', descriptionKey: 'shortcut_desc_bold' },
                italic: { ctrlKey: true, metaKey: false, altKey: false, shiftKey: false, key: 'i', descriptionKey: 'shortcut_desc_italic' },
        docResources: Array.from({ length: 5 }, () => ({ url: '', shortcut: null }))
            };

 // 2. Crea el perfil de Mac a partir del de Windows
            // Esta copia asegura que el perfil de Mac tenga todos los atajos definidos
            const macProfile = JSON.parse(JSON.stringify(windowsProfile));

            // 3. Carga los perfiles guardados si existen
            try {
                const savedProfiles = await db.settings.get('shortcutProfiles');
                shortcutProfiles.windows = savedProfiles?.value?.windows || windowsProfile;
                shortcutProfiles.mac = savedProfiles?.value?.mac || macProfile;
            } catch (e) {
                console.error("No se pudieron cargar los perfiles de atajos, usando valores por defecto.", e);
                shortcutProfiles.windows = windowsProfile;
                shortcutProfiles.mac = macProfile;
            }

            // 4. Carga y activa el perfil preferido del usuario
            activeProfile = localStorage.getItem('shortcutProfile') || (navigator.platform.toUpperCase().indexOf('MAC') >= 0 ? 'mac' : 'windows');
            shortcuts = { ...shortcutProfiles[activeProfile] };
        }
        
        restoreShortcutsBtn.addEventListener('click', async () => {
            shortcuts = JSON.parse(JSON.stringify(defaultShortcuts)); // Deep copy
            // Re-initialize docResources
            shortcuts.docResources = [];
            for (let i = 0; i < 5; i++) {
                shortcuts.docResources.push({ url: '', shortcut: null });
            }
            await saveShortcuts();
            renderShortcutsModal();
        });

        exportShortcutsBtn.addEventListener('click', () => {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(shortcuts, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "subpanda_shortcuts.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        });

        importShortcutsInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedShortcuts = JSON.parse(e.target.result);
                    if (typeof importedShortcuts === 'object' && importedShortcuts !== null) {
                        shortcuts = { ...defaultShortcuts, ...importedShortcuts };
                        await loadShortcuts(); // Re-run load to ensure docResources is validated
                        await saveShortcuts();
                        renderShortcutsModal();
                    } else {
                        throw new Error("Invalid format");
                    }
                } catch (err) {
                    showMessage(errorMessages[currentLanguage].shortcut_import_error);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        });

  setupPanel('findReplacePanel', 'findReplaceBtn', () => {
            findInput.focus();
        });
        

        findNextBtn.addEventListener('click', () => findAndNavigate(true));
        findPrevBtn.addEventListener('click', () => findAndNavigate(false));
        replaceBtn.addEventListener('click', replaceCurrentMatch);
        replaceAllBtn.addEventListener('click', replaceAllMatches);

        function findAndNavigate(forward = true) {
            const query = findInput.value;
            if (!query) {
                showMessage(errorMessages[currentLanguage]['no_find_query']);
                return;
            }

            findState.query = query;
            findState.caseSensitive = caseSensitiveCheckbox.checked;
            findState.useRegex = regexCheckbox.checked;

            let regex;
            try {
                regex = findState.useRegex ? new RegExp(findState.query, findState.caseSensitive ? '' : 'i') : null;
            } catch (e) {
                showMessage(`Error de expresión regular: ${e.message}`);
                return;
            }

            let startEntryIndex = 0;
            let startMatchIndex = 0;

            if (findState.lastFound) {
                startEntryIndex = findState.lastFound.entryIndex;
                startMatchIndex = forward ? findState.lastFound.matchEnd : findState.lastFound.matchStart - 1;
            } else {
                if (!forward) {
                    startEntryIndex = srtEntries.length - 1;
                    startMatchIndex = Infinity;
                }
            }

            let found = false;
            let currentEntryIndex = startEntryIndex;
            const totalEntries = srtEntries.length;

            for (let i = 0; i < totalEntries; i++) {
                const entry = srtEntries[currentEntryIndex];
                const text = entry.translation;
                let match;

                if (findState.useRegex) {
                    regex.lastIndex = 0;
                    if (forward) {
                        let searchFrom = (currentEntryIndex === startEntryIndex) ? startMatchIndex : 0;
                        const subText = text.substring(searchFrom);
                        match = regex.exec(subText);
                        if (match) {
                            match.index += searchFrom;
                        }
                    } else {
                        let allMatches = [];
                        let tempRegex = new RegExp(regex.source, regex.flags.includes('g') ? regex.flags : regex.flags + 'g');
                        let tempMatch;
                        while((tempMatch = tempRegex.exec(text)) !== null) {
                            allMatches.push(tempMatch);
                        }
                        let searchUntil = (currentEntryIndex === startEntryIndex) ? startMatchIndex : text.length;
                        match = allMatches.reverse().find(m => m.index < searchUntil);
                    }
                } else {
                    const searchText = findState.caseSensitive ? text : text.toLowerCase();
                    const queryLower = findState.caseSensitive ? findState.query : findState.query.toLowerCase();

                    if (forward) {
                        let searchFrom = (currentEntryIndex === startEntryIndex) ? startMatchIndex : 0;
                        const foundIndex = searchText.indexOf(queryLower, searchFrom);
                        if (foundIndex !== -1) {
                            match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                        }
                    } else {
                        let searchUntil = (currentEntryIndex === startEntryIndex) ? startMatchIndex : text.length;
                        const foundIndex = searchText.lastIndexOf(queryLower, searchUntil);
                        if (foundIndex !== -1) {
                            match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                        }
                    }
                }

                if (match) {
                    findState.lastFound = {
                        entryIndex: currentEntryIndex,
                        matchStart: match.index,
                        matchEnd: match.index + match[0].length,
                    };
                    navigateToTranslation(currentEntryIndex);
                    const targetEditor = document.getElementById(`translation-${currentEntryIndex}`);
                    if (targetEditor) {
                        const range = document.createRange();
                        const sel = window.getSelection();
                        range.setStart(targetEditor.firstChild, findState.lastFound.matchStart);
                        range.setEnd(targetEditor.firstChild, findState.lastFound.matchEnd);
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                    found = true;
                    return;
                }

                currentEntryIndex = (currentEntryIndex + (forward ? 1 : -1) + totalEntries) % totalEntries;
            }

            if (!found) {
                showMessage(errorMessages[currentLanguage]['no_match_found']);
                findState.lastFound = null;
            }
        }


    function replaceCurrentMatch() {
            const replaceWith = replaceInput.value; // <-- LÍNEA AÑADIDA: Ahora sí lee el texto de reemplazo

            if (!findState.lastFound || !findState.query) {
                showMessage(errorMessages[currentLanguage]['no_match_found']);
                return;
            }

            const { entryIndex, matchStart, matchEnd } = findState.lastFound;
            const entry = srtEntries[entryIndex];
            const targetEditor = document.getElementById(`translation-${entryIndex}`);

            if (!entry || !targetEditor) return; // Comprobación de seguridad

            let originalText = entry.translation;
            let replacedText;

            // Esta lógica ahora usa 'replaceWith' para construir el nuevo texto
            if (findState.useRegex) {
                const regex = new RegExp(findState.query, findState.caseSensitive ? '' : 'i');
                replacedText = originalText.substring(0, matchStart) +
                               originalText.substring(matchStart, matchEnd).replace(regex, replaceWith) +
                               originalText.substring(matchEnd);
            } else {
                replacedText = originalText.substring(0, matchStart) +
                               replaceWith +
                               originalText.substring(matchEnd);
            }

            // MEJORA: Actualizamos los datos y la interfaz directamente sin recargar toda la lista
            entry.translation = replacedText;
            targetEditor.innerHTML = replacedText;
            targetEditor.dispatchEvent(new Event('input', { bubbles: true })); // Esto recalcula las estadísticas (CPS, etc.)

            // Buscamos automáticamente la siguiente coincidencia
            findAndNavigate(true);
        }

        function replaceAllMatches() {
            const query = findInput.value;
            const replaceWith = replaceInput.value;
            if (!query) {
                showMessage(errorMessages[currentLanguage]['no_find_query']);
                return;
            }

            let replacedCount = 0;
            let regex;
            
            // ❗ CORRECCIÓN: Se ha arreglado la creación de la expresión regular
            try {
                if (regexCheckbox.checked) {
                    // Si el usuario escribe una expresión regular, la usamos tal cual
                    regex = new RegExp(query, (caseSensitiveCheckbox.checked ? 'g' : 'ig'));
                } else {
                    // Si es texto normal, escapamos caracteres especiales para que no den error
                    const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    regex = new RegExp(escapedQuery, (caseSensitiveCheckbox.checked ? 'g' : 'ig'));
                }
            } catch (e) {
                showMessage(`Error de expresión regular: ${e.message}`);
                return;
            }

            srtEntries.forEach(entry => {
                let originalTranslation = entry.translation;
                
                // Contamos las coincidencias antes de reemplazar
                const matches = originalTranslation.match(regex);
                if (matches) {
                    replacedCount += matches.length;
                }

                // Realizamos el reemplazo
                const newTranslation = originalTranslation.replace(regex, replaceWith);

                if (originalTranslation !== newTranslation) {
                    entry.translation = newTranslation;
                }
            });

            if (replacedCount > 0) {
                // MEJORA: Actualizamos la interfaz de forma más eficiente
                const scrollPosition = document.getElementById('editorMainContent').scrollTop;
                const activeIndex = getCurrentFocusedIndex()?.entryIndex ?? 0;
                renderTranslations(srtEntries, activeIndex, true);
                document.getElementById('editorMainContent').scrollTop = scrollPosition;
                updateStatsDisplay();
                showMessage(translations[currentLanguage]['replacements_made'].replace('{0}', replacedCount));
            } else {
                showMessage(errorMessages[currentLanguage]['no_match_found']);
            }

            findState.lastFound = null;
        }

       function setLanguage(lang) {
    // --- INICIO DE LA LÓGICA AÑADIDA ---
    // 1. Antes de cambiar el idioma, generamos el prompt por defecto del idioma ACTUAL (el viejo).
    const oldDefaultPrompt = translations[currentLanguage]['ai_default_instruction_1']
        .replace('{0}', qaSettings.charsPerLineLimit)
        .replace('{1}', qaSettings.cpsLimit);
    
    // 2. Comprobamos si el usuario está usando (o dejó) el prompt por defecto sin modificar.
    const isUsingDefaultPrompt = (aiCustomInstructions.instruction1 === oldDefaultPrompt);
    // --- FIN DE LA PRIMERA PARTE ---

    currentLanguage = lang;
    
    langEsBtn.classList.toggle('active', lang === 'es');
    langEnBtn.classList.toggle('active', lang === 'en');

    // --- INICIO DE LA SEGUNDA PARTE ---
    // 3. Si estaba usando el prompt por defecto, lo actualizamos al del NUEVO idioma.
    if (isUsingDefaultPrompt) {
        const newDefaultPrompt = translations[currentLanguage]['ai_default_instruction_1']
            .replace('{0}', qaSettings.charsPerLineLimit)
            .replace('{1}', qaSettings.cpsLimit);
        aiCustomInstructions.instruction1 = newDefaultPrompt;
        saveAiCustomInstructions(); // Guardamos el cambio para que persista.
    }
    // --- FIN DE LA LÓGICA AÑADIDA ---
    
    const t = translations[lang];
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (t[key]) el.textContent = t[key];
    });
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if (t[key]) el.placeholder = t[key];
    });
    
    if (srtEntries.length > 0) {
        const activeIndex = getCurrentFocusedIndex()?.entryIndex ?? lastActiveSubtitleIndex;
        renderTranslations(srtEntries, activeIndex, true);
    } else {
         const initialMessageElement = document.getElementById('initialMessage');
        if (initialMessageElement) initialMessageElement.textContent = t.no_translations;
    }
    renderGlossary();
    tmSearch();

    // --- INICIO DE LA CORRECCIÓN ---
    // Esta línea fuerza la actualización del panel de la IA con el nuevo idioma.
    // Comprueba si hay datos de contexto antes de intentar redibujar el panel.
    if (srtEntries.some(e => e.context)) {
        updateContextPanel(lastActiveSubtitleIndex);
    }
    // --- FIN DE LA CORRECCIÓN ---

// Actualizar títulos de botones dinámicamente
    document.getElementById('zoomOutBtn').title = t['zoom_out'];
    document.getElementById('zoomInBtn').title = t['zoom_in'];
    // Actualiza el título del botón de bloqueo según su estado actual
    lockWaveformBtn.title = isWaveformLocked ? t['unlock_waveform'] : t['lock_waveform'];
followPlaybackBtn.title = isFollowPlaybackActive ? t['follow_playback_off'] : t['follow_playback_on'];
}


        // --- Terminology Sidebar Logic ---
        function setupPanel(panelId, buttonId, openCallback) {
            const panel = document.getElementById(panelId);
            const button = document.getElementById(buttonId);
            const closeButton = panel.querySelector('button[id^="close"]');
            const resetButton = panel.querySelector('.reset-panel-btn');

            button.addEventListener('click', () => {
                openFloatingPanel(panel, button, openCallback);
            });

            closeButton.addEventListener('click', () => {
                closeFloatingPanel(panel, button);
            });
            
            resetButton.addEventListener('click', (e) => {
                e.stopPropagation();
                resetPanelPosition(panel);
            });
        }

        function populateIsoLanguagesDatalist() {
            isoLanguagesDatalist.innerHTML = '';
            isoLanguagesData.forEach(lang => {
                const option = document.createElement('option');
                option.value = lang.code;
                option.textContent = lang.name;
                isoLanguagesDatalist.appendChild(option);
            });
        }

        function resetGlossary() {
            glossary = [];
            glossarySourceLanguage = '';
            glossaryTargetLanguage = '';
            if (configSrcLang) configSrcLang.value = 'en-US';
            if (configTgtLang) configTgtLang.value = 'es-ES';
            if (srcTermInput) srcTermInput.value = "";
            if (tgtTermInput) tgtTermInput.value = "";
            if (searchTermInput) searchTermInput.value = "";
            if (terminologyLanguageConfigSection && terminologyEditorSection) {
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }
            renderGlossary();
        }

        function showLanguageConfigSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection) {
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }
        }

        function showGlossaryEditorSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection && displaySrcLang && displayTgtLang) {
                terminologyLanguageConfigSection.style.display = 'none';
                terminologyEditorSection.style.display = 'block';
                displaySrcLang.value = glossarySourceLanguage;
                displayTgtLang.value = glossaryTargetLanguage;
                renderGlossary();
            }
        }

        function confirmGlossaryLanguages() {
            const srcLang = configSrcLang ? configSrcLang.value.trim() : '';
            const tgtLang = configTgtLang ? configTgtLang.value.trim() : '';
            if (!srcLang || !tgtLang) {
                showMessage(errorMessages[currentLanguage]['lang_config_required']);
                return;
            }
            glossarySourceLanguage = srcLang;
            glossaryTargetLanguage = tgtLang;
            showGlossaryEditorSection();
            renderTranslations(srtEntries);
        }

        function addTerm() {
    const srcTerm = srcTermInput ? srcTermInput.value.trim() : '';
    const tgtTerm = tgtTermInput ? tgtTermInput.value.trim() : '';
    if (!srcTerm || !tgtTerm) {
        showMessage(errorMessages[currentLanguage]['both_terms_required']);
        return;
    }

    // 1. Añadimos el término al array de datos.
    glossary.push({
        srcLang: glossarySourceLanguage,
        srcTerm: srcTerm,
        tgtLang: glossaryTargetLanguage,
        tgtTerm: tgtTerm
    });

    // 2. Limpiamos los campos de entrada.
    if (srcTermInput) srcTermInput.value = "";
    if (tgtTermInput) tgtTermInput.value = "";

    // 3. Llamamos a nuestra nueva función para que actualice la pantalla SIN MOVERLA.
    updateTranslations();
}

        function deleteTerm(index) {
    glossary.splice(index, 1);
    // Llamamos a la nueva función, que ya se encarga de todo.
    updateTranslations();
}

        function renderGlossary() {
            if (!glossaryTableBody) return;
            const search = searchTermInput ? searchTermInput.value.toLowerCase() : '';
            glossaryTableBody.innerHTML = "";
            const t = translations[currentLanguage];
            const filteredGlossary = glossary.filter(entry =>
                (entry.srcTerm && entry.srcTerm.toLowerCase().includes(search)) ||
                (entry.tgtTerm && entry.tgtTerm.toLowerCase().includes(search))
            );
            const highlightedTerms = [];
            const otherTerms = [];
            filteredGlossary.forEach(entry => {
                if (entry.srcTerm && termsFoundInActiveSegment.has(entry.srcTerm)) {
                    highlightedTerms.push(entry);
                } else {
                    otherTerms.push(entry);
                }
            });
            currentGlossaryLatestResults = [...highlightedTerms, ...otherTerms.sort((a, b) => a.srcTerm.localeCompare(b.srcTerm))];
            
            const renderRow = (entry) => {
                 const row = document.createElement("tr");
                if (highlightedTerms.includes(entry)) {
                    row.classList.add('glossary-row-highlight');
                }
                row.innerHTML = `<td>${entry.srcTerm}</td><td>${entry.tgtTerm}</td><td><button class="btn btn-destructive text-xs" onclick="deleteTerm(${glossary.indexOf(entry)})">${t.delete_button}</button></td>`;
                glossaryTableBody.appendChild(row);
            };

            currentGlossaryLatestResults.forEach(renderRow);
        }

// --- FUNCIONES DE EXPORTACIÓN TMX (RECUPERANDO LA VERSIÓN OLD COMPATIBLE TAO) ---

/**
 * Función auxiliar para escapar caracteres especiales para el formato XML/TMX.
 * Esto asegura que el TMX sea válido y convierte los saltos de línea a <br/>.
 * @param {string} text El texto a sanear.
 * @returns {string} El texto saneado.
 */
function sanitizeForXML(text) {
    if (!text) return '';
    
    // 1. Normalización de saltos de línea de contenido editable a <br/>
    text = text.replace(/<\/div>\s*<div>/gi, '<br/>'); // Divs internos a <br/>
    text = text.replace(/<div[^>]*>/gi, '').replace(/<\/div>/gi, ''); // Eliminar divs restantes
    text = text.replace(/<br\s*\/?>/gi, '<br/>'); // Br a <br/>
    text = text.replace(/<[^>]+>/g, ''); // Eliminar otras etiquetas HTML
    text = text.trim();
    
    // 2. Escapar caracteres XML estándar
    return text.replace(/&/g, '&amp;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;')
               .replace(/"/g, '&quot;')
               .replace(/'/g, '&apos;');
}


/**
 * Exporta la Memoria de Traducción (TM) al formato TMX 1.4 compatible.
 */
function exportTMX() {
    // Nota: Asume la existencia de las variables globales 'translationMemory', 'sourceLang', 'targetLang', 'fileNameInput', 'errorMessages' y 'translations'.
    
    if (!translationMemory || translationMemory.length === 0) {
        showMessage(errorMessages[currentLanguage]['no_tm_to_save'] || "No hay Memoria de Traducción para guardar.");
        return;
    }
    
    const srcLangCode = sourceLang || 'en-US';
    const tgtLangCode = targetLang || 'es-ES';

    // 1. Construir el Encabezado TMX
    const tmxHeader = `<?xml version="1.0" encoding="UTF-8"?>
<tmx version="1.4">
  <header datatype="plaintext" segtype="sentence"
    adminlang="en-us" srclang="${srcLangCode}"
    o-tmf="none" creationtool="subpandaTM" creationtoolversion="1.0">
  </header>
  <body>`;
    
    // 2. Construir el Cuerpo TMX (Unidades de Traducción)
    const tmxBody = translationMemory.map(entry => {
        // Usar sanitizeForXML para limpiar y escapar el texto, convirtiendo saltos de línea a <br/>
        let sourceText = sanitizeForXML(entry.source); 
        let targetText = sanitizeForXML(entry.target); 

        return `    <tu>
      <tuv xml:lang="${srcLangCode}">
        <seg>${sourceText}</seg>
      </tuv>
      <tuv xml:lang="${tgtLangCode}">
        <seg>${targetText}</seg>
      </tuv>
    </tu>`;
    }).join('\n');

    // 3. Construir el Pie de Página TMX
    const tmxFooter = `
  </body>
</tmx>`;
    
    const tmxContent = tmxHeader + tmxBody + tmxFooter;

    // 4. Lógica para guardar el archivo
    const baseFilename = (fileNameInput.value.trim() || 'TranslationMemory'); 
    const filename = baseFilename.endsWith('.tmx') ? baseFilename : baseFilename + '.tmx';

    try {
        const blob = new Blob([tmxContent], { type: 'text/xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", url);
        downloadAnchorNode.setAttribute("download", filename);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        document.body.removeChild(downloadAnchorNode);
        URL.revokeObjectURL(url);
        
        showMessage(translations[currentLanguage]['file_saved_successfully_tmx'] || "Archivo TMX guardado correctamente.");
    } catch (error) {
        showMessage(errorMessages[currentLanguage]['error_saving_file'] || `Error al guardar el archivo: ${error.message}`);
        console.error("Error saving TMX file:", error);
    }
}

// --- FIN: FUNCIONES DE EXPORTACIÓN TMX ---

        function generateTBX() {
            const xml = [`<?xml version="1.0" encoding="UTF-8"?><martif type="TBX" xml:lang="${glossarySourceLanguage}"><text><body>`];
            glossary.forEach(entry => {
                xml.push(`<termEntry><LangSet xml:lang="${entry.srcLang}"><tig><term>${entry.srcTerm}</term></tig></LangSet><LangSet xml:lang="${entry.tgtLang}"><tig><term>${entry.tgtTerm}</term></tig></LangSet></termEntry>`);
            });
            xml.push(`</body></text></martif>`);
            return xml.join("\n");
        }

        /**
         * Opens a modal to ask for a filename before downloading the TBX file.
         */
        function downloadTBX() {
            if (glossary.length === 0 && (!glossarySourceLanguage || !glossaryTargetLanguage)) {
                showMessage(errorMessages[currentLanguage]['cannot_download_empty_or_unconfigured_glossary']);
                return;
            }
            fileNameInputTbx.value = 'glossary.tbx';
            saveTbxModal.classList.remove('hidden');
            fileNameInputTbx.focus();
        }

        function loadTBX() {
            if (!tbxFileInput) return;
            tbxFileInput.click();
            tbxFileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                showLoadingOverlay(errorMessages[currentLanguage]['loading_file']);
                try {
                    const reader = new FileReader();
                    await new Promise((resolve, reject) => {
                        reader.onload = () => {
                            try {
                                const parser = new DOMParser();
                                const xmlDoc = parser.parseFromString(reader.result, "application/xml");
                                if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                                    throw new Error("Invalid XML/TBX format: " + xmlDoc.getElementsByTagName("parsererror")[0].textContent);
                                }
                                if (xmlDoc.getElementsByTagName("tu").length > 0) {
                                    showTMInternalMessage(errorMessages[currentLanguage]['tbx_file_expected_tmx_found'], true);
                                    reject(new Error("Attempted to load TMX into Glossary."));
                                    return;
                                }
                                const entries = xmlDoc.getElementsByTagName("termEntry");
                                glossary = [];
                                let firstEntryLangs = { src: '', tgt: '' };
                                if (entries.length > 0) {
                                    const firstSets = entries[0].getElementsByTagName("LangSet");
                                    if (firstSets.length >= 2) {
                                        firstEntryLangs.src = firstSets[0].getAttribute("xml:lang");
                                        firstEntryLangs.tgt = firstSets[1].getAttribute("xml:lang");
                                    }
                                }
                                for (let entry of entries) {
                                    const sets = entry.getElementsByTagName("LangSet");
                                    if (sets.length >= 2) {
                                        const lang1 = sets[0].getAttribute("xml:lang");
                                        const term1 = sets[0].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                                        const lang2 = sets[1].getAttribute("xml:lang");
                                        const term2 = sets[1].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                                        glossary.push({ srcLang: lang1, srcTerm: term1, tgtLang: lang2, tgtTerm: term2 });
                                    }
                                }
                                if (glossary.length > 0 && firstEntryLangs.src && firstEntryLangs.tgt) {
                                    glossarySourceLanguage = firstEntryLangs.src;
                                    glossaryTargetLanguage = firstEntryLangs.tgt;
                                } else if (glossary.length === 0) {
                                    showMessage(errorMessages[currentLanguage]['error_loading_tbx_file']);
                                }
                                showGlossaryEditorSection();
                                updateTranslations();
                                resolve();
                            } catch (error) {
                                reject(error);
                            }
                        };
                        reader.onerror = reject;
                        reader.readAsText(file);
                    });
                } catch (error) {
                    console.error("Error loading TBX file:", error);
                    if (!error.message.includes("Attempted to load TMX")) {
                        showMessage(errorMessages[currentLanguage]['error_loading_tbx_file']);
                    }
                    resetGlossary();
                } finally {
                    hideLoadingOverlay();
                }
            };
        }

        // --- Translation Memory (TM) Logic ---
        function levenshteinDistance(a, b) {
            const an = a.length, bn = b.length;
            if (an === 0) return bn;
            if (bn === 0) return an;
            const matrix = Array(bn + 1).fill(null).map(() => Array(an + 1).fill(null));
            for (let i = 0; i <= an; i++) matrix[0][i] = i;
            for (let i = 0; i <= bn; i++) matrix[i][0] = i;
            for (let i = 1; i <= bn; i++) {
                for (let j = 1; j <= an; j++) {
                    const cost = a[j - 1] === b[i - 1] ? 0 : 1;
                    matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + cost);
                }
            }
            return matrix[bn][an];
        }

        function calculateSimilarity(s1, s2) {
            if (!s1 || !s2) return 0;
            const longerLength = Math.max(s1.length, s2.length);
            if (longerLength === 0) return 100;
            const distance = levenshteinDistance(s1, s2);
            return ((longerLength - distance) / longerLength) * 100;
        }
        
        function renderDiff(tmText, originalText) {
            const dmp = new diff_match_patch();
            const diffs = dmp.diff_main(tmText, originalText);
            dmp.diff_cleanupSemantic(diffs);

            return diffs.map(([op, text]) => {
                const safeText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '&para;<br>');
                switch (op) {
                    case DIFF_INSERT: return `<span class="diff-insertion">${safeText}</span>`;
                    case DIFF_DELETE: return `<span class="diff-deletion">${safeText}</span>`;
                    case DIFF_EQUAL: return safeText;
                }
            }).join('');
        }

        function showTMInternalMessage(msg, isError = false) {
            if (tmInternalMessage) {
                tmInternalMessage.textContent = msg;
                tmInternalMessage.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'border-red-500', 'bg-blue-100', 'text-blue-800', 'border-blue-500');
                tmInternalMessage.classList.add(isError ? 'bg-red-100' : 'bg-blue-100', isError ? 'text-red-800' : 'text-blue-800', isError ? 'border-red-500' : 'border-blue-500');
                tmInternalMessage.classList.remove('hidden');
            }
        }

        function hideTMInternalMessage() {
            if (tmInternalMessage) {
                tmInternalMessage.classList.add('hidden');
                tmInternalMessage.textContent = '';
            }
        }

        function resetTM() {
            translationMemory = [];
            tmSearchInput.value = '';
            renderTMSearchResults([]);
            showTMLanguageConfigSection();
            hideTMInternalMessage(); // Hide the message on reset
        }

        function showTMLanguageConfigSection() {
            if (tmLanguageConfigSection && tmEditorSection) {
                tmLanguageConfigSection.style.display = 'block';
                tmEditorSection.style.display = 'none';
                if (tmConfigSrcLang) tmConfigSrcLang.value = 'en-US';
                if (tmConfigTgtLang) tmConfigTgtLang.value = 'es-ES';
                hideTMInternalMessage();
            }
        }

        function showTMEditorSection() {
            if (tmLanguageConfigSection && tmEditorSection && displayTmSrcLang && displayTmTgtLang) {
                tmLanguageConfigSection.style.display = 'none';
                tmEditorSection.style.display = 'block';
                displayTmSrcLang.value = tmSourceLanguage;
                displayTmTgtLang.value = tmTargetLanguage;
                tmSearch();
                hideTMInternalMessage();
            }
        }

        function confirmTMLanguages() {
            const srcLang = tmConfigSrcLang ? tmConfigSrcLang.value.trim() : '';
            const tgtLang = tmConfigTgtLang ? tmConfigTgtLang.value.trim() : '';
            if (!srcLang || !tgtLang) {
                showTMInternalMessage(errorMessages[currentLanguage]['lang_config_required'], true);
                return;
            }
            tmSourceLanguage = srcLang;
            tmTargetLanguage = tgtLang;
            showTMEditorSection();
        }

        
async function loadTMX(file) {
            showLoadingOverlay(errorMessages[currentLanguage]['loading_file']);
            hideTMInternalMessage();

            // Helper function to unescape XML special characters back to HTML.
            const unescapeXml = (safe) => {
                if (typeof safe !== 'string') return '';
                // The order matters for correctness
                return safe.replace(/&lt;/g, '<')
                           .replace(/&gt;/g, '>')
                           .replace(/&apos;/g, '\'')
                           .replace(/&quot;/g, '"')
                           .replace(/&amp;/g, '&');
            };

            try {
                const reader = new FileReader();
                await new Promise((resolve, reject) => {
                    reader.onload = () => {
                        try {
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(reader.result, "application/xml");
                            const parserError = xmlDoc.getElementsByTagName("parsererror");

                            if (parserError.length > 0) {
                                console.error("Parser Error:", parserError[0].textContent);
                                throw new Error("The file contains invalid XML and could not be parsed.");
                            }
                            
                            if (xmlDoc.getElementsByTagName("termEntry").length > 0) {
                                showTMInternalMessage(errorMessages[currentLanguage]['tmx_file_expected_tbx_found'], true);
                                reject(new Error("Attempted to load TBX into Translation Memory."));
                                return;
                            }
                            
                            const tuElements = xmlDoc.getElementsByTagName("tu");
                            let newTM = [];
                            
                            const header = xmlDoc.getElementsByTagName("header")[0];
                            let detectedSrcLang = header ? header.getAttribute('srclang') : '';
                            let detectedTgtLang = ''; // Target language is not a standard header attribute

                            for (let tu of tuElements) {
                                const tuvElements = tu.getElementsByTagName("tuv");
                                if (tuvElements.length >= 2) {
                                    const srcTuv = tuvElements[0], tgtTuv = tuvElements[1];
                                    const srcLang = srcTuv.getAttribute("xml:lang"), tgtLang = tgtTuv.getAttribute("xml:lang");
                                    
                                    const srcSeg = srcTuv.getElementsByTagName("seg")[0]?.textContent || '';
                                    const tgtSeg = tgtTuv.getElementsByTagName("seg")[0]?.textContent || '';

                                    const unescapedSrcText = unescapeXml(srcSeg);
                                    const unescapedTgtText = unescapeXml(tgtSeg);

                                    newTM.push({
                                        srcLang,
                                        srcText: unescapedSrcText,
                                        tgtLang,
                                        tgtText: unescapedTgtText,
                                        srcWordCount: countWords(unescapedSrcText),
                                        tgtWordCount: countWords(unescapedTgtText)
                                    });
                                    
                                    if (!detectedSrcLang) detectedSrcLang = srcLang;
                                    if (!detectedTgtLang) detectedTgtLang = tgtLang;
                                }
                            }
                            
                            translationMemory = newTM;
                            tmSourceLanguage = detectedSrcLang || (tmConfigSrcLang ? tmConfigSrcLang.value : 'en-US');
                            tmTargetLanguage = detectedTgtLang || (tmConfigTgtLang ? tmConfigTgtLang.value : 'es-ES');
                            
                            showTMInternalMessage(`TMX loaded successfully with ${translationMemory.length} translation units.`);
                            showTMEditorSection();
                            tmSearch();
                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            } catch (error) {
                console.error("Error loading TMX file:", error);
                if (!error.message.includes("Attempted to load TBX")) {
                    showTMInternalMessage(`${errorMessages[currentLanguage]['error_loading_tmx_file']} - ${error.message}`, true);
                }
                resetTM();
            } finally {
                hideLoadingOverlay();
            }
        }



function generateTMX() {
            if (translationMemory.length === 0) {
                showTMInternalMessage(errorMessages[currentLanguage]['cannot_download_empty_tm'], true);
                return null;
            }

            // Helper function to escape characters that are special in XML.
            const escapeXml = (unsafe) => {
                if (typeof unsafe !== 'string') return '';
                return unsafe.replace(/[<>&'"]/g, (c) => {
                    switch (c) {
                        case '<': return '&lt;';
                        case '>': return '&gt;';
                        case '&': return '&amp;';
                        case '\'': return '&apos;';
                        case '"': return '&quot;';
                    }
                });
            };
            
            // Generate a UTC timestamp as required by the TMX standard for creationdate
            const creationDate = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');

            // A more compliant TMX header
            const header = `<?xml version="1.0" encoding="UTF-8"?>\n<tmx version="1.4">\n  <header\n    creationtool="subpandaTM"\n    creationtoolversion="1.0"\n    segtype="sentence"\n    o-tmf="subpandaTM"\n    adminlang="en-US"\n    srclang="${escapeXml(tmSourceLanguage || 'en-US')}"\n    datatype="unknown"\n    creationdate="${creationDate}"\n  >\n  </header>\n  <body>`;
            
            const xml = [header];
            
            translationMemory.forEach(entry => {
                const safeSrcText = escapeXml(entry.srcText);
                const safeTgtText = escapeXml(entry.tgtText);
                
                // Using template literals for better readability and ensuring no extra whitespace
                const tu = `    <tu creationdate="${creationDate}">\n      <tuv xml:lang="${escapeXml(entry.srcLang)}">\n        <seg>${safeSrcText}</seg>\n      </tuv>\n      <tuv xml:lang="${escapeXml(entry.tgtLang)}">\n        <seg>${safeTgtText}</seg>\n      </tuv>\n    </tu>`;
                xml.push(tu);
            });

            xml.push(`  </body>\n</tmx>`);
            // The .join('\n') ensures proper line breaks for readability
            return xml.join('\n');
        }
        /**
         * Opens a modal to ask for a filename before downloading the TMX file.
         */
        function downloadTMX() {
            if (translationMemory.length === 0) {
                showMessage(errorMessages[currentLanguage]['cannot_download_empty_tm']);
                return;
            }
            fileNameInputTmx.value = 'translation_memory.tmx';
            saveTmxModal.classList.remove('hidden');
            fileNameInputTmx.focus();
        }

        function addOrUpdateTMEntry(original, translation) {
            if (!original || !translation || !tmSourceLanguage || !tmTargetLanguage) return;
            const existingIndex = translationMemory.findIndex(e => e.srcText === original && e.srcLang === tmSourceLanguage && e.tgtLang === tmTargetLanguage);
            if (existingIndex !== -1) {
                translationMemory[existingIndex].tgtText = translation;
                translationMemory[existingIndex].tgtWordCount = countWords(translation);
            } else {
                translationMemory.push({ srcLang: tmSourceLanguage, srcText: original, tgtLang: tmTargetLanguage, tgtText: translation, srcWordCount: countWords(original), tgtWordCount: countWords(translation) });
            }
            tmSearch();
        }

        function findBestTMMatch(sourceSegmentText) {
            if (translationMemory.length === 0 || !sourceSegmentText.trim() || !tmSourceLanguage || !tmTargetLanguage) return null;
            let bestMatch = null, highestScore = 0;
            const MIN_FUZZY_THRESHOLD = 70;
            translationMemory.forEach(entry => {
                if (entry.srcLang === tmSourceLanguage && entry.tgtLang === tmTargetLanguage && entry.srcText.trim()) {
                    const score = calculateSimilarity(sourceSegmentText, entry.srcText);
                    if (score >= MIN_FUZZY_THRESHOLD && score > highestScore) {
                        highestScore = score;
                        bestMatch = { ...entry, score: score.toFixed(0) };
                    }
                }
            });
            return bestMatch;
        }

        function tmSearch(activeSegmentOriginalText = null) {
            const query = tmSearchInput ? tmSearchInput.value.toLowerCase().trim() : '';
            if (!activeSegmentOriginalText) {
                const currentFocused = getCurrentFocusedIndex();
                if (currentFocused && srtEntries[currentFocused.entryIndex]) {
                    activeSegmentOriginalText = srtEntries[currentFocused.entryIndex].original;
                }
            }

            const filteredTM = translationMemory.filter(entry => {
                if (query) {
                    return (entry.srcText && entry.srcText.toLowerCase().includes(query)) || (entry.tgtText && entry.tgtText.toLowerCase().includes(query));
                }
                return true;
            });

            let resultsToRender = filteredTM.map(entry => {
                let score = 0;
                let diffHtml = entry.srcText;
                if (activeSegmentOriginalText) {
                    score = calculateSimilarity(activeSegmentOriginalText, entry.srcText);
                    diffHtml = renderDiff(entry.srcText, activeSegmentOriginalText);
                } else if (query) {
                    score = calculateSimilarity(query, entry.srcText);
                }
                return { ...entry, score: score.toFixed(0), diffHtml: diffHtml };
            });

            resultsToRender.sort((a, b) => b.score - a.score);

            const MIN_FUZZY_THRESHOLD = 70;
            resultsToRender.forEach((result, index) => {
                result.isBestMatch = index === 0 && result.score >= MIN_FUZZY_THRESHOLD;
            });

            currentTMLatestSearchResults = resultsToRender;
            renderTMSearchResults(resultsToRender);
        }

        function renderTMSearchResults(results) {
            if (!tmSearchResultsTableBody) return;
            const t = translations[currentLanguage];
            tmSearchResultsTableBody.innerHTML = '';
            if (results.length === 0) {
                if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.remove('hidden');
                return;
            } 
            if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.add('hidden');
            
            hideTMInternalMessage();
            results.forEach(entry => {
                const row = document.createElement('tr');
                if (entry.isBestMatch) row.classList.add('tm-best-match-highlight');
                
                const originalContent = (entry.diffHtml || entry.srcText).replace(/\n/g, '<br>');
                const translationContent = entry.tgtText.replace(/\n/g, '<br>');

                row.innerHTML = `<td>${entry.score}%</td><td class="align-top">${originalContent}</td><td class="align-top">${translationContent}</td>`;
                
                row.addEventListener('click', () => {
                    const currentFocused = getCurrentFocusedIndex();
                    if (currentFocused) {
                        const targetEditor = document.getElementById(`translation-${currentFocused.entryIndex}`);
                        if (targetEditor && targetEditor.contentEditable === 'true') {
                            targetEditor.innerHTML = entry.tgtText;
                            const event = new Event('input', { bubbles: true });
                            targetEditor.dispatchEvent(event);
                        }
                    }
                });
                tmSearchResultsTableBody.appendChild(row);
            });
        }

        function showLoadingOverlay(message) {
            if (loadingMessage && loadingOverlay) {
                loadingMessage.textContent = message;
                loadingOverlay.classList.remove('hidden');
            }
        }

        function hideLoadingOverlay() {
            if (loadingOverlay) {
                loadingOverlay.classList.add('hidden');
            }
        }

        if (dropArea) {
            dropArea.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.add('border-blue-500');
            });
            dropArea.addEventListener('dragleave', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-blue-500');
            });
            dropArea.addEventListener('drop', async (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-blue-500');
                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    const fileToProcess = Array.from(files).find(file => file.name.toLowerCase().endsWith('.srt') || file.name.toLowerCase().endsWith('.subpanda'));
                    if (fileToProcess.name.toLowerCase().endsWith('.srt')) {
                        await processFile(fileToProcess);
                    } else if (fileToProcess.name.toLowerCase().endsWith('.subpanda')) {
                        await loadProject({ target: { files: [fileToProcess] } });
                    } else {
                         showMessage('Por favor, suelta un archivo .srt o .subpanda válido.');
                    }
                }
            });
        }

        if (addTermHeader && addTermContent && addTermAccordionIcon) {
            addTermHeader.addEventListener('click', () => {
                const isCollapsed = addTermContent.classList.contains('collapsed');
                if (isCollapsed) {
                    addTermContent.classList.remove('collapsed');
                    addTermContent.classList.add('expanded');
                    addTermAccordionIcon.classList.remove('rotated');
                } else {
                    addTermContent.classList.remove('expanded');
                    addTermContent.classList.add('collapsed');
                    addTermAccordionIcon.classList.add('rotated');
                }
            });
        }

        if (statsAccordionHeader && statsAccordionContent && statsAccordionIcon) {
            statsAccordionHeader.addEventListener('click', () => {
                const isCollapsed = statsAccordionContent.classList.contains('collapsed');
                if (isCollapsed) {
                    statsAccordionContent.classList.remove('collapsed');
                    statsAccordionContent.classList.add('expanded');
                    statsAccordionIcon.classList.remove('rotated');
                } else {
                    statsAccordionContent.classList.remove('expanded');
                    statsAccordionContent.classList.add('collapsed');
                    statsAccordionIcon.classList.add('rotated');
                }
            });
        }

        videoFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                videoFileName = file.name; // Store video file name
                const videoURL = URL.createObjectURL(file);
                videoPlayer.src = videoURL;
                wavesurfer.load(videoURL);
                document.getElementById('waveform').classList.remove('hidden');
                videoPlayer.controls = true;
                videoPlayer.load();
                     
                document.getElementById('videoLogoPlaceholder').classList.add('hidden');
        
                const loadVideoBtnSpan = document.querySelector('#loadVideoBtn span');
                if (loadVideoBtnSpan) {
                    loadVideoBtnSpan.textContent = translations[currentLanguage]['change_video'];
                }
            } else {
                showMessage(errorMessages[currentLanguage]['video_load_error']);
            }
        });

        /**
         * Jumps the video player to the start time of the specified subtitle and plays until the end time.
         * @param {number} entryIndex The index of the SRT entry to play.
         */
        function jumpToCurrentSubtitleTime(entryIndex) {
            if (srtEntries[entryIndex] && videoPlayer.src) {
                const entry = srtEntries[entryIndex];
                // CORRECCIÓN: Quitamos el "- 200". Ahora se detiene justo al final.
                const stopTime = entry.endTimeMs / 1000; 
                videoPlayer.currentTime = entry.startTimeMs / 1000;
                videoPlayer.play();

                if (timeUpdateListener) {
                    videoPlayer.removeEventListener('timeupdate', timeUpdateListener);
                }

                timeUpdateListener = () => {
                    // CORRECCIÓN: El listener ahora también se detiene si el vídeo se pausa
                    // por cualquier otro motivo (ej. el usuario le da a la pausa).
                    if (videoPlayer.currentTime >= stopTime || videoPlayer.paused) {
                        videoPlayer.pause(); // Pausa
                        videoPlayer.removeEventListener('timeupdate', timeUpdateListener);
                        timeUpdateListener = null;
                    }
                };
                
                videoPlayer.addEventListener('timeupdate', timeUpdateListener);

// Centra la vista de la onda en la región (AÑADIDO)
                 if (wsRegions) {
                     const region = wsRegions.getRegions().find(r => r.id === entry.regionId);
                     if (region) {
                         // Centrar la región en la vista de la onda
                         const duration = wavesurfer.getDuration();
                         const regionCenter = (region.start + region.end) / 2;
                         // Opcional: un pequeño zoom si es necesario
                         // wavesurfer.zoom(Number(document.getElementById('zoom-slider')?.value || 100));
         }
                 }
             }
        } // Fin de jumpToCurrentSubtitleTime
       
/**
 * Gestiona el resaltado y scroll automático durante la reproducción si el seguimiento está activo.
 */
function handlePlaybackTracking() {
    if (!isFollowPlaybackActive || !videoPlayer.src || srtEntries.length === 0 || !wsRegions) {
        // Si la función está desactivada o no hay nada que seguir, limpiamos resaltados
        clearPlaybackHighlights();
        return;
    }

    const currentTime = videoPlayer.currentTime;
    let activeEntryIndex = -1;
    let activeEntry = null;

    // Encuentra el subtítulo activo (igual que en updateSubtitlePreview)
    for (let i = 0; i < srtEntries.length; i++) {
        const entry = srtEntries[i];
        const startTime = entry.startTimeMs / 1000;
        const endTime = entry.endTimeMs / 1000;
        if (currentTime >= startTime && currentTime < endTime) { // Usamos < endTime para evitar solapamientos
            activeEntryIndex = i;
            activeEntry = entry;
            break;
        }
    }

    // Si NO encontramos un subtítulo activo
    if (activeEntryIndex === -1) {
        clearPlaybackHighlights();
        currentlyTrackedRegionId = null;
        currentlyTrackedEditorIndex = -1;
// --- INICIO CÓDIGO AÑADIDO ---
        // Limpiar la clase activa si no hay ningún subtítulo en reproducción
        if (lastFocusedEditorUnitIndex !== -1) {
            const prevUnit = document.getElementById(`translation-unit-${lastFocusedEditorUnitIndex}`);
            if (prevUnit) prevUnit.classList.remove('translation-unit-active');
            lastFocusedEditorUnitIndex = -1;
        }
        // --- FIN CÓDIGO AÑADIDO ---
        return;
    }

    // Si el subtítulo activo es el MISMO que ya estábamos siguiendo, no hacemos nada más
    if (currentlyTrackedEditorIndex === activeEntryIndex) {
        return;
    }

    // --- HEMOS ENCONTRADO UN NUEVO SUBTÍTULO ACTIVO ---

    // 1. Limpia los resaltados anteriores
    clearPlaybackHighlights();

    // 2. Resalta la nueva región en la onda
    const activeRegion = wsRegions.getRegions().find(r => r.id === activeEntry.regionId);
    if (activeRegion && activeRegion.element) {
        activeRegion.element.classList.add('region-playback-active');
        currentlyTrackedRegionId = activeEntry.regionId; // Guarda el ID actual
    }

    // 3. Haz scroll y activa el foco en el editor
        const editorUnit = document.getElementById(`translation-unit-${activeEntryIndex}`);
        if (editorUnit) {
            // --- INICIO CÓDIGO AÑADIDO ---
            // Busca el div editable DENTRO de la unidad del subtítulo
            const editorDiv = editorUnit.querySelector(`div[contenteditable="true"][data-entry-index="${activeEntryIndex}"]`);
            // --- FIN CÓDIGO AÑADIDO ---

            // Solo hacemos scroll si el elemento no está ya visible en el centro
            const rect = editorUnit.getBoundingClientRect();
            // CORRECCIÓN: Asegúrate de que parentElement.parentElement existe
            const parentContainer = document.getElementById('editorMainContent'); // Usar ID es más seguro
            const parentRect = parentContainer ? parentContainer.getBoundingClientRect() : null;
            const isVisible = parentRect && rect.top >= parentRect.top && rect.bottom <= parentRect.bottom;


            if (!isVisible) {
                 editorUnit.scrollIntoView({ behavior: 'smooth', block: 'center' });
                 // --- CÓDIGO AÑADIDO (Focus después del scroll) ---
                 // Añadimos un pequeño retardo para asegurar que el scroll ha terminado
                 // antes de intentar poner el foco, especialmente con 'smooth' scroll.
                 if (editorDiv) {
// --- INICIO CÓDIGO AÑADIDO ---
                // Limpiar la clase del anterior subtítulo con foco si existe
                if (lastFocusedEditorUnitIndex !== -1 && lastFocusedEditorUnitIndex !== activeEntryIndex) {
                    const prevUnit = document.getElementById(`translation-unit-${lastFocusedEditorUnitIndex}`);
                    if (prevUnit) prevUnit.classList.remove('translation-unit-active');
                }
                // Añadir la clase al actual
                if (editorUnit) editorUnit.classList.add('translation-unit-active');
                lastFocusedEditorUnitIndex = activeEntryIndex; // Actualizar
                // --- FIN CÓDIGO AÑADIDO ---
                    setTimeout(() => editorDiv.focus(), 300); // 300ms de retardo
                 }
                 // --- FIN CÓDIGO AÑADIDO ---
            } else {
                // --- CÓDIGO AÑADIDO (Focus si ya es visible) ---
                 // Si ya estaba visible, ponemos el foco directamente
                 if (editorDiv && document.activeElement !== editorDiv) {
// --- INICIO CÓDIGO AÑADIDO ---
                // Limpiar la clase del anterior subtítulo con foco si existe
                if (lastFocusedEditorUnitIndex !== -1 && lastFocusedEditorUnitIndex !== activeEntryIndex) {
                    const prevUnit = document.getElementById(`translation-unit-${lastFocusedEditorUnitIndex}`);
                    if (prevUnit) prevUnit.classList.remove('translation-unit-active');
                }
                // Añadir la clase al actual
                if (editorUnit) editorUnit.classList.add('translation-unit-active');
                lastFocusedEditorUnitIndex = activeEntryIndex; // Actualizar
                // --- FIN CÓDIGO AÑADIDO ---
                     editorDiv.focus();
                 }
                 // --- FIN CÓDIGO AÑADIDO ---
            }

            currentlyTrackedEditorIndex = activeEntryIndex; // Guarda el índice actual
        }
    }

/**
 * Limpia los resaltados visuales aplicados por handlePlaybackTracking.
 */
function clearPlaybackHighlights() {
    // Limpiar región de la onda
    if (currentlyTrackedRegionId && wsRegions) {
        const previousRegion = wsRegions.getRegions().find(r => r.id === currentlyTrackedRegionId);
        if (previousRegion && previousRegion.element) {
            previousRegion.element.classList.remove('region-playback-active');
        }
    }
    // Limpiar editor (si añadiste una clase específica)
    // if (currentlyTrackedEditorIndex !== -1) {
    //     const previousEditorUnit = document.getElementById(`translation-unit-${currentlyTrackedEditorIndex}`);
    //     if (previousEditorUnit) {
    //         previousEditorUnit.classList.remove('playback-active');
    //     }
    // }
}
 
        /**
         * Updates the subtitle preview overlay based on the video's current time and user selection.
         */
        function updateSubtitlePreview() {
            if (!videoPlayer.src || srtEntries.length === 0) {
                subtitlePreviewText.innerHTML = '';
                return;
            }



            const currentTime = videoPlayer.currentTime;
            let activeSubtitle = null;

            for (const entry of srtEntries) {
                const startTime = entry.startTimeMs / 1000;
                const endTime = entry.endTimeMs / 1000;
                if (currentTime >= startTime && currentTime <= endTime) {
                    activeSubtitle = entry;
                    break;
                }
            }

            if (activeSubtitle) {
                let textToShow = '';
                if (previewSource === 'translation') {
                    textToShow = activeSubtitle.translation.trim() || activeSubtitle.original;
                } else {
                    textToShow = activeSubtitle.original;
                }
                subtitlePreviewText.innerHTML = textToShow;
            } else {
                subtitlePreviewText.innerHTML = '';
            }
        }
        
// AÑADE ESTAS DOS FUNCIONES NUEVAS
/**
 * Actualiza el tamaño de la fuente de los subtítulos en la vista previa.
 * @param {number} newSize - El nuevo tamaño de la fuente en píxeles.
 */
// CÓDIGO CORREGIDO
function updateFontSize(newSize) {
    if (newSize < 10 || newSize > 60) return;

    subtitleFontSize = newSize;
    fontSizeDisplay.textContent = `${subtitleFontSize}px`;
    document.documentElement.style.setProperty('--user-font-size', `${subtitleFontSize}px`);

    // --- LÓGICA AÑADIDA ---
    // Si estamos en pantalla completa, actualiza el tamaño directamente.
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
    if (isFullscreen) {
        const fullscreenSize = subtitleFontSize + 26;
        subtitlePreviewText.style.fontSize = `${fullscreenSize}px`;
    }
}

/**
 * Establece la fuente de texto para la vista previa (original o traducción).
 * @param {string} source - Puede ser 'original' o 'translation'.
 */
function setPreviewSource(source) {
    previewSource = source;

    // Actualiza la clase 'active' en los botones
    setPreviewOriginal.classList.toggle('active', source === 'original');
    setPreviewTranslation.classList.toggle('active', source === 'translation');

    // Refresca la vista previa inmediatamente
    updateSubtitlePreview();
}

function toggleFullscreen() {
    // Comprueba si ya estamos en modo pantalla completa
    if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
        // Si no lo estamos, solicita la pantalla completa para el CONTENEDOR
        if (videoPlayerWrapper.requestFullscreen) {
            videoPlayerWrapper.requestFullscreen();
        } else if (videoPlayerWrapper.webkitRequestFullscreen) { /* Safari */
            videoPlayerWrapper.webkitRequestFullscreen();
        } else if (videoPlayerWrapper.msRequestFullscreen) { /* IE11 */
            videoPlayerWrapper.msRequestFullscreen();
        }
    } else {
        // Si ya estamos en pantalla completa, salimos
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen();
        }
    }
}

function goToSubtitleByNumber() {
    if (srtEntries.length === 0) return;
    const targetIndex = parseInt(goToSubtitleInput.value, 10);
    if (isNaN(targetIndex) || targetIndex < 1 || targetIndex > srtEntries.length) {
        showMessage(`Por favor, introduce un número entre 1 y ${srtEntries.length}.`);
        return;
    }
    // El usuario introduce el índice 1, pero en el array es el 0.
    navigateToTranslation(targetIndex - 1);
}

/**
 * Navega al subtítulo más cercano a un timecode específico.
 */
function goToSubtitleByTimecode() {
    if (srtEntries.length === 0 || !videoPlayer.src) return;
    try {
        let targetTimeMs;
if (useFrameTimecode) {
    targetTimeMs = parseFrameTime(goToTimecodeInput.value, projectFPS);
} else {
    targetTimeMs = parseTime(goToTimecodeInput.value);
}
        videoPlayer.currentTime = targetTimeMs / 1000;

        // Buscamos el subtítulo cuyo inicio es más cercano (pero no posterior) al tiempo introducido.
        let foundIndex = 0;
        for (let i = 0; i < srtEntries.length; i++) {
            if (srtEntries[i].startTimeMs <= targetTimeMs) {
                foundIndex = i;
            } else {
                break;
            }
        }
        navigateToTranslation(foundIndex);
    } catch (error) {
        showMessage("El formato del timecode no es válido. Usa HH:MM:SS,ms");
    }
}

// --- START: Subtitle Structural Editing & Undo/Redo Logic ---

        function saveStructuralState(oldState, newState) {
            // AÑADIR ESTA LÍNEA ->
            if (isApplyingState) return;
            historyStack.push({ type: 'structural', oldState, newState });
            redoStack = []; // Un nuevo cambio borra el historial de "rehacer"
            updateUndoRedoButtons();
        }



        /** <- AÑADIR ESTE BLOQUE COMPLETO ->
         * Guarda el estado de un cambio de tiempo en el historial.
         * @param {number} entryIndex - El índice del subtítulo modificado.
         * @param {object} oldValue - {startTimeMs, endTimeMs} ANTES del cambio.
         * @param {object} newValue - {startTimeMs, endTimeMs} DESPUÉS del cambio.
         */
        function saveTimeChange(entryIndex, oldValue, newValue) {
            if (isApplyingState) return;
            // No guardar si los tiempos no han cambiado realmente
            if (oldValue.startTimeMs === newValue.startTimeMs && oldValue.endTimeMs === newValue.endTimeMs) return;

            historyStack.push({ type: 'timeChange', entryIndex, oldValue, newValue });
            redoStack = [];
            updateUndoRedoButtons();
        }
        // <- FIN DEL BLOQUE AÑADIDO ->

        
        /**
         * Deshace la última acción del historial (textual o estructural).
         */
        function undo() {
            if (historyStack.length === 0) return;

            isApplyingState = true;
            const lastAction = historyStack.pop();
            redoStack.push(lastAction); // Guardamos la acción en la pila de "rehacer"

            if (lastAction.type === 'structural') {
                // Si es un cambio estructural, restauramos toda la lista de subtítulos
                srtEntries = JSON.parse(JSON.stringify(lastAction.oldState));
                renderTranslations(srtEntries, 0, true);
           } else if (lastAction.type === 'timeChange') { // <-- CORREGIDO
            // --- NUEVO: Manejar deshacer cambio de tiempo ---
            const { entryIndex, oldValue } = lastAction; // <-- CORREGIDO
            const entry = srtEntries[entryIndex];
            if (entry) {
                entry.startTimeMs = oldValue.startTimeMs;
                entry.endTimeMs = oldValue.endTimeMs;
                updateEntryTimes(entryIndex); // Actualiza UI y región de la onda
            }
        } else { // <-- MODIFICAR: Este 'else' ahora solo maneja 'text'
            // Manejar cambio de texto
            const { entryIndex, newValue } = lastUndo;
            const entry = srtEntries[entryIndex];
            const editor = document.getElementById(`translation-${entryIndex}`);
                if (entry && editor) {
                    entry.translation = newValue; // <-- CORREGIDO
                    editor.innerHTML = newValue;  // <-- CORREGIDO
                    editor.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }

            updateUndoRedoButtons();
            isApplyingState = false;
        }

        /**
         * Rehace la última acción deshecha (textual o estructural).
         */
        function redo() {
            if (redoStack.length === 0) return;
            isApplyingState = true;
            const lastUndo = redoStack.pop();
            historyStack.push(lastUndo); // Devolvemos la acción al historial principal

            if (lastUndo.type === 'structural') {
                // Si es un cambio estructural, aplicamos el nuevo estado
                srtEntries = JSON.parse(JSON.stringify(lastUndo.newState));
                renderTranslations(srtEntries, 0, true);
            } else {
                // Si es un cambio de texto, aplicamos el nuevo texto
                const { entryIndex, newValue } = lastUndo;
                const entry = srtEntries[entryIndex];
                const editor = document.getElementById(`translation-${entryIndex}`);
                if (entry && editor) {
                    entry.translation = newValue;
                    editor.innerHTML = newValue;
                    editor.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }

            updateUndoRedoButtons();
            isApplyingState = false;
        }


        /**
         * Vuelve a numerar los índices de los subtítulos después de una modificación (añadir/eliminar).
         * @param {number} startIndex - El índice del array a partir del cual empezar a renumerar.
         */
        function renumberSubtitles(startIndex = 0) {
            for (let i = startIndex; i < srtEntries.length; i++) {
                srtEntries[i].index = i + 1;
            }
        }

        /**
         * Fusiona un subtítulo con el siguiente.
         * @param {number} entryIndex - El índice del subtítulo actual.
         */
        function mergeWithNext(entryIndex) {
            if (entryIndex >= srtEntries.length - 1) return; // No se puede fusionar el último

            const oldState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado PREVIO

            const currentEntry = srtEntries[entryIndex];
            const nextEntry = srtEntries[entryIndex + 1];

            currentEntry.original += `\n${nextEntry.original}`;
            currentEntry.translation += `<br>${nextEntry.translation}`;
            currentEntry.endTimeMs = nextEntry.endTimeMs;
            currentEntry.durationMs = currentEntry.endTimeMs - currentEntry.startTimeMs;
            currentEntry.timecodes = `${formatTime(currentEntry.startTimeMs)} --> ${formatTime(currentEntry.endTimeMs)}`;

            srtEntries.splice(entryIndex + 1, 1);
            renumberSubtitles(entryIndex + 1);
            
            const newState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado POSTERIOR
            saveStructuralState(oldState, newState); // Registrar en el historial

            renderTranslations(srtEntries, entryIndex, true);
        }

        /**
         * Separa un subtítulo en dos en la posición del cursor.
         * @param {number} entryIndex - El índice del subtítulo a separar.
         */
        /**
         * Separa un subtítulo en dos en la posición del cursor.
         * @param {number} entryIndex - El índice del subtítulo a separar.
         */
        function splitSubtitle(entryIndex) {
            const editor = document.getElementById(`translation-${entryIndex}`);
            const selection = window.getSelection();
            if (!editor || !selection.rangeCount > 0) return;

            const range = selection.getRangeAt(0);
            const splitPoint = range.startOffset;
            const textContent = editor.innerText;

            if (splitPoint === 0 || splitPoint === textContent.length) {
                showMessage("Coloca el cursor en el punto donde quieres separar el subtítulo.");
                return;
            }
            
            const oldState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado PREVIO

            // --- INICIO DE LA MODIFICACIÓN ---

            // 1. Calculamos el hueco de 2 fotogramas
            const frameDurationMs = Math.round(1000 / projectFPS);
            const gapMs = frameDurationMs * 2;

            const currentEntry = srtEntries[entryIndex];
            const firstPartTranslation = editor.innerHTML.substring(0, splitPoint);
            const secondPartTranslation = editor.innerHTML.substring(splitPoint);

            const splitRatio = splitPoint / textContent.length;
            const originalSplitPoint = Math.round(currentEntry.original.length * splitRatio);
            const firstPartOriginal = currentEntry.original.substring(0, originalSplitPoint).trim();
            const secondPartOriginal = currentEntry.original.substring(originalSplitPoint).trim();

            // 2. Calculamos los nuevos tiempos
            const midPointTimeMs = currentEntry.startTimeMs + Math.round(currentEntry.durationMs * splitRatio);
            
            // El primer subtítulo termina en el punto de corte
            const firstPartEndTimeMs = midPointTimeMs;
            
            // El segundo subtítulo empieza DESPUÉS del hueco
            let secondPartStartTimeMs = midPointTimeMs + gapMs;

            // Guardamos el tiempo final original
            const originalEndTimeMs = currentEntry.endTimeMs;

            // 3. Comprobación de seguridad:
            // Si el hueco de 2 fotogramas es tan grande que "come" todo el segundo subtítulo...
            if (secondPartStartTimeMs >= originalEndTimeMs) {
                // ...lo forzamos a tener una duración mínima (ej. 1 fotograma)
                secondPartStartTimeMs = originalEndTimeMs - frameDurationMs;
                // Y nos aseguramos de que el primero no se solape
                if (firstPartEndTimeMs >= secondPartStartTimeMs) {
                    firstPartEndTimeMs = secondPartStartTimeMs - 1; // Dejamos 1ms de separación
                }
            }

            // 4. Creamos y actualizamos los subtítulos con los tiempos corregidos

            const newEntry = { 
                ...currentEntry, 
                index: currentEntry.index + 1, 
                original: secondPartOriginal, 
                translation: secondPartTranslation, 
                startTimeMs: secondPartStartTimeMs,         // <--- MODIFICADO
                endTimeMs: originalEndTimeMs,               // <--- MODIFICADO (usa el final original)
                durationMs: originalEndTimeMs - secondPartStartTimeMs, // <--- MODIFICADO
                timecodes: `${formatTime(secondPartStartTimeMs)} --> ${formatTime(originalEndTimeMs)}` // <--- MODIFICADO
            };
            
            delete newEntry.regionId; // (Esto es de tu corrección anterior, y está perfecto)

            currentEntry.original = firstPartOriginal;
            currentEntry.translation = firstPartTranslation;
            currentEntry.endTimeMs = firstPartEndTimeMs;        // <--- MODIFICADO
            currentEntry.durationMs = currentEntry.endTimeMs - currentEntry.startTimeMs;
            currentEntry.timecodes = `${formatTime(currentEntry.startTimeMs)} --> ${formatTime(firstPartEndTimeMs)}`; // <--- MODIFICADO
            
            // --- FIN DE LA MODIFICACIÓN ---

            srtEntries.splice(entryIndex + 1, 0, newEntry);
            renumberSubtitles(entryIndex + 1);
            
            const newState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado POSTERIOR
            saveStructuralState(oldState, newState); // Registrar en el historial

            renderTranslations(srtEntries, entryIndex + 1, true);
        }

        /**
         * Muestra un diálogo de confirmación antes de eliminar un subtítulo.
         * @param {number} entryIndex - El índice del subtítulo a eliminar.
         */
        function confirmDeleteSubtitle(entryIndex) {
            // Usamos la clave del objeto de traducciones para el mensaje
            if (confirm(translations[currentLanguage]['delete_subtitle_confirm'])) {
                deleteSubtitle(entryIndex);
            }
        }
        
        /**
         * Elimina un subtítulo del proyecto.
         * @param {number} entryIndex - El índice del subtítulo a eliminar.
         */
        function deleteSubtitle(entryIndex) {
            const oldState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado PREVIO
            
            srtEntries.splice(entryIndex, 1);
            renumberSubtitles(entryIndex);
            
            const newState = JSON.parse(JSON.stringify(srtEntries)); // Guardar estado POSTERIOR
            saveStructuralState(oldState, newState); // Registrar en el historial
            
            const newIndexToFocus = Math.min(entryIndex, srtEntries.length - 1);
            renderTranslations(srtEntries, newIndexToFocus, true);
        }
        
        // --- END: Subtitle Structural Editing & Undo/Redo Logic ---
        // --- Backup and Restore Functions ---
        function getProjectState() {
            if (srtEntries.length === 0) return null;
            return {
                fileName: currentFileName, srtEntries: srtEntries,
                glossary: { data: glossary, sourceLang: glossarySourceLanguage, targetLang: glossaryTargetLanguage },
                translationMemory: { data: translationMemory, sourceLang: tmSourceLanguage, targetLang: tmTargetLanguage },
                qaSettings: qaSettings, lastModified: new Date(),
 sessionPlan: sessionPlan
            };
        }

        async function saveBackup() {
            const projectState = getProjectState();
            if (!projectState) {
                backupBtn.classList.remove('animate-pulse-yellow');
                return;
            }
            try {
                await db.projects.put({ id: 1, ...projectState });
                backupBtn.classList.add('animate-pulse-yellow');
            } catch (error) {
                console.error('Error saving backup to IndexedDB:', error);
            }
        }
        
        function restoreProject(backupData) {
            currentFileName = backupData.fileName;
            srtEntries = backupData.srtEntries;
            glossary = backupData.glossary.data || [];
            glossarySourceLanguage = backupData.glossary.sourceLang;
            glossaryTargetLanguage = backupData.glossary.targetLang;
            translationMemory = backupData.translationMemory.data || [];
            tmSourceLanguage = backupData.translationMemory.sourceLang;
            tmTargetLanguage = backupData.translationMemory.targetLang;
            qaSettings = backupData.qaSettings || { cpsLimit: 20, charsPerLineLimit: 42 };
            
            renderTranslations(srtEntries);
            showGlossaryEditorSection();
            showTMEditorSection();
            
            showMessage(errorMessages[currentLanguage]['project_restored_message']);
        }

        // --- QA Functions ---
        function runFullQaCheck() {
            srtEntries.forEach((entry, index) => {
                const editorDiv = document.getElementById(`translation-${index}`);
                if (editorDiv) {
                    updateSubtitleStats(editorDiv, entry.charCountOriginal, entry.durationMs);
                }
            });
            updateStatsDisplay();
        }

        function calculateAllQaErrors() {
            const errors = [];
            srtEntries.forEach((entry, index) => {
                const errorTypes = new Set();
                const currentCPS = calculateCPS(entry.translation, entry.durationMs);
                if (currentCPS > qaSettings.cpsLimit) {
                    errorTypes.add('CPS');
                }
                const lines = entry.translation.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '').split('\n');
                lines.forEach(line => {
                    if (countCharactersWithoutTags(line) > qaSettings.charsPerLineLimit) {
                        errorTypes.add('Line length');
                    }
                });

                if (errorTypes.size > 0) {
                    errors.push({
                        index: index,
                        subtitleIndex: entry.index,
                        text: entry.translation.replace(/<[^>]+>/g, ' ').substring(0, 50) + '...',
                        errors: Array.from(errorTypes)
                    });
                }
            });
            return errors;
        }

        function renderQaErrorList() {
            const errors = calculateAllQaErrors();
            qaErrorListContainer.innerHTML = '';
            const t = translations[currentLanguage];
            if (errors.length === 0) {
                qaErrorListContainer.textContent = t.qa_no_errors;
                return;
            }
            
            errors.forEach(error => {
                const errorItem = document.createElement('div');
                errorItem.className = 'qa-error-item';
                errorItem.dataset.entryIndex = error.index;
                errorItem.innerHTML = `
                    <div class="font-bold">Subtitle #${error.subtitleIndex} <span class="text-red-500">(${error.errors.join(', ')})</span></div>
                    <div class="text-sm text-gray-600">${error.text}</div>
                `;
                qaErrorListContainer.appendChild(errorItem);
            });
        }

        // --- Project Save/Load Functions ---
async function saveProject(filename) {
            if (srtEntries.length === 0) {
                showMessage(errorMessages[currentLanguage]['no_project_to_save']);
                return;
            }
            showLoadingOverlay(translations[currentLanguage]['saving_file']);

            const projectData = {
                version: '1.0',
                srtEntries,
                glossary,
                glossarySourceLanguage,
                glossaryTargetLanguage,
                translationMemory,
                tmSourceLanguage,
                tmTargetLanguage,
                qaSettings,
                videoFileName,
                sessionPlan,
                currentLanguage
            };

            try {
                const zip = new JSZip();
                zip.file("project.json", JSON.stringify(projectData, null, 2));

                const content = await zip.generateAsync({ type: "blob" });
                
                const a = document.createElement("a");
                const url = URL.createObjectURL(content);
                a.href = url;
                a.download = filename.endsWith('.subpanda') ? filename : filename + '.subpanda'; // <-- LÍNEA MODIFICADA
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(url);
                a.remove();
                
                showMessage('Proyecto guardado con éxito.');
                
                // --- LÓGICA AÑADIDA ---
                if (typeof afterSaveAction === 'function') {
                    afterSaveAction();
                    afterSaveAction = null; // Resetea la acción
                }
                // --- FIN DE LÓGICA AÑADIDA ---

            } catch (error) {
                console.error("Error saving project:", error);
                showMessage('Error al guardar el proyecto.');
                afterSaveAction = null; // Resetea también en caso de error
            } finally {
                hideLoadingOverlay();
            }
        }
        async function loadProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoadingOverlay(translations[currentLanguage]['loading_file']);
            try {
                const zip = await JSZip.loadAsync(file);
                const projectJsonFile = zip.file("project.json");

                if (!projectJsonFile) {
                    throw new Error("Archivo de proyecto inválido: no se encontró project.json.");
                }

                const projectData = JSON.parse(await projectJsonFile.async("string"));
                
currentFileName = file.name;

 historyStack = [];
                    redoStack = [];
                    updateUndoRedoButtons();

                restoreProjectState(projectData);

                showMessage(errorMessages[currentLanguage]['project_loaded_success']);
                
                if (projectData.videoFileName) {
                    reselectVideoInfo.textContent = translations[currentLanguage]['reselect_video_prompt'].replace('{0}', projectData.videoFileName);
                    reselectVideoModal.classList.remove('hidden');
                }

            } catch (error) {
                console.error("Error loading project:", error);
                showMessage(`${errorMessages[currentLanguage]['error_loading_project']}: ${error.message}`);
            } finally {
                hideLoadingOverlay();
                event.target.value = ''; // Reset file input
            }
        }

        function restoreProjectState(data) {
            srtEntries = data.srtEntries || [];
            glossary = data.glossary || [];
            glossarySourceLanguage = data.glossarySourceLanguage || '';
            glossaryTargetLanguage = data.glossaryTargetLanguage || '';
            translationMemory = data.translationMemory || [];
            tmSourceLanguage = data.tmSourceLanguage || '';
            tmTargetLanguage = data.tmTargetLanguage || '';
            qaSettings = data.qaSettings || { cpsLimit: 20, charsPerLineLimit: 42 };
            videoFileName = data.videoFileName || null;
sessionPlan = data.sessionPlan || [];

            setLanguage(data.currentLanguage || 'es');
            
            renderTranslations(srtEntries);

renderPlanner();
            
            if (glossarySourceLanguage) {
                showGlossaryEditorSection();
            } else {
                showLanguageConfigSection();
            }

            if (tmSourceLanguage) {
                showTMEditorSection();
            } else {
                showTMLanguageConfigSection();
            }
        }

        function resetApplicationState() {
            srtEntries = [];
            currentFileName = 'subtitles.srt';
            videoFileName = null;
            
historyStack = [];
            redoStack = [];
            updateUndoRedoButtons();

            resetGlossary();
            resetTM();
            
            videoPlayer.pause();
            videoPlayer.src = '';
if (wavesurfer) {
                wavesurfer.empty();
clearSubtitleRegions();
                document.getElementById('waveform').classList.add('hidden');
            }
sessionPlan = []; // <-- AÑADIR ESTA LÍNEA
if (document.getElementById('plannerContainer')) { 
    document.getElementById('plannerContainer').classList.add('hidden');
    document.getElementById('sessionResults').innerHTML = '';
}
            document.getElementById('videoLogoPlaceholder').classList.remove('hidden');
            const loadVideoBtnSpan = document.querySelector('#loadVideoBtn span');
            if (loadVideoBtnSpan) {
                loadVideoBtnSpan.textContent = translations[currentLanguage]['load_video'];
            }
            
            renderTranslations([]);
            updateStatsDisplay();
            
            confirmNewProjectModal.classList.add('hidden');
        }

/**
 * Borra todos los datos de la aplicación (LocalStorage e IndexedDB)
 * y recarga la página para empezar desde cero.
 */
function resetApplicationCache() {
    const t = translations[currentLanguage];
    const confirmation = confirm(t['reset_app_confirm']);

    if (confirmation) {
        try {
            // Borra todo el LocalStorage (ajustes de IA, atajos, etc.)
            localStorage.clear();

            // Borra la base de datos IndexedDB (proyectos y backups)
            db.delete().then(() => {
                showMessage(t['reset_app_success']);
                // Espera un segundo para que el usuario vea el mensaje y recarga la página.
                setTimeout(() => {
                    location.reload();
                }, 1000);
            }).catch(err => {
                console.error("Error al borrar la base de datos:", err);
                showMessage(t['reset_db_error']);
            });

        } catch (error) {
            console.error("Error al resetear el almacenamiento:", error);
            showMessage(t['reset_storage_error']);
        }
    }
}

// --- START: PLANNER LOGIC ---

let sessionPlan = [];
let activeSessionIndex = -1;
let timerInterval = null;
let sessionStartTime = 0;

function calculateSessions() {
    const t = translations[currentLanguage]; // Obtenemos el diccionario del idioma actual

    if (srtEntries.length === 0) {
        showMessage(t['planner_load_srt_warning']); // Usamos la traducción
        return;
    }

    const numSessions = parseInt(document.getElementById('sessionCount').value, 10);
    const method = document.getElementById('divisionMethod').value;

    sessionPlan = [];
    activeSessionIndex = -1;
    clearInterval(timerInterval);

    const totalSubs = srtEntries.length;
    const totalDuration = srtEntries[totalSubs - 1].endTimeMs;
    const totalWords = srtEntries.reduce((sum, entry) => sum + entry.wordCountOriginal, 0);

    let lastIndex = 0;

    for (let i = 1; i <= numSessions; i++) {
        let session = {
            id: i,
            startSub: 0,
            endSub: 0,
            text: '',
            isCompleted: false,
            elapsedTime: 0
        };

        session.startSub = lastIndex + 1;

        if (method === 'subtitles') {
            const subsPerSession = Math.ceil(totalSubs / numSessions);
            session.endSub = Math.min(i * subsPerSession, totalSubs);
            session.text = t['planner_session_subs'].replace('{0}', session.startSub).replace('{1}', session.endSub);
        } 
        else if (method === 'time') {
            const timePerSession = totalDuration / numSessions;
            const sessionEndTime = i * timePerSession;
            const endEntry = srtEntries.find(entry => entry.startTimeMs >= sessionEndTime) || srtEntries[totalSubs - 1];
            session.endSub = endEntry.index;
            if (i === numSessions) session.endSub = totalSubs;

            const startTimeMs = Math.round((i - 1) * timePerSession);
            const endTimeMs = Math.round(sessionEndTime);
            const startTimeStr = formatTime(startTimeMs);
            const endTimeStr = formatTime(endTimeMs);
            session.text = t['planner_session_time'].replace('{0}', startTimeStr).replace('{1}', endTimeStr).replace('{2}', session.endSub);
        }
        else if (method === 'words') {
            const wordsPerSession = totalWords / numSessions;
            let currentWords = 0;
            let endSubIndex = lastIndex;
            for (let j = lastIndex; j < totalSubs; j++) {
                currentWords += srtEntries[j].wordCountOriginal;
                if ((j > lastIndex && currentWords > (wordsPerSession * 0.8)) || j === totalSubs - 1) {
                     endSubIndex = j;
                     if (i === numSessions) {
                         endSubIndex = totalSubs -1;
                     }
                     break;
                }
            }
             session.endSub = endSubIndex + 1;
             if (i === numSessions) session.endSub = totalSubs;
             const approxWords = Math.round(wordsPerSession);
             session.text = t['planner_session_words'].replace('{0}', session.startSub).replace('{1}', session.endSub).replace('{2}', approxWords);
        }

        lastIndex = session.endSub;
        sessionPlan.push(session);
    }

// --- INICIO DEL BLOQUE A AÑADIR ---
// Añadimos el ítem fijo de Revisión / QA al final del plan
sessionPlan.push({
    id: numSessions + 1,
    startSub: null, // No tiene subtítulo de inicio
    endSub: null,
    text: t['planner_session_qa'],
    isCompleted: false,
    elapsedTime: 0
});
// --- FIN DEL BLOQUE A AÑADIR ---

    renderPlanner();
}

function renderPlanner() {
    const resultsContainer = document.getElementById('sessionResults');
    resultsContainer.innerHTML = '';

    sessionPlan.forEach((session, index) => {
        const row = document.createElement('div');
        row.className = 'session-row';
        if (session.isCompleted) row.classList.add('completed');
        if (index === activeSessionIndex) row.classList.add('active');

        row.innerHTML = `
            <input type="checkbox" class="session-checkbox form-checkbox h-5 w-5 text-blue-600" data-index="${index}" ${session.isCompleted ? 'checked' : ''}>
            <div class="session-text">${session.text}</div>
            <div class="session-time" id="time-${index}">${formatElapsedTime(session.elapsedTime)}</div>
            <button class="btn btn-secondary text-xs" id="timer-btn-${index}" data-index="${index}">▶</button>
            <button class="btn btn-secondary text-xs" id="reset-btn-${index}" data-index="${index}">↻</button>
        `;
        resultsContainer.appendChild(row);
    });

    // Add event listeners
    resultsContainer.querySelectorAll('.session-checkbox').forEach(cb => {
        cb.addEventListener('change', (e) => {
            const index = parseInt(e.target.dataset.index, 10);
            sessionPlan[index].isCompleted = e.target.checked;
            if (e.target.checked) pauseTimer();
            renderPlanner();
        });
    });

    resultsContainer.querySelectorAll('.session-row').forEach(row => {
    row.addEventListener('click', (e) => {
        if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') {
            const index = parseInt(e.target.closest('.session-row').querySelector('.session-checkbox').dataset.index, 10);

            // Solo navegamos si la sesión tiene un subtítulo de inicio definido
            if (sessionPlan[index] && sessionPlan[index].startSub) {
                navigateToTranslation(sessionPlan[index].startSub - 1);
            }
        } // <-- ESTA ES LA LLAVE QUE SE HA MOVIDO A SU SITIO CORRECTO
    });
});

     resultsContainer.querySelectorAll('[id^=timer-btn-]').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(e.target.dataset.index, 10);

            if (activeSessionIndex === index && timerInterval) {
                pauseTimer();
            } else {
                startTimer(index);
            }
        });
    });

    resultsContainer.querySelectorAll('[id^=reset-btn-]').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(e.target.dataset.index, 10);
            resetTimer(index);
        });
    });
}

function startTimer(index) {
    clearInterval(timerInterval);
    activeSessionIndex = index;
    sessionStartTime = Date.now() - sessionPlan[index].elapsedTime;

    timerInterval = setInterval(updateTimerDisplay, 1000);
    renderPlanner(); // Re-render to show active state and button text change
    document.getElementById(`timer-btn-${index}`).textContent = '❚❚';
}

function pauseTimer() {
    if (activeSessionIndex === -1) return;
    clearInterval(timerInterval);
    timerInterval = null;
    sessionPlan[activeSessionIndex].elapsedTime = Date.now() - sessionStartTime;
    document.getElementById(`timer-btn-${activeSessionIndex}`).textContent = '▶';
}

function resetTimer(index) {
    if(activeSessionIndex === index) pauseTimer();
    sessionPlan[index].elapsedTime = 0;
    document.getElementById(`time-${index}`).textContent = '00:00:00';
}

function updateTimerDisplay() {
    const elapsedTime = Date.now() - sessionStartTime;
    document.getElementById(`time-${activeSessionIndex}`).textContent = formatElapsedTime(elapsedTime);
}

function formatElapsedTime(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

// --- END: PLANNER LOGIC ---

        // --- START: Floating Panel Logic (Drag, Resize, and Close) ---
        function closeFloatingPanel(panel, triggerButton) {
            panel.classList.remove('is-visible');
             if (triggerButton) {
                triggerButton.classList.remove('btn-active');
            }
        }

        function openFloatingPanel(panelToOpen, triggerButton, callback) {
            if (panelToOpen.classList.contains('is-visible')) {
                closeFloatingPanel(panelToOpen, triggerButton);
                return;
            }
            
            panelToOpen.classList.add('is-visible');
            
                 if (triggerButton) {
                triggerButton.classList.add('btn-active');
            }

            if (callback) {
                callback();
            }
        }
        
        function resetPanelPosition(panel) {
            // Remove inline styles set by dragging/resizing
            panel.style.left = '';
            panel.style.top = '';
            panel.style.width = '';
            panel.style.height = '';
            panel.style.right = '';
            panel.style.bottom = '';
            panel.style.transform = '';
            
            // Remove the moved data attribute
            delete panel.dataset.moved;
            
            // Re-apply visibility to ensure it's positioned correctly by CSS
            panel.classList.remove('is-visible');
            setTimeout(() => panel.classList.add('is-visible'), 10);
        }

        function makePanelDraggable(panel) {
            const header = panel.querySelector('.sidebar-header');
            let isDragging = false;
            let offsetX, offsetY;

            header.addEventListener('mousedown', (e) => {
                // Ignore clicks on buttons inside the header
                if (e.target.closest('button')) return;
                
                isDragging = true;
                panel.dataset.moved = 'true'; // Mark as moved
                
                const rect = panel.getBoundingClientRect();
                panel.style.left = `${rect.left}px`;
                panel.style.top = `${rect.top}px`;
                panel.style.right = 'auto';
                panel.style.bottom = 'auto';
                
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                
                panel.style.transition = 'none';
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'move';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                let newX = e.clientX - offsetX;
                let newY = e.clientY - offsetY;

                panel.style.left = `${newX}px`;
                panel.style.top = `${newY}px`;
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    panel.style.transition = ''; // Restore transitions
                    document.body.style.userSelect = '';
                    document.body.style.cursor = '';
                }
            });
        }
        
        function makePanelResizable(panel) {
            const resizers = document.createElement('div');
            resizers.innerHTML = `
                <div class="panel-resizer top-left"></div> <div class="panel-resizer top"></div> <div class="panel-resizer top-right"></div>
                <div class="panel-resizer left"></div>                                       <div class="panel-resizer right"></div>
                <div class="panel-resizer bottom-left"></div> <div class="panel-resizer bottom"></div> <div class="panel-resizer bottom-right"></div>
            `;
            panel.appendChild(resizers);
            
            let originalWidth, originalHeight, originalX, originalY, originalMouseX, originalMouseY;

            resizers.querySelectorAll('.panel-resizer').forEach(resizer => {
                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    panel.dataset.moved = 'true';
                    originalWidth = panel.offsetWidth;
                    originalHeight = panel.offsetHeight;
                    originalX = panel.offsetLeft;
                    originalY = panel.offsetTop;
                    originalMouseX = e.pageX;
                    originalMouseY = e.pageY;

                    const mouseMoveHandler = (e) => {
                        const dx = e.pageX - originalMouseX;
                        const dy = e.pageY - originalMouseY;

                        if (resizer.classList.contains('right')) {
                            panel.style.width = `${originalWidth + dx}px`;
                        } else if (resizer.classList.contains('left')) {
                            panel.style.width = `${originalWidth - dx}px`;
                            panel.style.left = `${originalX + dx}px`;
                        }

                        if (resizer.classList.contains('bottom')) {
                            panel.style.height = `${originalHeight + dy}px`;
                        } else if (resizer.classList.contains('top')) {
                            panel.style.height = `${originalHeight - dy}px`;
                            panel.style.top = `${originalY + dy}px`;
                        }
                        
                        // Handle corners
                        if (resizer.classList.contains('bottom-right')) {
                           panel.style.width = `${originalWidth + dx}px`;
                           panel.style.height = `${originalHeight + dy}px`;
                        } else if (resizer.classList.contains('bottom-left')) {
                           panel.style.width = `${originalWidth - dx}px`;
                           panel.style.left = `${originalX + dx}px`;
                           panel.style.height = `${originalHeight + dy}px`;
                        } else if (resizer.classList.contains('top-right')) {
                           panel.style.width = `${originalWidth + dx}px`;
                           panel.style.height = `${originalHeight - dy}px`;
                           panel.style.top = `${originalY + dy}px`;
                        } else if (resizer.classList.contains('top-left')) {
                           panel.style.width = `${originalWidth - dx}px`;
                           panel.style.left = `${originalX + dx}px`;
                           panel.style.height = `${originalHeight - dy}px`;
                           panel.style.top = `${originalY + dy}px`;
                        }
                    };

                    const mouseUpHandler = () => {
                        document.removeEventListener('mousemove', mouseMoveHandler);
                        document.removeEventListener('mouseup', mouseUpHandler);
                    };

                    document.addEventListener('mousemove', mouseMoveHandler);
                    document.addEventListener('mouseup', mouseUpHandler);
                });
            });
        }
        // --- END: Floating Panel Logic ---


        // --- Initialization on page load ---
        document.addEventListener('DOMContentLoaded', async () => {
            await loadShortcuts();
loadAiCustomInstructions();
            populateIsoLanguagesDatalist();
            setLanguage('es'); 
            resetApplicationState();

            // Initialize floating panels
            const terminologyPanel = document.getElementById('terminologySidebar');
            const tmPanel = document.getElementById('translationMemorySidebar');
            
            makePanelDraggable(terminologyPanel);
            makePanelResizable(terminologyPanel);
            makePanelDraggable(tmPanel);
            makePanelResizable(tmPanel);

const contextPanel = document.getElementById('contextSidebar');
makePanelDraggable(contextPanel);
makePanelResizable(contextPanel);
makePanelDraggable(goToSubtitlePanel);
makePanelResizable(goToSubtitlePanel);
           makePanelDraggable(findReplacePanel);
            makePanelResizable(findReplacePanel);

// --- INICIO: Inicialización de WaveSurfer ---
            const waveformContainer = document.getElementById('waveform');
            const videoPlayer = document.getElementById('videoPlayer'); // Ya tienes esta variable
            
           wavesurfer = WaveSurfer.create({
                container: waveformContainer,
                media: videoPlayer,
                waveColor: '#A8DBA8',
                progressColor: '#3B8686',
                cursorColor: '#FFD700',
                cursorWidth: 2,
                barWidth: 3,
                barRadius: 3,
                barGap: 2,
                height: 96,
                responsive: true,
                minPxPerSec: 100,
                plugins: [
                    WaveSurfer.Regions.create(),
                ]
            });

            wsRegions = wavesurfer.plugins[0];

             wavesurfer.on('ready', () => {
                 document.getElementById('waveform').classList.remove('hidden');
waveformControls.classList.remove('hidden');
                 // AÑADIDO: Solo renderiza si hay subtítulos cargados
                 if (srtEntries && srtEntries.length > 0) {
                     renderTranslations(srtEntries, lastActiveSubtitleIndex, true); // Renderiza subtítulos Y regiones
                 }
             });
            wavesurfer.on('error', (err) => {
                 console.error('WaveSurfer error:', err);
                 // MODIFICADO: Mensaje más genérico o quitarlo si no se carga video
                 // showMessage("Error con la onda de sonido.");
             });
              // Listener para cuando una región se mueve o redimensiona
             wsRegions.on('region-updated', (region) => {
                 const entryIndex = srtEntries.findIndex(e => e.regionId === region.id);
                 if (entryIndex !== -1) {
                     const entry = srtEntries[entryIndex];
                     const newStartTimeMs = Math.round(region.start * 1000);
                     const newEndTimeMs = Math.round(region.end * 1000);

                     // Comprueba si los tiempos realmente cambiaron para evitar bucles infinitos
                     if (entry.startTimeMs !== newStartTimeMs || entry.endTimeMs !== newEndTimeMs) {
                         // Guarda el estado ANTES de modificar los datos
if (!isApplyingState) { // Solo guarda si no estamos deshaciendo/rehaciendo
                        const oldTimes = { startTimeMs: entry.startTimeMs, endTimeMs: entry.endTimeMs };
                        const newTimes = { startTimeMs: newStartTimeMs, endTimeMs: newEndTimeMs };
                        saveTimeChange(entryIndex, oldTimes, newTimes);
                    }
                         entry.startTimeMs = newStartTimeMs;
                         entry.endTimeMs = newEndTimeMs;
                         updateEntryTimes(entryIndex); // Actualiza la tabla y la propia región
                     }
                 }
             });
              // Listener para clic en una región
             wsRegions.on('region-clicked', (region, e) => {
                 e.stopPropagation(); // Evita que el clic se propague al contenedor de la onda
                 const entryIndex = srtEntries.findIndex(e => e.regionId === region.id);
                 if (entryIndex !== -1) {
                      wavesurfer.setTime(region.start); // Va al inicio de la región
                      navigateToTranslation(entryIndex); // Activa el subtítulo en la lista
                 }
             });

// --- AÑADIR ESTE BLOQUE ---
const plannerContainer = document.getElementById('plannerContainer');
const plannerAccordionHeader = document.getElementById('plannerAccordionHeader');
const plannerAccordionContent = document.getElementById('plannerAccordionContent');
const plannerAccordionIcon = plannerAccordionHeader.querySelector('.accordion-icon');
const calculateSessionsBtn = document.getElementById('calculateSessionsBtn');
 const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);


plannerAccordionHeader.addEventListener('click', () => {
    const isCollapsed = plannerAccordionContent.classList.contains('collapsed');
    plannerAccordionContent.classList.toggle('collapsed', !isCollapsed);
    plannerAccordionContent.classList.toggle('expanded', isCollapsed);
    plannerAccordionIcon.classList.toggle('rotated', isCollapsed);
});
calculateSessionsBtn.addEventListener('click', calculateSessions);
// --- FIN DEL BLOQUE A AÑADIR ---
            
            // Setup panel buttons
            setupPanel('terminologySidebar', 'terminologyBtn', () => {
                 if (!glossarySourceLanguage || !glossaryTargetLanguage) {
                    showLanguageConfigSection();
                } else {
                    showGlossaryEditorSection();
                }
            });
            setupPanel('translationMemorySidebar', 'tmBtn', () => {
                if (!tmSourceLanguage || !tmTargetLanguage) {
                    showTMLanguageConfigSection();
                } else {
                    showTMEditorSection();
                    tmSearch();
                }
            });
setupPanel('contextSidebar', 'contextBtn');
setupPanel('goToSubtitlePanel', 'goToSubtitleBtn');
goToSubtitleActionBtn.addEventListener('click', goToSubtitleByNumber);
goToTimecodeActionBtn.addEventListener('click', goToSubtitleByTimecode);

            if (saveSrtButton) saveSrtButton.disabled = true;
            if (statsContainer) statsContainer.classList.add('hidden');
            if (addTermContent) addTermContent.classList.add('collapsed');
            if (statsAccordionContent) statsAccordionContent.classList.add('collapsed');
            
videoPlayer.addEventListener('timeupdate', () => {
    updateSubtitlePreview(); // Actualiza el texto de vista previa
    handlePlaybackTracking(); // Gestiona el resaltado/scroll automático
});

            // Inicializa los nuevos controles del reproductor
updateFontSize(subtitleFontSize);
setPreviewSource('translation'); // Establece el estado inicial

// Event listeners para los nuevos botones
setPreviewOriginal.addEventListener('click', () => setPreviewSource('original'));
setPreviewTranslation.addEventListener('click', () => setPreviewSource('translation'));
increaseFontSize.addEventListener('click', () => updateFontSize(subtitleFontSize + 2));
decreaseFontSize.addEventListener('click', () => updateFontSize(subtitleFontSize - 2));

// Event listener para nuestro botón de pantalla completa
customFullscreenBtn.addEventListener('click', toggleFullscreen);

// Detecta cualquier cambio en el estado de la pantalla completa
document.addEventListener('fullscreenchange', handleFullscreenClass);
document.addEventListener('webkitfullscreenchange', handleFullscreenClass);
document.addEventListener('mozfullscreenchange', handleFullscreenClass);
document.addEventListener('MSFullscreenChange', handleFullscreenClass);

function handleFullscreenClass() {
    // Comprueba si hay algún elemento en pantalla completa
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
    
    // Añade o quita la clase .is-fullscreen del contenedor del vídeo
    videoPlayerWrapper.classList.toggle('is-fullscreen', isFullscreen);
}

// Event listener para cambiar el icono cuando cambia el estado de la pantalla completa
function handleFullscreenChange() {
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);

    fullscreenEnterChar.classList.toggle('hidden', isFullscreen);
    fullscreenExitChar.classList.toggle('hidden', !isFullscreen);

    // --- LÓGICA AÑADIDA ---
    if (isFullscreen) {
        // Al entrar en pantalla completa, calculamos y forzamos el nuevo tamaño.
        const newSize = subtitleFontSize + 26;
        subtitlePreviewText.style.fontSize = `${newSize}px`;
    } else {
        // Al salir, limpiamos el estilo para que vuelva a usar la regla normal.
        subtitlePreviewText.style.fontSize = ''; 
    }
}
// 2. "Escuchamos" todas las versiones del evento que usan los navegadores.
document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
document.addEventListener('mozfullscreenchange', handleFullscreenChange);
document.addEventListener('MSFullscreenChange', handleFullscreenChange);          
            // Language switcher events
            langEsBtn.addEventListener('click', () => setLanguage('es'));
            langEnBtn.addEventListener('click', () => setLanguage('en'));

            // Resizer logic
            const horizontalResizer = document.getElementById('horizontal-resizer');
            const videoSection = document.querySelector('.video-player-section');
            let isHorizontalResizing = false;
            horizontalResizer.addEventListener('mousedown', () => { isHorizontalResizing = true; document.body.style.cursor = 'col-resize'; });
            document.addEventListener('mousemove', (e) => { if (isHorizontalResizing) { const container = document.querySelector('.main-app-content'); const newVideoWidthPercent = ((e.clientX - container.getBoundingClientRect().left) / container.offsetWidth) * 100; if (newVideoWidthPercent > 20 && newVideoWidthPercent < 80) videoSection.style.flexBasis = `${newVideoWidthPercent}%`; } });
            document.addEventListener('mouseup', () => { isHorizontalResizing = false; document.body.style.cursor = ''; });
            
            // Backup Initialization
            try {
                const backup = await db.projects.get(1);
                if (backup) backupBtn.classList.add('animate-pulse-yellow');
            } catch (error) {
                console.error('Error checking initial backup:', error);
            }
            setInterval(saveBackup, 300000);

            backupBtn.addEventListener('click', async () => {
                const backup = await db.projects.get(1);
                if (backup) {
                    backupFileName.textContent = backup.fileName;
                    backupLastModified.textContent = new Date(backup.lastModified).toLocaleString();
                    backupFoundView.classList.remove('hidden');
                    noBackupFoundView.classList.add('hidden');
                } else {
                    backupFoundView.classList.add('hidden');
                    noBackupFoundView.classList.remove('hidden');
                }
                backupModal.classList.remove('hidden');
            });
            closeBackupModalBtn.addEventListener('click', () => backupModal.classList.add('hidden'));

confirmRestoreBtn.addEventListener('click', async () => {
                // Mensaje de confirmación añadido
                if (confirm(translations[currentLanguage]['confirm_restore_message'])) {
                    const backup = await db.projects.get(1);
                    if (backup) {
                        restoreProject(backup);
                        backupModal.classList.add('hidden');
                    }
                }
            });
      
            deleteBackupBtn.addEventListener('click', async () => {
                if (confirm(errorMessages[currentLanguage]['backup_deleted_confirmation'])) {
                    await db.projects.delete(1);
                    backupBtn.classList.remove('animate-pulse-yellow');
                    backupModal.classList.add('hidden');
                    showMessage(errorMessages[currentLanguage]['backup_deleted_message']);
                }
            });
            exportSrtFromBackupBtn.addEventListener('click', async () => {
                const backup = await db.projects.get(1);
                if (!backup) { showMessage(errorMessages[currentLanguage]['no_backup_to_export']); return; }
                try {
                    const srtContent = reconstructSrt(backup.srtEntries);
                    const newFileName = `${backup.fileName.replace(/\.srt$/i, '')}_recuperado_${new Date().toISOString().slice(0, 10)}.srt`;
                    const blob = new Blob([srtContent], { type: 'text/plain;charset=utf-8' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = newFileName;
                    a.click();
                    URL.revokeObjectURL(a.href);
                    showMessage(`${errorMessages[currentLanguage]['backup_export_success']}: "${newFileName}"`);
                } catch (error) {
                    showMessage(`${errorMessages[currentLanguage]['backup_export_error']}${error.message}`);
                }
            });

            // QA Modal Initialization
            qaBtn.addEventListener('click', () => {
                qaCpsLimitInput.value = qaSettings.cpsLimit;
                qaCharsPerLineLimitInput.value = qaSettings.charsPerLineLimit;
                qaModal.classList.remove('hidden');
            });
            closeQaModalBtn.addEventListener('click', () => qaModal.classList.add('hidden'));
            saveQaSettingsBtn.addEventListener('click', () => {
    // 1. Generamos el texto de la 'antigua' instrucción por defecto para comparar.
    const oldDefaultInstruction = translations[currentLanguage]['ai_default_instruction_1']
        .replace('{0}', qaSettings.charsPerLineLimit)
        .replace('{1}', qaSettings.cpsLimit);

    // 2. Comprobamos si la instrucción actual es la que está por defecto.
    const isUsingDefault = (aiCustomInstructions.instruction1 === oldDefaultInstruction);

    // 3. Actualizamos los ajustes de QA con los nuevos valores de los campos.
    qaSettings.cpsLimit = parseInt(qaCpsLimitInput.value, 10) || qaSettings.cpsLimit;
    qaSettings.charsPerLineLimit = parseInt(qaCharsPerLineLimitInput.value, 10) || qaSettings.charsPerLineLimit;

    // 4. Si se estaba usando la instrucción por defecto, la regeneramos y la guardamos.
    if (isUsingDefault) {
        const newDefaultInstruction = translations[currentLanguage]['ai_default_instruction_1']
            .replace('{0}', qaSettings.charsPerLineLimit)
            .replace('{1}', qaSettings.cpsLimit);

        aiCustomInstructions.instruction1 = newDefaultInstruction;
        saveAiCustomInstructions(); // Guardamos el cambio en la configuración de la IA
    }

    // 5. Ejecutamos el chequeo de QA y cerramos la ventana.
    runFullQaCheck();
    qaModal.classList.add('hidden');
});

            // QA Error List Modal Initialization
            qaErrorStats.addEventListener('click', () => {
                if (calculateAllQaErrors().length > 0) {
                    renderQaErrorList();
                    qaErrorListModal.classList.remove('hidden');
                }
            });
            closeQaErrorListModalBtn.addEventListener('click', () => qaErrorListModal.classList.add('hidden'));
            qaErrorListContainer.addEventListener('click', (event) => {
                const errorItem = event.target.closest('.qa-error-item');
                if (errorItem) {
                    navigateToTranslation(parseInt(errorItem.dataset.entryIndex, 10));
                    qaErrorListModal.classList.add('hidden');
                }
            });

            // Event listeners for TBX/TMX modals
            cancelSaveTbxBtn.addEventListener('click', () => {
                saveTbxModal.classList.add('hidden');
            });

            confirmSaveTbxBtn.addEventListener('click', () => {
                const filename = fileNameInputTbx.value;
                if (!filename) {
                    showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                    return;
                }
                showLoadingOverlay(errorMessages[currentLanguage]['saving_file']);
                try {
                    const tbxContent = generateTBX();
                    const blob = new Blob([tbxContent], { type: "application/xml" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = filename.endsWith('.tbx') ? filename : filename + '.tbx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showMessage(errorMessages[currentLanguage]['file_saved_successfully_tbx']);
                } catch (error) {
                    showMessage(`${errorMessages[currentLanguage]['error_saving_file']} ${error.message}`);
                    console.error("Error downloading TBX:", error);
                } finally {
                    hideLoadingOverlay();
                    saveTbxModal.classList.add('hidden');
                }
            });

            cancelSaveTmxBtn.addEventListener('click', () => {
                saveTmxModal.classList.add('hidden');
            });

            confirmSaveTmxBtn.addEventListener('click', () => {
                const filename = fileNameInputTmx.value;
                if (!filename) {
                    showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                    return;
                }
                showLoadingOverlay(errorMessages[currentLanguage]['saving_file']);
                try {
                    const tmxContent = generateTMX();
                    if (!tmxContent) return;
                    const blob = new Blob([tmxContent], { type: "application/xml" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = filename.endsWith('.tmx') ? filename : filename + '.tmx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showMessage(errorMessages[currentLanguage]['file_saved_successfully_tmx']);
                } catch (error) {
                    showMessage(`${errorMessages[currentLanguage]['error_saving_file']} ${error.message}`);
                    console.error("Error downloading TMX:", error);
                } finally {
                    hideLoadingOverlay();
                    saveTmxModal.classList.add('hidden');
                }
            });

            // Project Save/Load Listeners
            newProjectBtn.addEventListener('click', () => {
                if (srtEntries.length > 0) {
                    confirmNewProjectModal.classList.remove('hidden');
                } else {
                    resetApplicationState();
                }
            });

// --- Timecode Modal Listeners ---
            const timecodeModal = document.getElementById('timecodeModal');
            const timecodeSettingsBtn = document.getElementById('timecodeSettingsBtn');
            const closeTimecodeModalBtn = document.getElementById('closeTimecodeModalBtn');
            const saveTimecodeSettingsBtn = document.getElementById('saveTimecodeSettingsBtn');
            const projectFpsInput = document.getElementById('projectFpsInput');
            const useFrameTimecodeToggle = document.getElementById('useFrameTimecodeToggle');

            timecodeSettingsBtn.addEventListener('click', () => {
                // Cargar valores actuales en el modal
                projectFpsInput.value = projectFPS;
                useFrameTimecodeToggle.checked = useFrameTimecode;
                timecodeModal.classList.remove('hidden');
            });

            closeTimecodeModalBtn.addEventListener('click', () => {
                timecodeModal.classList.add('hidden');
            });

            saveTimecodeSettingsBtn.addEventListener('click', () => {
                // Guardar nuevos valores
                const newFPS = parseFloat(projectFpsInput.value);
                projectFPS = isNaN(newFPS) || newFPS <= 0 ? 25 : newFPS;
                useFrameTimecode = useFrameTimecodeToggle.checked;

                // Actualizar el placeholder del panel "Ir a..."
                if (useFrameTimecode) {
                    goToTimecodeInput.value = formatFrameTime(0, projectFPS);
                } else {
                    goToTimecodeInput.value = formatTime(0);
                }
                
                // Refrescar la lista de traducción para mostrar el nuevo formato
                renderTranslations(srtEntries, lastActiveSubtitleIndex, true);
                
                timecodeModal.classList.add('hidden');
            });

// --- Lógica de importación de contexto ---
const contextFileInput = document.getElementById('contextFileInput');
const importFromPasteBtn = document.getElementById('importFromPasteBtn');
const contextPasteArea = document.getElementById('contextPasteArea');

contextFileInput.addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    showLoadingOverlay(translations[currentLanguage]['loading_file']);
    try {
        const content = await file.text();
        const parsedContext = JSON.parse(content);
        processAndApplyContext(parsedContext);
    } catch (error) {
        showMessage(`Error: ${error.message}`);
        console.error(error);
    } finally {
        hideLoadingOverlay();
        event.target.value = ''; // Resetea el input
    }
});

importFromPasteBtn.addEventListener('click', () => {
    const content = contextPasteArea.value;
    if (!content.trim()) {
        showMessage("El área de texto está vacía.");
        return;
    }
    showLoadingOverlay("Procesando contexto...");
    try {
        const parsedContext = JSON.parse(content);
        processAndApplyContext(parsedContext);
    } catch (error) {
        showMessage(`Error en el JSON: ${error.message}`);
        console.error(error);
    } finally {
        hideLoadingOverlay();
    }
});

    saveProjectBtn.addEventListener('click', () => {
                if (srtEntries.length === 0) {
                    showMessage(errorMessages[currentLanguage]['no_project_to_save']);
                    return;
                }
                // Sugiere un nombre de archivo basado en el SRT actual
                projectFileNameInput.value = currentFileName.replace(/\.[^/.]+$/, '');
                saveProjectModal.classList.remove('hidden');
                projectFileNameInput.focus();
            });

 confirmSaveProjectBtn.addEventListener('click', () => {
                const filename = projectFileNameInput.value.trim();
                if (!filename) {
                    showMessage(errorMessages[currentLanguage]['please_enter_filename']);
                    return;
                }
                saveProject(filename); // Llama a la función de guardado con el nuevo nombre
                saveProjectModal.classList.add('hidden');
            });

            cancelSaveProjectBtn.addEventListener('click', () => {
                saveProjectModal.classList.add('hidden');
                afterSaveAction = null; // Cancela cualquier acción pendiente
            });

            projectFile.addEventListener('change', loadProject);
resetAppBtn.addEventListener('click', resetApplicationCache);            

            // TMX File Input Listener
            tmFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    loadTMX(file);
                }
                event.target.value = ''; // Reset input
            });

            // New Project Confirmation Modal Listeners
            cancelNewProjectBtn.addEventListener('click', () => {
                confirmNewProjectModal.classList.add('hidden');
            });
            continueWithoutSavingBtn.addEventListener('click', () => {
                resetApplicationState();
            });
saveAndContinueBtn.addEventListener('click', () => {
                confirmNewProjectModal.classList.add('hidden');
                // Define la acción a ejecutar después de guardar
                afterSaveAction = resetApplicationState;
                // Dispara el clic en el botón de guardar para abrir el modal
                saveProjectBtn.click();
            });

const copyPromptBtn = document.getElementById('copyPromptBtn');
const pasteJsonBtn = document.getElementById('pasteJsonBtn');

copyPromptBtn.addEventListener('click', copyAIPrompt);
pasteJsonBtn.addEventListener('click', pasteJsonFromClipboard);
contextPasteArea.addEventListener('input', validateJsonInTextarea);


      reselectVideoInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
              if (file) {
        videoFileName = file.name;
        const videoURL = URL.createObjectURL(file); // <-- CORREGIDO: Creada ANTES
        videoPlayer.src = videoURL; // <-- CORREGIDO: Mover src aquí también
        wavesurfer.load(videoURL); // <-- Ahora videoURL existe
        document.getElementById('waveform').classList.remove('hidden');
        videoPlayer.controls = true;
                    videoPlayer.load();
                                
                    document.getElementById('videoLogoPlaceholder').classList.add('hidden');
            
                    const loadVideoBtnSpan = document.querySelector('#loadVideoBtn span');
                    if (loadVideoBtnSpan) {
                        loadVideoBtnSpan.textContent = translations[currentLanguage]['change_video'];
                    }
                    reselectVideoModal.classList.add('hidden');
                }
            });

            skipReselectVideoBtn.addEventListener('click', () => {
                reselectVideoModal.classList.add('hidden');
            });

            // Lógica para los modales de confirmación de reseteo
            confirmResetGlossaryBtn.addEventListener('click', () => {
                resetGlossary();
                confirmResetGlossaryModal.classList.add('hidden');
            });

            cancelResetGlossaryBtn.addEventListener('click', () => {
                confirmResetGlossaryModal.classList.add('hidden');
            });

            confirmResetTmBtn.addEventListener('click', () => {
                resetTM();
                confirmResetTmModal.classList.add('hidden');
            });

             cancelResetTmBtn.addEventListener('click', () => {
                confirmResetTmModal.classList.add('hidden');
            });

        // Funciones para mostrar los modales de confirmación
        function showConfirmResetGlossary() {
            if (glossary.length === 0) {
                resetGlossary();
                return;
            }
            confirmResetGlossaryModal.classList.remove('hidden');
        }

       function showConfirmResetTm() {
            if (translationMemory.length === 0) {
                resetTM();
                return;
            }
            confirmResetTmModal.classList.remove('hidden');
        }

// --- Lógica para el modal de Ajustes de IA ---
const aiSettingsModal = document.getElementById('aiSettingsModal');
const aiSettingsBtn = document.getElementById('aiSettingsBtn');
const closeAiSettingsModalBtn = document.getElementById('closeAiSettingsModalBtn');
const saveAiSettingsBtn = document.getElementById('saveAiSettingsBtn');
const aiInstruction1 = document.getElementById('aiInstruction1');
const aiInstruction2 = document.getElementById('aiInstruction2');
const aiInstruction3 = document.getElementById('aiInstruction3');

aiSettingsBtn.addEventListener('click', () => {
    // Carga las instrucciones actuales en los campos de texto
    aiInstruction1.value = aiCustomInstructions.instruction1;
    aiInstruction2.value = aiCustomInstructions.instruction2;
    aiInstruction3.value = aiCustomInstructions.instruction3;
    aiSettingsModal.classList.remove('hidden');
});

closeAiSettingsModalBtn.addEventListener('click', () => {
    aiSettingsModal.classList.add('hidden');
});

saveAiSettingsBtn.addEventListener('click', () => {
    const defaultInstruction = translations[currentLanguage]['ai_default_instruction_1']
        .replace('{0}', qaSettings.charsPerLineLimit)
        .replace('{1}', qaSettings.cpsLimit);

    // Guarda los nuevos valores
    aiCustomInstructions.instruction1 = aiInstruction1.value.trim() || defaultInstruction;
    aiCustomInstructions.instruction2 = aiInstruction2.value.trim();
    aiCustomInstructions.instruction3 = aiInstruction3.value.trim();
    saveAiCustomInstructions();
    aiSettingsModal.classList.add('hidden');
    showMessage("Ajustes de la IA guardados.");
});

if (contextHelpHeader && contextHelpContent) {
                contextHelpHeader.addEventListener('click', () => {
                    const isCollapsed = contextHelpContent.classList.contains('collapsed');
                    const icon = contextHelpHeader.querySelector('.accordion-icon');
                    if (isCollapsed) {
                        contextHelpContent.classList.remove('collapsed');
                        contextHelpContent.classList.add('expanded');
                        if (icon) icon.classList.add('rotated');
                    } else {
                        contextHelpContent.classList.remove('expanded');
                        contextHelpContent.classList.add('collapsed');
                        if (icon) icon.classList.remove('rotated');
                    }
                });
            }

// --- INICIO: Listeners para la botonera de la onda ---
        lockWaveformBtn.addEventListener('click', toggleWaveformLock);
        zoomInBtn.addEventListener('click', () => zoomWaveform(1));
        zoomOutBtn.addEventListener('click', () => zoomWaveform(-1));
        // --- FIN: Listeners para la botonera de la onda ---

// --- INICIO: Listener para botón de seguimiento ---
followPlaybackBtn.addEventListener('click', () => {
    isFollowPlaybackActive = !isFollowPlaybackActive;
    followPlaybackBtn.classList.toggle('active', isFollowPlaybackActive); // Usa la clase 'active' genérica
    followPlaybackBtn.title = isFollowPlaybackActive
        ? translations[currentLanguage]['follow_playback_off']
        : translations[currentLanguage]['follow_playback_on'];

    // Si se acaba de desactivar, limpia los resaltados
    if (!isFollowPlaybackActive) {
        clearPlaybackHighlights();
        currentlyTrackedRegionId = null;
        currentlyTrackedEditorIndex = -1;
    } else {
         handlePlaybackTracking(); // Intenta resaltar inmediatamente si se activa
    }
});
// --- FIN: Listener para botón de seguimiento ---

const statusBar = document.getElementById('statusBar');
    const toggleStatusBarBtn = document.getElementById('toggleStatusBarBtn');

// --- INICIO: MODIFICAR ESTE BLOQUE (Lógica de la Barra de Estado) ---
        if (statusBar && toggleStatusBarBtn) {
            // Comprueba el estado guardado al cargar la página
            const savedState = localStorage.getItem('statusBarVisible') === 'true';
            let textKey = 'show_status_bar_btn'; // Texto por defecto

            if (savedState) {
                statusBar.classList.add('is-visible');
                document.body.classList.add('status-bar-visible'); // Mantenemos esto por si acaso, aunque no afecte visualmente ahora
                textKey = 'hide_status_bar_btn'; // Texto si está visible
            }
            // Establecemos el atributo i18n para que se actualice con el idioma
            const buttonSpan = toggleStatusBarBtn.querySelector('span'); // Guardamos el span en una variable
            if (buttonSpan) { // Comprobamos si el span existe
                 buttonSpan.setAttribute('data-i18n', textKey);
                 // Añadimos esta línea para asegurar que el texto se actualice al cargar
                 buttonSpan.textContent = translations[currentLanguage][textKey];
            }


            // Listener del botón
            toggleStatusBarBtn.addEventListener('click', () => {
                // Añadimos un console.log para depurar
                console.log("Botón de barra de estado pulsado. Estado actual:", statusBar.classList.contains('is-visible'));

                const isVisible = statusBar.classList.toggle('is-visible');
                document.body.classList.toggle('status-bar-visible', isVisible);

                // Actualiza el texto del botón y el atributo i18n
                const newTextKey = isVisible ? 'hide_status_bar_btn' : 'show_status_bar_btn';
                if (buttonSpan) { // Usamos la variable guardada
                    buttonSpan.textContent = translations[currentLanguage][newTextKey];
                    buttonSpan.setAttribute('data-i18n', newTextKey);
                }

                // Guardar el estado en el navegador
                localStorage.setItem('statusBarVisible', isVisible);

                // Añadimos otro console.log para ver el estado después del toggle
                console.log("Nuevo estado:", isVisible);
            });
        } else {
             // Añadimos un log si los elementos no se encuentran
             console.error("Error: No se encontró statusBar o toggleStatusBarBtn.");
        }
        // --- FIN: MODIFICAR ESTE BLOQUE ---

// --- INICIO: NUEVO ESCUCHA GLOBAL DE ATAJOS DE TECLADO ---
document.addEventListener('keydown', (event) => {
    const activeElement = document.activeElement;
    const isTypingInInput = activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable;

    // --- Lógica para Atajos de Documentación ---
    const triggeredDocAction = shortcuts.docResources.find(res => {
        if (!res.shortcut) return false;
        const sc = res.shortcut;
        const keyMatch = (sc.key === ' ' && event.code === 'Space') || (sc.key.toLowerCase() === event.key.toLowerCase());
        return keyMatch &&
               sc.ctrlKey === event.ctrlKey &&
               sc.metaKey === event.metaKey &&
               sc.altKey === event.altKey &&
               sc.shiftKey === event.shiftKey;
    });

    if (triggeredDocAction) {
        event.preventDefault();
        const selectedText = window.getSelection().toString().trim();
        const resourceUrl = triggeredDocAction.url;
        if (selectedText && resourceUrl && resourceUrl.includes('{word}')) {
            const finalUrl = resourceUrl.replace('{word}', encodeURIComponent(selectedText));
            window.open(finalUrl, '_blank');
        }
        return;
    }
    
    if (isTypingInInput) {
        return;
    }

    // --- Lógica para Atajos Globales (SOLO VÍDEO) ---
    const globalActions = [
        'jumpToTime', 'playSegment', 'playSegmentLoop', 'playPause', 
        'seekForward', 'seekBackward', 'seekForwardFast', 'seekBackwardFast'
    ];
    
    const triggeredGlobalAction = Object.keys(shortcuts).find(action => {
        if (!globalActions.includes(action)) return false;
        const shortcut = shortcuts[action];
        const keyMatch = (shortcut.key === ' ' && event.code === 'Space') || (shortcut.key.toLowerCase() === event.key.toLowerCase());
        return keyMatch &&
               shortcut.ctrlKey === event.ctrlKey &&
               shortcut.metaKey === event.metaKey &&
               shortcut.altKey === event.altKey &&
               shortcut.shiftKey === event.shiftKey;
    });

    if (triggeredGlobalAction) {
        event.preventDefault();
        switch (triggeredGlobalAction) {
            case 'jumpToTime':
            case 'playSegment':
                jumpToCurrentSubtitleTime(lastActiveSubtitleIndex);
                break;
            case 'playSegmentLoop':
                playSubtitleLoop(lastActiveSubtitleIndex);
                break;
            case 'playPause':
                if (videoPlayer.paused) videoPlayer.play();
                else videoPlayer.pause();
                break;
            case 'seekForward':
                videoPlayer.currentTime += 3;
                break;
            case 'seekBackward':
                videoPlayer.currentTime -= 3;
                break;
            case 'seekForwardFast':
                videoPlayer.currentTime += 5;
                break;
            case 'seekBackwardFast':
                videoPlayer.currentTime -= 5;
                break;
        }
    }
});
// --- FIN: NUEVO ESCUCHA GLOBAL DE ATAJOS DE TECLADO ---
   
followPlaybackBtn.title = translations[currentLanguage]['follow_playback_on'];
    });

   
</script>
<div id="statusBar"></div>
</body>
</html>
