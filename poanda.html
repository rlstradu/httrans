<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">Poanda</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos generales para el cuerpo y la fuente */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Fondo para modo claro */
            color: #202020; /* Color de texto general para modo claro */
            transition: background-color 0.3s ease, color 0.3s ease; /* Transiciones suaves */
        }
        /* Permite redimensionar verticalmente las áreas de texto */
        textarea {
            resize: vertical;
            overflow-y: hidden; /* Oculta el scrollbar inicial, se maneja con auto-redimensionado */
        }
        /* Asegura que el texto preformateado respete los saltos de línea y no desborde */
        pre {
            white-space: pre-wrap;
            overflow-wrap: break-word; /* Evita la división de palabras, ajustando el texto de forma más natural */
        }
        /* Estilo para el icono de check (SVG) */
        .check-icon {
            display: none; /* Oculto por defecto */
            margin-left: 8px; /* Espacio a la izquierda del icono */
            vertical-align: middle; /* Alineación vertical */
            width: 20px; /* Ancho del icono */
            height: 20px; /* Altura del icono */
            color: #22c55e; /* Color verde para el check */
        }

        /* Estilos de los botones con efectos hover */
        .btn-load {
            background-color: #f48790;
            color: #000;
        }
        .btn-load:hover {
            background-color: #e07a82;
            transform: scale(1.02);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn-save {
            background-color: #f7cf7e;
            color: #000;
        }
        .btn-save:hover {
            background-color: #e3b76e;
            transform: scale(1.02);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Color del botón Validar */
        .btn-validate {
            background-color: #f7cf7e;
            color: #000;
        }
        .btn-validate:hover {
            background-color: #e3b76e;
            transform: scale(1.02);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Color del botón Editar (Edit) */
        .btn-edit {
            background-color: #f48790;
            color: #000;
        }
        .btn-edit:hover {
            background-color: #e07a82;
            transform: scale(1.02);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Estilos específicos para los campos de visualización de código (msgid, msgctxt) */
        .po-display-code {
            background-color: #e3e3e3; /* Fondo gris claro */
            border: 1px solid #000; /* Borde negro */
            color: #202020; /* Texto negro oscuro */
        }
        /* El textarea msgstr siempre tendrá fondo blanco y texto negro */
        .msgstr-textarea {
            background-color: #ffffff; /* Fondo blanco */
            color: #000000; /* Texto negro */
            min-height: 80px; /* Altura mínima por defecto para los campos de traducción */
        }

        /* Fondo de las unidades de traducción en modo claro */
        .translation-unit-bg {
            background-color: #f8f8f8; /* Fondo muy claro para el contenedor de unidades de traducción */
            border-color: #e5e7eb; /* Borde claro */
        }

        /* Ajustes de color de texto para asegurar contraste en modo claro */
        .text-on-light-contrast {
            color: #202020; /* Negro oscuro para texto sobre fondos claros */
        }

        /* Clases para el layout de 2 columnas */
        .translation-row {
            display: flex;
            flex-direction: column; /* Por defecto en móvil: columna */
            gap: 1rem; /* Espacio entre columnas/filas */
        }

        @media (min-width: 768px) { /* A partir de md (768px) */
            .translation-row {
                flex-direction: row; /* En desktop: fila */
            }
            .original-col, .translation-col { /* Ambas columnas tienen el mismo ancho */
                flex: 1; /* Ocupan la misma proporción del espacio disponible */
            }
        }

        /* Estilos para el pop-up (modal) */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            width: 500px; /* Default width for message/shortcuts modal */
        }

        /* Specific width for findReplaceModal to accommodate text on one line */
        #findReplaceModal .modal-content {
            width: 650px; /* Increased width to prevent text wrapping */
            max-width: 95%; /* Ensure it doesn't overflow on smaller screens */
        }
        .shortcut-icon {
            display: inline-block;
            width: 1em; /* Adjust size as needed */
            height: 1em;
            vertical-align: middle;
            margin: 0 4px;
        }

        /* Main layout container for editor and terminology sidebar */
        .main-editor-layout {
            display: flex;
            flex-direction: column; /* Default to column on small screens */
            gap: 1rem; /* Espacio entre editor y barra lateral */
            width: 100%;
        }

        @media (min-width: 1024px) { /* On large screens, switch to row layout */
            .main-editor-layout {
                flex-direction: row;
                gap: 1rem; /* Apply gap universally on large screens */
            }
            .editor-main-content {
                flex: 2; /* Main editor takes 2/3 width or 2/4 total when both sidebars are visible */
            }
            /* Sidebar widths */
            .terminology-sidebar, .translation-memory-sidebar {
                min-width: 300px;
                max-width: 400px;
            }
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .sidebar-content {
            max-height: calc(100vh - 200px); /* Adjust based on header/footer */
            overflow-y: auto;
            padding-right: 0.5rem; /* For scrollbar space */
        }

        /* Styles for glossary specific inputs and buttons within sidebar */
        .glossary-input-group label, .tm-input-group label {
            white-space: nowrap;
        }
        .glossary-input-group input, .glossary-input-group select,
        .tm-input-group input, .tm-input-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9rem;
            margin-top: 4px;
            color: #202020;
            background-color: #fff;
        }
        .glossary-btn-primary, .tm-btn-primary {
            background-color: #007bff;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        .glossary-btn-primary:hover, .tm-btn-primary:hover {
            background-color: #0056b3;
        }
        .glossary-btn-secondary, .tm-btn-secondary {
            background-color: #e0e0e0;
            color: #333;
            padding: 8px 15px;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        .glossary-btn-secondary:hover, .tm-btn-secondary:hover {
            background-color: #d0d0d0;
        }
        .glossary-delete-btn, .tm-delete-btn {
            background-color: #f44336;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
        }
        .glossary-delete-btn:hover, .tm-delete-btn:hover {
            background-color: #da190b;
        }
        .glossary-table th, .glossary-table td, .tm-table th, .tm-table td {
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            font-size: 0.9rem;
        }
        .glossary-table th, .tm-table th {
            background-color: #f0f0f0;
            font-weight: 600;
        }
        .glossary-info-box, .tm-info-box {
            background-color: #f0f8ff;
            border: 1px solid #d0e8f8;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            color: #333;
        }

        /* Glossary Highlight for text and rows */
        .glossary-highlight {
            background-color: #ffcc00; /* Yellow highlight for text */
            padding: 0 2px;
            border-radius: 3px;
        }

        .glossary-row-highlight {
            background-color: #ffcc00 !important; /* Yellow highlight for glossary table rows */
            transition: background-color 0.3s ease;
        }

        /* Active translation unit highlight */
        .translation-unit-active {
            border: 2px solid #3b82f6; /* Blue border for active unit */
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25); /* Light blue glow */
        }

        /* Loading Overlay Styles */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* Above modals */
            font-size: 1.2rem;
            color: #333;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Accordion styles */
        .accordion-item {
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            overflow: hidden;
            margin-bottom: 1rem;
        }
        .accordion-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 0.75rem 1rem;
            background-color: #f9fafb; /* Light background for header */
            border-bottom: 1px solid #e5e7eb;
            user-select: none; /* Prevent text selection on double click */
        }

        .accordion-header:hover {
            background-color: #f3f4f6;
            color: #3b82f6; /* Tailwind blue-500 */
        }

        .accordion-icon {
            transition: transform 0.3s ease;
        }

        .accordion-icon.rotated {
            transform: rotate(180deg);
        }

        .accordion-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0 1rem; /* Adjust padding for collapsed state */
        }
        .accordion-content.collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        .accordion-content.expanded {
            max-height: 500px; /* Sufficiently large value to show all content */
            padding-top: 1rem; /* Restore padding when expanded */
            padding-bottom: 1rem;
        }

        /* TM Search Results Table Column Widths */
        .tm-table th:nth-child(1), .tm-table td:nth-child(1) {
            width: 10%; /* Percentage column narrower */
            max-width: 60px; /* Max width to ensure it doesn't get too wide */
            text-align: center;
        }
        .tm-table th:nth-child(2), .tm-table td:nth-child(2) {
            width: 45%; /* Original column */
        }
        .tm-table th:nth-child(3), .tm-table td:nth-child(3) {
            width: 45%; /* Translation column */
        }

        /* Highlight for active TM match in table */
        .tm-best-match-highlight {
            background-color: #d1fae5 !important; /* Light green */
            border-color: #10b981 !important; /* Emerald-500 */
            border-width: 2px;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.25); /* Light green glow */
        }

        /* Fixed width for dropArea - always 90% */
        #dropArea {
            width: 100%; /* Ensure it always tries to take full width */
            max-width: 90%; /* Fixed max-width at 90% */
            transition: none; /* No transition as width is fixed now */
        }

        /* Floating Sidebars - Always visible, controlled by transform */
        .terminology-sidebar, .translation-memory-sidebar {
            position: fixed;
            top: 60px; /* Adjust as needed, e.g., below your header bar */
            bottom: 20px;
            width: 350px; /* Increased default width for sidebars */
            z-index: 500;
            background-color: #fff;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out, width 0.3s ease-in-out; /* Add width to transition */
            opacity: 0; /* Hidden by default */
            pointer-events: none; /* No interaction when hidden */
            resize: horizontal; /* Enable horizontal resizing */
            overflow: auto; /* Allow scrolling if content overflows during resize */
            min-width: 300px; /* Minimum width for resizing */
            max-width: 600px; /* Maximum width for resizing */
        }

        .terminology-sidebar {
            left: 1rem; /* Position on the left with some margin */
            transform: translateX(-100%); /* Start completely off-screen to the left */
        }
        .terminology-sidebar.show-sidebar {
            transform: translateX(0); /* Slide into view */
            opacity: 1;
            pointer-events: all;
        }

        .translation-memory-sidebar {
            right: 1rem; /* Position on the right with some margin */
            transform: translateX(100%); /* Start completely off-screen to the right */
        }
        .translation-memory-sidebar.show-sidebar {
            transform: translateX(0); /* Slide into view */
            opacity: 1;
            pointer-events: all;
        }

        /* Adjust padding of main content when sidebars are open */
        .editor-main-content {
            padding-left: 1rem; /* Default padding */
            padding-right: 1rem; /* Default padding */
            transition: padding-left 0.3s ease-in-out, padding-right 0.3s ease-in-out;
            /* Keep max-height and overflow-y as before */
            max-height: 70vh;
            overflow-y: auto;
        }

        @media (min-width: 1024px) { /* Apply padding adjustments only on larger screens */
            .editor-main-content.left-sidebar-active {
                padding-left: calc(var(--terminology-sidebar-width, 350px) + 2rem); /* Use CSS variable for dynamic padding */
            }
            .editor-main-content.right-sidebar-active {
                padding-right: calc(var(--translation-memory-sidebar-width, 350px) + 2rem); /* Use CSS variable for dynamic padding */
            }
        }

        /* Text size for main content divs */
        .po-display-code, .msgstr-textarea {
            font-size: 1rem; /* text-base */
        }

        /* Centering the top utility buttons */
        .top-utility-buttons-container {
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem; /* space-x-3 */
            /* Ensure it can grow if needed, or enforce a min-width to prevent wrapping */
            min-width: 400px; /* Example: adjust this based on desired button spacing and text length */
        }
        /* Style for the actual buttons within the container, reducing font size */
        .top-utility-buttons-container button {
            font-size: 0.875rem; /* text-sm, to help fit text on one line */
            white-space: nowrap; /* Prevent text from wrapping inside buttons */
            padding-left: 0.75rem; /* px-3 */
            padding-right: 0.75rem; /* px-3 */
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">
    <div class="bg-white p-8 rounded-lg shadow-xl w-full relative mb-4" id="dropArea">
        <!-- Top Utility Buttons (Shortcuts, Find/Replace, Terminolo, Translation Memory) -->
        <div class="top-utility-buttons-container">
            <button id="shortcutsBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="shortcuts_btn" id="shortcutsBtnText">Atajos</span>
            </button>
            <button id="findReplaceBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="find_replace_btn" id="findReplaceBtnText">Buscar y reemplazar</span>
            </button>
            <button id="terminologyBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="terminology_btn" id="terminologyBtnText">Terminología</span>
            </button>
            <button id="tmBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="tm_btn" id="tmBtnText">Memoria de traducción</span>
            </button>
        </div>
        <!-- Removed Language Buttons -->

        <div class="flex flex-col items-center mb-6 mt-12">
            <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/poanda-logo-final.png" alt="Poanda Logo" class="max-w-xs h-auto mb-2">
            <div data-i18n="tool_description" id="toolDescription" class="text-lg text-center text-on-light-contrast">
                Una herramienta sencilla para editar archivos .po.
            </div>
        </div>

        <!-- Main file controls: Load and Save .po -->
        <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mb-6">
            <label for="poFile" class="block font-medium cursor-pointer py-2 px-4 rounded-md shadow-sm transition duration-300 btn-load">
                <span data-i18n="load_file" id="loadBtnText">Cargar archivo .po</span>
                <input type="file" id="poFile" accept=".po" class="hidden">
            </label>
            <button id="savePo" class="font-medium py-2 px-4 rounded-md shadow-sm transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed btn-save" disabled>
                <span data-i18n="save_file" id="saveBtnText">Guardar archivo .po</span>
            </button>
        </div>

        <!-- Main Editor Layout (Translation content + Terminology Sidebar + Translation Memory Sidebar) -->
        <div class="main-editor-layout" id="mainEditorLayout">
            <!-- Translation Content (Left Column) -->
            <div class="editor-main-content space-y-4 max-h-[70vh] overflow-y-auto pr-2" id="editorMainContent">
                <div id="translationsContainer">
                    <!-- Translations will be rendered here -->
                    <div data-i18n="no_translations" id="initialMessage" class="text-center text-on-light-contrast p-4 border border-gray-300 rounded-md">
                        Carga un archivo .po para empezar a editar.
                    </div>
                </div>
            </div>

            <!-- Terminology Sidebar (Left Floating) -->
            <div id="terminologySidebar" class="terminology-sidebar p-4 border border-gray-300 rounded-lg shadow-md">
                <div class="sidebar-header">
                    <h3 class="text-lg font-bold text-on-light-contrast" data-i18n="terminology_sidebar_title" id="terminologySidebarTitle">Terminología</h3>
                    <button id="closeTerminologySidebarBtn" class="text-gray-500 hover:text-gray-700">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <div class="sidebar-content">
                    <!-- Language Configuration Section -->
                    <div id="terminologyLanguageConfigSection" class="space-y-4">
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="config_lang_title" id="configLangTitle">Configurar idiomas del glosario</h4>
                        <div class="glossary-info-box mb-4">
                            <p data-i18n="config_lang_info" id="configLangInfo"></p>
                        </div>
                        <div class="flex flex-col space-y-2 mb-4">
                            <div class="glossary-input-group">
                                <label for="configSrcLang" data-i18n="source_language" id="sourceLanguageLabel">Idioma de origen:</label>
                                <input id="configSrcLang" list="isoLanguages" value="en-US" class="block w-full" />
                            </div>
                            <div class="glossary-input-group">
                                <label for="configTgtLang" data-i18n="target_language" id="targetLanguageLabel">Idioma de destino:</label>
                                <input id="configTgtLang" list="isoLanguages" value="es-ES" class="block w-full" />
                            </div>
                            <button onclick="confirmGlossaryLanguages()" data-i18n="confirm_languages" id="confirmLanguagesBtn" class="glossary-btn-primary w-full">Confirmar idiomas</button>
                        </div>
                    </div>

                    <!-- Terminology Editor Section (Initially hidden) -->
                    <div id="terminologyEditorSection" style="display:none;">
                        <!-- Buttons: Import, Download, New Glossary -->
                        <div class="flex flex-col sm:flex-row gap-2 mb-4">
                            <button onclick="loadTBX()" data-i18n="import_tbx" id="importTbxBtn" class="glossary-btn-secondary flex-1 text-sm py-2 px-2">Importar TBX</button>
                            <input type="file" id="tbxFileInput" accept=".xml,.tbx" class="hidden" />
                            <button onclick="downloadTBX()" data-i18n="download_tbx" id="downloadTbxBtn" class="glossary-btn-secondary flex-1 text-sm py-2 px-2">Descargar TBX</button>
                            <button onclick="resetGlossary()" data-i18n="new_glossary" id="newGlossaryBtn" class="glossary-btn-secondary flex-1 text-sm py-2 px-2">Nuevo glosario</button>
                        </div>


                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="current_lang_title" id="currentLangTitle">Idiomas actuales del glosario</h4>
                        <div class="flex space-x-2 mb-4">
                            <div class="glossary-input-group flex-1">
                                <label data-i18n="source_language">Idioma de origen:</label>
                                <input id="displaySrcLang" disabled class="block w-full" />
                            </div>
                            <div class="glossary-input-group flex-1">
                                <label data-i18n="target_language">Idioma de destino:</label>
                                <input id="displayTgtLang" disabled class="block w-full" />
                            </div>
                        </div>

                        <!-- Add Term Accordion -->
                        <div class="accordion-item">
                            <div class="accordion-header flex justify-between items-center" id="addTermHeader">
                                <h4 class="text-md font-semibold text-on-light-contrast m-0" data-i18n="add_term_title" id="addTermTitleAccordion">Añadir término</h4>
                                <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </div>
                            <div class="accordion-content collapsed" id="addTermContent"> <!-- Changed to 'collapsed' by default -->
                                <div class="flex flex-col space-y-2 mb-4">
                                    <div class="glossary-input-group">
                                        <label for="srcTerm" data-i18n="term" id="termLabel">Término:</label>
                                        <input id="srcTerm" class="block w-full" />
                                    </div>
                                    <div class="glossary-input-group">
                                        <label for="tgtTerm" data-i18n="translation" id="translationLabel">Traducción:</label>
                                        <input id="tgtTerm" class="block w-full" />
                                    </div>
                                    <button onclick="addTerm()" data-i18n="add_button" id="addTermBtn" class="glossary-btn-primary w-full">Añadir</button>
                                </div>
                            </div>
                        </div>
                        <!-- End Add Term Accordion -->

                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="search_title" id="searchTitle">Buscar</h4>
                        <div class="mb-4">
                            <input id="searchTerm" data-i18n-placeholder="search_placeholder" class="block w-full" oninput="renderGlossary()" />
                        </div>

                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="glossary_list_title" id="glossaryListTitle">Glosario</h4>
                        <div class="overflow-x-auto">
                            <table class="glossary-table w-full">
                                <thead>
                                    <tr>
                                        <th data-i18n="source_term_col" id="sourceTermCol">Término de origen</th>
                                        <th data-i18n="target_term_col" id="targetTermCol">Término de destino</th>
                                        <th data-i18n="actions_col" id="actionsCol">Acciones</th>
                                    </tr>
                                </thead>
                                <tbody id="glossaryTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
                <datalist id="isoLanguages"></datalist>
            </div>

            <!-- Translation Memory Sidebar (Right Floating) -->
            <div id="translationMemorySidebar" class="translation-memory-sidebar p-4 border border-gray-300 rounded-lg shadow-md">
                <div class="sidebar-header">
                    <h3 class="text-lg font-bold text-on-light-contrast" data-i18n="tm_sidebar_title" id="tmSidebarTitle">Memoria de Traducción (TM)</h3>
                    <button id="closeTranslationMemorySidebarBtn" class="text-gray-500 hover:text-gray-700">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <div class="sidebar-content">
                    <!-- Internal TM message display -->
                    <div id="tmInternalMessage" class="tm-info-box mb-4 hidden"></div>

                    <!-- Language Configuration Section for TM -->
                    <div id="tmLanguageConfigSection" class="space-y-4">
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="tm_config_lang_title" id="tmConfigLangTitle">Configurar idiomas de la TM</h4>
                        <div class="tm-info-box mb-4">
                            <p data-i18n="tm_config_lang_info" id="tmConfigLangInfo"></p>
                        </div>
                        <div class="flex flex-col space-y-2 mb-4">
                            <div class="tm-input-group">
                                <label for="tmConfigSrcLang" data-i18n="source_language" id="tmSourceLanguageLabel">Idioma de origen:</label>
                                <input id="tmConfigSrcLang" list="isoLanguages" value="en-US" class="block w-full" />
                            </div>
                            <div class="tm-input-group">
                                <label for="tmConfigTgtLang" data-i18n="target_language" id="tmTargetLanguageLabel">Idioma de destino:</label>
                                <input id="tmConfigTgtLang" list="isoLanguages" value="es-ES" class="block w-full" />
                            </div>
                            <button onclick="confirmTMLanguages()" data-i18n="confirm_languages" id="tmConfirmLanguagesBtn" class="tm-btn-primary w-full">Confirmar idiomas</button>
                        </div>
                    </div>

                    <!-- TM Editor Section (Initially hidden) -->
                    <div id="tmEditorSection" style="display:none;">
                        <!-- TM File Controls -->
                        <div class="flex flex-col sm:flex-row gap-2 mb-4">
                            <button onclick="resetTM()" data-i18n="new_tm" id="newTmBtn" class="tm-btn-secondary flex-1 text-sm py-2 px-2">Nueva TM</button>
                            <label for="tmFileInput" class="block font-medium cursor-pointer py-2 px-4 rounded-md shadow-sm transition duration-300 tm-btn-secondary flex-1 text-sm text-center">
                                <span data-i18n="import_tmx" id="importTmxBtnText">Importar TMX</span>
                                <input type="file" id="tmFileInput" accept=".xml,.tmx" class="hidden" />
                            </label>
                            <button onclick="downloadTMX()" data-i18n="download_tmx" id="downloadTmxBtn" class="tm-btn-secondary flex-1 text-sm py-2 px-2">Descargar TMX</button>
                        </div>

                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="current_tm_lang_title" id="currentTmLangTitle">Idiomas actuales de la TM</h4>
                        <div class="flex space-x-2 mb-4">
                            <div class="tm-input-group flex-1">
                                <label data-i18n="source_language">Idioma de origen:</label>
                                <input id="displayTmSrcLang" disabled class="block w-full" />
                            </div>
                            <div class="tm-input-group flex-1">
                                <label data-i18n="target_language">Idioma de destino:</label>
                                <input id="displayTmTgtLang" disabled class="block w-full" />
                            </div>
                        </div>

                        <!-- TM Search Section -->
                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="tm_search_title" id="tmSearchTitle">Buscar en TM</h4>
                        <div class="mb-4">
                            <input id="tmSearchInput" data-i18n-placeholder="tm_search_placeholder" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white" oninput="tmSearch()" />
                        </div>

                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="tm_search_results_title" id="tmSearchResultsTitle">Resultados de búsqueda en TM</h4>
                        <div class="overflow-x-auto mb-4">
                            <table class="tm-table w-full">
                                <thead>
                                    <tr>
                                        <th data-i18n="tm_score_col" id="tmScoreCol">%</th>
                                        <th data-i18n="tm_original_col" id="tmOriginalCol">Original</th>
                                        <th data-i18n="tm_translation_col" id="tmTranslationCol">Traducción</th>
                                    </tr>
                                </thead>
                                <tbody id="tmSearchResultsTableBody">
                                    <!-- TM search results will be rendered here -->
                                </tbody>
                            </table>
                        </div>
                        <div data-i18n="tm_no_match_found" id="tmNoMatchFoundMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md hidden">
                            No se encontraron coincidencias en la TM.
                        </div>
                    </div>
                </div>
                <datalist id="isoLanguages"></datalist>
            </div>
        </div>

        <!-- Message Box Modal -->
        <div id="messageBox" class="modal hidden">
            <div class="modal-content">
                <p id="messageText" class="text-lg font-semibold text-on-light-contrast mb-4"></p>
                <button id="messageClose" class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-md transition duration-300">
                    <span data-i18n="ok" id="okBtnText">OK</span>
                </button>
            </div>
        </div>

        <!-- Shortcuts Modal -->
        <div id="shortcutsModal" class="modal hidden">
            <div class="modal-content">
                <h2 data-i18n="shortcuts_title" id="shortcutsTitle" class="text-xl font-bold mb-4 text-on-light-contrast">Atajos de teclado</h2>
                <ul class="list-disc list-inside text-on-light-contrast space-y-2">
                    <li id="shortcutValidate"><strong>Ctrl + Enter:</strong> Validar traducción y pasar a la siguiente.</li>
                    <li id="shortcutNext"><strong>Ctrl + <span id="arrowDownIconHtml"></span></strong>: Ir a la siguiente traducción.</li>
                    <li id="shortcutPrev"><strong>Ctrl + <span id="arrowUpIconHtml"></span></strong>: Ir a la traducción anterior.</li>
                    <li id="shortcutAlt1"><strong>Alt + [1-5]:</strong> Insertar sugerencia de la memoria de traducción.</li>
                    <li id="shortcutTmInsert"><strong>Ctrl + Alt + [1-5]:</strong> Insertar término traducido resaltado en glosario.</li>
                </ul>
                <button data-i18n="close_btn" id="shortcutsCloseBtn" class="mt-6 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-md transition duration-300">
                    <span id="closeBtnText">Cerrar</span>
                </button>
            </div>
        </div>

        <!-- Find and Replace Modal -->
        <div id="findReplaceModal" class="modal hidden">
            <div class="modal-content">
                <h2 data-i18n="find_replace_title" id="findReplaceTitle" class="text-xl font-bold mb-4 text-on-light-contrast">Buscar y reemplazar</h2>
                <div class="space-y-4">
                    <div>
                        <label for="findInput" data-i18n="find_label" id="findLabel" class="block text-sm font-medium text-on-light-contrast mb-1">Buscar:</label>
                        <input type="text" id="findInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                    </div>
                    <div>
                        <label for="replaceInput" data-i18n="replace_label" id="replaceLabel" class="block text-sm font-medium text-on-light-contrast mb-1">Reemplazar con:</label>
                        <input type="text" id="replaceInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white">
                    </div>
                    <div class="flex items-center space-x-4">
                        <label class="flex items-center text-on-light-contrast">
                            <input type="checkbox" id="caseSensitiveCheckbox" class="mr-2">
                            <span data-i18n="case_sensitive" id="caseSensitiveText">Distinguir mayúsculas y minúsculas</span>
                        </label>
                        <label class="flex items-center text-on-light-contrast">
                            <input type="checkbox" id="regexCheckbox" class="mr-2">
                            <span data-i18n="regular_expression" id="regexText">Expresión regular</span>
                        </label>
                    </div>
                    <div class="flex justify-end space-x-2">
                        <button data-i18n="find_prev" id="findPrevBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-4 rounded-md transition duration-300">
                            <span id="findPrevText">Buscar anterior</span>
                        </button>
                        <button data-i18n="find_next" id="findNextBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-4 rounded-md transition duration-300">
                            <span id="findNextText">Buscar siguiente</span>
                        </button>
                        <button data-i18n="replace" id="replaceBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-md transition duration-300">
                            <span id="replaceText">Reemplazar</span>
                        </button>
                        <button data-i18n="replace_all" id="replaceAllBtn" class="bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded-md transition duration-300">
                            <span id="replaceAllText">Reemplazar todo</span>
                        </button>
                    </div>
                </div>
                <button data-i18n="close_btn" id="findReplaceCloseBtn" class="mt-6 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-md transition duration-300 w-full">
                    <span id="closeBtnText">Cerrar</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Statistics Display (Moved to bottom and made accordion) -->
    <div id="statsContainer" class="bg-white p-4 rounded-lg shadow-xl w-full max-w-6xl mt-4 relative hidden">
        <div class="accordion-item">
            <div class="accordion-header" id="statsAccordionHeader">
                <h3 class="text-lg font-bold text-on-light-contrast" data-i18n="translation_stats_title" id="translationStatsTitle">Estadísticas de traducción</h3>
                <svg class="w-5 h-5 accordion-icon rotated" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </div>
            <div class="accordion-content collapsed" id="statsAccordionContent">
                <div class="bg-gray-100 p-3 rounded-md shadow-sm text-sm text-center text-on-light-contrast">
                    <p><span id="segmentsProgress">0/0 segmentos traducidos (0%)</span></p>
                    <p><span id="wordsTranslated">0 palabras traducidas</span> / <span id="wordsTotal">0 palabras originales totales</span></p>
                    <p><span id="wordsRemaining">0 palabras pendientes</span></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="loading-spinner"></div>
        <p id="loadingMessage"></p>
    </div>

    <script>
        // Global variables for Poanda editor
        let poEntries = [];
        let currentFileName = 'translations.po';
        let currentLanguage = 'es'; // Set default language to Spanish permanently
        let findState = {
            query: '',
            replace: '',
            caseSensitive: false,
            useRegex: false,
            lastFound: null,
        };

        // Global variable to keep track of terms found in the currently active/focused segment's original text
        let termsFoundInActiveSegment = new Set(); // Stores terms found in the currently focused original segment

        // Global variables for Terminology (Glossary)
        let glossary = [];
        let glossarySourceLanguage = '';
        let glossaryTargetLanguage = '';
        let currentGlossaryLatestResults = []; // Stores the last set of results rendered in glossary table for shortcuts


        // Global variables for Translation Memory (TM)
        let translationMemory = []; // Stores {srcLang, srcText, tgtLang, tgtText, srcWordCount, tgtWordCount}
        let tmSourceLanguage = ''; // Will typically be the source language of the PO file
        let tmTargetLanguage = ''; // Will typically be the target language of the PO file
        let tmBestMatchForActiveSegment = null; // Stores the best TM match for the currently focused segment
        let currentTMLatestSearchResults = []; // Stores the last set of results rendered in TM search table


        // DOM elements for Poanda editor
        const poFile = document.getElementById('poFile');
        const savePoButton = document.getElementById('savePo');
        const translationsContainer = document.getElementById('translationsContainer');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageClose = document.getElementById('messageClose');
        const poandaLogo = document.querySelector('.max-w-xs');
        const dropArea = document.getElementById('dropArea');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const mainEditorLayout = document.getElementById('mainEditorLayout');


        // Statistics DOM elements (now part of accordion)
        const statsContainer = document.getElementById('statsContainer');
        const segmentsProgress = document.getElementById('segmentsProgress');
        const wordsTranslated = document.getElementById('wordsTranslated');
        const wordsTotal = document.getElementById('wordsTotal');
        const wordsRemaining = document.getElementById('wordsRemaining');

        // Statistics Accordion DOM elements
        const statsAccordionHeader = document.getElementById('statsAccordionHeader');
        const statsAccordionContent = document.getElementById('statsAccordionContent');
        const statsAccordionIcon = statsAccordionHeader ? statsAccordionHeader.querySelector('.accordion-icon') : null;


        // Poanda Modals
        const shortcutsBtn = document.getElementById('shortcutsBtn');
        const shortcutsModal = document.getElementById('shortcutsModal');
        const shortcutsCloseBtn = document.getElementById('shortcutsCloseBtn');
        const arrowDownIconHtml = document.getElementById('arrowDownIconHtml');
        const arrowUpIconHtml = document.getElementById('arrowUpIconHtml');
        const findReplaceBtn = document.getElementById('findReplaceBtn');
        const findReplaceModal = document.getElementById('findReplaceModal');
        const findInput = document.getElementById('findInput');
        const replaceInput = document.getElementById('replaceInput');
        const caseSensitiveCheckbox = document.getElementById('caseSensitiveCheckbox');
        const regexCheckbox = document.getElementById('regexCheckbox');
        const findPrevBtn = document.getElementById('findPrevBtn');
        const findNextBtn = document.getElementById('findNextBtn');
        const replaceBtn = document.getElementById('replaceBtn');
        const replaceAllBtn = document.getElementById('replaceAllBtn');
        const findReplaceCloseBtn = document.getElementById('findReplaceCloseBtn');

        // Terminology Sidebar DOM elements
        const terminologyBtn = document.getElementById('terminologyBtn');
        const terminologySidebar = document.getElementById('terminologySidebar');
        const closeTerminologySidebarBtn = document.getElementById('closeTerminologySidebarBtn');
        const terminologyLanguageConfigSection = document.getElementById('terminologyLanguageConfigSection');
        const terminologyEditorSection = document.getElementById('terminologyEditorSection');
        const configSrcLang = document.getElementById('configSrcLang');
        const configTgtLang = document.getElementById('configTgtLang');
        const displaySrcLang = document.getElementById('displaySrcLang');
        const displayTgtLang = document.getElementById('displayTgtLang');
        const srcTermInput = document.getElementById('srcTerm');
        const tgtTermInput = document.getElementById('tgtTerm');
        const searchTermInput = document.getElementById('searchTerm');
        const glossaryTableBody = document.getElementById('glossaryTableBody');
        const tbxFileInput = document.getElementById('tbxFileInput');
        const isoLanguagesDatalist = document.getElementById('isoLanguages');

        // Buttons directly in config/editor sections for TBX
        const importTbxBtn = document.getElementById('importTbxBtn');
        const newGlossaryBtn = document.getElementById('newGlossaryBtn');
        const addTermHeader = document.getElementById('addTermHeader');
        const addTermContent = addTermHeader ? addTermHeader.nextElementSibling : null;
        const addTermAccordionIcon = addTermHeader ? addTermHeader.querySelector('.accordion-icon') : null;

        // Translation Memory Sidebar DOM elements
        const tmBtn = document.getElementById('tmBtn');
        const translationMemorySidebar = document.getElementById('translationMemorySidebar');
        const closeTranslationMemorySidebarBtn = document.getElementById('closeTranslationMemorySidebarBtn');
        const tmFileInput = document.getElementById('tmFileInput');
        const tmSearchInput = document.getElementById('tmSearchInput');
        const tmSearchResultsTableBody = document.getElementById('tmSearchResultsTableBody');
        const tmNoMatchFoundMessage = document.getElementById('tmNoMatchFoundMessage');
        // New TM config DOM elements
        const tmLanguageConfigSection = document.getElementById('tmLanguageConfigSection');
        const tmEditorSection = document.getElementById('tmEditorSection');
        const tmConfigSrcLang = document.getElementById('tmConfigSrcLang');
        const tmConfigTgtLang = document.getElementById('tmConfigTgtLang');
        const displayTmSrcLang = document.getElementById('displayTmSrcLang');
        const displayTmTgtLang = document.getElementById('displayTmTgtLang');
        const tmInternalMessage = document.getElementById('tmInternalMessage'); // New TM internal message element

        // DOM element for main content editor, needed for padding adjustments
        const editorMainContent = document.getElementById('editorMainContent');


        // Translations object (only Spanish now)
        const translations = {
            'es': {
                'title': 'Poanda',
                'load_file': 'Cargar archivo .po',
                'save_file': 'Guardar archivo .po',
                'original_msgid': 'Original (msgid):',
                'translation_msgstr': 'Traducción (msgstr):',
                'context_msgctxt': 'Contexto (msgctxt):',
                'validate': 'Validar',
                'edit': 'Editar',
                'fuzzy': 'Difuso',
                'char_count_original': 'Original: ',
                'char_count_translation': 'Traducción: ',
                'char_units': ' caracteres',
                'no_translations': 'Carga un archivo .po para empezar a editar.',
                'error_reading_file': 'Error al leer o analizar archivo .po: ',
                'error_saving_file': 'Error al guardar archivo .po: ',
                'file_saved_successfully': 'Archivo .po guardado con éxito.',
                'no_translations_to_save': 'No hay traducciones para guardar. Carga un archivo .po primero.',
                'reached_last': 'Has llegado a la última traducción.',
                'reached_first': 'Ya estás en la primera traducción.',
                'file_processing_error': '¡Error! No se pudo procesar el archivo. Asegúrate de que es un archivo .po válido.',
                'tool_description': 'Una herramienta sencilla para editar archivos .po.',
                'ok': 'OK',
                'shortcuts_btn': 'Atajos',
                'shortcuts_title': 'Atajos de teclado',
                'shortcut_validate': 'Ctrl + Enter: Validar traducción y pasar a la siguiente.',
                'shortcut_next': 'Ctrl + Flecha abajo: Ir a la siguiente traducción.',
                'shortcut_prev': 'Ctrl + Flecha arriba: Ir a la traducción anterior.',
                'shortcut_alt_1': 'Alt + [1-5]: Insertar sugerencia de la memoria de traducción.', // Updated shortcut for TM
                'shortcut_tm_insert': 'Ctrl + Alt + [1-5]: Insertar término traducido resaltado en glosario.', // Updated shortcut for Glossary
                'close_btn': 'Cerrar',
                'find_replace_btn': 'Buscar y reemplazar', // Reverted to full text
                'find_replace_title': 'Buscar y reemplazar',
                'find_label': 'Buscar:',
                'replace_label': 'Reemplazar con:',
                'case_sensitive': 'Distinguir mayúsculas y minúsculas',
                'regular_expression': 'Expresión regular',
                'find_prev': 'Buscar anterior',
                'find_next': 'Buscar siguiente',
                'replace': 'Reemplazar',
                'replace_all': 'Reemplazar todo',
                'no_match_found': 'No se encontró ninguna coincidencia.',
                'replaced_all': 'Todas las ocurrencias reemplazadas.',
                'no_find_query': 'Por favor, introduce el texto a buscar.',
                'loading_file': 'Cargando archivo...',
                'saving_file': 'Guardando archivo...',

                // Terminology specific translations
                'terminology_btn': 'Terminología',
                'terminology_sidebar_title': 'Terminología',
                'config_lang_title': 'Configurar idiomas del glosario',
                'config_lang_info': 'Define los idiomas de origen y destino de tu glosario. Puedes introducir el código ISO directamente o seleccionarlo de las sugerencias. Es fundamental que el código ISO sea correcto para que funcione correctamente con tu herramienta TAO.',
                'source_language': 'Idioma de origen:',
                'target_language': 'Idioma de destino:',
                'confirm_languages': 'Confirmar idiomas',
                'current_lang_title': 'Idiomas actuales del glosario',
                'add_term_title': 'Añadir término',
                'term': 'Término:',
                'translation': 'Traducción:',
                'add_button': 'Añadir',
                'search_title': 'Buscar',
                'search_placeholder': 'Buscar término...',
                'import_tbx': 'Importar TBX',
                'download_tbx': 'Descargar TBX',
                'new_glossary': 'Nuevo glosario',
                'glossary_list_title': 'Glosario',
                'source_term_col': 'Término de origen',
                'target_term_col': 'Término de destino',
                'actions_col': 'Acciones',
                'delete_button': 'Eliminar',
                'both_terms_required': 'Ambos términos son requeridos.',
                'lang_config_required': 'Por favor, configura los idiomas de origen y destino para el glosario.',
                'cannot_download_empty_or_unconfigured_glossary': 'No se puede descargar un glosario vacío o sin configurar.',
                'error_loading_tbx_file': 'Error al cargar el archivo TBX. Asegúrate de que sea un XML/TBX válido.',
                'no_valid_language_pairs_found_in_tbx': 'No se encontraron pares de idiomas válidos en el archivo TBX. Se usarán los valores por defecto (en-US, es-ES).',
                'translation_stats_title': 'Estadísticas de traducción',

                // Translation Memory specific translations
                'tm_btn': 'Memoria de traducción', // Reverted to full text
                'tm_sidebar_title': 'Memoria de Traducción (TM)',
                'new_tm': 'Nueva TM',
                'import_tmx': 'Importar TMX',
                'download_tmx': 'Descargar TMX',
                'no_tm_data': 'No hay datos en la memoria de traducción.',
                'tm_source_segment': 'Original:',
                'tm_target_segment': 'Traducción:',
                'tm_match_score': 'Coincidencia:',
                'tm_no_match_found': 'No se encontraron coincidencias en la TM.',
                'tm_insert_match': 'Insertar coincidencia',
                'error_loading_tmx_file': 'Error al cargar el archivo TMX. Asegúrate de que sea un XML/TMX válido.',
                'cannot_download_empty_tm': 'No se puede descargar una memoria de traducción vacía.',
                'tm_best_match': 'Mejor coincidencia de TM:',
                'tm_search_title': 'Buscar en TM',
                'tm_search_placeholder': 'Buscar en la memoria...',
                'tm_search_results_title': 'Resultados de búsqueda en TM',
                'tm_score_col': '%', /* Changed from 'Coincidencia' to '%' */
                'tm_original_col': 'Original',
                'tm_translation_col': 'Traducción',
                'tm_config_lang_title': 'Configurar idiomas de la TM',
                'tm_config_lang_info': 'Define los idiomas de origen y destino de tu Memoria de Traducción. Es fundamental que el código ISO sea correcto para que la coincidencia funcione correctamente.',
                'current_tm_lang_title': 'Idiomas actuales de la TM',
                'tm_initial_message': 'Crea una nueva TM o importa un archivo TMX para empezar a trabajar con la memoria de traducción.', // New message for initial state
                'tmx_file_expected_tbx_found': 'Este archivo parece ser un glosario (TBX). Por favor, usa la opción "Importar TBX" en el panel de Terminología.',
                'tbx_file_expected_tmx_found': 'Este archivo parece ser una memoria de traducción (TMX). Por favor, usa la opción "Importar TMX" en el panel de Memoria de Traducción.'
            }
        };

        // SVG icons for shortcuts
        const arrowDownIcon = `<svg class="shortcut-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 12a1 1 0 01-.707-.293l-4-4a1 1 0 011.414-1.414L10 9.586l3.293-3.293a1 1 0 111.414 1.414l-4 4A1 1 0 0110 12z" clip-rule="evenodd"></path></svg>`;
        const arrowUpIcon = `<svg class="shortcut-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 8a1 1 0 01.707.293l4 4a1 1 0 01-1.414 1.414L10 10.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4A1 1 0 0110 8z" clip-rule="evenodd"></path></svg>`;

        // List of common ISO 639-1 language codes for the datalist (for Terminology)
        const isoLanguagesData = [
          { code: "en", name: "English" }, { code: "en-US", name: "English (United States)" }, { code: "en-GB", name: "English (United Kingdom)" },
          { code: "es", name: "Español" }, { code: "es-ES", name: "Español (España)" }, { code: "es-MX", name: "Español (México)" },
          { code: "fr", name: "Français" }, { code: "de", name: "Deutsch" }, { code: "it", name: "Italiano" }, { code: "pt", name: "Português" },
          { code: "ja", name: "日本語 (Japanese)" }, { code: "zh", name: "中文 (Chinese)" }, { code: "ar", name: "العربية (Arabic)" },
          { code: "ru", name: "Русский (Russian)" }, { code: "ko", name: "한국어 (Korean)" }, { code: "nl", name: "Nederlands" },
          { code: "sv", name: "Svenska" }, { code: "da", name: "Dansk" }, { code: "no", name: "Norsk" }, { code: "fi", name: "Suomi" },
          { code: "tr", name: "Türkçe" }, { code: "pl", name: "Polski" }, { code: "cs", name: "Čeština" }, { code: "hu", name: "Magyar" },
          { code: "el", name: "Ελληνικά (Greek)" }, { code: "he", name: "עברית (Hebrew)" }, { code: "th", name: "ไทย (Thai)" },
          { code: "vi", name: "Tiếng Việt (Vietnamese)" }, { code: "id", name: "Bahasa Indonesia" }, { code: "ms", name: "Bahasa Melayu" },
          { code: "ca", name: "Català" }, { code: "eu", name: "Euskara" }, { code: "gl", name: "Galego" }, { code: "ro", name: "Română" },
          { code: "uk", name: "Українська (Ukrainian)" }, { code: "bg", name: "Български (Bulgarian)" }, { code: "hr", name: "Hrvatski" },
          { code: "sr", name: "Srpski" }, { code: "sk", name: "Slovenčina" }, { code: "sl", name: "Slovenščina" }, { code: "lt", name: "Lietuvių" },
          { code: "lv", name: "Latviešu" }, { code: "et", name: "Eesti" }, { code: "is", name: "Íslenska" }, { code: "ga", name: "Gaeilge" },
          { code: "mt", name: "Malti" },
        ];


        /**
         * Counts words in a given text string.
         * @param {string} text The text to count words from.
         * @returns {number} The number of words.
         */
        function countWords(text) {
            if (!text) return 0;
            // Trim leading/trailing whitespace and split by one or more whitespace characters
            const words = text.trim().split(/\s+/);
            // Filter out empty strings that might result from multiple spaces
            return words.filter(word => word.length > 0).length;
        }

        /**
         * Desescapa una cadena de texto en formato PO.
         * Elimina las comillas de inicio/fin y maneja los caracteres escapados como \n, \t, \", \\.
         * También convierte <br> y &lt;br&gt; en saltos de línea para una mejor visualización.
         * @param {string} s La cadena PO a desescapar.
         * @returns {string} La cadena desescapada.
         */
        function unescapePoString(s) {
            if (s.startsWith('"') && s.endsWith('"')) {
                s = s.substring(1, s.length - 1);
            }
            s = s.replace(/\\n/g, '\n')
                 .replace(/\\t/g, '\t')
                 .replace(/\\"/g, '"')
                 .replace(/\\\\/g, '\\');
            s = s.replace(/&lt;br&gt;/gi, '\n');
            s = s.replace(/<br\s*\/?>/gi, '\n');

            return s;
        }

        /**
         * Escapa una cadena de texto para el formato PO.
         * Añade comillas de inicio/fin y escapa caracteres especiales como ", \, \n, \t.
         * @param {string} s La cadena a escapar.
         * @returns {string} La cadena escapada en formato PO.
         */
        function escapePoString(s) {
            let escaped = s.replace(/\\/g, '\\\\')
                             .replace(/"/g, '\\"')
                             .replace(/\n/g, '\\n')
                             .replace(/\t/g, '\\t');
            return `"${escaped}"`;
        }

        /**
         * Heurística para dividir texto en "oraciones" para la visualización.
         * @param {string} text El texto a dividir.
         * @returns {Array<string>} Un array de segmentos de texto.
         */
        function splitTextIntoSentences(text) {
            if (!text || typeof text !== 'string' || text.trim() === '') {
                return [''];
            }
            // Use a regex that keeps the delimiters to re-assemble them correctly
            const sentenceDelimiters = /([.?!]+[\s\r\n]*)/g;
            const parts = text.split(sentenceDelimiters);

            const sentences = [];
            let currentSentence = '';

            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                if (part === null || part === undefined) continue;

                if (part.match(sentenceDelimiters)) { // If it's a delimiter
                    if (currentSentence.trim() !== '') {
                        sentences.push(currentSentence.trim() + part);
                        currentSentence = '';
                    } else if (part.trim() !== '') { // Handle cases where a delimiter might start a segment
                        sentences.push(part.trim());
                    }
                } else { // If it's a sentence part
                    currentSentence += part;
                }
            }
            if (currentSentence.trim() !== '') {
                sentences.push(currentSentence.trim());
            }

            return sentences.filter(s => s.length > 0 || text === '');
        }

        /**
         * Parses the content of a .po file.
         * @param {string} content The full content of the .po file.
         * @returns {Array<Object>} An array of PO entry objects.
         */
        function parsePoContent(content) {
            const entries = [];
            let currentEntry = null;
            const lines = content.split('\n');

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();

                if (trimmedLine.startsWith('#')) {
                    if (currentEntry) {
                        currentEntry.comments = currentEntry.comments || [];
                        currentEntry.comments.push(trimmedLine);
                        if (trimmedLine.includes('#, fuzzy')) {
                            currentEntry.fuzzy = true;
                        }
                    } else {
                        // Header comments before any msgid/msgstr block
                        if (entries.length === 0 || entries[entries.length - 1].comments.length === 0) {
                            // If no entries or the last entry doesn't have comments,
                            // this might be part of a global header comment.
                            // A more robust solution would distinguish global header from entry-specific comments.
                            if (entries.length === 0) {
                                // Create a dummy entry for header comments if no entries exist yet
                                entries.push({ comments: [trimmedLine], msgid: '', msgstr: '' });
                                currentEntry = entries[0];
                            } else {
                                // Add to previous entry's comments
                                entries[entries.length - 1].comments.push(trimmedLine);
                            }
                        }
                    }
                    continue;
                }

                if (trimmedLine.startsWith('msgctxt ')) {
                    if (currentEntry && currentEntry.msgid !== undefined) {
                        entries.push(currentEntry);
                        currentEntry = { comments: [] };
                    } else if (!currentEntry) {
                         currentEntry = { comments: [] };
                    }
                    currentEntry.msgctxt = unescapePoString(trimmedLine.substring(8));
                } else if (trimmedLine.startsWith('msgid ')) {
                    if (currentEntry && currentEntry.msgid !== undefined) {
                        entries.push(currentEntry);
                        currentEntry = { comments: [] };
                    } else if (!currentEntry) {
                         currentEntry = { comments: [] };
                    }
                    currentEntry.msgid = unescapePoString(trimmedLine.substring(6));
                } else if (trimmedLine.startsWith('msgstr ')) {
                    if (!currentEntry) {
                        currentEntry = { comments: [] };
                    }
                    currentEntry.msgstr = unescapePoString(trimmedLine.substring(7));
                    entries.push(currentEntry);
                    currentEntry = null; // Reset for next entry
                } else if (trimmedLine.startsWith('"') && trimmedLine.endsWith('"')) {
                    // Continuation of a multi-line msgid or msgstr
                    if (currentEntry) {
                        const unescapedPart = unescapePoString(trimmedLine);
                        if (currentEntry.msgstr === undefined) {
                            currentEntry.msgid = (currentEntry.msgid || '') + unescapedPart;
                        } else {
                            currentEntry.msgstr = (currentEntry.msgstr || '') + unescapedPart;
                        }
                    }
                } else if (trimmedLine === '') {
                    // Empty line separates entries. If there's an active entry being built, finalize it.
                    if (currentEntry && currentEntry.msgid !== undefined && currentEntry.msgstr !== undefined) {
                        entries.push(currentEntry);
                        currentEntry = null;
                    }
                     // If msgid is present but msgstr is not, and we hit an empty line, save it.
                    else if (currentEntry && currentEntry.msgid !== undefined && currentEntry.msgstr === undefined) {
                         // This case might happen at EOF or if msgstr is missing
                         entries.push(currentEntry);
                         currentEntry = null;
                    }
                    // For comments not associated with an entry, we ensure a fresh start for the next entry
                    if (!currentEntry && lines[i+1] && !lines[i+1].startsWith('#')) { // Only create new if next line isn't a comment
                         currentEntry = { comments: [] };
                    }
                }
            }
            // Add the last entry if it wasn't added (e.g., file ends without a blank line)
            if (currentEntry && (currentEntry.msgid !== undefined || currentEntry.msgctxt !== undefined)) {
                if (currentEntry.msgstr === undefined) { // Ensure msgstr is at least an empty string if not present
                    currentEntry.msgstr = '';
                }
                entries.push(currentEntry);
            }

            // Post-processing for sentence segmentation, word counts, and translation status
            entries.forEach(entry => {
                // Handle the special header entry (msgid "")
                if (entry.msgid === '' && entry.msgctxt === undefined) {
                    entry.isHeader = true;
                    entry.sentenceSegments = [{
                        original: entry.msgid,
                        translation: entry.msgstr,
                        wordCountOriginal: countWords(entry.msgid),
                        wordCountTranslation: countWords(entry.msgstr),
                        isTranslated: entry.msgstr.trim() !== ''
                    }];
                } else {
                    entry.isHeader = false;
                    const originalSegments = splitTextIntoSentences(entry.msgid || '');
                    const translatedSegments = splitTextIntoSentences(entry.msgstr || '');

                    entry.sentenceSegments = [];
                    const maxLength = Math.max(originalSegments.length, translatedSegments.length);
                    for (let j = 0; j < maxLength; j++) {
                        const originalText = originalSegments[j] || '';
                        const translationText = translatedSegments[j] || '';
                        entry.sentenceSegments.push({
                            original: originalText,
                            translation: translationText,
                            wordCountOriginal: countWords(originalText),
                            wordCountTranslation: countWords(translationText),
                            isTranslated: translationText.trim() !== ''
                        });
                    }
                }
            });
            return entries;
        }


        /**
         * Reconstruye el contenido de un archivo PO a partir de una matriz de entradas.
         * @param {Array<Object>} entries La matriz de objetos de traducción.
         * @returns {string} El contenido del archivo PO reconstruido.
         */
        function reconstructPo(entries) {
            let poContent = '';
            entries.forEach(entry => {
                if (entry.comments && entry.comments.length > 0) {
                    poContent += entry.comments.join('\n') + '\n';
                }
                if (entry.msgctxt !== undefined) {
                    poContent += `msgctxt ${escapePoString(entry.msgctxt)}\n`;
                }
                if (entry.msgid !== undefined) {
                    poContent += `msgid ${escapePoString(entry.msgid)}\n`;
                }

                let fullMsgstr = '';
                if (entry.sentenceSegments && entry.sentenceSegments.length > 0) {
                    // For header, directly use the stored msgstr
                    if (entry.isHeader) {
                        fullMsgstr = entry.msgstr || '';
                    } else {
                        // For regular entries, join segmented translations
                        fullMsgstr = entry.sentenceSegments.map(s => s.translation).join(' ').trim();
                    }
                } else {
                    fullMsgstr = entry.msgstr || ''; // Fallback if no segments
                }

                if (fullMsgstr !== undefined) {
                    poContent += `msgstr ${escapePoString(fullMsgstr)}\n`;
                }
                poContent += '\n';
            });
            return poContent;
        }

        /**
         * Adjusts the height of a textarea to fit its content.
         * If the translation textarea is empty, it matches the height of the original textarea.
         * @param {HTMLTextAreaElement} textarea The textarea element (msgstr).
         * @param {HTMLElement} [originalElement] The original element (msgid pre) for height comparison.
         */
        function autoResizeTextarea(textarea, originalElement) {
            textarea.style.height = 'auto';
            if (textarea.value.trim() === '' && originalElement) {
                // If textarea is empty, set its height to match the original element's scroll height
                textarea.style.height = originalElement.scrollHeight + 'px';
            } else {
                // Otherwise, let it expand to its own content
                textarea.style.height = textarea.scrollHeight + 'px';
            }
        }

        /**
         * Updates the character count for a specific textarea.
         * @param {HTMLTextAreaElement} textarea The textarea element.
         * @param {number} originalLength The length of the original string segment.
         */
        function updateCharCount(textarea, originalLength) {
            const entryIndex = parseInt(textarea.dataset.entryIndex);
            const segmentIndex = parseInt(textarea.dataset.segmentIndex);
            const charCountSpan = document.getElementById(`charCount-${entryIndex}-${segmentIndex}`);
            if (charCountSpan) {
                charCountSpan.textContent = `${translations.es['char_count_original']}${originalLength} ${translations.es['char_units']} | ${translations.es['char_count_translation']}${textarea.value.length} ${translations.es['char_units']}`;
            }
        }

        /**
         * Configures the editable state of a translation entry (editable/solo lectura).
         * @param {number} entryIndex The index of the main PO entry.
         * @param {number} segmentIndex The index of the sentence segment.
         * @param {boolean} isEditable True to make it editable, false for read-only.
         */
        function setTranslationEditableState(entryIndex, segmentIndex, isEditable) {
            const msgstrTextarea = document.getElementById(`msgstr-${entryIndex}-${segmentIndex}`);
            const validateButton = document.getElementById(`validateBtn-${entryIndex}-${segmentIndex}`);
            const editButton = document.getElementById(`editBtn-${entryIndex}-${segmentIndex}`);
            const checkIcon = document.getElementById(`checkIcon-${entryIndex}-${segmentIndex}`);
            const translationUnit = document.getElementById(`translation-unit-${entryIndex}`); // Get the parent unit


            if (!msgstrTextarea || !validateButton || !editButton || !checkIcon || !translationUnit) {
                console.error(`Elements not found for index ${entryIndex}-${segmentIndex}`);
                return;
            }

            msgstrTextarea.readOnly = !isEditable;
            if (!isEditable) {
                msgstrTextarea.classList.add('bg-gray-200');
                translationUnit.classList.remove('translation-unit-active'); // Remove active highlight on validate

                // Update translation status and words when segment is validated
                const segment = poEntries[entryIndex].sentenceSegments[segmentIndex];
                segment.isTranslated = msgstrTextarea.value.trim() !== '';
                segment.wordCountTranslation = countWords(msgstrTextarea.value);
                updateStatsDisplay(); // Update stats
                addOrUpdateTMEntry(segment.original, segment.translation); // Add/Update TM
            } else {
                msgstrTextarea.classList.remove('bg-gray-200');
                translationUnit.classList.add('translation-unit-active'); // Add active highlight on edit/focus
            }

            validateButton.style.display = isEditable ? 'inline-block' : 'none';
            editButton.style.display = isEditable ? 'none' : 'inline-block';
            checkIcon.style.display = isEditable ? 'none' : 'inline-block';

            if (isEditable) {
                msgstrTextarea.focus();
                // Ensure cursor is at the end of the text
                msgstrTextarea.setSelectionRange(msgstrTextarea.value.length, msgstrTextarea.value.length);
            }
        }

        /**
         * Applies glossary term highlighting to a given text segment.
         * Collects terms that were successfully highlighted.
         * @param {string} text The original text to highlight.
         * @returns {{html: string, foundTerms: Set<string>}} Object with HTML string and set of found terms.
         */
        function applyGlossaryHighlightToText(text) {
            let highlightedHtml = text;
            const currentFoundTerms = new Set(); // Terms found in *this specific* segment

            // Ensure glossarySourceLanguage is set and matches the original's implicit language
            if (!glossarySourceLanguage) {
                return { html: text, foundTerms: currentFoundTerms }; // Cannot highlight without source language
            }

            // Sort glossary terms by length in descending order to match longer terms first
            const sortedGlossary = [...glossary].sort((a, b) => b.srcTerm.length - a.srcTerm.length);


            sortedGlossary.forEach(glossaryEntry => {
                // Only highlight if the glossary entry's source language matches the current editor's source language
                // Assuming poEntries are implicitly in poanda's current source language.
                // For a more robust solution, each poEntry might need a source language field.
                // For now, we assume the glossary source language is the relevant source for highlighting.
                // Also, ensure the glossary entry has a source term.
                if (glossarySourceLanguage && glossaryEntry.srcTerm) {
                    const term = glossaryEntry.srcTerm;
                    // Use word boundaries \b to avoid partial word matches
                    // Escape special regex characters in the term
                    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    // 'g' for global, 'i' for case-insensitive
                    const regex = new RegExp(`\\b(${escapedTerm})\\b`, 'gi'); // Added word boundaries


                    // Only replace if the term is found (to avoid unnecessary string manipulations)
                    if (highlightedHtml.match(regex)) {
                        highlightedHtml = highlightedHtml.replace(regex, (match, p1) => {
                            // p1 is the captured group, which is the actual matched term (case-preserved)
                            currentFoundTerms.add(term); // Add the actual term from the glossary (case-preserved)
                            return `<span class="glossary-highlight">${p1}</span>`; // Highlight the matched part
                        });
                    }
                }
            });
            return { html: highlightedHtml, foundTerms: currentFoundTerms };
        }

        /**
         * Updates highlighting in the glossary table based on terms found in the editor.
         * This function is implicitly called via renderGlossary() after termsFoundInActiveSegment is updated.
         */
        function updateGlossaryTableHighlights() {
            renderGlossary(); // Re-render glossary, which applies highlights based on termsFoundInActiveSegment
        }


        /**
         * Renders translation entries in the user interface, including sentence segmentation.
         * @param {Array<Object>} entries The array of translation objects to render.
         */
        function renderTranslations(entries) {
            translationsContainer.innerHTML = '';
            termsFoundInActiveSegment.clear(); // Clear terms when re-rendering all translations

            if (entries.length === 0) {
                translationsContainer.innerHTML = `
                    <div data-i18n="no_translations" id="initialMessage" class="text-center text-on-light-contrast p-4 border border-gray-300 rounded-md">
                        Carga un archivo .po para empezar a editar.
                    </div>
                `;
                savePoButton.disabled = true;
                statsContainer.classList.add('hidden'); // Hide stats if no translations
                return;
            }

            entries.forEach((entry, entryIndex) => {
                // Skip rendering header entry explicitly in the main editor area, but keep in poEntries
                if (entry.isHeader) {
                    return;
                }

                const translationUnit = document.createElement('div');
                translationUnit.id = `translation-unit-${entryIndex}`; // Added ID for highlighting
                translationUnit.className = 'translation-unit-bg p-4 rounded-lg shadow-sm border border-gray-200 mb-6';

                if (entry.comments && entry.comments.length > 0) {
                    const commentsDiv = document.createElement('div');
                    commentsDiv.className = 'text-xs text-gray-500 mb-2 whitespace-pre-wrap';
                    commentsDiv.textContent = entry.comments.join('\n');
                    translationUnit.appendChild(commentsDiv);
                }
                if (entry.msgctxt) {
                    const msgctxtLabel = document.createElement('label');
                    msgctxtLabel.className = 'block text-sm font-medium text-on-light-contrast mb-1';
                    msgctxtLabel.textContent = translations.es['context_msgctxt'];
                    translationUnit.appendChild(msgctxtLabel);

                    const msgctxtPre = document.createElement('pre');
                    msgctxtPre.className = 'po-display-code p-2 rounded-md text-base overflow-auto max-h-32'; /* Changed text-sm to text-base */
                    msgctxtPre.textContent = entry.msgctxt;
                    translationUnit.appendChild(msgctxtPre);
                }

                entry.sentenceSegments.forEach((segment, segmentIndex) => {

                    const segmentRow = document.createElement('div');
                    segmentRow.className = 'translation-row mb-4';

                    const originalCol = document.createElement('div');
                    originalCol.className = 'original-col';

                    const msgidLabel = document.createElement('label');
                    msgidLabel.className = 'block text-sm font-medium text-on-light-contrast mb-1';
                    msgidLabel.textContent = translations.es['original_msgid'];
                    originalCol.appendChild(msgidLabel);

                    const msgidPre = document.createElement('pre');
                    msgidPre.id = `msgid-pre-${entryIndex}-${segmentIndex}`; // Added ID for easier lookup
                    msgidPre.className = 'po-display-code p-2 rounded-md text-base overflow-auto max-h-32'; /* Changed text-sm to text-base */
                    msgidPre.textContent = segment.original; // Initial text without highlight
                    originalCol.appendChild(msgidPre);
                    segmentRow.appendChild(originalCol);

                    const translationCol = document.createElement('div');
                    translationCol.className = 'translation-col';

                    const msgstrLabel = document.createElement('label');
                    msgstrLabel.className = 'block text-sm font-medium text-on-light-contrast mb-1';
                    msgstrLabel.textContent = translations.es['translation_msgstr'];
                    translationCol.appendChild(msgstrLabel);

                    const msgstrTextarea = document.createElement('textarea');
                    msgstrTextarea.id = `msgstr-${entryIndex}-${segmentIndex}`;
                    msgstrTextarea.className = 'msgstr-textarea mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500 text-base'; /* Changed text-sm to text-base */
                    msgstrTextarea.value = segment.translation;
                    msgstrTextarea.dataset.entryIndex = entryIndex;
                    msgstrTextarea.dataset.segmentIndex = segmentIndex;
                    msgstrTextarea.dataset.originalLength = segment.original.length;

                    translationCol.appendChild(msgstrTextarea);
                    segmentRow.appendChild(translationCol);
                    translationUnit.appendChild(segmentRow);

                    const controlsContainer = document.createElement('div');
                    controlsContainer.className = 'flex items-center justify-between mt-2 w-full';

                    const charCountSpan = document.createElement('span');
                    charCountSpan.id = `charCount-${entryIndex}-${segmentIndex}`;
                    charCountSpan.className = 'inline-block text-sm font-semibold text-on-light-contrast'; /* Added inline-block for persistent visibility */
                    controlsContainer.appendChild(charCountSpan);

                    const actionButtonsContainer = document.createElement('div');
                    actionButtonsContainer.className = 'flex items-center space-x-2';

                    const checkIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    checkIcon.setAttribute("id", `checkIcon-${entryIndex}-${segmentIndex}`);
                    checkIcon.setAttribute("class", "check-icon text-green-500");
                    checkIcon.setAttribute("fill", "none");
                    checkIcon.setAttribute("viewBox", "0 0 24 24");
                    checkIcon.setAttribute("stroke", "currentColor");
                    checkIcon.innerHTML = `
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                    `;
                    actionButtonsContainer.appendChild(checkIcon);

                    const validateButton = document.createElement('button');
                    validateButton.id = `validateBtn-${entryIndex}-${segmentIndex}`;
                    validateButton.className = 'validate-button font-medium py-1 px-3 rounded-md shadow-sm transition duration-300 btn-validate';
                    validateButton.textContent = translations.es['validate'];
                    validateButton.dataset.entryIndex = entryIndex;
                    validateButton.dataset.segmentIndex = segmentIndex;
                    actionButtonsContainer.appendChild(validateButton);

                    const editButton = document.createElement('button');
                    editButton.id = `editBtn-${entryIndex}-${segmentIndex}`;
                    editButton.className = 'edit-button font-medium py-1 px-3 rounded-md shadow-sm transition duration-300 btn-edit';
                    editButton.textContent = translations.es['edit'];
                    editButton.dataset.entryIndex = entryIndex;
                    editButton.dataset.segmentIndex = segmentIndex;
                    editButton.style.display = 'none';
                    actionButtonsContainer.appendChild(editButton);

                    controlsContainer.appendChild(actionButtonsContainer);
                    translationUnit.appendChild(controlsContainer);

                    msgstrTextarea.addEventListener('input', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        const segment = poEntries[currentEntryIndex].sentenceSegments[currentSegmentIndex];

                        segment.translation = event.target.value;
                        segment.wordCountTranslation = countWords(event.target.value);
                        segment.isTranslated = event.target.value.trim() !== ''; // Update translation status

                        const originalSegmentPre = originalCol.querySelector('pre');
                        autoResizeTextarea(event.target, originalSegmentPre);
                        updateCharCount(event.target, parseInt(event.target.dataset.originalLength));
                        updateStatsDisplay(); // Update stats on every input

                        // Re-evaluate glossary highlights on input as content changes
                        if (document.activeElement === msgstrTextarea) {
                            // Force re-highlight by simulating blur then focus
                            const tempOriginalText = segment.original; // Save original text
                            originalCol.querySelector('pre').textContent = tempOriginalText; // Clear highlight
                            termsFoundInActiveSegment.clear(); // Clear terms
                            const highlightResult = applyGlossaryHighlightToText(tempOriginalText); // Re-apply highlight
                            originalCol.querySelector('pre').innerHTML = highlightResult.html;
                            highlightResult.foundTerms.forEach(term => termsFoundInActiveSegment.add(term));
                            updateGlossaryTableHighlights(); // Update glossary table
                        }
                    });

                    // Add focus and blur event listeners for dynamic highlighting and active unit
                    msgstrTextarea.addEventListener('focus', (event) => {
                        // Remove highlight from any previously active unit
                        document.querySelectorAll('.translation-unit-active').forEach(unit => {
                            unit.classList.remove('translation-unit-active');
                        });
                        // Add highlight to the current unit
                        translationUnit.classList.add('translation-unit-active');

                        termsFoundInActiveSegment.clear(); // Clear previous terms
                        const originalSegmentPre = document.getElementById(`msgid-pre-${entryIndex}-${segmentIndex}`);
                        if (originalSegmentPre && glossarySourceLanguage && glossary.length > 0) {
                            const highlightResult = applyGlossaryHighlightToText(segment.original);
                            originalSegmentPre.innerHTML = highlightResult.html;
                            highlightResult.foundTerms.forEach(term => termsFoundInActiveSegment.add(term));
                        }
                        updateGlossaryTableHighlights(); // Update glossary table based on current terms
                        autoResizeTextarea(event.target, originalCol.querySelector('pre')); // Ensure resize on focus
                        event.target.scrollIntoView({ behavior: 'smooth', block: 'center' }); // Scroll into view

                        // TM: Find best match when segment is focused and update TM search results
                        const currentSegmentOriginal = poEntries[entryIndex].sentenceSegments[segmentIndex].original;
                        tmBestMatchForActiveSegment = findBestTMMatch(currentSegmentOriginal); // Update global
                        tmSearch(); // Re-render TM results, which will now show the active segment match
                    });

                    msgstrTextarea.addEventListener('blur', (event) => {
                        const originalSegmentPre = document.getElementById(`msgid-pre-${entryIndex}-${segmentIndex}`);
                        if (originalSegmentPre) {
                            originalSegmentPre.textContent = segment.original; // Revert to plain text on blur
                        }
                        // Only remove active unit highlight if moving focus outside this unit.
                        termsFoundInActiveSegment.clear(); // Clear terms when segment loses focus
                        updateGlossaryTableHighlights(); // Remove table highlights
                        // TM: Clear active segment match and refresh TM search results
                        tmBestMatchForActiveSegment = null;
                        tmSearch(); // Refresh TM search results to remove the active segment match
                    });


                    msgstrTextarea.addEventListener('click', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        if (event.target.readOnly) {
                            setTranslationEditableState(currentEntryIndex, currentSegmentIndex, true);
                        }
                    });

                    validateButton.addEventListener('click', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        setTranslationEditableState(currentEntryIndex, currentSegmentIndex, false);
                        goToNextTranslation(currentEntryIndex, currentSegmentIndex);
                        // Stats and TM update are handled inside setTranslationEditableState now
                    });

                    editButton.addEventListener('click', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        setTranslationEditableState(currentEntryIndex, currentSegmentIndex, true);
                    });

                    // Call autoResizeTextarea on initial render for correct default height
                    autoResizeTextarea(msgstrTextarea, msgidPre);
                    updateCharCount(msgstrTextarea, segment.original.length);
                });

                if (entry.fuzzy) {
                    const fuzzyIndicator = document.createElement('span');
                    fuzzyIndicator.className = 'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800 mt-2';
                    fuzzyIndicator.textContent = translations.es['fuzzy'];
                    translationUnit.appendChild(fuzzyIndicator);
                }

                translationsContainer.appendChild(translationUnit);
            });
            savePoButton.disabled = false;
            statsContainer.classList.remove('hidden'); // Show stats container
            updateStatsDisplay(); // Initial stats display after rendering

            // Initial focus on the first editable translation if any (this will trigger its focus listener for highlight)
            const firstEditableSegment = getFirstEditableSegment();
            if (firstEditableSegment) {
                navigateToTranslation(firstEditableSegment.entryIndex, firstEditableSegment.segmentIndex);
            }
            // The glossary table highlights will be updated by the initial navigateToTranslation call's focus event.
        }

        /**
         * Updates the display of translation progress and word counts.
         */
        function updateStatsDisplay() {
            let totalSegments = 0;
            let translatedSegments = 0;
            let totalWordsOriginal = 0;
            let totalWordsTranslated = 0;

            poEntries.forEach(entry => {
                // Skip header entry
                if (entry.isHeader) {
                    return;
                }
                if (entry.sentenceSegments) {
                    entry.sentenceSegments.forEach(segment => {
                        totalSegments++;
                        totalWordsOriginal += segment.wordCountOriginal;
                        if (segment.isTranslated) {
                            translatedSegments++;
                            totalWordsTranslated += segment.wordCountTranslation;
                        }
                    });
                }
            });

            const percentage = totalSegments > 0 ? ((translatedSegments / totalSegments) * 100).toFixed(0) : 0;
            segmentsProgress.textContent = `${translatedSegments}/${totalSegments} segmentos traducidos (${percentage}%)`;
            wordsTranslated.textContent = `${totalWordsTranslated} palabras traducidas`;
            wordsTotal.textContent = `${totalWordsOriginal} palabras originales totales`;
            wordsRemaining.textContent = `${totalWordsOriginal - totalWordsTranslated} palabras pendientes`;
        }


        /**
         * Gets the index of the currently focused translation textarea, including the segment index.
         * @returns {{entryIndex: number, segmentIndex: number} | null} The object with indices, or null.
         */
        function getCurrentFocusedIndex() {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.classList.contains('msgstr-textarea')) {
                return {
                    entryIndex: parseInt(activeElement.dataset.entryIndex),
                    segmentIndex: parseInt(activeElement.dataset.segmentIndex)
                };
            }
            return null;
        }

        /**
         * Finds the first editable segment (not a header).
         * @returns {{entryIndex: number, segmentIndex: number} | null} The object with indices, or null.
         */
        function getFirstEditableSegment() {
            for (let i = 0; i < poEntries.length; i++) {
                const entry = poEntries[i];
                if (!entry.isHeader && entry.sentenceSegments && entry.sentenceSegments.length > 0) {
                    return { entryIndex: i, segmentIndex: 0 };
                }
            }
            return null;
        }


        /**
         * Navigates to and focuses a specific translation field (segment).
         * @param {number} entryIndex The index of the PO entry.
         * @param {number} segmentIndex The index of the sentence segment.
         */
        function navigateToTranslation(entryIndex, segmentIndex) {
            const targetTextarea = document.getElementById(`msgstr-${entryIndex}-${segmentIndex}`);
            if (targetTextarea) {
                // Blur the previously focused textarea to trigger its blur event if it's different
                const currentlyFocusedTextarea = document.activeElement;
                if (currentlyFocusedTextarea && currentlyFocusedTextarea.classList.contains('msgstr-textarea') && currentlyFocusedTextarea !== targetTextarea) {
                    currentlyFocusedTextarea.blur(); // This will trigger the blur event listener
                }
                setTranslationEditableState(entryIndex, segmentIndex, true); // Make it editable and focus
                targetTextarea.scrollIntoView({ behavior: 'smooth', block: 'center' }); // Scroll into view
            }
        }

        /**
         * Moves focus to the next translation field (segment).
         * @param {number} currentEntryIndex The current index of the PO entry.
         * @param {number} currentSegmentIndex The current index of the sentence segment.
         */
        function goToNextTranslation(currentEntryIndex, currentSegmentIndex) {
            if (poEntries.length === 0) return;

            let nextEntryIndex = currentEntryIndex;
            let nextSegmentIndex = currentSegmentIndex + 1;

            // Loop to find the next *editable* segment
            while (true) {
                if (nextEntryIndex >= poEntries.length) {
                    showMessage(translations.es['reached_last']);
                    return;
                }

                const currentEntry = poEntries[nextEntryIndex];
                if (currentEntry.isHeader || !currentEntry.sentenceSegments || currentEntry.sentenceSegments.length === 0) {
                    // Skip header or entries with no segments
                    nextEntryIndex++;
                    nextSegmentIndex = 0;
                    continue;
                }

                if (nextSegmentIndex < currentEntry.sentenceSegments.length) {
                    navigateToTranslation(nextEntryIndex, nextSegmentIndex);
                    return;
                } else {
                    // Move to the next entry
                    nextEntryIndex++;
                    nextSegmentIndex = 0;
                }
            }
        }

        /**
         * Moves focus to the previous translation field (segment).
         * @param {number} currentEntryIndex The current index of the PO entry.
         * @param {number} currentSegmentIndex The current index of the sentence segment.
         */
        function goToPreviousTranslation(currentEntryIndex, currentSegmentIndex) {
            if (poEntries.length === 0) return;

            let prevEntryIndex = currentEntryIndex;
            let prevSegmentIndex = currentSegmentIndex - 1;

            // Loop to find the previous *editable* segment
            while (true) {
                if (prevEntryIndex < 0) {
                    showMessage(translations.es['reached_first']);
                    return;
                }

                const currentEntry = poEntries[prevEntryIndex];
                if (currentEntry.isHeader || !currentEntry.sentenceSegments || currentEntry.sentenceSegments.length === 0) {
                    // Skip header or entries with no segments
                    prevEntryIndex--;
                    prevSegmentIndex = (prevEntryIndex >= 0 && poEntries[prevEntryIndex].sentenceSegments) ? poEntries[prevEntryIndex].sentenceSegments.length - 1 : 0;
                    continue;
                }

                if (prevSegmentIndex >= 0) {
                    navigateToTranslation(prevEntryIndex, prevSegmentIndex);
                    return;
                } else {
                    // Move to the previous entry's last segment
                    prevEntryIndex--;
                    prevSegmentIndex = (prevEntryIndex >= 0 && poEntries[prevEntryIndex].sentenceSegments) ? poEntries[prevEntryIndex].sentenceSegments.length - 1 : 0;
                }
            }
        }

        // --- Event Handlers ---

        poFile.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                await processFile(file);
            }
        });

        savePoButton.addEventListener('click', async () => {
            if (poEntries.length === 0) {
                showMessage(translations.es['no_translations_to_save']);
                return;
            }
            showLoadingOverlay(translations.es['saving_file']);
            try {
                const updatedPoContent = reconstructPo(poEntries);
                const blob = new Blob([updatedPoContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = currentFileName.replace(/\.po$/i, '') + '.po';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showMessage(translations.es['file_saved_successfully']);
            } catch (error) {
                showMessage(`${translations.es['error_saving_file']} ${error.message}`);
                console.error("Error saving file:", error);
            } finally {
                hideLoadingOverlay();
            }
        });

        async function processFile(file) {
            currentFileName = file.name;
            showLoadingOverlay(translations.es['loading_file']);
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        poEntries = parsePoContent(content); // Now only calls parsePoContent
                        renderTranslations(poEntries);
                        updateStatsDisplay(); // Ensure stats are updated after parsing and rendering
                        resolve();
                    } catch (error) {
                        showMessage(`${translations.es['error_reading_file']} ${error.message}`);
                        console.error("Error parsing file:", error);
                        translationsContainer.innerHTML = `
                            <div class="text-center text-red-500 p-4 border border-red-300 rounded-md">
                                ${translations.es['file_processing_error']}
                            </div>
                        `;
                        savePoButton.disabled = true;
                        statsContainer.classList.add('hidden'); // Hide stats on error
                        resolve(); // Resolve even on error to hide loading overlay
                    } finally {
                        hideLoadingOverlay();
                    }
                };
                reader.onerror = () => {
                    showMessage(translations.es['error_reading_file'] + (file.name || ''));
                    savePoButton.disabled = true;
                    statsContainer.classList.add('hidden'); // Hide stats on error
                    hideLoadingOverlay();
                    resolve();
                };
                reader.readAsText(file);
            });
        }

        document.addEventListener('keydown', (event) => {
            // Check if any modal is open. If so, prevent default shortcuts to avoid interference.
            if (!shortcutsModal.classList.contains('hidden') || !findReplaceModal.classList.contains('hidden') || !messageBox.classList.contains('hidden')) {
                return;
            }

            const isNumberKey = event.key >= '1' && event.key <= '5';
            const indexToInsert = parseInt(event.key) - 1; // 0-indexed

            if (event.altKey && !event.ctrlKey) { // Only Alt + [1-5]
                if (isNumberKey) {
                    event.preventDefault(); // Prevent browser default action (e.g., opening dev tools)
                    const currentFocused = getCurrentFocusedIndex();
                    if (!currentFocused) return; // Only if a textarea is focused

                    const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                    if (!targetTextarea || targetTextarea.readOnly) return; // Only if editable textarea

                    // ALT + [1-5]: Insert TM suggestion
                    if (currentTMLatestSearchResults.length > indexToInsert) {
                        const tmToInsert = currentTMLatestSearchResults[indexToInsert];
                        const textToInsert = tmToInsert.tgtText;

                        const start = targetTextarea.selectionStart;
                        const end = targetTextarea.selectionEnd;
                        const currentValue = targetTextarea.value;

                        targetTextarea.value = currentValue.substring(0, start) +
                                               textToInsert +
                                               currentValue.substring(end);

                        // Move cursor to the end of inserted text
                        targetTextarea.selectionStart = targetTextarea.selectionEnd = start + textToInsert.length;

                        // Trigger input event manually to update stats and char counts
                        const inputEvent = new Event('input', { bubbles: true });
                        targetTextarea.dispatchEvent(inputEvent);
                    } else {
                        showMessage(translations.es['tm_no_match_found']);
                    }
                }
            } else if (event.ctrlKey && event.altKey) { // Only Ctrl + Alt + [1-5]
                 if (isNumberKey) {
                    event.preventDefault(); // Prevent browser default action
                    const currentFocused = getCurrentFocusedIndex();
                    if (!currentFocused) return; // Only if a textarea is focused

                    const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                    if (!targetTextarea || targetTextarea.readOnly) return; // Only if editable textarea

                    // CTRL + ALT + [1-5]: Insert Glossary term
                    if (currentGlossaryLatestResults.length > indexToInsert) {
                        const glossaryTermToInsert = currentGlossaryLatestResults[indexToInsert];
                        const termTextToInsert = glossaryTermToInsert.tgtTerm;

                        const start = targetTextarea.selectionStart;
                        const end = targetTextarea.selectionEnd;
                        const currentValue = targetTextarea.value;

                        targetTextarea.value = currentValue.substring(0, start) +
                                               termTextToInsert +
                                               currentValue.substring(end);

                        // Move cursor to the end of inserted text
                        targetTextarea.selectionStart = targetTextarea.selectionEnd = start + termTextToInsert.length;

                        // Trigger input event manually to update stats and char counts
                        const inputEvent = new Event('input', { bubbles: true });
                        targetTextarea.dispatchEvent(inputEvent);
                    } else {
                        showMessage(translations.es['no_match_found']); // Reusing generic "no match found" for glossary
                    }
                }
            } else if (event.ctrlKey) { // Standard Ctrl shortcuts (not Alt)
                const currentFocused = getCurrentFocusedIndex();
                if (!currentFocused) return;

                switch (event.key) {
                    case 'Enter':
                        event.preventDefault();
                        setTranslationEditableState(currentFocused.entryIndex, currentFocused.segmentIndex, false);
                        goToNextTranslation(currentFocused.entryIndex, currentFocused.segmentIndex);
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        goToNextTranslation(currentFocused.entryIndex, currentFocused.segmentIndex);
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        goToPreviousTranslation(currentFocused.entryIndex, currentFocused.segmentIndex);
                        break;
                }
            }
        });

        // --- Message Box Functions ---
        function showMessage(msg) {
            messageText.textContent = msg;
            messageBox.classList.remove('hidden');
        }

        messageClose.addEventListener('click', () => {
            messageBox.classList.add('hidden');
        });

        // --- Keyboard Shortcuts Modal ---
        shortcutsBtn.addEventListener('click', () => {
            shortcutsModal.classList.remove('hidden');
        });

        shortcutsCloseBtn.addEventListener('click', () => {
            shortcutsModal.classList.add('hidden');
        });

        // --- Find and Replace Modal ---
        findReplaceBtn.addEventListener('click', () => {
            findReplaceModal.classList.remove('hidden');
            findInput.focus();
        });

        findReplaceCloseBtn.addEventListener('click', () => {
            findReplaceModal.classList.add('hidden');
            findState.lastFound = null; // Clear last found state on close
            // Clear any active selections
            const currentFocused = getCurrentFocusedIndex();
            if (currentFocused) {
                const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                if (targetTextarea) {
                    targetTextarea.setSelectionRange(targetTextarea.value.length, targetTextarea.value.length);
                }
            }
        });

        // Find Next / Find Previous Logic
        findNextBtn.addEventListener('click', () => findAndNavigate(true));
        findPrevBtn.addEventListener('click', () => findAndNavigate(false));
        replaceBtn.addEventListener('click', replaceCurrentMatch);
        replaceAllBtn.addEventListener('click', replaceAllMatches);

        function findAndNavigate(forward = true) {
            const query = findInput.value;
            if (!query) {
                showMessage(translations.es['no_find_query']);
                return;
            }

            findState.query = query;
            findState.caseSensitive = caseSensitiveCheckbox.checked;
            findState.useRegex = regexCheckbox.checked;

            let regex;
            try {
                regex = findState.useRegex ? new RegExp(findState.query, findState.caseSensitive ? '' : 'i') : null;
            } catch (e) {
                showMessage(`Error de expresión regular: ${e.message}`);
                return;
            }

            let startEntryIndex = 0;
            let startSegmentIndex = 0;
            let startMatchIndex = 0; // Where to start searching within a segment

            // If a previous match exists, start from there
            if (findState.lastFound) {
                startEntryIndex = findState.lastFound.entryIndex;
                startSegmentIndex = findState.lastFound.segmentIndex;
                startMatchIndex = forward ? findState.lastFound.matchEnd : findState.lastFound.matchStart - 1; // Start after for next, before for prev
            } else {
                // If no previous match, start from beginning (forward) or end (backward)
                if (!forward) {
                    startEntryIndex = poEntries.length - 1;
                    if (poEntries[startEntryIndex] && poEntries[startEntryIndex].sentenceSegments) {
                        startSegmentIndex = poEntries[startEntryIndex].sentenceSegments.length - 1;
                    } else {
                        startSegmentIndex = 0;
                    }
                    startMatchIndex = Infinity; // For backward search, search from end of string
                }
            }

            let found = false;
            let currentEntryIndex = startEntryIndex;
            let currentSegmentIndex = startSegmentIndex;
            const totalEntries = poEntries.length;

            for (let i = 0; i < totalEntries; i++) { // Outer loop for entries
                const entry = poEntries[currentEntryIndex];
                if (!entry || entry.isHeader || !entry.sentenceSegments) { // Skip headers
                    currentEntryIndex = (currentEntryIndex + (forward ? 1 : -1) + totalEntries) % totalEntries;
                    currentSegmentIndex = forward ? 0 : (entry && entry.sentenceSegments ? entry.sentenceSegments.length - 1 : 0);
                    continue;
                }

                const totalSegments = entry.sentenceSegments.length;
                let segmentLoopStart = forward ? 0 : totalSegments - 1;
                let segmentLoopEnd = forward ? totalSegments : -1;
                let segmentLoopStep = forward ? 1 : -1;

                if (currentEntryIndex === startEntryIndex) { // Adjust segment loop start if in the initial entry
                    segmentLoopStart = startSegmentIndex;
                }


                for (let j = segmentLoopStart; forward ? (j < segmentLoopEnd) : (j >= segmentLoopEnd); j += segmentLoopStep) { // Inner loop for segments
                    const segment = entry.sentenceSegments[j];
                    const text = segment.translation;
                    let match;

                    if (findState.useRegex) {
                        regex.lastIndex = 0; // Always reset for new segment/start position
                        if (forward) {
                            // If current segment is the start segment, begin search from startMatchIndex
                            let searchFrom = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : 0;
                            // Search only within the relevant part of the string
                            const subText = text.substring(searchFrom);
                            match = regex.exec(subText);
                            if (match) {
                                match.index += searchFrom; // Adjust index relative to full string
                            }
                        } else {
                            // Backward regex search is complex. Find all matches and then pick the relevant one.
                            let allMatches = [];
                            let tempRegex = new RegExp(regex.source, regex.flags.includes('g') ? regex.flags : regex.flags + 'g');
                            let tempMatch;
                            while((tempMatch = tempRegex.exec(text)) !== null) {
                                allMatches.push(tempMatch);
                            }
                            // If current segment is the start segment, search up to startMatchIndex
                            let searchUntil = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : text.length;
                            match = allMatches.reverse().find(m => m.index < searchUntil);
                        }
                    } else {
                        const searchText = findState.caseSensitive ? text : text.toLowerCase();
                        const queryLower = findState.caseSensitive ? findState.query : findState.query.toLowerCase();

                        if (forward) {
                            let searchFrom = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : 0;
                            const foundIndex = searchText.indexOf(queryLower, searchFrom);
                            if (foundIndex !== -1) {
                                match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                            }
                        } else {
                            let searchUntil = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : text.length;
                            const foundIndex = searchText.lastIndexOf(queryLower, searchUntil);
                            if (foundIndex !== -1) {
                                match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                            }
                        }
                    }

                    if (match) {
                        findState.lastFound = {
                            entryIndex: currentEntryIndex,
                            segmentIndex: j,
                            matchStart: match.index,
                            matchEnd: match.index + match[0].length,
                        };
                        navigateToTranslation(currentEntryIndex, j);
                        const targetTextarea = document.getElementById(`msgstr-${currentEntryIndex}-${j}`);
                        if (targetTextarea) {
                            targetTextarea.setSelectionRange(findState.lastFound.matchStart, findState.lastFound.matchEnd);
                        }
                        found = true;
                        return; // Exit all loops
                    }
                }
                if (found) break; // Exit outer loop if found

                // Move to next/previous entry
                currentEntryIndex = (currentEntryIndex + (forward ? 1 : -1) + totalEntries) % totalEntries;
                currentSegmentIndex = forward ? 0 : (poEntries[currentEntryIndex].sentenceSegments ? poEntries[currentEntryIndex].sentenceSegments.length - 1 : 0);
                // The `entry` in `entry && entry.sentenceSegments` above will be `poEntries[currentEntryIndex]`
                // after the assignment.
            }

            if (!found) {
                showMessage(translations.es['no_match_found']);
                findState.lastFound = null;
            }
        }


        function replaceCurrentMatch() {
            if (!findState.lastFound || !findState.query) {
                showMessage(translations.es['no_match_found']);
                return;
            }

            const { entryIndex, segmentIndex, matchStart, matchEnd } = findState.lastFound;
            const segment = poEntries[entryIndex].sentenceSegments[segmentIndex];
            let originalText = segment.translation;
            let replacedText;

            if (findState.useRegex) {
                 // Create a non-global regex for single replacement
                 const regex = new RegExp(findState.query, findState.caseSensitive ? '' : 'i');
                 replacedText = originalText.substring(0, matchStart) +
                                originalText.substring(matchStart, matchEnd).replace(regex, findState.replace) +
                                originalText.substring(Math.min(matchEnd, originalText.length)); // Ensure substring is within bounds

            } else {
                replacedText = originalText.substring(0, matchStart) +
                               findState.replace +
                               originalText.substring(Math.min(matchEnd, originalText.length)); // Ensure substring is within bounds
            }

            segment.translation = replacedText;
            segment.wordCountTranslation = countWords(replacedText); // Update word count
            segment.isTranslated = replacedText.trim() !== ''; // Update translation status

            renderTranslations(poEntries); // Re-render to update UI
            navigateToTranslation(entryIndex, segmentIndex); // Re-focus and scroll
            updateStatsDisplay(); // Update stats

            // After replacement, clear lastFound to ensure next 'Find' starts fresh,
            // or perform another 'Find Next' to select the next occurrence immediately.
            // For now, clearing seems more straightforward for single replacement.
            findState.lastFound = null;
        }

        function replaceAllMatches() {
            const query = findInput.value;
            const replaceWith = replaceInput.value;
            if (!query) {
                showMessage(translations.es['no_find_query']);
                return;
            }

            let replacedCount = 0;
            let regex;
            try {
                // Ensure global flag 'g' for replaceAll
                regex = new RegExp(query, (caseSensitiveCheckbox.checked ? '' : 'i') + 'g' + (regexCheckbox.checked ? '' : ''));
            } catch (e) {
                showMessage(`Error de expresión regular: ${e.message}`);
                return;
            }

            poEntries.forEach(entry => {
                // Skip header entry
                if (entry.isHeader) {
                    return;
                }

                entry.sentenceSegments.forEach(segment => {
                    let originalTranslation = segment.translation;
                    let newTranslation;

                    if (regexCheckbox.checked) {
                        newTranslation = originalTranslation.replace(regex, replaceWith);
                    } else {
                        // For non-regex, a simple replaceAll (using regex internally with 'g' flag for simplicity)
                        const searchStr = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // Escape query for regex
                        const nonRegexRegex = new RegExp(searchStr, (caseSensitiveCheckbox.checked ? '' : 'i') + 'g');
                        newTranslation = originalTranslation.replace(nonRegexRegex, replaceWith);
                    }

                    if (originalTranslation !== newTranslation) {
                        segment.translation = newTranslation;
                        segment.wordCountTranslation = countWords(newTranslation); // Update word count
                        segment.isTranslated = newTranslation.trim() !== ''; // Update translation status
                        replacedCount++;
                    }
                });
            });

            renderTranslations(poEntries); // Re-render the whole thing to reflect all changes
            showMessage(`${replacedCount} ${translations.es['replaced_all']}`);
            findState.lastFound = null; // Clear last found state after replace all
            updateStatsDisplay(); // Update stats after replace all
        }


        // --- Language Change (now only updates UI texts to Spanish, no actual language switch) ---
        // Removed the language selection mechanism, permanently setting the app to Spanish.
        function setLanguage(lang) {
            // This function is now effectively a no-op for actual language switching,
            // but is kept to trigger UI text updates if needed by existing calls.
            currentLanguage = 'es'; // Ensure it's always Spanish
            updateTextContent();
            renderTranslations(poEntries);
            renderGlossary();
        }

        function updateTextContent() {
            // Helper to safely update text content
            const setTextContent = (id, text) => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = text;
                } else {
                    console.warn(`Element with ID '${id}' not found for textContent update.`);
                }
            };

            // Update title
            document.title = translations.es['title'];

            // Poanda Editor UI
            setTextContent('toolDescription', translations.es['tool_description']);
            setTextContent('loadBtnText', translations.es['load_file']);
            setTextContent('saveBtnText', translations.es['save_file']);
            setTextContent('okBtnText', translations.es['ok']);

            const initialMessageElement = document.getElementById('initialMessage');
            if (initialMessageElement) {
                initialMessageElement.textContent = translations.es['no_translations'];
            }

            // Shortcuts modal content
            setTextContent('shortcutsTitle', translations.es['shortcuts_title']);
            // Special handling for HTML within shortcut list items
            const shortcutValidateElement = document.getElementById('shortcutValidate');
            if(shortcutValidateElement) shortcutValidateElement.innerHTML = `<strong>Ctrl + Enter:</strong> ${translations.es['shortcut_validate'].substring(translations.es['shortcut_validate'].indexOf(':') + 1).trim()}`;

            if(arrowDownIconHtml) arrowDownIconHtml.innerHTML = arrowDownIcon;
            if(arrowUpIconHtml) arrowUpIconHtml.innerHTML = arrowUpIcon;
            const shortcutNextElement = document.getElementById('shortcutNext');
            if(shortcutNextElement) shortcutNextElement.innerHTML = `<strong>Ctrl + ${arrowDownIconHtml.innerHTML}</strong>: ${translations.es['shortcut_next'].substring(translations.es['shortcut_next'].indexOf(':') + 1).trim()}`;
            const shortcutPrevElement = document.getElementById('shortcutPrev');
            if(shortcutPrevElement) shortcutPrevElement.innerHTML = `<strong>Ctrl + ${arrowUpIconHtml.innerHTML}</strong>: ${translations.es['shortcut_prev'].substring(translations.es['shortcut_prev'].indexOf(':') + 1).trim()}`;

            setTextContent('closeBtnText', translations.es['close_btn']);
            setTextContent('shortcutsBtnText', translations.es['shortcuts_btn']);
            const shortcutAlt1Element = document.getElementById('shortcutAlt1');
            if(shortcutAlt1Element) shortcutAlt1Element.innerHTML = `<strong>Alt + [1-5]:</strong> ${translations.es['shortcut_alt_1'].substring(translations.es['shortcut_alt_1'].indexOf(':') + 1).trim()}`;
            const shortcutTmInsertElement = document.getElementById('shortcutTmInsert');
            if(shortcutTmInsertElement) shortcutTmInsertElement.innerHTML = `<strong>Ctrl + Alt + [1-5]:</strong> ${translations.es['shortcut_tm_insert'].substring(translations.es['shortcut_tm_insert'].indexOf(':') + 1).trim()}`;


            // Find/replace modal content
            setTextContent('findReplaceBtnText', translations.es['find_replace_btn']);
            setTextContent('findReplaceTitle', translations.es['find_replace_title']);
            setTextContent('findLabel', translations.es['find_label']);
            setTextContent('replaceLabel', translations.es['replace_label']);
            setTextContent('caseSensitiveText', translations.es['case_sensitive']);
            setTextContent('regexText', translations.es['regular_expression']);
            setTextContent('findPrevText', translations.es['find_prev']);
            setTextContent('findNextText', translations.es['find_next']);
            setTextContent('replaceText', translations.es['replace']);
            setTextContent('replaceAllText', translations.es['replace_all']);
            setTextContent('findReplaceCloseText', translations.es['close_btn']);

            // Terminology Sidebar UI
            setTextContent('terminologyBtnText', translations.es['terminology_btn']);
            setTextContent('terminologySidebarTitle', translations.es['terminology_sidebar_title']);
            setTextContent('configLangTitle', translations.es['config_lang_title']);
            setTextContent('configLangInfo', translations.es['config_lang_info']);
            setTextContent('sourceLanguageLabel', translations.es['source_language']);
            setTextContent('targetLanguageLabel', translations.es['target_language']);
            setTextContent('confirmLanguagesBtn', translations.es['confirm_languages']);
            setTextContent('currentLangTitle', translations.es['current_lang_title']);
            // These should use .value for input fields, not .textContent for labels.
            // document.getElementById('displaySrcLang').value = glossarySourceLanguage; // Already setting this on showGlossaryEditorSection()
            // document.getElementById('displayTgtLang').value = glossaryTargetLanguage; // Already setting this on showGlossaryEditorSection()
            setTextContent('addTermTitleAccordion', translations.es['add_term_title']);
            setTextContent('termLabel', translations.es['term']);
            setTextContent('translationLabel', translations.es['translation']);
            setTextContent('addTermBtn', translations.es['add_button']);
            setTextContent('searchTitle', translations.es['search_title']);
            if (searchTermInput) searchTermInput.placeholder = translations.es['search_placeholder'];
            setTextContent('importTbxBtn', translations.es['import_tbx']);
            setTextContent('downloadTbxBtn', translations.es['download_tbx']);
            setTextContent('newGlossaryBtn', translations.es['new_glossary']);
            setTextContent('glossaryListTitle', translations.es['glossary_list_title']);
            setTextContent('sourceTermCol', translations.es['source_term_col']);
            setTextContent('targetTermCol', translations.es['target_term_col']);
            setTextContent('actionsCol', translations.es['actions_col']);
            // delete_button text is handled in renderGlossary

            // Statistics Accordion Title
            setTextContent('translationStatsTitle', translations.es['translation_stats_title']);

            // Translation Memory Sidebar UI
            setTextContent('tmBtnText', translations.es['tm_btn']);
            setTextContent('tmSidebarTitle', translations.es['tm_sidebar_title']);
            setTextContent('newTmBtn', translations.es['new_tm']);
            setTextContent('importTmxBtnText', translations.es['import_tmx']);
            setTextContent('downloadTmxBtn', translations.es['download_tmx']);
            setTextContent('tmSearchTitle', translations.es['tm_search_title']);
            if (tmSearchInput) tmSearchInput.placeholder = translations.es['tm_search_placeholder'];
            setTextContent('tmSearchResultsTitle', translations.es['tm_search_results_title']);
            setTextContent('tmScoreCol', translations.es['tm_score_col']); /* Updated */
            setTextContent('tmOriginalCol', translations.es['tm_original_col']);
            setTextContent('tmTranslationCol', translations.es['tm_translation_col']);
            // TM suggestion box labels (dynamic, so not here)
            setTextContent('tmConfigLangTitle', translations.es['tm_config_lang_title']);
            setTextContent('tmConfigLangInfo', translations.es['tm_config_lang_info']);
            setTextContent('tmSourceLanguageLabel', translations.es['source_language']);
            setTextContent('tmTargetLanguageLabel', translations.es['target_language']);
            setTextContent('tmConfirmLanguagesBtn', translations.es['confirm_languages']);
            setTextContent('currentTmLangTitle', translations.es['current_tm_lang_title']);
            if (tmInternalMessage) tmInternalMessage.textContent = translations.es['tm_initial_message']; // Set initial message
        }

        /**
         * Adjusts the padding of the main editor content based on open sidebars.
         * Applies only on screens wider than 1024px.
         */
        function updateMainContentOffset() {
            const isTerminologyOpen = terminologySidebar.classList.contains('show-sidebar');
            const isTranslationMemoryOpen = translationMemorySidebar.classList.contains('show-sidebar');

            // Remove existing padding classes first
            if (editorMainContent) { // Added null check for editorMainContent
                editorMainContent.classList.remove('left-sidebar-active', 'right-sidebar-active');

                // Apply new padding classes based on open sidebars
                if (isTerminologyOpen) {
                    editorMainContent.classList.add('left-sidebar-active');
                    // Set CSS variable for current width
                    document.documentElement.style.setProperty('--terminology-sidebar-width', terminologySidebar.offsetWidth + 'px');
                }
                if (isTranslationMemoryOpen) {
                    editorMainContent.classList.add('right-sidebar-active');
                    // Set CSS variable for current width
                    document.documentElement.style.setProperty('--translation-memory-sidebar-width', translationMemorySidebar.offsetWidth + 'px');
                }
            } else {
                console.warn("editorMainContent element not found for offset update.");
            }
        }


        // --- Terminology Sidebar Logic ---
        terminologyBtn.addEventListener('click', () => {
            const isHidden = !terminologySidebar.classList.contains('show-sidebar'); // Check current state
            if (isHidden) {
                terminologySidebar.classList.add('show-sidebar');
            } else {
                terminologySidebar.classList.remove('show-sidebar');
            }
            updateMainContentOffset(); // Update offset
            // When sidebar opens, decide which section to show
            if (isHidden) { // If it was hidden and now shown
                if (!glossarySourceLanguage || !glossaryTargetLanguage) {
                    showLanguageConfigSection(); // Show language config if not set
                } else {
                    showGlossaryEditorSection(); // Show editor if languages are already set
                }
            }
        });

        closeTerminologySidebarBtn.addEventListener('click', () => {
            terminologySidebar.classList.remove('show-sidebar'); // Use show-sidebar
            updateMainContentOffset(); // Update offset
        });

        /**
         * Populates the datalist with ISO language codes.
         */
        function populateIsoLanguagesDatalist() {
            isoLanguagesDatalist.innerHTML = '';
            isoLanguagesData.forEach(lang => {
                const option = document.createElement('option');
                option.value = lang.code;
                option.textContent = lang.name;
                isoLanguagesDatalist.appendChild(option);
            });
        }

        /**
         * Resets the glossary and UI to the initial "New Glossary" state.
         */
        function resetGlossary() {
            glossary = [];
            glossarySourceLanguage = '';
            glossaryTargetLanguage = '';
            if (configSrcLang) configSrcLang.value = 'en-US'; // Added null check
            if (configTgtLang) configTgtLang.value = 'es-ES'; // Added null check
            if (srcTermInput) srcTermInput.value = ""; // Added null check
            if (tgtTermInput) tgtTermInput.value = ""; // Added null check
            if (searchTermInput) searchTermInput.value = ""; // Added null check

            if (terminologyLanguageConfigSection && terminologyEditorSection) { // Added null checks
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }

            renderGlossary(); // Clear table
            renderTranslations(poEntries); // Re-render main editor to remove any old highlights
            updateStatsDisplay(); // Update stats display if glossary reset clears highlighting
        }

        /**
         * Shows the language configuration section and hides others.
         */
        function showLanguageConfigSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection) { // Added null checks
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }
        }

        /**
         * Shows the glossary editor section and hides others.
         */
        function showGlossaryEditorSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection && displaySrcLang && displayTgtLang) { // Added null checks
                terminologyLanguageConfigSection.style.display = 'none';
                terminologyEditorSection.style.display = 'block';
                displaySrcLang.value = glossarySourceLanguage; // Set input value
                displayTgtLang.value = glossaryTargetLanguage; // Set input value
                renderGlossary();
            }
        }

        /**
         * Confirms the glossary's source and target languages from user input.
         * Enables the main editor section if languages are valid.
         */
        function confirmGlossaryLanguages() {
            const srcLang = configSrcLang ? configSrcLang.value.trim() : ''; // Added null check
            const tgtLang = configTgtLang ? configTgtLang.value.trim() : ''; // Added null check

            if (!srcLang || !tgtLang) {
                showMessage(translations.es['lang_config_required']);
                return;
            }

            glossarySourceLanguage = srcLang;
            glossaryTargetLanguage = tgtLang;

            showGlossaryEditorSection(); // Show editor after confirming languages
            renderTranslations(poEntries); // Re-render main editor to apply new highlights based on glossary
        }

        /**
         * Adds a new term to the glossary. Uses the globally configured languages.
         */
        function addTerm() {
            const srcTerm = srcTermInput ? srcTermInput.value.trim() : ''; // Added null check
            const tgtTerm = tgtTermInput ? tgtTermInput.value.trim() : ''; // Added null check

            if (!srcTerm || !tgtTerm) {
                showMessage(translations.es['both_terms_required']);
                return;
            }

            glossary.push({
                srcLang: glossarySourceLanguage,
                srcTerm: srcTerm,
                tgtLang: glossaryTargetLanguage,
                tgtTerm: tgtTerm
            });
            if (srcTermInput) srcTermInput.value = ""; // Added null check
            if (tgtTermInput) tgtTermInput.value = ""; // Added null check
            renderGlossary();
            renderTranslations(poEntries); // Re-render main editor to apply new highlights based on new term
        }

        /**
         * Deletes a term from the glossary at the specified index.
         * @param {number} index - The index of the term to delete.
         */
        function deleteTerm(index) {
            glossary.splice(index, 1);
            renderGlossary();
            renderTranslations(poEntries); // Re-render main editor to update highlights
        }

        /**
         * Renders the glossary table, filtering terms based on the search input.
         */
        function renderGlossary() {
            if (!glossaryTableBody) { // Added null check
                console.warn("glossaryTableBody element not found. Cannot render glossary.");
                return;
            }
            const search = searchTermInput ? searchTermInput.value.toLowerCase() : ''; // Added null check
            glossaryTableBody.innerHTML = "";

            // Filter the glossary first based on the search term
            const filteredGlossary = glossary.filter(entry =>
                (entry.srcTerm && entry.srcTerm.toLowerCase().includes(search)) || // Added null check
                (entry.tgtTerm && entry.tgtTerm.toLowerCase().includes(search)) // Added null check
            );

            const highlightedTerms = [];
            const otherTerms = [];

            // Separate terms into highlighted and non-highlighted groups based on termsFoundInActiveSegment
            filteredGlossary.forEach(entry => {
                if (entry.srcTerm && termsFoundInActiveSegment.has(entry.srcTerm)) { // Added null check
                    highlightedTerms.push(entry);
                } else {
                    otherTerms.push(entry);
                }
            });

            // Combine and sort all glossary results for shortcut access
            currentGlossaryLatestResults = [...highlightedTerms, ...otherTerms.sort((a, b) => a.srcTerm.localeCompare(b.srcTerm))];

            // Render highlighted terms first
            highlightedTerms.forEach((entry, i) => {
                const row = document.createElement("tr");
                row.classList.add('glossary-row-highlight'); // Always highlight these
                row.innerHTML = `
                    <td>${entry.srcTerm}</td>
                    <td>${entry.tgtTerm}</td>
                    <td><button class="glossary-delete-btn" onclick="deleteTerm(${glossary.indexOf(entry)})">${translations.es['delete_button']}</button></td>
                `;
                glossaryTableBody.appendChild(row);
            });

            // Then render other terms
            otherTerms.forEach((entry, i) => {
                const row = document.createElement("tr");
                // No highlight class for these
                row.innerHTML = `
                    <td>${entry.srcTerm}</td>
                    <td>${entry.tgtTerm}</td>
                    <td><button class="glossary-delete-btn" onclick="deleteTerm(${glossary.indexOf(entry)})">${translations.es['delete_button']}</button></td>
                `;
                glossaryTableBody.appendChild(row);
            });
        }

        /**
         * Generates a TBX XML string from the current glossary data.
         * @returns {string} The TBX XML content.
         */
        function generateTBX() {
            const xml = [`<?xml version="1.0" encoding="UTF-8"?>`,
                `<martif type="TBX" xml:lang="${glossarySourceLanguage}">`,
                `  <text>`,
                `    <body>`];

            glossary.forEach(entry => {
                xml.push(`      <termEntry>`);
                xml.push(`        <LangSet xml:lang="${entry.srcLang}">`);
                xml.push(`          <tig><term>${entry.srcTerm}</term></tig>`);
                xml.push(`        </LangSet>`);
                xml.push(`        <LangSet xml:lang="${entry.tgtLang}">`);
                xml.push(`          <tig><term>${entry.tgtTerm}</term></tig>`);
                xml.push(`        </LangSet>`);
                xml.push(`      </termEntry>`);
            });

            xml.push(`    </body>`, `  </text>`, `</martif>`);
            return xml.join("\n");
        }

        /**
         * Triggers a download of the generated TBX XML file.
         */
        function downloadTBX() {
            if (glossary.length === 0 && (!glossarySourceLanguage || !glossaryTargetLanguage)) {
                showMessage(translations.es['cannot_download_empty_or_unconfigured_glossary']);
                return;
            }
            showLoadingOverlay(translations.es['saving_file']);
            try {
                const blob = new Blob([generateTBX()], { type: "application/xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "glossary.tbx";
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(url);
                showMessage(translations.es['file_saved_successfully']); // Reuse generic save success message
            } catch (error) {
                showMessage(`${translations.es['error_saving_file']} ${error.message}`);
                console.error("Error downloading TBX:", error);
            } finally {
                hideLoadingOverlay();
            }
        }

        /**
         * Loads TBX data from a user-selected XML/TBX file.
         * Parses the XML and updates the glossary array and sets glossary languages.
         */
        function loadTBX() {
            if (!tbxFileInput) { // Added null check
                console.warn("tbxFileInput element not found. Cannot load TBX.");
                return;
            }
            tbxFileInput.click(); // Trigger file input click
            tbxFileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                showLoadingOverlay(translations.es['loading_file']);
                try {
                    const reader = new FileReader();
                    await new Promise((resolve, reject) => {
                        reader.onload = () => {
                            try {
                                const parser = new DOMParser();
                                const xmlDoc = parser.parseFromString(reader.result, "application/xml");

                                // Check for XML parsing errors
                                if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                                    const errorText = xmlDoc.getElementsByTagName("parsererror")[0].textContent;
                                    console.error("Error parsing XML:", errorText);
                                    throw new Error("Invalid XML/TBX format: " + errorText);
                                }

                                // --- New: Check if it's a TMX file instead of TBX ---
                                if (xmlDoc.getElementsByTagName("tu").length > 0) {
                                    showTMInternalMessage(translations.es['tbx_file_expected_tmx_found'], true);
                                    reject(new Error("Attempted to load TMX into Glossary.")); // Reject to stop process
                                    return;
                                }
                                // --- End New Check ---

                                const entries = xmlDoc.getElementsByTagName("termEntry");

                                glossary = [];
                                let firstEntryLangs = { src: '', tgt: '' };

                                if (entries.length > 0) {
                                    const firstSets = entries[0].getElementsByTagName("LangSet");
                                    if (firstSets.length >= 2) {
                                        firstEntryLangs.src = firstSets[0].getAttribute("xml:lang");
                                        firstEntryLangs.tgt = firstSets[1].getAttribute("xml:lang"); // Corrected to use firstSets[1] for target language
                                    }
                                }

                                for (let entry of entries) {
                                    const sets = entry.getElementsByTagName("LangSet");
                                    if (sets.length >= 2) { // Ensure there are at least two LangSet elements
                                        const lang1 = sets[0].getAttribute("xml:lang");
                                        const term1 = sets[0].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                                        const lang2 = sets[1].getAttribute("xml:lang");
                                        const term2 = sets[1].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                                        glossary.push({ srcLang: lang1, srcTerm: term1, tgtLang: lang2, tgtTerm: term2 });
                                    }
                                }

                                if (glossary.length > 0 && firstEntryLangs.src && firstEntryLangs.tgt) {
                                    glossarySourceLanguage = firstEntryLangs.src;
                                    glossaryTargetLanguage = firstEntryLangs.tgt;
                                } else if (glossary.length === 0) { // If no entries found but parsed, might be empty or malformed TBX
                                    showMessage(translations.es['error_loading_tbx_file']); // Generic parsing error for TBX
                                }
                                // No longer showing specific message for no valid language pairs if glossary.length is 0

                                showGlossaryEditorSection(); // Show editor after loading
                                renderTranslations(poEntries); // Re-render main editor to apply new highlights
                                resolve();
                            } catch (error) {
                                reject(error);
                            }
                        };
                        reader.onerror = reject;
                        reader.readAsText(file);
                    });
                } catch (error) {
                    console.error("Error loading TBX file:", error);
                    // Check if the error was from the TMX check, otherwise show generic TBX error
                    if (error.message.includes("Attempted to load TMX")) {
                        // Message already shown by the TMX check
                    } else {
                        showMessage(translations.es['error_loading_tbx_file']);
                    }
                    resetGlossary(); // Reset to config state on error
                } finally {
                    hideLoadingOverlay();
                }
            };
        }

        // --- Translation Memory (TM) Logic ---

        // Levenshtein distance function for fuzzy matching
        function levenshteinDistance(a, b) {
            const an = a.length;
            const bn = b.length;
            if (an === 0) return bn;
            if (bn === 0) return an;

            const matrix = [];

            // increment along the first column of each row
            for (let i = 0; i <= bn; i++) {
                matrix[i] = [i];
            }

            // increment each column in the first row
            for (let j = 0; j <= an; j++) {
                matrix[0][j] = j;
            }

            // Fill in the rest of the matrix
            for (let i = 1; i <= bn; i++) {
                for (let j = 1; j <= an; j++) {
                    const cost = (a[j - 1] === b[i - 1]) ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1, // deletion
                        matrix[i][j - 1] + 1, // insertion
                        matrix[i - 1][j - 1] + cost // substitution
                    );
                }
            }
            return matrix[bn][an];
        }

        // Calculate similarity percentage based on Levenshtein distance
        function calculateSimilarity(s1, s2) {
            if (!s1 || !s2) return 0;
            const longerLength = Math.max(s1.length, s2.length);
            if (longerLength === 0) return 100;
            const distance = levenshteinDistance(s1, s2);
            return ((longerLength - distance) / longerLength) * 100;
        }


        tmBtn.addEventListener('click', () => {
            const isHidden = !translationMemorySidebar.classList.contains('show-sidebar'); // Check current state
            if (isHidden) {
                translationMemorySidebar.classList.add('show-sidebar');
            } else {
                translationMemorySidebar.classList.remove('show-sidebar');
            }
            updateMainContentOffset(); // Update offset
            // When sidebar opens, decide which section to show
            if (isHidden) { // If it was hidden and now shown
                if (!tmSourceLanguage || !tmTargetLanguage) {
                    showTMLanguageConfigSection(); // Show language config if not set
                } else {
                    showTMEditorSection(); // Show editor if languages are already set
                    tmSearch(); // Perform initial search when opening
                }
            }
        });

        closeTranslationMemorySidebarBtn.addEventListener('click', () => {
            translationMemorySidebar.classList.remove('show-sidebar'); // Use show-sidebar
            updateMainContentOffset(); // Update offset
        });

        tmFileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                await loadTMX(file);
            }
        });

        /**
         * Displays an internal message within the TM sidebar.
         * @param {string} msg The message to display.
         * @param {boolean} isError If true, styles the message as an error.
         */
        function showTMInternalMessage(msg, isError = false) {
            if (tmInternalMessage) { // Added null check
                tmInternalMessage.textContent = msg;
                tmInternalMessage.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'border-red-500', 'bg-blue-100', 'text-blue-800', 'border-blue-500'); // Clear previous styles
                if (isError) {
                    tmInternalMessage.classList.add('bg-red-100', 'text-red-800', 'border-red-500');
                } else {
                    tmInternalMessage.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-500'); // Default info style
                }
                tmInternalMessage.classList.remove('hidden');
            } else {
                console.warn("tmInternalMessage element not found.");
            }
        }

        /**
         * Hides the internal TM message.
         */
        function hideTMInternalMessage() {
            if (tmInternalMessage) { // Added null check
                tmInternalMessage.classList.add('hidden');
                tmInternalMessage.textContent = '';
            }
        }

        /**
         * Resets the translation memory.
         */
        function resetTM() {
            translationMemory = [];
            tmSourceLanguage = '';
            tmTargetLanguage = '';
            if (tmSearchInput) tmSearchInput.value = ''; // Added null check
            renderTMSearchResults([]); // Clear search results table
            // Show config section for new TM
            showTMLanguageConfigSection();
            showTMInternalMessage(translations.es['tm_initial_message']); // Inform user TM is empty
        }

        /**
         * Shows the TM language configuration section and hides others.
         */
        function showTMLanguageConfigSection() {
            if (tmLanguageConfigSection && tmEditorSection) { // Added null checks
                tmLanguageConfigSection.style.display = 'block';
                tmEditorSection.style.display = 'none';
                // Reset config inputs to default values for a new setup
                if (tmConfigSrcLang) tmConfigSrcLang.value = 'en-US'; // Added null check
                if (tmConfigTgtLang) tmConfigTgtLang.value = 'es-ES'; // Added null check
                hideTMInternalMessage(); // Clear message when showing config
            }
        }

        /**
         * Shows the TM editor section and hides others.
         */
        function showTMEditorSection() {
            if (tmLanguageConfigSection && tmEditorSection && displayTmSrcLang && displayTmTgtLang) { // Added null checks
                tmLanguageConfigSection.style.display = 'none';
                tmEditorSection.style.display = 'block';
                displayTmSrcLang.value = tmSourceLanguage;
                displayTmTgtLang.value = tmTargetLanguage;
                tmSearch(); // Perform initial search when opening
                hideTMInternalMessage(); // Clear message when showing editor
            }
        }

        /**
         * Confirms the TM's source and target languages from user input.
         * Enables the main TM editor section if languages are valid.
         */
        function confirmTMLanguages() {
            const srcLang = tmConfigSrcLang ? tmConfigSrcLang.value.trim() : ''; // Added null check
            const tgtLang = tmConfigTgtLang ? tmConfigTgtLang.value.trim() : ''; // Added null check

            if (!srcLang || !tgtLang) {
                showTMInternalMessage(translations.es['lang_config_required'], true); // Show error message
                return;
            }

            tmSourceLanguage = srcLang;
            tmTargetLanguage = tgtLang;

            showTMEditorSection(); // Show editor after confirming languages
            // No need to renderTranslations or updateStats here, as it's not directly affected by TM language change.
        }

        /**
         * Parses a TMX file content and populates the translationMemory array.
         * @param {File} file The TMX file object.
         */
        async function loadTMX(file) {
            showLoadingOverlay(translations.es['loading_file']);
            hideTMInternalMessage(); // Hide any previous internal message

            try {
                const reader = new FileReader();
                await new Promise((resolve, reject) => {
                    reader.onload = () => {
                        try {
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(reader.result, "application/xml");

                            if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                                const errorText = xmlDoc.getElementsByTagName("parsererror")[0].textContent;
                                console.error("Error parsing XML:", errorText);
                                throw new Error("Invalid XML/TMX format: " + errorText);
                            }

                            // --- New: Check if it's a TBX file instead of TMX ---
                            if (xmlDoc.getElementsByTagName("termEntry").length > 0) {
                                showTMInternalMessage(translations.es['tmx_file_expected_tbx_found'], true);
                                reject(new Error("Attempted to load TBX into Translation Memory.")); // Reject to stop process
                                return;
                            }
                            // --- End New Check ---

                            const tuElements = xmlDoc.getElementsByTagName("tu");
                            let newTM = [];
                            let detectedSrcLang = '';
                            let detectedTgtLang = '';

                            // Try to detect source and target languages from the first tu
                            if (tuElements.length > 0) {
                                const tuvElements = tuElements[0].getElementsByTagName("tuv");
                                if (tuvElements.length >= 2) {
                                    detectedSrcLang = tuvElements[0].getAttribute("xml:lang");
                                    detectedTgtLang = tuvElements[1].getAttribute("xml:lang");
                                }
                            }

                            for (let tu of tuElements) {
                                const tuvElements = tu.getElementsByTagName("tuv");
                                if (tuvElements.length >= 2) {
                                    const srcTuv = tuvElements[0];
                                    const tgtTuv = tuvElements[1];
                                    const srcLang = srcTuv.getAttribute("xml:lang");
                                    const tgtLang = tgtTuv.getAttribute("xml:lang");
                                    const srcSeg = srcTuv.getElementsByTagName("seg")[0]?.textContent || '';
                                    const tgtSeg = tgtTuv.getElementsByTagName("seg")[0]?.textContent || '';

                                    newTM.push({
                                        srcLang: srcLang,
                                        srcText: srcSeg,
                                        tgtLang: tgtLang,
                                        tgtText: tgtSeg,
                                        srcWordCount: countWords(srcSeg),
                                        tgtWordCount: countWords(tgtSeg)
                                    });
                                }
                            }

                            translationMemory = newTM;
                            tmSourceLanguage = detectedSrcLang || (tmConfigSrcLang ? tmConfigSrcLang.value : 'en-US'); // Fallback to current config input
                            tmTargetLanguage = detectedTgtLang || (tmConfigTgtLang ? tmConfigTgtLang.value : 'es-ES'); // Fallback to current config input

                            showTMInternalMessage(`TMX cargado con ${translationMemory.length} unidades de traducción.`);
                            showTMEditorSection(); // Show editor section
                            tmSearch(); // Refresh TM search results
                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            } catch (error) {
                console.error("Error loading TMX file:", error);
                // Check if the error was from the TBX check, otherwise show generic TMX error
                if (error.message.includes("Attempted to load TBX")) {
                    // Message already shown by the TBX check
                } else {
                    showTMInternalMessage(translations.es['error_loading_tmx_file'], true); // Show error message
                }
                resetTM(); // Reset to config state on error
            } finally {
                hideLoadingOverlay();
            }
        }

        /**
         * Generates a TMX XML string from the current translation memory data.
         * @returns {string} The TMX XML content.
         */
        function generateTMX() {
            if (translationMemory.length === 0) {
                showTMInternalMessage(translations.es['cannot_download_empty_tm'], true); // Show error message
                return null;
            }

            const header = `<?xml version="1.0" encoding="UTF-8"?>
<tmx version="1.4">
  <header creationtool="Poanda" creationtoolversion="1.0"
          datatype="unknown" segtype="sentence" changeid="PoandaUser"
          srclang="${tmSourceLanguage || 'en-US'}" o-tmf="Poanda"
          adminlang="en-US" `;

            // If a target language is explicitly set, add it. Otherwise, TMX supports multiple targets.
            const targetLangAttr = tmTargetLanguage ? `targetlang="${tmTargetLanguage}"` : '';

            const xml = [header + targetLangAttr + `>
  </header>
  <body>`];

            translationMemory.forEach(entry => {
                xml.push(`    <tu>
      <tuv xml:lang="${entry.srcLang}"><seg>${entry.srcText}</seg></tuv>
      <tuv xml:lang="${entry.tgtLang}"><seg>${entry.tgtText}</seg></tuv>
    </tu>`);
            });

            xml.push(`  </body>
</tmx>`);
            return xml.join("\n");
        }

        /**
         * Triggers a download of the generated TMX XML file.
         */
        function downloadTMX() {
            const tmxContent = generateTMX();
            if (!tmxContent) return; // generateTMX already shows message if empty

            showLoadingOverlay(translations.es['saving_file']);
            try {
                const blob = new Blob([tmxContent], { type: "application/xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "translation_memory.tmx";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showTMInternalMessage(translations.es['file_saved_successfully']); // Reuse generic save success message
            } catch (error) {
                showTMInternalMessage(`${translations.es['error_saving_file']} ${error.message}`, true); // Show error message
                console.error("Error downloading TMX:", error);
            } finally {
                hideLoadingOverlay();
            }
        }

        /**
         * Adds or updates an entry in the translation memory.
         * @param {string} original The original segment text.
         * @param {string} translation The translated segment text.
         */
        function addOrUpdateTMEntry(original, translation) {
            if (!original || !translation) return; // Only add valid pairs
            if (!tmSourceLanguage || !tmTargetLanguage) {
                console.warn("TM languages not configured. Skipping TM update.");
                return; // Cannot add/update without configured languages
            }

            const existingIndex = translationMemory.findIndex(
                entry => entry.srcText === original && entry.srcLang === tmSourceLanguage && entry.tgtLang === tmTargetLanguage
            );

            if (existingIndex !== -1) {
                // Update existing entry
                translationMemory[existingIndex].tgtText = translation;
                translationMemory[existingIndex].tgtWordCount = countWords(translation);
            } else {
                // Add new entry
                translationMemory.push({
                    srcLang: tmSourceLanguage,
                    srcText: original,
                    tgtLang: tmTargetLanguage,
                    tgtText: translation,
                    srcWordCount: countWords(original),
                    tgtWordCount: countWords(translation)
                });
            }
            tmSearch(); // Re-render TM search results to reflect changes
        }

        /**
         * Finds the best matching TM entry for a given source segment.
         * @param {string} sourceSegmentText The text of the current source segment.
         * @returns {Object|null} The best matching TM entry with a score, or null if no match >= 70%.
         */
        function findBestTMMatch(sourceSegmentText) {
            if (translationMemory.length === 0 || !sourceSegmentText.trim() || !tmSourceLanguage || !tmTargetLanguage) {
                return null; // Return null if no TM data or languages not configured
            }

            let bestMatch = null;
            let highestScore = 0;
            const MIN_FUZZY_THRESHOLD = 70; // 70% threshold

            translationMemory.forEach(entry => {
                // Only compare if languages match and source text is available
                if (entry.srcLang === tmSourceLanguage && entry.tgtLang === tmTargetLanguage && entry.srcText.trim()) {
                    const score = calculateSimilarity(sourceSegmentText, entry.srcText);
                    if (score >= MIN_FUZZY_THRESHOLD && score > highestScore) {
                        highestScore = score;
                        bestMatch = { ...entry, score: score.toFixed(0) }; // Store score with entry
                    }
                }
            });

            return bestMatch;
        }

        /**
         * Performs a search on the translation memory and renders results.
         * Integrates best match for active segment.
         */
        function tmSearch() {
            const query = tmSearchInput ? tmSearchInput.value.toLowerCase().trim() : ''; // Added null check
            let resultsToRender = [];

            // Get the current active segment's original text
            const currentFocused = getCurrentFocusedIndex();
            let activeSegmentOriginalText = null;
            if (currentFocused && poEntries[currentFocused.entryIndex] && poEntries[currentFocused.entryIndex].sentenceSegments && poEntries[currentFocused.entryIndex].sentenceSegments[currentFocused.segmentIndex]) { // Added null checks
                activeSegmentOriginalText = poEntries[currentFocused.entryIndex].sentenceSegments[currentFocused.segmentIndex].original;
            }

            // Find the best match for the active segment if any
            tmBestMatchForActiveSegment = null; // Reset global best match
            if (activeSegmentOriginalText) {
                tmBestMatchForActiveSegment = findBestTMMatch(activeSegmentOriginalText);
            }

            // If there's a best match for the active segment AND no specific search query is entered,
            // or if the search query matches the best match exactly, display it as the primary result.
            // This prioritizes the segment-focused match over general search if applicable.
            if (tmBestMatchForActiveSegment && (query === '' || tmBestMatchForActiveSegment.srcText.toLowerCase().includes(query))) {
                resultsToRender.push({ ...tmBestMatchForActiveSegment, isBestMatch: true });
            }


            // Filter the entire TM based on the search query
            const filteredTM = translationMemory.filter(entry => {
                // Exclude the best match if it's already added as the primary result AND
                // it matches the primary result that's already in `resultsToRender`
                if (tmBestMatchForActiveSegment && entry.srcText === tmBestMatchForActiveSegment.srcText && entry.tgtText === tmBestMatchForActiveSegment.tgtText) {
                    return false;
                }
                // Filter by query if a query is present
                if (query) {
                    return (entry.srcText && entry.srcText.toLowerCase().includes(query)) ||
                           (entry.tgtText && entry.tgtText.toLowerCase().includes(query));
                }
                return true; // If no query, include all remaining entries
            });

            // Add filtered results. Calculate score against search query if query exists.
            filteredTM.forEach(entry => {
                let score = 0;
                if (query) {
                    score = calculateSimilarity(query, entry.srcText); // Score against the actual search query
                } else if (activeSegmentOriginalText) {
                    score = calculateSimilarity(activeSegmentOriginalText, entry.srcText); // Score against active segment if no query
                }
                resultsToRender.push({ ...entry, score: score.toFixed(0) });
            });

            // Sort the search results (excluding the active best match if it's already first)
            // Sort by score (descending) first, then alphabetically by source text for consistency
            resultsToRender.sort((a, b) => {
                // Ensure best match stays at top if it was intentionally placed there
                if (a.isBestMatch) return -1;
                if (b.isBestMatch) return 1;
                
                if (b.score !== a.score) {
                    return b.score - a.score; // Higher score first
                }
                return a.srcText.localeCompare(b.srcText); // Alphabetical secondary sort
            });

            currentTMLatestSearchResults = resultsToRender; // Store for shortcut
            renderTMSearchResults(resultsToRender);
        }


        /**
         * Renders the TM search results in the table.
         * @param {Array<Object>} results Array of TM entries to display.
         */
        function renderTMSearchResults(results) {
            if (!tmSearchResultsTableBody) { // Added null check for tmSearchResultsTableBody
                console.warn("tmSearchResultsTableBody element not found. Cannot render TM search results.");
                return;
            }
            tmSearchResultsTableBody.innerHTML = '';
            if (results.length === 0) {
                if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.remove('hidden'); // Added null check
                // If there's an internal message (e.g., "no data"), don't override it.
                // Otherwise, show "no results" message.
                if (tmInternalMessage && tmInternalMessage.classList.contains('hidden')) { // Added null check
                    if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.remove('hidden'); // Added null check
                }
                return;
            } else {
                if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.add('hidden'); // Added null check
            }
            hideTMInternalMessage(); // Hide general internal message once results are shown

            results.forEach(entry => {
                const row = document.createElement('tr');
                // Apply green highlight if it's the best match for the active segment
                if (entry.isBestMatch) {
                    row.classList.add('tm-best-match-highlight'); // Tailwind green colors for highlight
                }
                row.innerHTML = `
                    <td>${entry.score}%</td>
                    <td><pre class="whitespace-pre-wrap">${entry.srcText}</pre></td>
                    <td><pre class="whitespace-pre-wrap">${entry.tgtText}</pre></td>
                `;
                // Add click listener to insert the translation from this row
                row.addEventListener('click', () => {
                    const currentFocused = getCurrentFocusedIndex();
                    if (currentFocused) {
                        const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                        if (targetTextarea && !targetTextarea.readOnly) {
                            targetTextarea.value = entry.tgtText;
                            // Trigger input event manually to update stats and char counts
                            const event = new Event('input', { bubbles: true });
                            targetTextarea.dispatchEvent(event);
                        }
                    }
                });
                tmSearchResultsTableBody.appendChild(row);
            });
        }


        // --- Loading Overlay Functions ---
        function showLoadingOverlay(message) {
            if (loadingMessage && loadingOverlay) { // Added null checks
                loadingMessage.textContent = message;
                loadingOverlay.classList.remove('hidden');
            }
        }

        function hideLoadingOverlay() {
            if (loadingOverlay) { // Added null check
                loadingOverlay.classList.add('hidden');
            }
        }

        // --- Drag and Drop functionality ---
        if (dropArea) { // Added null check
            dropArea.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.add('border-blue-500'); // Visual feedback for drag over
            });

            dropArea.addEventListener('dragleave', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-blue-500');
            });

            dropArea.addEventListener('drop', async (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-blue-500');

                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    const poFileToProcess = Array.from(files).find(file => file.name.toLowerCase().endsWith('.po'));
                    if (poFileToProcess) {
                        await processFile(poFileToProcess);
                    } else {
                        showMessage('Por favor, suelta un archivo .po válido.');
                    }
                }
            });
        }

        // --- Accordion Logic for Add Term ---
        if (addTermHeader && addTermContent && addTermAccordionIcon) {
            addTermHeader.addEventListener('click', () => {
                const isCollapsed = addTermContent.classList.contains('collapsed');
                if (isCollapsed) {
                    addTermContent.classList.remove('collapsed');
                    addTermContent.classList.add('expanded');
                    addTermAccordionIcon.classList.remove('rotated');
                } else {
                    addTermContent.classList.remove('expanded');
                    addTermContent.classList.add('collapsed');
                    addTermAccordionIcon.classList.add('rotated');
                }
            });
        }

        // --- Accordion Logic for Stats ---
        if (statsAccordionHeader && statsAccordionContent && statsAccordionIcon) {
            statsAccordionHeader.addEventListener('click', () => {
                const isCollapsed = statsAccordionContent.classList.contains('collapsed');
                if (isCollapsed) {
                    statsAccordionContent.classList.remove('collapsed');
                    statsAccordionContent.classList.add('expanded');
                    statsAccordionIcon.classList.remove('rotated');
                } else {
                    statsAccordionContent.classList.remove('expanded');
                    statsAccordionContent.classList.add('collapsed');
                    statsAccordionIcon.classList.add('rotated');
                }
            });
        }

        /**
         * Adjusts the padding of the main editor content based on open sidebars.
         * Applies only on screens wider than 1024px.
         */
        function updateMainContentOffset() {
            const isTerminologyOpen = terminologySidebar.classList.contains('show-sidebar');
            const isTranslationMemoryOpen = translationMemorySidebar.classList.contains('show-sidebar');

            // Remove existing padding classes first
            if (editorMainContent) { // Added null check for editorMainContent
                editorMainContent.classList.remove('left-sidebar-active', 'right-sidebar-active');

                // Apply new padding classes based on open sidebars
                if (isTerminologyOpen) {
                    editorMainContent.classList.add('left-sidebar-active');
                    // Set CSS variable for current width
                    document.documentElement.style.setProperty('--terminology-sidebar-width', terminologySidebar.offsetWidth + 'px');
                }
                if (isTranslationMemoryOpen) {
                    editorMainContent.classList.add('right-sidebar-active');
                    // Set CSS variable for current width
                    document.documentElement.style.setProperty('--translation-memory-sidebar-width', translationMemorySidebar.offsetWidth + 'px');
                }
            } else {
                console.warn("editorMainContent element not found for offset update.");
            }
        }


        // --- Initialization on page load ---
        document.addEventListener('DOMContentLoaded', () => {
            populateIsoLanguagesDatalist();
            // currentLanguage is now permanently 'es'
            updateTextContent(); // Apply initial language and content
            resetGlossary(); // Start in the new glossary configuration mode (first step)
            resetTM(); // Initialize TM - this will now show the language config for TM and its initial message
            // Initial renderTranslations will happen when a file is loaded or on a new glossary to clear previous content.
            // For first load, we ensure the "no_translations" message is shown.
            if (translationsContainer) { // Added null check
                translationsContainer.innerHTML = `
                    <div data-i18n="no_translations" id="initialMessage" class="text-center text-on-light-contrast p-4 border border-gray-300 rounded-md">
                        ${translations.es['no_translations']}
                    </div>
                `;
            }
            if (savePoButton) savePoButton.disabled = true; // Added null check
            if (statsContainer) statsContainer.classList.add('hidden'); // Added null check

            // Ensure accordions are collapsed on initial load
            if (addTermContent && addTermAccordionIcon) {
                addTermContent.classList.add('collapsed');
                addTermContent.classList.remove('expanded');
                addTermAccordionIcon.classList.remove('rotated'); // Ensure it's not rotated initially
            }
            if (statsAccordionContent && statsAccordionIcon) {
                statsAccordionContent.classList.add('collapsed');
                statsAccordionContent.classList.remove('expanded');
                statsAccordionIcon.classList.add('rotated'); // Ensure it's rotated (closed) initially
            }
            // Ensure TM sidebar is hidden initially
            if (translationMemorySidebar) translationMemorySidebar.classList.remove('show-sidebar'); // Added null check

            updateMainContentOffset(); // Set initial padding based on hidden state of sidebars
        });
    </script>
</body>
</html>
