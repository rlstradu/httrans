<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">Poanda</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/diff@5.0.0/dist/diff.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- THEME COLORS --- */
        :root {
            --color-primary: #F48790; /* Pink */
            --color-secondary: #F7CF7E; /* Yellow */
            --color-dark: #373737; /* Dark Gray */
            --color-light-gray: #f3f4f6;
            --color-white: #ffffff;
            --color-medium-gray: #e5e7eb;
            --color-neutral-gray: #6b7280;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--color-light-gray);
            color: var(--color-dark);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        textarea {
            resize: vertical;
            overflow-y: hidden;
        }
        pre {
            white-space: pre-wrap;
            overflow-wrap: break-word;
        }
        .check-icon {
            display: none;
            margin-left: 8px;
            vertical-align: middle;
            width: 20px;
            height: 20px;
            color: #22c55e;
        }
        /* --- THEMED BUTTONS --- */
        .btn-load, .btn-edit { background-color: var(--color-primary); color: var(--color-dark); }
        .btn-load:hover, .btn-edit:hover { background-color: #e07a82; transform: scale(1.02); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        
        .btn-save, .btn-validate { background-color: var(--color-secondary); color: var(--color-dark); }
        .btn-save:hover, .btn-validate:hover { background-color: #e3b76e; transform: scale(1.02); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        
        .btn-convert-mo { background-color: var(--color-dark); color: var(--color-white); }
        .btn-convert-mo:hover { background-color: #555555; transform: scale(1.02); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        
        /* --- MODAL BUTTONS --- */
        .btn-modal-primary { background-color: var(--color-primary); color: var(--color-dark); }
        .btn-modal-primary:hover { background-color: #e07a82; }
        .btn-modal-secondary { background-color: var(--color-secondary); color: var(--color-dark); }
        .btn-modal-secondary:hover { background-color: #e3b76e; }
        .btn-modal-dark { background-color: var(--color-dark); color: var(--color-white); }
        .btn-modal-dark:hover { background-color: #555555; }
        .btn-modal-neutral { background-color: var(--color-medium-gray); color: var(--color-dark); }
        .btn-modal-neutral:hover { background-color: #d1d5db; }
        
        .po-display-code { background-color: var(--color-medium-gray); border: 1px solid #d1d5db; color: var(--color-dark); }
        .msgstr-textarea { background-color: var(--color-white); color: var(--color-dark); min-height: 80px; }
        .translation-unit-bg { background-color: var(--color-white); border-color: var(--color-medium-gray); }
        .text-on-light-contrast { color: var(--color-dark); }
        .translation-row { display: flex; flex-direction: column; gap: 1rem; }
        @media (min-width: 768px) {
            .translation-row { flex-direction: row; }
            .original-col, .translation-col { flex: 1; }
        }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--color-white); padding: 2rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); max-width: 90%; width: 500px;  position: relative; }
 #findReplaceModal .modal-content { width: 650px; max-width: 95%; }
        #shortcutsModal .modal-content { width: 550px; max-width: 95%; }
        .shortcut-icon { display: inline-block; width: 1em; height: 1em; vertical-align: middle; margin: 0 4px; }
        .main-editor-layout { display: flex; flex-direction: column; gap: 1rem; width: 100%; }
        @media (min-width: 1024px) {
            .main-editor-layout { flex-direction: row; }
            #central-column { flex: 2; }
            .terminology-sidebar, .translation-memory-sidebar { min-width: 300px; max-width: 400px; }
        }
        .sidebar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; cursor: move; user-select: none; }
        .sidebar-content { height: calc(100% - 60px); overflow-y: auto; padding-right: 0.5rem; }
        .glossary-input-group label, .tm-input-group label { white-space: nowrap; }
        .glossary-input-group input, .glossary-input-group select, .tm-input-group input, .tm-input-group select { width: 100%; padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9rem; margin-top: 4px; color: var(--color-dark); background-color: var(--color-white); }
        .glossary-btn-primary, .tm-btn-primary { background-color: var(--color-primary); color: var(--color-dark); padding: 8px 15px; border-radius: 5px; transition: background-color 0.2s; }
        .glossary-btn-primary:hover, .tm-btn-primary:hover { background-color: #e07a82; }
        .glossary-btn-secondary, .tm-btn-secondary { background-color: #e0e0e0; color: #333; padding: 8px 15px; border-radius: 5px; transition: background-color 0.2s; }
        .glossary-btn-secondary:hover, .tm-btn-secondary:hover { background-color: #d0d0d0; }
        .glossary-delete-btn, .tm-delete-btn { background-color: #f44336; color: white; padding: 6px 12px; border-radius: 4px; font-size: 0.85rem; }
        .glossary-delete-btn:hover, .tm-delete-btn:hover { background-color: #da190b; }
        .glossary-table th, .glossary-table td, .tm-table th, .tm-table td { padding: 8px 12px; border: 1px solid #e0e0e0; font-size: 0.9rem; }
        .glossary-table th, .tm-table th { background-color: #f0f0f0; font-weight: 600; }
        
        .tm-table {
            table-layout: fixed;
            width: 100%;
        }

        .glossary-info-box, .tm-info-box { background-color: #fef3c7; border: 1px solid var(--color-secondary); padding: 10px; border-radius: 6px; font-size: 0.85rem; color: var(--color-dark); }
        .glossary-highlight { background-color: var(--color-secondary); padding: 0 2px; border-radius: 3px; }
        .glossary-row-highlight { background-color: #fde68a !important; transition: background-color 0.3s ease; }
        .translation-unit-active { border: 2px solid var(--color-primary); box-shadow: 0 0 0 3px rgba(244, 135, 144, 0.25); }
        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1001; font-size: 1.2rem; color: #333; }
        .loading-spinner { border: 4px solid #f3f3f3; border-top: 4px solid var(--color-primary); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .tm-table th:nth-child(1), .tm-table td:nth-child(1) { width: 70px; text-align: center; }
.tm-table th:nth-child(2), .tm-table td:nth-child(2) { width: 50%; }
.tm-table th:nth-child(3), .tm-table td:nth-child(3) { width: 50%; }
        .tm-best-match-highlight { background-color: #fce7f3 !important; border-color: var(--color-primary) !important; border-width: 2px; box-shadow: 0 0 0 3px rgba(244, 135, 144, 0.25); }
        #dropArea { width: 100%; max-width: 90%; transition: none; }
        .terminology-sidebar, .translation-memory-sidebar { 
            position: fixed; 
            top: 60px; 
            bottom: 20px; 
            width: 350px; 
            z-index: 500; 
            background-color: var(--color-white); 
            border: 1px solid var(--color-medium-gray); 
            border-radius: 0.5rem; 
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); 
            transition: opacity 0.3s ease-in-out; 
            opacity: 0; 
            pointer-events: none; 
            overflow: hidden;
            min-width: 300px; 
            max-width: 80vw;
            min-height: 200px;
            max-height: 90vh;
        }
        .terminology-sidebar { left: 1rem; transform: translateX(-110%); }
        .terminology-sidebar.show-sidebar { transform: translateX(0); opacity: 1; pointer-events: all; }
        .translation-memory-sidebar { right: 1rem; transform: translateX(110%); }
        .translation-memory-sidebar.show-sidebar { transform: translateX(0); opacity: 1; pointer-events: all; }
        
        #central-column { padding-left: 1rem; padding-right: 1rem; transition: padding-left 0.3s ease-in-out, padding-right 0.3s ease-in-out; }
        .translations-container-scrolling { max-height: calc(70vh - 50px); overflow-y: auto; } /* Adjusted height */

        @media (min-width: 1024px) {
            #central-column.left-sidebar-active { padding-left: calc(var(--terminology-sidebar-width, 350px) + 2rem); }
            #central-column.right-sidebar-active { padding-right: calc(var(--translation-memory-sidebar-width, 350px) + 2rem); }
        }
        .po-display-code, .msgstr-textarea { font-size: 1rem; }
        .top-utility-buttons-container { position: absolute; top: 4px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; justify-content: center; gap: 0.75rem; min-width: 400px; }
        .top-utility-buttons-container button, .top-utility-buttons-container .dropdown-btn { font-size: 0.875rem; white-space: nowrap; padding-left: 0.75rem; padding-right: 0.75rem; background-color: var(--color-white); color: var(--color-dark); border: 1px solid #d1d5db; }
        .top-utility-buttons-container button:hover, .top-utility-buttons-container .dropdown-btn:hover { background-color: #f9fafb; }
        .utility-btn-active { background-color: var(--color-dark) !important; color: var(--color-white) !important; border-color: var(--color-dark) !important; }
        .dropdown { position: relative; display: inline-block; }
        .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 1; border-radius: 0.375rem; }
        .dropdown-content a { color: black; padding: 12px 16px; text-decoration: none; display: block; font-size: 0.875rem; }
        .dropdown-content a:hover { background-color: #f1f1f1; cursor: pointer; }
        .dropdown:hover .dropdown-content { display: block; }
        .dropdown:hover .dropdown-btn { background-color: #f9fafb; }
        #statsContainer { transform: translateY(100%); transition: transform 0.3s ease-in-out; }
        #statsContainer.show { transform: translateY(0); }
        .diff-added { background-color: #e6ffed; color: #22863a; padding: 1px 2px; border-radius: 3px; }
        .diff-removed { background-color: #ffebe9; color: #b31d28; text-decoration: line-through; padding: 1px 2px; border-radius: 3px; }
        #backupIndicator {
            display: none;
            width: 8px;
            height: 8px;
            background-color: #22c55e;
            border-radius: 50%;
            margin-left: 8px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
        }
        .search-highlight {
            background-color: yellow;
        }
        .current-search-highlight {
            background-color: orange;
        }
        .resizer {
            position: absolute;
            background: transparent;
            z-index: 10;
        }
        .resizer-t { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .resizer-r { top: 0; right: -5px; bottom: 0; width: 10px; cursor: ew-resize; }
        .resizer-b { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .resizer-l { top: 0; left: -5px; bottom: 0; width: 10px; cursor: ew-resize; }
        .resizer-tl { top: -5px; left: -5px; width: 10px; height: 10px; cursor: nwse-resize; }
        .resizer-tr { top: -5px; right: -5px; width: 10px; height: 10px; cursor: nesw-resize; }
        .resizer-bl { bottom: -5px; left: -5px; width: 10px; height: 10px; cursor: nesw-resize; }
        .resizer-br { bottom: -5px; right: -5px; width: 10px; height: 10px; cursor: nwse-resize; }
    
        .shortcut-input {
            background-color: #f9fafb;
            border: 1px solid #d1d5db;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            width: 100%;
            text-align: center;
            font-weight: 500;
            cursor: pointer;
        }
        .shortcut-input:focus {
            outline: 2px solid var(--color-primary);
            border-color: var(--color-primary);
        }


   #shortcutsEditor {
            max-height: 50vh; /* Limita la altura al 50% de la ventana */
            overflow-y: auto; /* Muestra el scrollbar vertical si el contenido se desborda */
            padding-right: 1rem; /* Añade un pequeño espacio para que el scrollbar no tape el contenido */
        }

#messageBox {
    z-index: 1001;
}

    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">
    
    <!-- Language Switcher -->
    <div class="absolute top-4 right-4 space-x-2 z-10">
        <button id="langEnBtn" class="px-3 py-1 text-sm font-medium rounded-md transition duration-300">EN</button>
        <button id="langEsBtn" class="px-3 py-1 text-sm font-medium rounded-md transition duration-300">ES</button>
    </div>

    <div class="bg-white p-8 rounded-lg shadow-xl w-full relative mb-4" id="dropArea">
        <!-- Top Utility Buttons -->
        <div class="top-utility-buttons-container">
            <div class="dropdown">
                <button id="projectBtn" class="dropdown-btn font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                    <span data-i18n="project_btn">Project</span>
                </button>
                <div class="dropdown-content">
                    <a id="newProjectBtn" data-i18n="new_project_btn">New Project</a>
                    <a id="openProjectBtn" data-i18n="open_project_btn">Open Project</a>
                    <a id="saveProjectBtn" data-i18n="save_project_btn">Save Project</a>
                </div>
            </div>
            <button id="backupBtn" class="font-medium py-1 px-3 rounded-md shadow-sm transition duration-300 flex items-center">
                <span data-i18n="backup_btn">Backup</span>
                <span id="backupIndicator"></span>
            </button>
            <button id="shortcutsBtn" class="font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="shortcuts_btn"></span>
            </button>
            <button id="findReplaceBtn" class="font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="find_replace_btn"></span>
            </button>
            <button id="terminologyBtn" class="font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="terminology_btn"></span>
            </button>
            <button id="tmBtn" class="font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="tm_btn"></span>
            </button>
            <button id="statsBtn" class="font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="statistics_btn"></span>
            </button>
        </div>

        <div class="flex flex-col items-center mb-6 mt-12">
            <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/poanda-logo-final.png" alt="Poanda Logo" class="max-w-xs h-auto mb-2">
            <div data-i18n="tool_description" id="toolDescription" class="text-lg text-center text-on-light-contrast"></div>
        </div>

        <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mb-6">
            <label for="poFile" class="block font-medium cursor-pointer py-2 px-4 rounded-md shadow-sm transition duration-300 btn-load">
                <span data-i18n="load_file" id="loadBtnText"></span>
                <input type="file" id="poFile" accept=".po" class="hidden">
                <input type="file" id="projectFile" accept=".zip,.poanda" class="hidden">
                <input type="file" id="backupFile" accept=".json,.poanda-backup" class="hidden">
            </label>
            <button id="savePo" class="font-medium py-2 px-4 rounded-md shadow-sm transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed btn-save" disabled>
                <span data-i18n="save_file" id="saveBtnText"></span>
            </button>
            <button id="convertToMoButton" class="font-medium py-2 px-4 rounded-md shadow-sm transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed btn-convert-mo" disabled>
                <span data-i18n="convert_to_mo_btn"></span>
            </button>
        </div>

        <div class="main-editor-layout" id="mainEditorLayout">
            <!-- Central Column Wrapper -->
            <div id="central-column" class="flex-1 flex flex-col min-w-0">
                <!-- PO Editor Search Bar -->
                <div id="poSearchContainer" class="mb-4 p-4 bg-gray-50 rounded-lg border border-gray-200 hidden">
                    <div class="flex items-center gap-2">
                        <input type="text" id="poSearchInput" data-i18n-placeholder="po_search_placeholder" class="flex-grow p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white">
                        <button id="searchPrevBtn" class="p-1 rounded-md hover:bg-gray-200 disabled:opacity-50" disabled>
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>
                        </button>
                        <button id="searchNextBtn" class="p-1 rounded-md hover:bg-gray-200 disabled:opacity-50" disabled>
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
                        </button>
                        <span id="searchResultCounter" class="text-sm text-gray-600 whitespace-nowrap">0 / 0</span>
                    </div>
                    <div class="flex items-center space-x-4 text-sm text-gray-600 mt-2">
                        <label class="flex items-center cursor-pointer">
                            <input type="checkbox" id="searchInOriginalCheckbox" checked class="mr-2">
                            <span data-i18n="search_in_original"></span>
                        </label>
                        <label class="flex items-center cursor-pointer">
                            <input type="checkbox" id="searchInTranslationCheckbox" checked class="mr-2">
                            <span data-i18n="search_in_translation"></span>
                        </label>
                    </div>
                </div>
                <!-- Scrolling Content Area -->
                <div class="translations-container-scrolling pr-2">
                    <div id="translationsContainer" class="space-y-4">
                        <div data-i18n="no_translations" id="initialMessage" class="text-center text-on-light-contrast p-4 border border-gray-300 rounded-md"></div>
                    </div>
                </div>
            </div>
            
            <!-- Sidebars -->
            <div id="terminologySidebar" class="terminology-sidebar p-4 border border-gray-300 rounded-lg shadow-md">
                <div class="resizer resizer-t"></div><div class="resizer resizer-r"></div><div class="resizer resizer-b"></div><div class="resizer resizer-l"></div>
                <div class="resizer resizer-tl"></div><div class="resizer resizer-tr"></div><div class="resizer resizer-bl"></div><div class="resizer resizer-br"></div>
                <div class="sidebar-header">
                    <h3 class="text-lg font-bold text-on-light-contrast" data-i18n="terminology_sidebar_title" id="terminologySidebarTitle"></h3>
                    <div class="flex items-center gap-2">
                        <button class="reset-panel-btn text-gray-500 hover:text-gray-700">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 8.812A9.024 9.024 0 0112 4.5c4.97 0 9 4.03 9 9s-4.03 9-9 9a9.006 9.006 0 01-8.35-5.786"></path></svg>
                        </button>
                        <button id="closeTerminologySidebarBtn" class="text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    </div>
                </div>
                <div class="sidebar-content">
                    <div id="terminologyLanguageConfigSection" class="space-y-4">
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="config_lang_title" id="configLangTitle"></h4>
                        <div class="glossary-info-box mb-4"><p data-i18n="config_lang_info" id="configLangInfo"></p></div>
                        <div class="flex flex-col space-y-2 mb-4">
                            <div class="glossary-input-group"><label for="configSrcLang" data-i18n="source_language" id="sourceLanguageLabel"></label><input id="configSrcLang" list="isoLanguages" value="en-US" class="block w-full" /></div>
                            <div class="glossary-input-group"><label for="configTgtLang" data-i18n="target_language" id="targetLanguageLabel"></label><input id="configTgtLang" list="isoLanguages" value="es-ES" class="block w-full" /></div>
                            <button onclick="confirmGlossaryLanguages()" data-i18n="confirm_languages" id="confirmLanguagesBtn" class="glossary-btn-primary w-full"></button>
                        </div>
                    </div>
                    <div id="terminologyEditorSection" style="display:none;">
                        <div class="flex flex-col sm:flex-row gap-2 mb-4">
                            <button onclick="loadTBX()" data-i18n="import_tbx" id="importTbxBtn" class="glossary-btn-secondary flex-1 text-sm py-2 px-2"></button>
                            <input type="file" id="tbxFileInput" accept=".xml,.tbx" class="hidden" />
                            <button onclick="downloadTBX()" data-i18n="download_tbx" id="downloadTbxBtn" class="glossary-btn-secondary flex-1 text-sm py-2 px-2"></button>
                            <button onclick="resetGlossary()" data-i18n="new_glossary" id="newGlossaryBtn" class="glossary-btn-secondary flex-1 text-sm py-2 px-2"></button>
                        </div>
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="current_lang_title" id="currentLangTitle"></h4>
                        <div class="flex space-x-2 mb-4">
                            <div class="glossary-input-group flex-1"><label data-i18n="source_language" id="displaySourceLanguageLabel"></label><input id="displaySrcLang" disabled class="block w-full" /></div>
                            <div class="glossary-input-group flex-1"><label data-i18n="target_language" id="displayTargetLanguageLabel"></label><input id="displayTgtLang" disabled class="block w-full" /></div>
                        </div>
                        <div class="accordion-item">
                            <div class="accordion-header flex justify-between items-center" id="addTermHeader">
                                <h4 class="text-md font-semibold text-on-light-contrast m-0" data-i18n="add_term_title" id="addTermTitleAccordion"></h4>
                                <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </div>
                            <div class="accordion-content collapsed" id="addTermContent">
                                <div class="flex flex-col space-y-2 mb-4">
                                    <div class="glossary-input-group"><label for="srcTerm" data-i18n="term" id="termLabel"></label><input id="srcTerm" class="block w-full" /></div>
                                    <div class="glossary-input-group"><label for="tgtTerm" data-i18n="translation" id="translationLabel"></label><input id="tgtTerm" class="block w-full" /></div>
                                    <button onclick="addTerm()" data-i18n="add_button" id="addTermBtn" class="glossary-btn-primary w-full"></button>
                                </div>
                            </div>
                        </div>
                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="search_title" id="searchTitle"></h4>
                        <div class="mb-4"><input id="searchTerm" data-i18n-placeholder="search_placeholder" class="block w-full" oninput="renderGlossary()" /></div>
                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="glossary_list_title" id="glossaryListTitle"></h4>
                        <div class="overflow-x-auto"><table class="glossary-table w-full"><thead><tr><th data-i18n="source_term_col" id="sourceTermCol"></th><th data-i18n="target_term_col" id="targetTermCol"></th><th data-i18n="actions_col" id="actionsCol"></th></tr></thead><tbody id="glossaryTableBody"></tbody></table></div>
                    </div>
                </div>
                <datalist id="isoLanguages"></datalist>
            </div>
            <div id="translationMemorySidebar" class="translation-memory-sidebar p-4 border border-gray-300 rounded-lg shadow-md">
                <div class="resizer resizer-t"></div><div class="resizer resizer-r"></div><div class="resizer resizer-b"></div><div class="resizer resizer-l"></div>
                <div class="resizer resizer-tl"></div><div class="resizer resizer-tr"></div><div class="resizer resizer-bl"></div><div class="resizer resizer-br"></div>
                <div class="sidebar-header">
                    <h3 class="text-lg font-bold text-on-light-contrast" data-i18n="tm_sidebar_title" id="tmSidebarTitle"></h3>
                    <div class="flex items-center gap-2">
                        <button class="reset-panel-btn text-gray-500 hover:text-gray-700">
                             <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 8.812A9.024 9.024 0 0112 4.5c4.97 0 9 4.03 9 9s-4.03 9-9 9a9.006 9.006 0 01-8.35-5.786"></path></svg>
                        </button>
                        <button id="closeTranslationMemorySidebarBtn" class="text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    </div>
                </div>
                <div class="sidebar-content">
                    <div id="tmInternalMessage" class="tm-info-box mb-4 hidden"></div>
                    <div id="tmLanguageConfigSection" class="space-y-4">
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="tm_config_lang_title" id="tmConfigLangTitle"></h4>
                        <div class="tm-info-box mb-4"><p data-i18n="tm_config_lang_info" id="tmConfigLangInfo"></p></div>
                        <div class="flex flex-col space-y-2 mb-4">
                            <div class="tm-input-group"><label for="tmConfigSrcLang" data-i18n="source_language" id="tmSourceLanguageLabel"></label><input id="tmConfigSrcLang" list="isoLanguages" value="en-US" class="block w-full" /></div>
                            <div class="tm-input-group"><label for="tmConfigTgtLang" data-i18n="target_language" id="tmTargetLanguageLabel"></label><input id="tmConfigTgtLang" list="isoLanguages" value="es-ES" class="block w-full" /></div>
                            <button onclick="confirmTMLanguages()" data-i18n="confirm_languages" id="tmConfirmLanguagesBtn" class="tm-btn-primary w-full"></button>
                        </div>
                    </div>
                    <div id="tmEditorSection" style="display:none;">
                        <div class="flex flex-col sm:flex-row gap-2 mb-4">
                            <button onclick="resetTM()" data-i18n="new_tm" id="newTmBtn" class="tm-btn-secondary flex-1 text-sm py-2 px-2"></button>
                            <label for="tmFileInput" class="block font-medium cursor-pointer py-2 px-4 rounded-md shadow-sm transition duration-300 tm-btn-secondary flex-1 text-sm text-center">
                                <span data-i18n="import_tmx" id="importTmxBtnText"></span><input type="file" id="tmFileInput" accept=".xml,.tmx" class="hidden" />
                            </label>
                            <button onclick="downloadTMX()" data-i18n="download_tmx" id="downloadTmxBtn" class="tm-btn-secondary flex-1 text-sm py-2 px-2"></button>
                        </div>
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="current_tm_lang_title" id="currentTmLangTitle"></h4>
                        <div class="flex space-x-2 mb-4">
                            <div class="tm-input-group flex-1"><label data-i18n="source_language" id="displayTmSourceLanguageLabel"></label><input id="displayTmSrcLang" disabled class="block w-full" /></div>
                            <div class="tm-input-group flex-1"><label data-i18n="target_language" id="displayTmTargetLanguageLabel"></label><input id="displayTmTgtLang" disabled class="block w-full" /></div>
                        </div>
                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="tm_search_title" id="tmSearchTitle"></h4>
                        <div class="mb-4"><input id="tmSearchInput" data-i18n-placeholder="tm_search_placeholder" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white" oninput="tmSearch()" /></div>
                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="tm_search_results_title" id="tmSearchResultsTitle"></h4>
                        <div class="overflow-x-auto mb-4"><table class="tm-table w-full"><thead><tr><th data-i18n="tm_score_col" id="tmScoreCol"></th><th data-i18n="tm_original_col" id="tmOriginalCol"></th><th data-i18n="tm_translation_col" id="tmTranslationCol"></th></tr></thead><tbody id="tmSearchResultsTableBody"></tbody></table></div>
                        <div data-i18n="tm_no_match_found" id="tmNoMatchFoundMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md hidden"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="messageBox" class="modal hidden"><div class="modal-content"><p id="messageText" class="text-lg font-semibold text-on-light-contrast mb-4"></p><button id="messageClose" class="py-2 px-4 rounded-md transition duration-300 btn-modal-primary"><span data-i18n="ok" id="okBtnText"></span></button></div></div>
        
        <div id="shortcutsModal" class="modal hidden">
            <div class="modal-content">
                <h2 data-i18n="shortcuts_title" class="text-xl font-bold mb-4 text-on-light-contrast"></h2>
                <div id="shortcutsEditor" class="space-y-4">
                    <!-- Shortcut editor content will be generated here by JS -->
                </div>
                <div class="flex flex-wrap justify-end gap-2 mt-6">
                    <button id="importShortcutsBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-secondary"><span data-i18n="import_shortcuts_btn"></span></button>
                    <input type="file" id="importShortcutsInput" class="hidden" accept=".json">
                    <button id="exportShortcutsBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-secondary"><span data-i18n="export_shortcuts_btn"></span></button>
                    <button id="resetShortcutsBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-dark"><span data-i18n="reset_defaults_btn"></span></button>
                </div>
                <div class="flex justify-end gap-2 mt-4">
                    <button id="shortcutsCloseBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-neutral"><span data-i18n="cancel_button"></span></button>
                    <button id="saveShortcutsBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-primary"><span data-i18n="save_button"></span></button>
                </div>
            </div>
        </div>

        <div id="findReplaceModal" class="modal hidden"><div class="modal-content"><h2 data-i18n="find_replace_title" id="findReplaceTitle" class="text-xl font-bold mb-4 text-on-light-contrast"></h2><div class="space-y-4"><div><label for="findInput" data-i18n="find_label" id="findLabel" class="block text-sm font-medium text-on-light-contrast mb-1"></label><input type="text" id="findInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></div><div><label for="replaceInput" data-i18n="replace_label" id="replaceLabel" class="block text-sm font-medium text-on-light-contrast mb-1"></label><input type="text" id="replaceInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></div><div class="flex items-center space-x-4"><label class="flex items-center text-on-light-contrast"><input type="checkbox" id="caseSensitiveCheckbox" class="mr-2"><span data-i18n="case_sensitive" id="caseSensitiveText"></span></label><label class="flex items-center text-on-light-contrast"><input type="checkbox" id="regexCheckbox" class="mr-2"><span data-i18n="regular_expression" id="regexText"></span></label></div><div class="flex justify-end space-x-2"><button data-i18n="find_prev" id="findPrevBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-neutral"><span id="findPrevText"></span></button><button data-i18n="find_next" id="findNextBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-neutral"><span id="findNextText"></span></button><button data-i18n="replace" id="replaceBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-secondary"><span id="replaceText"></span></button><button data-i18n="replace_all" id="replaceAllBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-primary"><span id="replaceAllText"></span></button></div></div><button data-i18n="close_btn" id="findReplaceCloseBtn" class="mt-6 py-2 px-4 rounded-md transition duration-300 w-full btn-modal-dark"><span id="findReplaceCloseBtnText"></span></button></div></div>
        <div id="saveProjectModal" class="modal hidden"><div class="modal-content"><h2 data-i18n="save_project_title" id="saveProjectTitle" class="text-xl font-bold mb-4 text-on-light-contrast"></h2><div class="space-y-4"><div><label for="projectFilenameInput" data-i18n="filename_label" id="filenameLabel" class="block text-sm font-medium text-on-light-contrast mb-1"></label><input type="text" id="projectFilenameInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></div></div><div class="flex justify-end space-x-2 mt-6"><button id="saveProjectCancelBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-neutral"><span data-i18n="cancel_button"></span></button><button id="saveProjectConfirmBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-primary"><span data-i18n="save_button"></span></button></div></div></div>
        
        <div id="backupModal" class="modal hidden">
            <div class="modal-content">
                <h2 data-i18n="backup_title" class="text-xl font-bold mb-4 text-on-light-contrast"></h2>
                <p data-i18n="backup_info_text" class="text-on-light-contrast mb-4"></p>
                <div class="bg-gray-100 p-3 rounded-md mb-6">
                    <p class="text-sm text-gray-700"><strong data-i18n="last_backup_label"></strong> <span id="lastBackupTime"></span></p>
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <button id="loadLocalBackupBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 disabled:opacity-50 btn-modal-primary" disabled><span data-i18n="load_local_backup_btn"></span></button>
                    <button id="saveBackupToDiskBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 disabled:opacity-50 btn-modal-secondary" disabled><span data-i18n="save_backup_to_disk_btn"></span></button>
                    <label class="font-medium py-2 px-4 rounded-md transition duration-300 cursor-pointer text-center btn-modal-secondary"><span data-i18n="load_backup_from_disk_btn"></span><input type="file" id="loadBackupFromFileInput" class="hidden" accept=".json,.poanda-backup"/></label>
                    <button id="deleteLocalBackupBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 disabled:opacity-50 btn-modal-dark" disabled><span data-i18n="delete_local_backup_btn"></span></button>
                </div>
                 <button id="backupCloseBtn" class="mt-6 py-2 px-4 rounded-md transition duration-300 w-full btn-modal-neutral"><span data-i18n="close_btn"></span></button>
            </div>
        </div>

        <div id="restoreBackupModal" class="modal hidden"><div class="modal-content"><h2 data-i18n="restore_backup_title" id="restoreBackupTitle" class="text-xl font-bold mb-4 text-on-light-contrast"></h2><p data-i18n="restore_backup_info" id="restoreBackupInfo" class="text-on-light-contrast mb-6"></p><div class="flex justify-end space-x-2"><button id="discardBackupBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-neutral"><span data-i18n="discard_button"></span></button><button id="restoreBackupBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-primary"><span data-i18n="restore_button"></span></button></div></div></div>

        <div id="convertToMoModal" class="modal hidden">
            <div class="modal-content">
                <h2 data-i18n="mo_converter_title" class="text-xl font-bold mb-4 text-on-light-contrast"></h2>
                <p data-i18n="mo_converter_info" class="text-on-light-contrast mb-6"></p>
                <div class="flex justify-end space-x-2">
                    <button id="moConverterCloseBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-neutral"><span data-i18n="close_btn"></span></button>
                    <button id="moConverterActionBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-primary"><span data-i18n="mo_converter_action_btn"></span></button>
                </div>
            </div>
        </div>
    </div>

    <div id="statsContainer" class="fixed bottom-0 left-0 right-0 bg-white p-3 border-t border-gray-200 shadow-lg z-[900]"><div class="max-w-7xl mx-auto text-sm text-center text-gray-700 flex flex-wrap justify-center md:justify-around items-center gap-x-6 gap-y-2"><p><strong class="font-semibold" data-i18n="stats_progress_label"></strong> <span id="segmentsProgress">0/0 segments (0%)</span></p><p><strong class="font-semibold" data-i18n="stats_words_label"></strong> <span id="wordsTranslated">0</span> / <span id="wordsTotal">0</span></p><p><strong class="font-semibold" data-i18n="stats_remaining_label"></strong> <span id="wordsRemaining">0</span></p></div></div>
    <div id="loadingOverlay" class="loading-overlay hidden"><div class="loading-spinner"></div><p id="loadingMessage"></p></div>

    <script>
        // Global variables for Poanda editor
        let poEntries = [];
        let currentFileName = 'translations.po';
        let currentLanguage = 'en'; // Default language set to English
        let findState = {
            query: '',
            replace: '',
            caseSensitive: false,
            useRegex: false,
            lastFound: null,
        };
        let searchResults = [];
        let currentSearchIndex = -1;

        // Global variable to keep track of terms found in the currently active/focused segment's original text
        let termsFoundInActiveSegment = new Set(); // Stores terms found in the currently focused original segment

        // Global variables for Terminology (Glossary)
        let glossary = [];
        let glossarySourceLanguage = '';
        let glossaryTargetLanguage = '';
        let currentGlossaryLatestResults = []; // Stores the last set of results rendered in glossary table for shortcuts


        // Global variables for Translation Memory (TM)
        let translationMemory = []; // Stores {srcLang, srcText, tgtLang, tgtText, srcWordCount, tgtWordCount}
        let tmSourceLanguage = ''; // Will typically be the source language of the PO file
        let tmTargetLanguage = ''; // Will typically be the target language of the PO file
        let tmBestMatchForActiveSegment = null; // Stores the best TM match for the currently focused segment
        let currentTMLatestSearchResults = []; // Stores the last set of results rendered in TM search table

        // DOM elements for Poanda editor
        const poFile = document.getElementById('poFile');
        const savePoButton = document.getElementById('savePo');
        const translationsContainer = document.getElementById('translationsContainer');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageClose = document.getElementById('messageClose');
        const poandaLogo = document.querySelector('.max-w-xs');
        const dropArea = document.getElementById('dropArea');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const mainEditorLayout = document.getElementById('mainEditorLayout');

        // PO Editor Search DOM elements
        const poSearchContainer = document.getElementById('poSearchContainer');
        const poSearchInput = document.getElementById('poSearchInput');
        const searchInOriginalCheckbox = document.getElementById('searchInOriginalCheckbox');
        const searchInTranslationCheckbox = document.getElementById('searchInTranslationCheckbox');
        const searchPrevBtn = document.getElementById('searchPrevBtn');
        const searchNextBtn = document.getElementById('searchNextBtn');
        const searchResultCounter = document.getElementById('searchResultCounter');


        // Project DOM elements
        const projectFileInput = document.getElementById('projectFile');
        const newProjectBtn = document.getElementById('newProjectBtn');
        const openProjectBtn = document.getElementById('openProjectBtn');
        const saveProjectBtn = document.getElementById('saveProjectBtn');
        
        // Save Project Modal DOM elements
        const saveProjectModal = document.getElementById('saveProjectModal');
        const projectFilenameInput = document.getElementById('projectFilenameInput');
        const saveProjectConfirmBtn = document.getElementById('saveProjectConfirmBtn');
        const saveProjectCancelBtn = document.getElementById('saveProjectCancelBtn');

        // Restore Backup Modal DOM elements
        const restoreBackupModal = document.getElementById('restoreBackupModal');
        const restoreBackupBtn = document.getElementById('restoreBackupBtn');
        const discardBackupBtn = document.getElementById('discardBackupBtn');
        
        // Backup Modal DOM elements
        const backupBtn = document.getElementById('backupBtn');
        const backupIndicator = document.getElementById('backupIndicator');
        const backupModal = document.getElementById('backupModal');
        const lastBackupTime = document.getElementById('lastBackupTime');
        const loadLocalBackupBtn = document.getElementById('loadLocalBackupBtn');
        const saveBackupToDiskBtn = document.getElementById('saveBackupToDiskBtn');
        const loadBackupFromFileInput = document.getElementById('loadBackupFromFileInput');
        const deleteLocalBackupBtn = document.getElementById('deleteLocalBackupBtn');
        const backupCloseBtn = document.getElementById('backupCloseBtn');
        const backupFileInput = document.getElementById('backupFile');


        // Statistics DOM elements
        const statsBtn = document.getElementById('statsBtn');
        const statsContainer = document.getElementById('statsContainer');
        const segmentsProgress = document.getElementById('segmentsProgress');
        const wordsTranslated = document.getElementById('wordsTranslated');
        const wordsTotal = document.getElementById('wordsTotal');
        const wordsRemaining = document.getElementById('wordsRemaining');


        // Poanda Modals
        const shortcutsBtn = document.getElementById('shortcutsBtn');
        const shortcutsModal = document.getElementById('shortcutsModal');
        const shortcutsCloseBtn = document.getElementById('shortcutsCloseBtn');
        const findReplaceBtn = document.getElementById('findReplaceBtn');
        const findReplaceModal = document.getElementById('findReplaceModal');
        const findInput = document.getElementById('findInput');
        const replaceInput = document.getElementById('replaceInput');
        const caseSensitiveCheckbox = document.getElementById('caseSensitiveCheckbox');
        const regexCheckbox = document.getElementById('regexCheckbox');
        const findPrevBtn = document.getElementById('findPrevBtn');
        const findNextBtn = document.getElementById('findNextBtn');
        const replaceBtn = document.getElementById('replaceBtn');
        const replaceAllBtn = document.getElementById('replaceAllBtn');
        const findReplaceCloseBtn = document.getElementById('findReplaceCloseBtn');

        // Shortcuts Modal DOM elements
        const shortcutsEditor = document.getElementById('shortcutsEditor');
        const saveShortcutsBtn = document.getElementById('saveShortcutsBtn');
        const importShortcutsBtn = document.getElementById('importShortcutsBtn');
        const importShortcutsInput = document.getElementById('importShortcutsInput');
        const exportShortcutsBtn = document.getElementById('exportShortcutsBtn');
        const resetShortcutsBtn = document.getElementById('resetShortcutsBtn');

        // Terminology Sidebar DOM elements
        const terminologyBtn = document.getElementById('terminologyBtn');
        const terminologySidebar = document.getElementById('terminologySidebar');
        const closeTerminologySidebarBtn = document.getElementById('closeTerminologySidebarBtn');
        const terminologyLanguageConfigSection = document.getElementById('terminologyLanguageConfigSection');
        const terminologyEditorSection = document.getElementById('terminologyEditorSection');
        const configSrcLang = document.getElementById('configSrcLang');
        const configTgtLang = document.getElementById('configTgtLang');
        const displaySrcLang = document.getElementById('displaySrcLang');
        const displayTgtLang = document.getElementById('displayTgtLang');
        const srcTermInput = document.getElementById('srcTerm');
        const tgtTermInput = document.getElementById('tgtTerm');
        const searchTermInput = document.getElementById('searchTerm');
        const glossaryTableBody = document.getElementById('glossaryTableBody');
        const tbxFileInput = document.getElementById('tbxFileInput');
        const isoLanguagesDatalist = document.getElementById('isoLanguages');

        // Buttons directly in config/editor sections for TBX
        const importTbxBtn = document.getElementById('importTbxBtn');
        const newGlossaryBtn = document.getElementById('newGlossaryBtn');
        const addTermHeader = document.getElementById('addTermHeader');
        const addTermContent = addTermHeader ? addTermHeader.nextElementSibling : null;
        const addTermAccordionIcon = addTermHeader ? addTermHeader.querySelector('.accordion-icon') : null;

        // Translation Memory Sidebar DOM elements
        const tmBtn = document.getElementById('tmBtn');
        const translationMemorySidebar = document.getElementById('translationMemorySidebar');
        const closeTranslationMemorySidebarBtn = document.getElementById('closeTranslationMemorySidebarBtn');
        const tmFileInput = document.getElementById('tmFileInput');
        const tmSearchInput = document.getElementById('tmSearchInput');
        const tmSearchResultsTableBody = document.getElementById('tmSearchResultsTableBody');
        const tmNoMatchFoundMessage = document.getElementById('tmNoMatchFoundMessage');
        // New TM config DOM elements
        const tmLanguageConfigSection = document.getElementById('tmLanguageConfigSection');
        const tmEditorSection = document.getElementById('tmEditorSection');
        const tmConfigSrcLang = document.getElementById('tmConfigSrcLang');
        const tmConfigTgtLang = document.getElementById('tmConfigTgtLang');
        const displayTmSrcLang = document.getElementById('displayTmSrcLang');
        const displayTmTgtLang = document.getElementById('displayTmTgtLang');
        const tmInternalMessage = document.getElementById('tmInternalMessage'); // New TM internal message element

        // DOM element for main content editor, needed for padding adjustments
        const centralColumn = document.getElementById('central-column');

        // NEW: PO to MO Converter DOM Elements
        const convertToMoButton = document.getElementById('convertToMoButton');
        const convertToMoModal = document.getElementById('convertToMoModal');
        const moConverterCloseBtn = document.getElementById('moConverterCloseBtn');
        const moConverterActionBtn = document.getElementById('moConverterActionBtn');

        // Translations object for EN and ES
        const translations = {
            'en': {
                'title': 'Poanda',
                'load_file': 'Load .po file',
                'save_file': 'Save .po file',
                'convert_to_mo_btn': 'Convert to .mo',
                'original_msgid': 'Original (msgid):',
                'translation_msgstr': 'Translation (msgstr):',
                'context_msgctxt': 'Context (msgctxt):',
                'validate': 'Validate',
                'edit': 'Edit',
                'fuzzy': 'Fuzzy',
                'char_count_original': 'Original: ',
                'char_count_translation': 'Translation: ',
                'char_units': ' characters',
                'no_translations': 'Load a .po file or open a project to start editing.',
                'error_reading_file': 'Error reading or parsing .po file: ',
                'error_saving_file': 'Error saving .po file: ',
                'file_saved_successfully': '.po file saved successfully.',
'tbx_saved_successfully': 'TBX file saved successfully.',
                'no_translations_to_save': 'No translations to save. Load a .po file first.',
                'reached_last': 'You have reached the last translation.',
                'reached_first': 'You are already at the first translation.',
                'file_processing_error': 'Error! Could not process the file. Make sure it is a valid .po file.',
                'tool_description': 'A simple tool for editing .po files.',
                'ok': 'OK',
                'shortcuts_btn': 'Shortcuts',
                'shortcuts_title': 'Keyboard Shortcuts',
                'shortcut_validate': 'Validate & Next Segment',
                'shortcut_next': 'Next Segment',
                'shortcut_prev': 'Previous Segment',
              'shortcut_tm_insert_1': 'Insert TM Match 1',
                'shortcut_tm_insert_2': 'Insert TM Match 2',
                'shortcut_tm_insert_3': 'Insert TM Match 3',
                'shortcut_tm_insert_4': 'Insert TM Match 4',
                'shortcut_tm_insert_5': 'Insert TM Match 5',
                'shortcut_glossary_insert_1': 'Insert Glossary Term 1',
                'shortcut_glossary_insert_2': 'Insert Glossary Term 2',
                'shortcut_glossary_insert_3': 'Insert Glossary Term 3',
                'shortcut_glossary_insert_4': 'Insert Glossary Term 4',
                'shortcut_glossary_insert_5': 'Insert Glossary Term 5',
                'save_shortcuts_btn': 'Save Shortcuts',
                'import_shortcuts_btn': 'Import',
                'export_shortcuts_btn': 'Export',
                'reset_defaults_btn': 'Reset to Defaults',
                'shortcuts_saved': 'Shortcuts saved successfully!',
                'shortcuts_loaded': 'Shortcuts imported successfully!',
                'shortcuts_reset': 'Shortcuts have been reset to default.',
                'error_loading_shortcuts': 'Error loading shortcuts file. Ensure it is a valid JSON configuration.',
                'click_to_set_shortcut': 'Click and press the desired key combination',
                'close_btn': 'Close',
                'find_replace_btn': 'Find & Replace',
                'find_replace_title': 'Find and Replace',
                'find_label': 'Find:',
                'replace_label': 'Replace with:',
                'case_sensitive': 'Case sensitive',
                'regular_expression': 'Regular expression',
                'find_prev': 'Find previous',
                'find_next': 'Find next',
                'replace': 'Replace',
                'replace_all': 'Replace all',
                'no_match_found': 'No match found.',
                'replaced_all': 'All occurrences replaced.',
                'no_find_query': 'Please enter text to find.',
                'loading_file': 'Loading file...',
                'saving_file': 'Saving file...',
                'terminology_btn': 'Terminology',
                'terminology_sidebar_title': 'Terminology',
                'config_lang_title': 'Configure Glossary Languages',
                'config_lang_info': 'Define the source and target languages for your glossary. You can enter the ISO code directly or select from the suggestions. It is crucial that the ISO code is correct for it to work properly with your CAT tool.',
                'source_language': 'Source Language:',
                'target_language': 'Target Language:',
                'confirm_languages': 'Confirm Languages',
                'current_lang_title': 'Current Glossary Languages',
                'add_term_title': 'Add Term',
                'term': 'Term:',
                'translation': 'Translation:',
                'add_button': 'Add',
                'search_title': 'Search',
                'search_placeholder': 'Search term...',
                'import_tbx': 'Import TBX',
                'download_tbx': 'Download TBX',
                'new_glossary': 'New Glossary',
                'glossary_list_title': 'Glossary',
                'source_term_col': 'Source Term',
                'target_term_col': 'Target Term',
                'actions_col': 'Actions',
                'delete_button': 'Delete',
                'both_terms_required': 'Both terms are required.',
                'lang_config_required': 'Please configure the source and target languages for the glossary.',
                'cannot_download_empty_or_unconfigured_glossary': 'Cannot download an empty or unconfigured glossary.',
                'error_loading_tbx_file': 'Error loading TBX file. Make sure it is a valid XML/TBX.',
                'no_valid_language_pairs_found_in_tbx': 'No valid language pairs were found in the TBX file. Default values (en-US, es-ES) will be used.',
                'statistics_btn': 'Statistics',
                'stats_progress_label': 'Progress:',
                'stats_words_label': 'Words (Translated / Total):',
                'stats_remaining_label': 'Remaining Words:',
                'tm_btn': 'Translation Memory',
                'tm_sidebar_title': 'Translation Memory (TM)',
                'new_tm': 'New TM',
                'import_tmx': 'Import TMX',
                'download_tmx': 'Download TMX',
                'no_tm_data': 'No data in the translation memory.',
                'tm_source_segment': 'Original:',
                'tm_target_segment': 'Translation:',
                'tm_match_score': 'Match:',
                'tm_no_match_found': 'No matches found in the TM.',
                'tm_insert_match': 'Insert match',
                'error_loading_tmx_file': 'Error loading TMX file. Make sure it is a valid XML/TMX.',
                'cannot_download_empty_tm': 'Cannot download an empty translation memory.',
                'tm_best_match': 'Best TM match:',
                'tm_search_title': 'Search in TM',
                'tm_search_placeholder': 'Search in memory...',
                'tm_search_results_title': 'TM Search Results',
                'tm_score_col': '%',
                'tm_original_col': 'Original',
                'tm_translation_col': 'Translation',
                'tm_config_lang_title': 'Configure TM Languages',
                'tm_config_lang_info': 'Define the source and target languages for your Translation Memory. It is crucial that the ISO code is correct for matching to work properly.',
                'current_tm_lang_title': 'Current TM Languages',
                'tm_initial_message': 'Create a new TM or import a TMX file to start working with the translation memory.',
                'tmx_file_expected_tbx_found': 'This file appears to be a glossary (TBX). Please use the "Import TBX" option in the Terminology panel.',
                'tbx_file_expected_tmx_found': 'This file appears to be a translation memory (TMX). Please use the "Import TMX" option in the Translation Memory panel.',
                'project_btn': 'Project',
                'new_project_btn': 'New Project',
                'open_project_btn': 'Open Project',
                'save_project_btn': 'Save Project',
                'project_saved': 'Project saved successfully.',
                'error_saving_project': 'Error saving project.',
                'no_project_to_save': 'There is no active .po file to save as a project.',
                'loading_project': 'Loading project...',
                'project_loaded': 'Project loaded successfully.',
                'error_opening_project': 'Error opening project file.',
                'invalid_project_file': 'Invalid project file. The zip must contain a .po file.',
                'new_project_confirm': 'Are you sure you want to start a new project? All unsaved progress will be lost.',
                'save_project_title': 'Save Project',
                'filename_label': 'Filename:',
                'save_button': 'Save',
                'cancel_button': 'Cancel',
                'enter_filename': 'Please enter a filename.',
                'restore_backup_title': 'Restore Session',
                'restore_backup_info': 'We found a backup of your previous session. Would you like to restore it?',
                'restore_button': 'Restore',
                'discard_button': 'Discard',
                'backup_btn': 'Backup',
                'backup_title': 'Backup Management',
                'backup_info_text': 'Poanda automatically saves a local backup of your entire session (PO file, TM, and glossary) to your browser every 10 seconds. You can restore this backup here or save it to a file for safekeeping.',
                'last_backup_label': 'Last backup:',
                'no_backup_available': 'No backup available.',
                'load_local_backup_btn': 'Load Local Backup',
                'save_backup_to_disk_btn': 'Save Backup to Disk',
                'load_backup_from_disk_btn': 'Load Backup from Disk',
                'delete_local_backup_btn': 'Delete Local Backup',
                'backup_deleted': 'Local backup has been deleted.',
                'backup_loaded_from_file': 'Backup loaded successfully from file.',
                'error_loading_backup_file': 'Error loading backup file. Ensure it is a valid .poanda-backup file.',
                'delete_local_backup_btn_confirm': 'Are you sure you want to delete the local backup? This action cannot be undone.',
                'mo_converter_title': 'PO to MO Converter',
                'mo_converter_info': 'This will compile the current .po file into a binary .mo file. The conversion happens entirely in your browser.',
                'mo_converter_action_btn': 'Convert and Download .mo',
                'mo_conversion_success': 'MO file converted and downloaded successfully.',
                'mo_conversion_error': 'Error during MO conversion. Check the browser console (F12) for details.',
                'no_file_to_convert': 'No .po file loaded to convert.',
                'po_search_placeholder': 'Search in file...',
                'search_in_original': 'Search in original',
                'search_in_translation': 'Search in translation',
            },
            'es': {
                'title': 'Poanda',
                'load_file': 'Cargar archivo .po',
                'save_file': 'Guardar archivo .po',
                'convert_to_mo_btn': 'Convertir a .mo',
                'original_msgid': 'Original (msgid):',
                'translation_msgstr': 'Traducción (msgstr):',
                'context_msgctxt': 'Contexto (msgctxt):',
                'validate': 'Validar',
                'edit': 'Editar',
                'fuzzy': 'Difuso',
                'char_count_original': 'Original: ',
                'char_count_translation': 'Traducción: ',
                'char_units': ' caracteres',
                'no_translations': 'Carga un archivo .po o abre un proyecto para empezar a editar.',
                'error_reading_file': 'Error al leer o analizar archivo .po: ',
                'error_saving_file': 'Error al guardar archivo .po: ',
                'file_saved_successfully': 'Archivo .po guardado con éxito.',
'tbx_saved_successfully': 'Archivo TBX guardado con éxito.',
                'no_translations_to_save': 'No hay traducciones para guardar. Carga un archivo .po primero.',
                'reached_last': 'Has llegado a la última traducción.',
                'reached_first': 'Ya estás en la primera traducción.',
                'file_processing_error': '¡Error! No se pudo procesar el archivo. Asegúrate de que es un archivo .po válido.',
                'tool_description': 'Una herramienta sencilla para editar archivos .po.',
                'ok': 'OK',
                'shortcuts_btn': 'Atajos',
                'shortcuts_title': 'Atajos de teclado',
                'shortcut_validate': 'Validar e ir al siguiente segmento',
                'shortcut_next': 'Siguiente segmento',
                'shortcut_prev': 'Segmento anterior',

           'shortcut_tm_insert_1': 'Insertar concordancia de MT 1',
                'shortcut_tm_insert_2': 'Insertar concordancia de MT 2',
                'shortcut_tm_insert_3': 'Insertar concordancia de MT 3',
                'shortcut_tm_insert_4': 'Insertar concordancia de MT 4',
                'shortcut_tm_insert_5': 'Insertar concordancia de MT 5',
                'shortcut_glossary_insert_1': 'Insertar término del glosario 1',
                'shortcut_glossary_insert_2': 'Insertar término del glosario 2',
                'shortcut_glossary_insert_3': 'Insertar término del glosario 3',
                'shortcut_glossary_insert_4': 'Insertar término del glosario 4',
                'shortcut_glossary_insert_5': 'Insertar término del glosario 5',

                'save_shortcuts_btn': 'Guardar atajos',
                'import_shortcuts_btn': 'Importar',
                'export_shortcuts_btn': 'Exportar',
                'reset_defaults_btn': 'Restablecer',
                'shortcuts_saved': '¡Atajos guardados correctamente!',
                'shortcuts_loaded': '¡Atajos importados correctamente!',
                'shortcuts_reset': 'Los atajos se han restablecido a los valores por defecto.',
                'error_loading_shortcuts': 'Error al cargar el archivo de atajos. Asegúrate de que es un archivo de configuración JSON válido.',
                'click_to_set_shortcut': 'Haz clic y presiona la combinación de teclas deseada',
                'close_btn': 'Cerrar',
                'find_replace_btn': 'Buscar y reemplazar',
                'find_replace_title': 'Buscar y reemplazar',
                'find_label': 'Buscar:',
                'replace_label': 'Reemplazar con:',
                'case_sensitive': 'Distinguir mayúsculas y minúsculas',
                'regular_expression': 'Expresión regular',
                'find_prev': 'Buscar anterior',
                'find_next': 'Buscar siguiente',
                'replace': 'Reemplazar',
                'replace_all': 'Reemplazar todo',
                'no_match_found': 'No se encontró ninguna coincidencia.',
                'replaced_all': 'Todas las ocurrencias reemplazadas.',
                'no_find_query': 'Por favor, introduce el texto a buscar.',
                'loading_file': 'Cargando archivo...',
                'saving_file': 'Guardando archivo...',
                'terminology_btn': 'Terminología',
                'terminology_sidebar_title': 'Terminología',
                'config_lang_title': 'Configurar idiomas del glosario',
                'config_lang_info': 'Define los idiomas de origen y destino de tu glosario. Puedes introducir el código ISO directamente o seleccionarlo de las sugerencias. Es fundamental que el código ISO sea correcto para que funcione correctamente con tu herramienta TAO.',
                'source_language': 'Idioma de origen:',
                'target_language': 'Idioma de destino:',
                'confirm_languages': 'Confirmar idiomas',
                'current_lang_title': 'Idiomas actuales del glosario',
                'add_term_title': 'Añadir término',
                'term': 'Término:',
                'translation': 'Traducción:',
                'add_button': 'Añadir',
                'search_title': 'Buscar',
                'search_placeholder': 'Buscar término...',
                'import_tbx': 'Importar TBX',
                'download_tbx': 'Descargar TBX',
                'new_glossary': 'Nuevo glosario',
                'glossary_list_title': 'Glosario',
                'source_term_col': 'Término de origen',
                'target_term_col': 'Término de destino',
                'actions_col': 'Acciones',
                'delete_button': 'Eliminar',
                'both_terms_required': 'Ambos términos son requeridos.',
                'lang_config_required': 'Por favor, configura los idiomas de origen y destino para el glosario.',
                'cannot_download_empty_or_unconfigured_glossary': 'No se puede descargar un glosario vacío o sin configurar.',
                'error_loading_tbx_file': 'Error al cargar el archivo TBX. Asegúrate de que sea un XML/TBX válido.',
                'no_valid_language_pairs_found_in_tbx': 'No se encontraron pares de idiomas válidos en el archivo TBX. Se usarán los valores por defecto (en-US, es-ES).',
                'statistics_btn': 'Estadísticas',
                'stats_progress_label': 'Progreso:',
                'stats_words_label': 'Palabras (Traducidas / Totales):',
                'stats_remaining_label': 'Palabras Pendientes:',
                'tm_btn': 'Memoria de traducción',
                'tm_sidebar_title': 'Memoria de Traducción (TM)',
                'new_tm': 'Nueva TM',
                'import_tmx': 'Importar TMX',
                'download_tmx': 'Descargar TMX',
                'no_tm_data': 'No hay datos en la memoria de traducción.',
                'tm_source_segment': 'Original:',
                'tm_target_segment': 'Traducción:',
                'tm_match_score': 'Coincidencia:',
                'tm_no_match_found': 'No se encontraron coincidencias en la TM.',
                'tm_insert_match': 'Insertar coincidencia',
                'error_loading_tmx_file': 'Error al cargar el archivo TMX. Asegúrate de que sea un XML/TMX válido.',
                'cannot_download_empty_tm': 'No se puede descargar una memoria de traducción vacía.',
                'tm_best_match': 'Mejor coincidencia de TM:',
                'tm_search_title': 'Buscar en TM',
                'tm_search_placeholder': 'Buscar en la memoria...',
                'tm_search_results_title': 'Resultados de búsqueda en TM',
                'tm_score_col': '%',
                'tm_original_col': 'Original',
                'tm_translation_col': 'Traducción',
                'tm_config_lang_title': 'Configurar idiomas de la TM',
                'tm_config_lang_info': 'Define los idiomas de origen y destino de tu Memoria de Traducción. Es fundamental que el código ISO sea correcto para que la coincidencia funcione correctamente.',
                'current_tm_lang_title': 'Idiomas actuales de la TM',
                'tm_initial_message': 'Crea una nueva TM o importa un archivo TMX para empezar a trabajar con la memoria de traducción.',
                'tmx_file_expected_tbx_found': 'Este archivo parece ser un glosario (TBX). Por favor, usa la opción "Importar TBX" en el panel de Terminología.',
                'tbx_file_expected_tmx_found': 'Este archivo parece ser una memoria de traducción (TMX). Por favor, usa la opción "Importar TMX" en el panel de Memoria de Traducción.',
                'project_btn': 'Proyecto',
                'new_project_btn': 'Nuevo proyecto',
                'open_project_btn': 'Abrir proyecto',
                'save_project_btn': 'Guardar proyecto',
                'project_saved': 'Proyecto guardado con éxito.',
                'error_saving_project': 'Error al guardar el proyecto.',
                'no_project_to_save': 'No hay ningún archivo .po activo para guardar como proyecto.',
                'loading_project': 'Cargando proyecto...',
                'project_loaded': 'Proyecto cargado con éxito.',
                'error_opening_project': 'Error al abrir el archivo del proyecto.',
                'invalid_project_file': 'Archivo de proyecto no válido. El zip debe contener un archivo .po.',
                'new_project_confirm': '¿Seguro que quieres iniciar un nuevo proyecto? Se perderá todo el progreso no guardado.',
                'save_project_title': 'Guardar Proyecto',
                'filename_label': 'Nombre del archivo:',
                'save_button': 'Guardar',
                'cancel_button': 'Cancelar',
                'enter_filename': 'Por favor, introduce un nombre de archivo.',
                'restore_backup_title': 'Restaurar sesión',
                'restore_backup_info': 'Hemos encontrado una copia de seguridad de tu sesión anterior. ¿Quieres restaurarla?',
                'restore_button': 'Restaurar',
                'discard_button': 'Descartar',
                'backup_btn': 'Copia de seguridad',
                'backup_title': 'Gestión de Copias de Seguridad',
                'backup_info_text': 'Poanda guarda automáticamente una copia de seguridad local de toda tu sesión (archivo PO, MT y glosario) en tu navegador cada 10 segundos. Puedes restaurar esta copia aquí o guardarla en un archivo para mayor seguridad.',
                'last_backup_label': 'Última copia:',
                'no_backup_available': 'No hay ninguna copia de seguridad disponible.',
                'load_local_backup_btn': 'Cargar copia local',
                'save_backup_to_disk_btn': 'Guardar copia en disco',
                'load_backup_from_disk_btn': 'Cargar copia del disco',
                'delete_local_backup_btn': 'Eliminar copia local',
                'backup_deleted': 'La copia de seguridad local ha sido eliminada.',
                'backup_loaded_from_file': 'Copia de seguridad cargada con éxito desde el archivo.',
                'error_loading_backup_file': 'Error al cargar el archivo de copia de seguridad. Asegúrate de que es un archivo .poanda-backup válido.',
                'delete_local_backup_btn_confirm': '¿Seguro que quieres eliminar la copia de seguridad local? Esta acción no se puede deshacer.',
                'mo_converter_title': 'Convertidor de PO a MO',
                'mo_converter_info': 'Esto compilará el archivo .po actual a un archivo binario .mo. La conversión se realiza completamente en tu navegador.',
                'mo_converter_action_btn': 'Convertir y Descargar .mo',
                'mo_conversion_success': 'Archivo .mo convertido y descargado con éxito.',
                'mo_conversion_error': 'Error durante la conversión a MO. Revisa la consola del navegador (F12) para más detalles.',
                'no_file_to_convert': 'No hay ningún archivo .po cargado para convertir.',
                'po_search_placeholder': 'Buscar en el archivo...',
                'search_in_original': 'Buscar en original',
                'search_in_translation': 'Buscar en traducción',
            }
        };

        // --- Shortcut Configuration ---
      const defaultShortcutConfig = {
            validateAndNext: { ctrlKey: true, altKey: false, shiftKey: false, key: 'Enter' },
            nextSegment: { ctrlKey: true, altKey: false, shiftKey: false, key: 'ArrowDown' },
            prevSegment: { ctrlKey: true, altKey: false, shiftKey: false, key: 'ArrowUp' },
 insertTMMatch1: { ctrlKey: true, altKey: true, shiftKey: false, key: '1' },
        insertTMMatch2: { ctrlKey: true, altKey: true, shiftKey: false, key: '2' },
        insertTMMatch3: { ctrlKey: true, altKey: true, shiftKey: false, key: '3' },
        insertTMMatch4: { ctrlKey: true, altKey: true, shiftKey: false, key: '4' },
        insertTMMatch5: { ctrlKey: true, altKey: true, shiftKey: false, key: '5' },
            insertGlossaryTerm1: { ctrlKey: true, altKey: false, shiftKey: false, key: '1' },
            insertGlossaryTerm2: { ctrlKey: true, altKey: false, shiftKey: false, key: '2' },
            insertGlossaryTerm3: { ctrlKey: true, altKey: false, shiftKey: false, key: '3' },
            insertGlossaryTerm4: { ctrlKey: true, altKey: false, shiftKey: false, key: '4' },
            insertGlossaryTerm5: { ctrlKey: true, altKey: false, shiftKey: false, key: '5' }
        };

        let shortcutConfig = {};
        let tempShortcutConfig = {}; // To hold changes before saving

        // --- Helper function to load shortcuts ---
      function loadShortcuts() {
            const savedShortcuts = localStorage.getItem('poandaShortcutConfig');
            let finalConfig = { ...defaultShortcutConfig }; // Empezamos con los valores por defecto

            if (savedShortcuts) {
                const savedConfig = JSON.parse(savedShortcuts);
                // Recorremos los atajos guardados y solo aplicamos los que siguen siendo válidos
                for (const action in savedConfig) {
                    // Si la acción del archivo guardado existe en nuestra configuración por defecto, la usamos.
                    if (defaultShortcutConfig.hasOwnProperty(action)) {
                        finalConfig[action] = savedConfig[action];
                    }
                }
            }
            shortcutConfig = finalConfig;
        }


        // SVG icons for shortcuts
        const arrowDownIcon = `<svg class="shortcut-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 12a1 1 0 01-.707-.293l-4-4a1 1 0 011.414-1.414L10 9.586l3.293-3.293a1 1 0 111.414 1.414l-4 4A1 1 0 0110 12z" clip-rule="evenodd"></path></svg>`;
        const arrowUpIcon = `<svg class="shortcut-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 8a1 1 0 01.707.293l4 4a1 1 0 01-1.414 1.414L10 10.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4A1 1 0 0110 8z" clip-rule="evenodd"></path></svg>`;

        // List of common ISO 639-1 language codes for the datalist (for Terminology)
        const isoLanguagesData = [
          { code: "en", name: "English" }, { code: "en-US", name: "English (United States)" }, { code: "en-GB", name: "English (United Kingdom)" },
          { code: "es", name: "Español" }, { code: "es-ES", name: "Español (España)" }, { code: "es-MX", name: "Español (México)" },
          { code: "fr", name: "Français" }, { code: "de", name: "Deutsch" }, { code: "it", name: "Italiano" }, { code: "pt", name: "Português" },
          { code: "ja", name: "日本語 (Japanese)" }, { code: "zh", name: "中文 (Chinese)" }, { code: "ar", name: "العربية (Arabic)" },
          { code: "ru", name: "Русский (Russian)" }, { code: "ko", name: "한국어 (Korean)" }, { code: "nl", name: "Nederlands" },
          { code: "sv", name: "Svenska" }, { code: "da", name: "Dansk" }, { code: "no", name: "Norsk" }, { code: "fi", name: "Suomi" },
          { code: "tr", name: "Türkçe" }, { code: "pl", name: "Polski" }, { code: "cs", name: "Čeština" }, { code: "hu", name: "Magyar" },
          { code: "el", name: "Ελληνικά (Greek)" }, { code: "he", name: "עברית (Hebrew)" }, { code: "th", name: "ไทย (Thai)" },
          { code: "vi", name: "Tiếng Việt (Vietnamese)" }, { code: "id", name: "Bahasa Indonesia" }, { code: "ms", name: "Bahasa Melayu" },
          { code: "ca", name: "Català" }, { code: "eu", name: "Euskara" }, { code: "gl", name: "Galego" }, { code: "ro", name: "Română" },
          { code: "uk", name: "Українська (Ukrainian)" }, { code: "bg", name: "Български (Bulgarian)" }, { code: "hr", name: "Hrvatski" },
          { code: "sr", name: "Srpski" }, { code: "sk", name: "Slovenčina" }, { code: "sl", name: "Slovenščina" }, { code: "lt", name: "Lietuvių" },
          { code: "lv", name: "Latviešu" }, { code: "et", name: "Eesti" }, { code: "is", name: "Íslenska" }, { code: "ga", name: "Gaeilge" },
          { code: "mt", name: "Malti" },
        ];


        /**
         * Counts words in a given text string.
         * @param {string} text The text to count words from.
         * @returns {number} The number of words.
         */
        function countWords(text) {
            if (!text) return 0;
            // Trim leading/trailing whitespace and split by one or more whitespace characters
            const words = text.trim().split(/\s+/);
            // Filter out empty strings that might result from multiple spaces
            return words.filter(word => word.length > 0).length;
        }

        /**
         * Unescapes a string from PO format.
         * Removes start/end quotes and handles escaped characters like \n, \t, \", \\.
         * Also converts <br> and &lt;br&gt; to newlines for better display.
         * @param {string} s The PO string to unescape.
         * @returns {string} The unescaped string.
         */
        function unescapePoString(s) {
            if (s.startsWith('"') && s.endsWith('"')) {
                s = s.substring(1, s.length - 1);
            }
            s = s.replace(/\\n/g, '\n')
                 .replace(/\\t/g, '\t')
                 .replace(/\\"/g, '"')
                 .replace(/\\\\/g, '\\');
            s = s.replace(/&lt;br&gt;/gi, '\n');
            s = s.replace(/<br\s*\/?>/gi, '\n');

            return s;
        }

        /**
         * Escapes a string for PO format.
         * Adds start/end quotes and escapes special characters like ", \, \n, \t.
         * @param {string} s The string to escape.
         * @returns {string} The escaped string in PO format.
         */
        function escapePoString(s) {
            let escaped = s.replace(/\\/g, '\\\\')
                             .replace(/"/g, '\\"')
                             .replace(/\n/g, '\\n')
                             .replace(/\t/g, '\\t');
            return `"${escaped}"`;
        }

        /**
         * Heuristic to split text into "sentences" for display.
         * @param {string} text The text to split.
         * @returns {Array<string>} An array of text segments.
         */
        function splitTextIntoSentences(text) {
            if (!text || typeof text !== 'string' || text.trim() === '') {
                return [''];
            }
            // Use a regex that keeps the delimiters to re-assemble them correctly
            const sentenceDelimiters = /([.?!]+[\s\r\n]*)/g;
            const parts = text.split(sentenceDelimiters);

            const sentences = [];
            let currentSentence = '';

            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                if (part === null || part === undefined) continue;

                if (part.match(sentenceDelimiters)) { // If it's a delimiter
                    if (currentSentence.trim() !== '') {
                        sentences.push(currentSentence.trim() + part);
                        currentSentence = '';
                    } else if (part.trim() !== '') { // Handle cases where a delimiter might start a segment
                        sentences.push(part.trim());
                    }
                } else { // If it's a sentence part
                    currentSentence += part;
                }
            }
            if (currentSentence.trim() !== '') {
                sentences.push(currentSentence.trim());
            }

            return sentences.filter(s => s.length > 0 || text === '');
        }

        /**
         * Parses the content of a .po file.
         * @param {string} content The full content of the .po file.
         * @returns {Array<Object>} An array of PO entry objects.
         */
        function parsePoContent(content) {
            const entries = [];
            let currentEntry = null;
            const lines = content.split('\n');

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();

                if (trimmedLine.startsWith('#')) {
                    if (currentEntry) {
                        currentEntry.comments = currentEntry.comments || [];
                        currentEntry.comments.push(trimmedLine);
                        if (trimmedLine.includes('#, fuzzy')) {
                            currentEntry.fuzzy = true;
                        }
                    } else {
                        // Header comments before any msgid/msgstr block
                        if (entries.length === 0 || entries[entries.length - 1].comments.length === 0) {
                            // If no entries or the last entry doesn't have comments,
                            // this might be part of a global header comment.
                            // A more robust solution would distinguish global header from entry-specific comments.
                            if (entries.length === 0) {
                                // Create a dummy entry for header comments if no entries exist yet
                                entries.push({ comments: [trimmedLine], msgid: '', msgstr: '' });
                                currentEntry = entries[0];
                            } else {
                                // Add to previous entry's comments
                                entries[entries.length - 1].comments.push(trimmedLine);
                            }
                        }
                    }
                    continue;
                }

                if (trimmedLine.startsWith('msgctxt ')) {
                    if (currentEntry && currentEntry.msgid !== undefined) {
                        entries.push(currentEntry);
                        currentEntry = { comments: [] };
                    } else if (!currentEntry) {
                         currentEntry = { comments: [] };
                    }
                    currentEntry.msgctxt = unescapePoString(trimmedLine.substring(8));
                } else if (trimmedLine.startsWith('msgid ')) {
                    if (currentEntry && currentEntry.msgid !== undefined) {
                        entries.push(currentEntry);
                        currentEntry = { comments: [] };
                    } else if (!currentEntry) {
                         currentEntry = { comments: [] };
                    }
                    currentEntry.msgid = unescapePoString(trimmedLine.substring(6));
                } else if (trimmedLine.startsWith('msgstr ')) {
                    if (!currentEntry) {
                        currentEntry = { comments: [] };
                    }
                    currentEntry.msgstr = unescapePoString(trimmedLine.substring(7));
                    entries.push(currentEntry);
                    currentEntry = null; // Reset for next entry
                } else if (trimmedLine.startsWith('"') && trimmedLine.endsWith('"')) {
                    // Continuation of a multi-line msgid or msgstr
                    if (currentEntry) {
                        const unescapedPart = unescapePoString(trimmedLine);
                        if (currentEntry.msgstr === undefined) {
                            currentEntry.msgid = (currentEntry.msgid || '') + unescapedPart;
                        } else {
                            currentEntry.msgstr = (currentEntry.msgstr || '') + unescapedPart;
                        }
                    }
                } else if (trimmedLine === '') {
                    // Empty line separates entries. If there's an active entry being built, finalize it.
                    if (currentEntry && currentEntry.msgid !== undefined && currentEntry.msgstr !== undefined) {
                        entries.push(currentEntry);
                        currentEntry = null;
                    }
                     // If msgid is present but msgstr is not, and we hit an empty line, save it.
                    else if (currentEntry && currentEntry.msgid !== undefined && currentEntry.msgstr === undefined) {
                         // This case might happen at EOF or if msgstr is missing
                         entries.push(currentEntry);
                         currentEntry = null;
                    }
                    // For comments not associated with an entry, we ensure a fresh start for the next entry
                    if (!currentEntry && lines[i+1] && !lines[i+1].startsWith('#')) { // Only create new if next line isn't a comment
                         currentEntry = { comments: [] };
                    }
                }
            }
            // Add the last entry if it wasn't added (e.g., file ends without a blank line)
            if (currentEntry && (currentEntry.msgid !== undefined || currentEntry.msgctxt !== undefined)) {
                if (currentEntry.msgstr === undefined) { // Ensure msgstr is at least an empty string if not present
                    currentEntry.msgstr = '';
                }
                entries.push(currentEntry);
            }

            // Post-processing for sentence segmentation, word counts, and translation status
            entries.forEach(entry => {
                // Handle the special header entry (msgid "")
                if (entry.msgid === '' && entry.msgctxt === undefined) {
                    entry.isHeader = true;
                    entry.sentenceSegments = [{
                        original: entry.msgid,
                        translation: entry.msgstr,
                        wordCountOriginal: countWords(entry.msgid),
                        wordCountTranslation: countWords(entry.msgstr),
                        isTranslated: entry.msgstr.trim() !== ''
                    }];
                } else {
                    entry.isHeader = false;
                    const originalSegments = splitTextIntoSentences(entry.msgid || '');
                    const translatedSegments = splitTextIntoSentences(entry.msgstr || '');

                    entry.sentenceSegments = [];
                    const maxLength = Math.max(originalSegments.length, translatedSegments.length);
                    for (let j = 0; j < maxLength; j++) {
                        const originalText = originalSegments[j] || '';
                        const translationText = translatedSegments[j] || '';
                        entry.sentenceSegments.push({
                            original: originalText,
                            translation: translationText,
                            wordCountOriginal: countWords(originalText),
                            wordCountTranslation: countWords(translationText),
                            isTranslated: translationText.trim() !== ''
                        });
                    }
                }
            });
            return entries;
        }


        /**
         * Reconstructs the content of a PO file from an array of entries.
         * @param {Array<Object>} entries The array of translation objects.
         * @returns {string} The reconstructed PO file content.
         */
        function reconstructPo(entries) {
            let poContent = '';
            entries.forEach(entry => {
                if (entry.comments && entry.comments.length > 0) {
                    // Filter out fuzzy comment if msgstr is not empty
                    const commentsToKeep = entry.fuzzy && entry.msgstr && entry.msgstr.trim() !== '' 
                        ? entry.comments.filter(c => !c.includes('#, fuzzy')) 
                        : entry.comments;
                    if(commentsToKeep.length > 0) {
                        poContent += commentsToKeep.join('\n') + '\n';
                    }
                }
                if (entry.msgctxt !== undefined) {
                    poContent += `msgctxt ${escapePoString(entry.msgctxt)}\n`;
                }
                if (entry.msgid !== undefined) {
                    poContent += `msgid ${escapePoString(entry.msgid)}\n`;
                }

                let fullMsgstr = '';
                if (entry.sentenceSegments && entry.sentenceSegments.length > 0) {
                    // For header, directly use the stored msgstr
                    if (entry.isHeader) {
                        fullMsgstr = entry.msgstr || '';
                    } else {
                        // For regular entries, join segmented translations
                        fullMsgstr = entry.sentenceSegments.map(s => s.translation).join(' ').trim();
                    }
                } else {
                    fullMsgstr = entry.msgstr || ''; // Fallback if no segments
                }

                if (fullMsgstr !== undefined) {
                    poContent += `msgstr ${escapePoString(fullMsgstr)}\n`;
                }
                poContent += '\n';
            });
            return poContent;
        }

        /**
         * Adjusts the height of a textarea to fit its content.
         * If the translation textarea is empty, it matches the height of the original textarea.
         * @param {HTMLTextAreaElement} textarea The textarea element (msgstr).
         * @param {HTMLElement} [originalElement] The original element (msgid pre) for height comparison.
         */
        function autoResizeTextarea(textarea, originalElement) {
            textarea.style.height = 'auto';
            if (textarea.value.trim() === '' && originalElement) {
                // If textarea is empty, set its height to match the original element's scroll height
                textarea.style.height = originalElement.scrollHeight + 'px';
            } else {
                // Otherwise, let it expand to its own content
                textarea.style.height = textarea.scrollHeight + 'px';
            }
        }

        /**
         * Updates the character count for a specific textarea.
         * @param {HTMLTextAreaElement} textarea The textarea element.
         * @param {number} originalLength The length of the original string segment.
         */
      

function updateCharCount(textarea, originalLength, charCountSpan) {
    if (charCountSpan) {
        charCountSpan.textContent = `${translations[currentLanguage]['char_count_original']}${originalLength} ${translations[currentLanguage]['char_units']} | ${translations[currentLanguage]['char_count_translation']}${textarea.value.length} ${translations[currentLanguage]['char_units']}`;
    }
}

        /**
         * Configures the editable state of a translation entry (editable/read-only).
         * @param {number} entryIndex The index of the main PO entry.
         * @param {number} segmentIndex The index of the sentence segment.
         * @param {boolean} isEditable True to make it editable, false for read-only.
         */
        function setTranslationEditableState(entryIndex, segmentIndex, isEditable) {
            const msgstrTextarea = document.getElementById(`msgstr-${entryIndex}-${segmentIndex}`);
            const validateButton = document.getElementById(`validateBtn-${entryIndex}-${segmentIndex}`);
            const editButton = document.getElementById(`editBtn-${entryIndex}-${segmentIndex}`);
            const checkIcon = document.getElementById(`checkIcon-${entryIndex}-${segmentIndex}`);
            const translationUnit = document.getElementById(`translation-unit-${entryIndex}`); // Get the parent unit


            if (!msgstrTextarea || !validateButton || !editButton || !checkIcon || !translationUnit) {
                console.error(`Elements not found for index ${entryIndex}-${segmentIndex}`);
                return;
            }

            msgstrTextarea.readOnly = !isEditable;
            if (!isEditable) {
                msgstrTextarea.classList.add('bg-gray-200');
                translationUnit.classList.remove('translation-unit-active'); // Remove active highlight on validate

                // Update translation status and words when segment is validated
                const segment = poEntries[entryIndex].sentenceSegments[segmentIndex];
                segment.isTranslated = msgstrTextarea.value.trim() !== '';
                segment.wordCountTranslation = countWords(msgstrTextarea.value);
                updateStatsDisplay(); // Update stats
                addOrUpdateTMEntry(segment.original, segment.translation); // Add/Update TM
            } else {
                msgstrTextarea.classList.remove('bg-gray-200');
                translationUnit.classList.add('translation-unit-active'); // Add active highlight on edit/focus
            }

            validateButton.style.display = isEditable ? 'inline-block' : 'none';
            editButton.style.display = isEditable ? 'none' : 'inline-block';
            checkIcon.style.display = isEditable ? 'none' : 'inline-block';

            if (isEditable) {
                msgstrTextarea.focus();
                // Ensure cursor is at the end of the text
                msgstrTextarea.setSelectionRange(msgstrTextarea.value.length, msgstrTextarea.value.length);
            }
        }

        /**
         * Applies glossary term highlighting to a given text segment.
         * Collects terms that were successfully highlighted.
         * @param {string} text The original text to highlight.
         * @returns {{html: string, foundTerms: Set<string>}} Object with HTML string and set of found terms.
         */
        function applyGlossaryHighlightToText(text) {
            let highlightedHtml = text;
            const currentFoundTerms = new Set(); // Terms found in *this specific* segment

            // Ensure glossarySourceLanguage is set and matches the original's implicit language
            if (!glossarySourceLanguage) {
                return { html: text, foundTerms: currentFoundTerms }; // Cannot highlight without source language
            }

            // Sort glossary terms by length in descending order to match longer terms first
            const sortedGlossary = [...glossary].sort((a, b) => b.srcTerm.length - a.srcTerm.length);


            sortedGlossary.forEach(glossaryEntry => {
                // Only highlight if the glossary entry's source language matches the current editor's source language
                // Assuming poEntries are implicitly in poanda's current source language.
                // For a more robust solution, each poEntry might need a source language field.
                // For now, we assume the glossary source language is the relevant source for highlighting.
                // Also, ensure the glossary entry has a source term.
                if (glossarySourceLanguage && glossaryEntry.srcTerm) {
                    const term = glossaryEntry.srcTerm;
                    // Use word boundaries \b to avoid partial word matches
                    // Escape special regex characters in the term
                    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    // 'g' for global, 'i' for case-insensitive
                    const regex = new RegExp(`\\b(${escapedTerm})\\b`, 'gi'); // Added word boundaries


                    // Only replace if the term is found (to avoid unnecessary string manipulations)
                    if (highlightedHtml.match(regex)) {
                        highlightedHtml = highlightedHtml.replace(regex, (match, p1) => {
                            // p1 is the captured group, which is the actual matched term (case-preserved)
                            currentFoundTerms.add(term); // Add the actual term from the glossary (case-preserved)
                            return `<span class="glossary-highlight">${p1}</span>`; // Highlight the matched part
                        });
                    }
                }
            });
            return { html: highlightedHtml, foundTerms: currentFoundTerms };
        }

        /**
         * Updates highlighting in the glossary table based on terms found in the editor.
         * This function is implicitly called via renderGlossary() after termsFoundInActiveSegment is updated.
         */
        function updateGlossaryTableHighlights() {
            renderGlossary(); // Re-render glossary, which applies highlights based on termsFoundInActiveSegment
        }


        /**
         * Renders translation entries in the user interface, including sentence segmentation.
         * @param {Array<Object>} entries The array of translation objects to render.
         */
        function renderTranslations(entries) {
            translationsContainer.innerHTML = '';
            termsFoundInActiveSegment.clear(); // Clear terms when re-rendering all translations

            if (entries.length === 0) {
                translationsContainer.innerHTML = `
                    <div data-i18n="no_translations" id="initialMessage" class="text-center text-on-light-contrast p-4 border border-gray-300 rounded-md">
                        ${translations[currentLanguage]['no_translations']}
                    </div>
                `;
                savePoButton.disabled = true;
                convertToMoButton.disabled = true; 
                poSearchContainer.classList.add('hidden'); // Hide search bar
                statsContainer.classList.remove('show'); // Hide stats if no translations
                updateUtilityButtonStates(); 
                return;
            }

            poSearchContainer.classList.remove('hidden'); // Show search bar

            entries.forEach((entry, entryIndex) => {
                // Skip rendering header entry explicitly in the main editor area, but keep in poEntries
                if (entry.isHeader) {
                    return;
                }

                const translationUnit = document.createElement('div');
                translationUnit.id = `translation-unit-${entryIndex}`; // Added ID for highlighting
                translationUnit.className = 'translation-unit-bg p-4 rounded-lg shadow-sm border';

                if (entry.comments && entry.comments.length > 0) {
                    const commentsDiv = document.createElement('div');
                    commentsDiv.className = 'text-xs text-gray-500 mb-2 whitespace-pre-wrap';
                    commentsDiv.textContent = entry.comments.join('\n');
                    translationUnit.appendChild(commentsDiv);
                }
                if (entry.msgctxt) {
                    const msgctxtLabel = document.createElement('label');
                    msgctxtLabel.className = 'block text-sm font-medium text-on-light-contrast mb-1';
                    msgctxtLabel.textContent = translations[currentLanguage]['context_msgctxt'];
                    translationUnit.appendChild(msgctxtLabel);

                    const msgctxtPre = document.createElement('pre');
                    msgctxtPre.className = 'po-display-code p-2 rounded-md text-base overflow-auto max-h-32';
                    msgctxtPre.textContent = entry.msgctxt;
                    translationUnit.appendChild(msgctxtPre);
                }

                entry.sentenceSegments.forEach((segment, segmentIndex) => {

                    const segmentRow = document.createElement('div');
                    segmentRow.className = 'translation-row mb-4';

                    const originalCol = document.createElement('div');
                    originalCol.className = 'original-col';

                    const msgidLabel = document.createElement('label');
                    msgidLabel.className = 'block text-sm font-medium text-on-light-contrast mb-1';
                    msgidLabel.textContent = translations[currentLanguage]['original_msgid'];
                    originalCol.appendChild(msgidLabel);

                    const msgidPre = document.createElement('pre');
                    msgidPre.id = `msgid-pre-${entryIndex}-${segmentIndex}`; // Added ID for easier lookup
                    msgidPre.className = 'po-display-code p-2 rounded-md text-base overflow-auto max-h-32';
                    msgidPre.textContent = segment.original; // Initial text without highlight
                    originalCol.appendChild(msgidPre);
                    segmentRow.appendChild(originalCol);

                    const translationCol = document.createElement('div');
                    translationCol.className = 'translation-col';

                    const msgstrLabel = document.createElement('label');
                    msgstrLabel.className = 'block text-sm font-medium text-on-light-contrast mb-1';
                    msgstrLabel.textContent = translations[currentLanguage]['translation_msgstr'];
                    translationCol.appendChild(msgstrLabel);

                    const msgstrTextarea = document.createElement('textarea');
                    msgstrTextarea.id = `msgstr-${entryIndex}-${segmentIndex}`;
                    msgstrTextarea.className = 'msgstr-textarea mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-red-500 focus:border-red-500 text-base';
                    msgstrTextarea.value = segment.translation;
                    msgstrTextarea.dataset.entryIndex = entryIndex;
                    msgstrTextarea.dataset.segmentIndex = segmentIndex;
                    msgstrTextarea.dataset.originalLength = segment.original.length;

                    translationCol.appendChild(msgstrTextarea);
                    segmentRow.appendChild(translationCol);
                    translationUnit.appendChild(segmentRow);

                    const controlsContainer = document.createElement('div');
                    controlsContainer.className = 'flex items-center justify-between mt-2 w-full';

                    const charCountSpan = document.createElement('span');
                    charCountSpan.id = `charCount-${entryIndex}-${segmentIndex}`;
                    charCountSpan.className = 'inline-block text-sm font-semibold text-on-light-contrast';
                    controlsContainer.appendChild(charCountSpan);

                    const actionButtonsContainer = document.createElement('div');
                    actionButtonsContainer.className = 'flex items-center space-x-2';

                    const checkIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    checkIcon.setAttribute("id", `checkIcon-${entryIndex}-${segmentIndex}`);
                    checkIcon.setAttribute("class", "check-icon text-green-500");
                    checkIcon.setAttribute("fill", "none");
                    checkIcon.setAttribute("viewBox", "0 0 24 24");
                    checkIcon.setAttribute("stroke", "currentColor");
                    checkIcon.innerHTML = `
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                    `;
                    actionButtonsContainer.appendChild(checkIcon);

                    const validateButton = document.createElement('button');
                    validateButton.id = `validateBtn-${entryIndex}-${segmentIndex}`;
                    validateButton.className = 'validate-button font-medium py-1 px-3 rounded-md shadow-sm transition duration-300 btn-validate';
                    validateButton.textContent = translations[currentLanguage]['validate'];
                    validateButton.dataset.entryIndex = entryIndex;
                    validateButton.dataset.segmentIndex = segmentIndex;
                    actionButtonsContainer.appendChild(validateButton);

                    const editButton = document.createElement('button');
                    editButton.id = `editBtn-${entryIndex}-${segmentIndex}`;
                    editButton.className = 'edit-button font-medium py-1 px-3 rounded-md shadow-sm transition duration-300 btn-edit';
                    editButton.textContent = translations[currentLanguage]['edit'];
                    editButton.dataset.entryIndex = entryIndex;
                    editButton.dataset.segmentIndex = segmentIndex;
                    editButton.style.display = 'none';
                    actionButtonsContainer.appendChild(editButton);

                    controlsContainer.appendChild(actionButtonsContainer);
                    translationUnit.appendChild(controlsContainer);

                    msgstrTextarea.addEventListener('input', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        const segment = poEntries[currentEntryIndex].sentenceSegments[currentSegmentIndex];

                        segment.translation = event.target.value;
                        segment.wordCountTranslation = countWords(event.target.value);
                        segment.isTranslated = event.target.value.trim() !== '';

                        const originalSegmentPre = originalCol.querySelector('pre');
                        autoResizeTextarea(event.target, originalSegmentPre);
      const charCountSpan = document.getElementById(`charCount-${currentEntryIndex}-${currentSegmentIndex}`);
updateCharCount(event.target, parseInt(event.target.dataset.originalLength), charCountSpan);
                        updateStatsDisplay();

                        if (document.activeElement === msgstrTextarea) {
                            const tempOriginalText = segment.original;
                            originalCol.querySelector('pre').textContent = tempOriginalText;
                            termsFoundInActiveSegment.clear();
                            const highlightResult = applyGlossaryHighlightToText(tempOriginalText);
                            originalCol.querySelector('pre').innerHTML = highlightResult.html;
                            highlightResult.foundTerms.forEach(term => termsFoundInActiveSegment.add(term));
                            updateGlossaryTableHighlights();
                        }
                    });

                    msgstrTextarea.addEventListener('focus', (event) => {
                        document.querySelectorAll('.translation-unit-active').forEach(unit => {
                            unit.classList.remove('translation-unit-active');
                        });
                        translationUnit.classList.add('translation-unit-active');

                        termsFoundInActiveSegment.clear();
                        const originalSegmentPre = document.getElementById(`msgid-pre-${entryIndex}-${segmentIndex}`);
                        if (originalSegmentPre && glossarySourceLanguage && glossary.length > 0) {
                            const highlightResult = applyGlossaryHighlightToText(segment.original);
                            originalSegmentPre.innerHTML = highlightResult.html;
                            highlightResult.foundTerms.forEach(term => termsFoundInActiveSegment.add(term));
                        }
                        updateGlossaryTableHighlights();
                        autoResizeTextarea(event.target, originalCol.querySelector('pre'));
                        event.target.scrollIntoView({ behavior: 'smooth', block: 'center' });

                        const currentSegmentOriginal = poEntries[entryIndex].sentenceSegments[segmentIndex].original;
                        tmBestMatchForActiveSegment = findBestTMMatch(currentSegmentOriginal);
                        tmSearch();
                    });

                    msgstrTextarea.addEventListener('blur', (event) => {
                        const originalSegmentPre = document.getElementById(`msgid-pre-${entryIndex}-${segmentIndex}`);
                        if (originalSegmentPre) {
                            originalSegmentPre.textContent = segment.original;
                        }
                        termsFoundInActiveSegment.clear();
                        updateGlossaryTableHighlights();
                        tmBestMatchForActiveSegment = null;
                        tmSearch();
                    });


                    msgstrTextarea.addEventListener('click', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        if (event.target.readOnly) {
                            setTranslationEditableState(currentEntryIndex, currentSegmentIndex, true);
                        }
                    });

                    validateButton.addEventListener('click', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        setTranslationEditableState(currentEntryIndex, currentSegmentIndex, false);
                        goToNextTranslation(currentEntryIndex, currentSegmentIndex);
                    });

                    editButton.addEventListener('click', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        setTranslationEditableState(currentEntryIndex, currentSegmentIndex, true);
                    });

                    autoResizeTextarea(msgstrTextarea, msgidPre);
updateCharCount(msgstrTextarea, segment.original.length, charCountSpan);
                });

                if (entry.fuzzy) {
                    const fuzzyIndicator = document.createElement('span');
                    fuzzyIndicator.className = 'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800 mt-2';
                    fuzzyIndicator.textContent = translations[currentLanguage]['fuzzy'];
                    translationUnit.appendChild(fuzzyIndicator);
                }

                translationsContainer.appendChild(translationUnit);
            });
            savePoButton.disabled = false;
            convertToMoButton.disabled = false;
            statsContainer.classList.add('show');
            updateStatsDisplay();
            updateUtilityButtonStates();

            const firstEditableSegment = getFirstEditableSegment();
            if (firstEditableSegment) {
                navigateToTranslation(firstEditableSegment.entryIndex, firstEditableSegment.segmentIndex);
            }
        }

        /**
         * Filters and highlights PO entries based on the search input.
         */
        function filterPOEntries() {
            const query = poSearchInput.value.trim();
            const searchInOriginal = searchInOriginalCheckbox.checked;
            const searchInTranslation = searchInTranslationCheckbox.checked;
            
            // Clear previous search state
            searchResults = [];
            currentSearchIndex = -1;
            document.querySelectorAll('.search-highlight, .current-search-highlight').forEach(el => {
                const parent = el.parentNode;
                if (parent) {
                    parent.innerHTML = parent.textContent; // Revert to plain text
                }
            });

            if (!query) {
                poEntries.forEach((entry, index) => {
                    const unit = document.getElementById(`translation-unit-${index}`);
                    if (unit) unit.style.display = 'block';
                });
                updateSearchCounter();
                return;
            }

            const queryRegex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            
            poEntries.forEach((entry, index) => {
                if (entry.isHeader) return;

                const unit = document.getElementById(`translation-unit-${index}`);
                if (!unit) return;

                let matchFound = false;
                const fullMsgstr = entry.sentenceSegments.map(s => s.translation).join(' ');

                // Highlight in original
                if (searchInOriginal) {
                    const msgidElements = unit.querySelectorAll('.original-col pre');
                    msgidElements.forEach(el => {
                        const originalText = el.textContent;
                        if (originalText.match(queryRegex)) {
                            matchFound = true;
                            el.innerHTML = originalText.replace(queryRegex, match => `<span class="search-highlight">${match}</span>`);
                        }
                    });
                }

                // Check for match in translation (without highlighting the textarea)
                if (searchInTranslation && fullMsgstr.match(queryRegex)) {
                    matchFound = true;
                }

                unit.style.display = matchFound ? 'block' : 'none';
            });

            // Populate searchResults array with all new highlights
            searchResults = document.querySelectorAll('.search-highlight');
            updateSearchCounter();
        }
        
        /**
         * Updates the search result counter and button states.
         */
        function updateSearchCounter() {
            const total = searchResults.length;
            const current = total > 0 ? currentSearchIndex + 1 : 0;
            searchResultCounter.textContent = `${current} / ${total}`;
            
            searchPrevBtn.disabled = total === 0;
            searchNextBtn.disabled = total === 0;
        }

        /**
         * Navigates to the next or previous search result.
         * @param {number} direction - 1 for next, -1 for previous.
         */
        function navigateToSearchResult(direction) {
            if (searchResults.length === 0) return;

            // Remove highlight from the current result
            if (currentSearchIndex >= 0 && searchResults[currentSearchIndex]) {
                searchResults[currentSearchIndex].classList.remove('current-search-highlight');
                searchResults[currentSearchIndex].classList.add('search-highlight');
            }

            // Update index
            currentSearchIndex += direction;

            // Loop around
            if (currentSearchIndex >= searchResults.length) {
                currentSearchIndex = 0;
            }
            if (currentSearchIndex < 0) {
                currentSearchIndex = searchResults.length - 1;
            }

            // Highlight the new current result
            const currentResult = searchResults[currentSearchIndex];
            if (currentResult) {
                currentResult.classList.remove('search-highlight');
                currentResult.classList.add('current-search-highlight');
                currentResult.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            
            updateSearchCounter();
        }


        /**
         * Updates the display of translation progress and word counts.
         */
        function updateStatsDisplay() {
            let totalSegments = 0;
            let translatedSegments = 0;
            let totalWordsOriginal = 0;
            let totalWordsTranslated = 0;

            poEntries.forEach(entry => {
                if (entry.isHeader) return;
                
                if (entry.sentenceSegments) {
                    entry.sentenceSegments.forEach(segment => {
                        totalSegments++;
                        totalWordsOriginal += segment.wordCountOriginal;
                        if (segment.isTranslated) {
                            translatedSegments++;
                            totalWordsTranslated += segment.wordCountTranslation;
                        }
                    });
                }
            });

            const percentage = totalSegments > 0 ? ((translatedSegments / totalSegments) * 100).toFixed(0) : 0;
            segmentsProgress.textContent = `${translatedSegments} / ${totalSegments} segments (${percentage}%)`;
            wordsTranslated.textContent = `${totalWordsTranslated}`;
            wordsTotal.textContent = `${totalWordsOriginal}`;
            wordsRemaining.textContent = `${totalWordsOriginal - totalWordsTranslated}`;
        }


        /**
         * Gets the index of the currently focused translation textarea, including the segment index.
         * @returns {{entryIndex: number, segmentIndex: number} | null} The object with indices, or null.
         */
        function getCurrentFocusedIndex() {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.classList.contains('msgstr-textarea')) {
                return {
                    entryIndex: parseInt(activeElement.dataset.entryIndex),
                    segmentIndex: parseInt(activeElement.dataset.segmentIndex)
                };
            }
            return null;
        }

        /**
         * Finds the first editable segment (not a header).
         * @returns {{entryIndex: number, segmentIndex: number} | null} The object with indices, or null.
         */
        function getFirstEditableSegment() {
            for (let i = 0; i < poEntries.length; i++) {
                const entry = poEntries[i];
                if (!entry.isHeader && entry.sentenceSegments && entry.sentenceSegments.length > 0) {
                    return { entryIndex: i, segmentIndex: 0 };
                }
            }
            return null;
        }


        /**
         * Navigates to and focuses a specific translation field (segment).
         * @param {number} entryIndex The index of the PO entry.
         * @param {number} segmentIndex The index of the sentence segment.
         */
        function navigateToTranslation(entryIndex, segmentIndex) {
            const targetTextarea = document.getElementById(`msgstr-${entryIndex}-${segmentIndex}`);
            if (targetTextarea) {
                const currentlyFocusedTextarea = document.activeElement;
                if (currentlyFocusedTextarea && currentlyFocusedTextarea.classList.contains('msgstr-textarea') && currentlyFocusedTextarea !== targetTextarea) {
                    currentlyFocusedTextarea.blur();
                }
                setTranslationEditableState(entryIndex, segmentIndex, true);
                targetTextarea.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        /**
         * Moves focus to the next translation field (segment).
         * @param {number} currentEntryIndex The current index of the PO entry.
         * @param {number} currentSegmentIndex The current index of the sentence segment.
         */
        function goToNextTranslation(currentEntryIndex, currentSegmentIndex) {
            if (poEntries.length === 0) return;

            let nextEntryIndex = currentEntryIndex;
            let nextSegmentIndex = currentSegmentIndex + 1;

            while (true) {
                if (nextEntryIndex >= poEntries.length) {
                    showMessage(translations[currentLanguage]['reached_last']);
                    return;
                }

                const currentEntry = poEntries[nextEntryIndex];
                if (currentEntry.isHeader || !currentEntry.sentenceSegments || currentEntry.sentenceSegments.length === 0) {
                    nextEntryIndex++;
                    nextSegmentIndex = 0;
                    continue;
                }

                if (nextSegmentIndex < currentEntry.sentenceSegments.length) {
                    navigateToTranslation(nextEntryIndex, nextSegmentIndex);
                    return;
                } else {
                    nextEntryIndex++;
                    nextSegmentIndex = 0;
                }
            }
        }

        /**
         * Moves focus to the previous translation field (segment).
         * @param {number} currentEntryIndex The current index of the PO entry.
         * @param {number} currentSegmentIndex The current index of the sentence segment.
         */
        function goToPreviousTranslation(currentEntryIndex, currentSegmentIndex) {
            if (poEntries.length === 0) return;

            let prevEntryIndex = currentEntryIndex;
            let prevSegmentIndex = currentSegmentIndex - 1;

            while (true) {
                if (prevEntryIndex < 0) {
                    showMessage(translations[currentLanguage]['reached_first']);
                    return;
                }

                const currentEntry = poEntries[prevEntryIndex];
                if (currentEntry.isHeader || !currentEntry.sentenceSegments || currentEntry.sentenceSegments.length === 0) {
                    prevEntryIndex--;
                    prevSegmentIndex = (prevEntryIndex >= 0 && poEntries[prevEntryIndex].sentenceSegments) ? poEntries[prevEntryIndex].sentenceSegments.length - 1 : 0;
                    continue;
                }

                if (prevSegmentIndex >= 0) {
                    navigateToTranslation(prevEntryIndex, prevSegmentIndex);
                    return;
                } else {
                    prevEntryIndex--;
                    prevSegmentIndex = (prevEntryIndex >= 0 && poEntries[prevEntryIndex].sentenceSegments) ? poEntries[prevEntryIndex].sentenceSegments.length - 1 : 0;
                }
            }
        }

        // --- Event Handlers ---

        poFile.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                currentFileName = file.name;
                const content = await file.text();
                processPoContent(content);
            }
        });

        function processPoContent(content) {
             showLoadingOverlay(translations[currentLanguage]['loading_file']);
             try {
                poEntries = parsePoContent(content);
setTimeout(() => {
    renderTranslations(poEntries);
    updateStatsDisplay();
}, 0);
                poSearchInput.value = ''; // Clear search on new file
                filterPOEntries(); // Apply empty filter to reset view
             } catch (error) {
                showMessage(`${translations[currentLanguage]['error_reading_file']} ${error.message}`);
                console.error("Error parsing file:", error);
                translationsContainer.innerHTML = `
                    <div class="text-center text-red-500 p-4 border border-red-300 rounded-md">
                        ${translations[currentLanguage]['file_processing_error']}
                    </div>
                `;
                savePoButton.disabled = true;
                convertToMoButton.disabled = true;
                poSearchContainer.classList.add('hidden');
                statsContainer.classList.remove('show');
                updateUtilityButtonStates();
             } finally {
                hideLoadingOverlay();
             }
        }

        savePoButton.addEventListener('click', async () => {
            if (poEntries.length === 0) {
                showMessage(translations[currentLanguage]['no_translations_to_save']);
                return;
            }
            showLoadingOverlay(translations[currentLanguage]['saving_file']);
            try {
                const updatedPoContent = reconstructPo(poEntries);
                const blob = new Blob([updatedPoContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = currentFileName.replace(/\.po$/i, '') + '.po';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showMessage(translations[currentLanguage]['file_saved_successfully']);
            } catch (error) {
                showMessage(`${translations[currentLanguage]['error_saving_file']} ${error.message}`);
                console.error("Error saving file:", error);
            } finally {
                hideLoadingOverlay();
            }
        });

        async function processFile(file) {
            currentFileName = file.name;
            const content = await file.text();
            processPoContent(content);
        }

        // Main keydown listener
        document.addEventListener('keydown', (event) => {
            // Ignore keydown events if a modal is open or if the event originates from an input field not part of the main translation flow
            const activeElement = document.activeElement;
            const isModalOpen = !shortcutsModal.classList.contains('hidden') || 
                                !findReplaceModal.classList.contains('hidden') || 
                                !messageBox.classList.contains('hidden') || 
                                !saveProjectModal.classList.contains('hidden') ||
                                !backupModal.classList.contains('hidden') ||
                                !restoreBackupModal.classList.contains('hidden');

            if (isModalOpen && activeElement.id !== 'findInput' && activeElement.id !== 'replaceInput') {
                 // Exception for find/replace inputs inside their modal
                if (activeElement.closest('.modal') && !activeElement.classList.contains('shortcut-input')) {
                   return;
                }
            }

            // Check if the event matches any configured shortcut
            for (const action in shortcutConfig) {
                const config = shortcutConfig[action];

                if (event.ctrlKey === config.ctrlKey &&
                    event.altKey === config.altKey &&
                    event.shiftKey === config.shiftKey &&
                    event.key.toLowerCase() === config.key.toLowerCase()) {
                    
                    event.preventDefault();
                    handleShortcutAction(action, event.key);
                    return; 
                }
            }
        });

        function handleShortcutAction(action, pressedKey) {
            const currentFocused = getCurrentFocusedIndex();

            // La mayoría de las acciones requieren un segmento activo
            if (!currentFocused && !action.startsWith('open')) return;

            // Manejo dinámico para acciones numeradas
            if (action.startsWith('insertTMMatch') || action.startsWith('insertGlossaryTerm')) {
                const isTM = action.startsWith('insertTMMatch');
                const items = isTM ? currentTMLatestSearchResults : currentGlossaryLatestResults;
                const index = parseInt(action.slice(-1)) - 1; // Extrae el número del final de la acción

                if (items.length > index) {
                    const itemToInsert = items[index];
                    const textToInsert = isTM ? itemToInsert.tgtText : itemToInsert.tgtTerm;
                    const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                    
                    if (targetTextarea && !targetTextarea.readOnly) {
                        const start = targetTextarea.selectionStart;
                        const end = targetTextarea.selectionEnd;
                        targetTextarea.value = targetTextarea.value.substring(0, start) + textToInsert + targetTextarea.value.substring(end);
                        targetTextarea.selectionStart = targetTextarea.selectionEnd = start + textToInsert.length;
                        
                        // Dispara el evento 'input' para actualizar contadores
                        targetTextarea.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                } else {
                    showMessage(translations[currentLanguage][isTM ? 'tm_no_match_found' : 'no_match_found']);
                }
                return; // Acción manejada
            }

            // Manejo para el resto de acciones
            switch (action) {
                case 'validateAndNext':
                    setTranslationEditableState(currentFocused.entryIndex, currentFocused.segmentIndex, false);
                    goToNextTranslation(currentFocused.entryIndex, currentFocused.segmentIndex);
                    break;
                case 'nextSegment':
                    goToNextTranslation(currentFocused.entryIndex, currentFocused.segmentIndex);
                    break;
                case 'prevSegment':
                    goToPreviousTranslation(currentFocused.entryIndex, currentFocused.segmentIndex);
                    break;
            }
        }


        function showMessage(msg) {
            messageText.textContent = msg;
            messageBox.classList.remove('hidden');
        }

        messageClose.addEventListener('click', () => {
            messageBox.classList.add('hidden');
        });

        shortcutsBtn.addEventListener('click', () => {
            tempShortcutConfig = JSON.parse(JSON.stringify(shortcutConfig)); // Create a deep copy for editing
            renderShortcutsUI();
            shortcutsModal.classList.remove('hidden');
        });

        shortcutsCloseBtn.addEventListener('click', () => {
            shortcutsModal.classList.add('hidden');
        });

        findReplaceBtn.addEventListener('click', () => {
            findReplaceModal.classList.remove('hidden');
            findInput.focus();
        });

        findReplaceCloseBtn.addEventListener('click', () => {
            findReplaceModal.classList.add('hidden');
            findState.lastFound = null;
            const currentFocused = getCurrentFocusedIndex();
            if (currentFocused) {
                const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                if (targetTextarea) {
                    targetTextarea.setSelectionRange(targetTextarea.value.length, targetTextarea.value.length);
                }
            }
        });

        findNextBtn.addEventListener('click', () => findAndNavigate(true));
        findPrevBtn.addEventListener('click', () => findAndNavigate(false));
        replaceBtn.addEventListener('click', replaceCurrentMatch);
        replaceAllBtn.addEventListener('click', replaceAllMatches);

        function findAndNavigate(forward = true) {
            const query = findInput.value;
            if (!query) {
                showMessage(translations[currentLanguage]['no_find_query']);
                return;
            }

            findState.query = query;
            findState.caseSensitive = caseSensitiveCheckbox.checked;
            findState.useRegex = regexCheckbox.checked;

            let regex;
            try {
                regex = findState.useRegex ? new RegExp(findState.query, findState.caseSensitive ? '' : 'i') : null;
            } catch (e) {
                showMessage(`Regular expression error: ${e.message}`);
                return;
            }

            let startEntryIndex = 0;
            let startSegmentIndex = 0;
            let startMatchIndex = 0;

            if (findState.lastFound) {
                startEntryIndex = findState.lastFound.entryIndex;
                startSegmentIndex = findState.lastFound.segmentIndex;
                startMatchIndex = forward ? findState.lastFound.matchEnd : findState.lastFound.matchStart - 1;
            } else {
                if (!forward) {
                    startEntryIndex = poEntries.length - 1;
                    if (poEntries[startEntryIndex] && poEntries[startEntryIndex].sentenceSegments) {
                        startSegmentIndex = poEntries[startEntryIndex].sentenceSegments.length - 1;
                    } else {
                        startSegmentIndex = 0;
                    }
                    startMatchIndex = Infinity;
                }
            }

            let found = false;
            let currentEntryIndex = startEntryIndex;
            let currentSegmentIndex = startSegmentIndex;
            const totalEntries = poEntries.length;

            for (let i = 0; i < totalEntries; i++) {
                const entry = poEntries[currentEntryIndex];
                if (!entry || entry.isHeader || !entry.sentenceSegments) {
                    currentEntryIndex = (currentEntryIndex + (forward ? 1 : -1) + totalEntries) % totalEntries;
                    currentSegmentIndex = forward ? 0 : (entry && entry.sentenceSegments ? entry.sentenceSegments.length - 1 : 0);
                    continue;
                }

                const totalSegments = entry.sentenceSegments.length;
                let segmentLoopStart = forward ? 0 : totalSegments - 1;
                let segmentLoopEnd = forward ? totalSegments : -1;
                let segmentLoopStep = forward ? 1 : -1;

                if (currentEntryIndex === startEntryIndex) {
                    segmentLoopStart = startSegmentIndex;
                }


                for (let j = segmentLoopStart; forward ? (j < segmentLoopEnd) : (j >= segmentLoopEnd); j += segmentLoopStep) {
                    const segment = entry.sentenceSegments[j];
                    const text = segment.translation;
                    let match;

                    if (findState.useRegex) {
                        regex.lastIndex = 0;
                        if (forward) {
                            let searchFrom = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : 0;
                            const subText = text.substring(searchFrom);
                            match = regex.exec(subText);
                            if (match) {
                                match.index += searchFrom;
                            }
                        } else {
                            let allMatches = [];
                            let tempRegex = new RegExp(regex.source, regex.flags.includes('g') ? regex.flags : regex.flags + 'g');
                            let tempMatch;
                            while((tempMatch = tempRegex.exec(text)) !== null) {
                                allMatches.push(tempMatch);
                            }
                            let searchUntil = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : text.length;
                            match = allMatches.reverse().find(m => m.index < searchUntil);
                        }
                    } else {
                        const searchText = findState.caseSensitive ? text : text.toLowerCase();
                        const queryLower = findState.caseSensitive ? findState.query : findState.query.toLowerCase();

                        if (forward) {
                            let searchFrom = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : 0;
                            const foundIndex = searchText.indexOf(queryLower, searchFrom);
                            if (foundIndex !== -1) {
                                match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                            }
                        } else {
                            let searchUntil = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : text.length;
                            const foundIndex = searchText.lastIndexOf(queryLower, searchUntil);
                            if (foundIndex !== -1) {
                                match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                            }
                        }
                    }

                    if (match) {
                        findState.lastFound = {
                            entryIndex: currentEntryIndex,
                            segmentIndex: j,
                            matchStart: match.index,
                            matchEnd: match.index + match[0].length,
                        };
                        navigateToTranslation(currentEntryIndex, j);
                        const targetTextarea = document.getElementById(`msgstr-${currentEntryIndex}-${j}`);
                        if (targetTextarea) {
                            targetTextarea.setSelectionRange(findState.lastFound.matchStart, findState.lastFound.matchEnd);
                        }
                        found = true;
                        return;
                    }
                }
                if (found) break;

                currentEntryIndex = (currentEntryIndex + (forward ? 1 : -1) + totalEntries) % totalEntries;
                currentSegmentIndex = forward ? 0 : (poEntries[currentEntryIndex].sentenceSegments ? poEntries[currentEntryIndex].sentenceSegments.length - 1 : 0);
            }

            if (!found) {
                showMessage(translations[currentLanguage]['no_match_found']);
                findState.lastFound = null;
            }
        }


        function replaceCurrentMatch() {
            if (!findState.lastFound || !findState.query) {
                showMessage(translations[currentLanguage]['no_match_found']);
                return;
            }

            const { entryIndex, segmentIndex, matchStart, matchEnd } = findState.lastFound;
            const segment = poEntries[entryIndex].sentenceSegments[segmentIndex];
            let originalText = segment.translation;
            let replacedText;

            if (findState.useRegex) {
                 const regex = new RegExp(findState.query, findState.caseSensitive ? '' : 'i');
                 replacedText = originalText.substring(0, matchStart) +
                                originalText.substring(matchStart, matchEnd).replace(regex, findState.replace) +
                                originalText.substring(Math.min(matchEnd, originalText.length));

            } else {
                replacedText = originalText.substring(0, matchStart) +
                               findState.replace +
                               originalText.substring(Math.min(matchEnd, originalText.length));
            }

            segment.translation = replacedText;
            segment.wordCountTranslation = countWords(replacedText);
            segment.isTranslated = replacedText.trim() !== '';

            renderTranslations(poEntries);
            navigateToTranslation(entryIndex, segmentIndex);
            updateStatsDisplay();

            findState.lastFound = null;
        }

        function replaceAllMatches() {
            const query = findInput.value;
            const replaceWith = replaceInput.value;
            if (!query) {
                showMessage(translations[currentLanguage]['no_find_query']);
                return;
            }

            let replacedCount = 0;
            let regex;
            try {
                regex = new RegExp(query, (caseSensitiveCheckbox.checked ? '' : 'i') + 'g' + (regexCheckbox.checked ? '' : ''));
            } catch (e) {
                showMessage(`Regular expression error: ${e.message}`);
                return;
            }

            poEntries.forEach(entry => {
                if (entry.isHeader) {
                    return;
                }

                entry.sentenceSegments.forEach(segment => {
                    let originalTranslation = segment.translation;
                    let newTranslation;

                    if (regexCheckbox.checked) {
                        newTranslation = originalTranslation.replace(regex, replaceWith);
                    } else {
                        const searchStr = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const nonRegexRegex = new RegExp(searchStr, (caseSensitiveCheckbox.checked ? '' : 'i') + 'g');
                        newTranslation = originalTranslation.replace(nonRegexRegex, replaceWith);
                    }

                    if (originalTranslation !== newTranslation) {
                        segment.translation = newTranslation;
                        segment.wordCountTranslation = countWords(newTranslation);
                        segment.isTranslated = newTranslation.trim() !== '';
                        replacedCount++;
                    }
                });
            });

            renderTranslations(poEntries);
            showMessage(`${replacedCount} ${translations[currentLanguage]['replaced_all']}`);
            findState.lastFound = null;
            updateStatsDisplay();
        }


        function setLanguage(lang) {
            currentLanguage = lang;
            document.documentElement.lang = lang;
            
            const langEnBtn = document.getElementById('langEnBtn');
            const langEsBtn = document.getElementById('langEsBtn');
            
            langEnBtn.classList.remove('active-lang');
            langEsBtn.classList.remove('active-lang');
            langEnBtn.style.backgroundColor = 'var(--color-medium-gray)';
            langEnBtn.style.color = 'var(--color-dark)';
            langEsBtn.style.backgroundColor = 'var(--color-medium-gray)';
            langEsBtn.style.color = 'var(--color-dark)';


            if (lang === 'en') {
                langEnBtn.classList.add('active-lang');
                langEnBtn.style.backgroundColor = 'var(--color-dark)';
                langEnBtn.style.color = 'var(--color-white)';
            } else {
                langEsBtn.classList.add('active-lang');
                langEsBtn.style.backgroundColor = 'var(--color-dark)';
                langEsBtn.style.color = 'var(--color-white)';
            }

            updateTextContent();
            renderTranslations(poEntries);
            renderGlossary();
        }

        function updateTextContent() {
            const lang = translations[currentLanguage];

            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (lang[key]) {
                    if (element.hasAttribute('data-i18n-placeholder')) {
                        element.placeholder = lang[key];
                    } else {
                        element.textContent = lang[key];
                    }
                }
            });
            
            const displaySourceLanguageLabel = document.getElementById('displaySourceLanguageLabel');
            if (displaySourceLanguageLabel) displaySourceLanguageLabel.textContent = lang['source_language'];
            
            const displayTargetLanguageLabel = document.getElementById('displayTargetLanguageLabel');
            if (displayTargetLanguageLabel) displayTargetLanguageLabel.textContent = lang['target_language'];

            const displayTmSourceLanguageLabel = document.getElementById('displayTmSourceLanguageLabel');
            if (displayTmSourceLanguageLabel) displayTmSourceLanguageLabel.textContent = lang['source_language'];

            const displayTmTargetLanguageLabel = document.getElementById('displayTmTargetLanguageLabel');
            if (displayTmTargetLanguageLabel) displayTmTargetLanguageLabel.textContent = lang['target_language'];
            
            const findReplaceCloseBtnText = document.getElementById('findReplaceCloseBtnText');
            if(findReplaceCloseBtnText) findReplaceCloseBtnText.textContent = lang['close_btn'];
        }

        function updateMainContentOffset() {
            const isTerminologyOpen = terminologySidebar.classList.contains('show-sidebar');
            const isTranslationMemoryOpen = translationMemorySidebar.classList.contains('show-sidebar');
            
            if (centralColumn) {
                centralColumn.classList.remove('left-sidebar-active', 'right-sidebar-active');

                if (isTerminologyOpen) {
                    centralColumn.classList.add('left-sidebar-active');
                    document.documentElement.style.setProperty('--terminology-sidebar-width', terminologySidebar.offsetWidth + 'px');
                }
                if (isTranslationMemoryOpen) {
                    centralColumn.classList.add('right-sidebar-active');
                    document.documentElement.style.setProperty('--translation-memory-sidebar-width', translationMemorySidebar.offsetWidth + 'px');
                }
            } else {
                console.warn("central-column element not found for offset update.");
            }
        }

        function updateUtilityButtonStates() {
            if (terminologySidebar.classList.contains('show-sidebar')) {
                terminologyBtn.classList.add('utility-btn-active');
            } else {
                terminologyBtn.classList.remove('utility-btn-active');
            }

            if (translationMemorySidebar.classList.contains('show-sidebar')) {
                tmBtn.classList.add('utility-btn-active');
            } else {
                tmBtn.classList.remove('utility-btn-active');
            }

            if (statsContainer.classList.contains('show')) {
                statsBtn.classList.add('utility-btn-active');
            } else {
                statsBtn.classList.remove('utility-btn-active');
            }
        }

        // --- Shortcut Customization Logic ---
        function formatShortcut(config) {
            let parts = [];
            if (config.ctrlKey) parts.push('Ctrl');
            if (config.altKey) parts.push('Alt');
            if (config.shiftKey) parts.push('Shift');
            
            let key = config.key;
            if (key === 'ArrowUp') key = '↑';
            if (key === 'ArrowDown') key = '↓';
            if (key === 'ArrowLeft') key = '←';
            if (key === 'ArrowRight') key = '→';

            parts.push(key);
            return parts.join(' + ');
        }

        function renderShortcutsUI() {
            shortcutsEditor.innerHTML = '';
            const lang = translations[currentLanguage];

            for (const action in tempShortcutConfig) {
                const config = tempShortcutConfig[action];
                
                let translationKey;
                if (action.startsWith('insertTMMatch')) {
                    translationKey = `shortcut_tm_insert_${action.slice(-1)}`;
                } else if (action.startsWith('insertGlossaryTerm')) {
                    translationKey = `shortcut_glossary_insert_${action.slice(-1)}`;
                } else {
                    // --- INICIO DE LA CORRECCIÓN ---
                    // Hacemos una correspondencia manual para los casos que no coinciden
                    switch (action) {
                        case 'validateAndNext':
                            translationKey = 'shortcut_validate';
                            break;
                        case 'nextSegment':
                            translationKey = 'shortcut_next';
                            break;
                        case 'prevSegment':
                            translationKey = 'shortcut_prev';
                            break;
                        default:
                            // Un respaldo para futuros atajos que sí coincidan
                            translationKey = `shortcut_${action}`;
                            break;
                    }
                    // --- FIN DE LA CORRECCIÓN ---
                }
                const actionLabel = lang[translationKey] || action;
                
                const row = document.createElement('div');
                row.className = 'grid grid-cols-2 items-center gap-4';
                
                const label = document.createElement('label');
                label.className = 'text-on-light-contrast font-medium';
                label.textContent = actionLabel;
                row.appendChild(label);
                
                const input = document.createElement('input');
                input.type = 'text';
                input.readOnly = true;
                input.className = 'shortcut-input';
                input.value = formatShortcut(config);
                input.dataset.action = action;
                input.placeholder = lang['click_to_set_shortcut'];

                input.addEventListener('keydown', (e) => {
                    e.preventDefault();
                    
                    const tempConfig = {
                        ctrlKey: e.ctrlKey,
                        altKey: e.altKey,
                        shiftKey: e.shiftKey,
                        key: '...'
                    };
                    input.value = formatShortcut(tempConfig);

                    if (!['Control', 'Alt', 'Shift', 'Meta'].includes(e.key)) {
                        const newConfig = {
                            ctrlKey: e.ctrlKey,
                            altKey: e.altKey,
                            shiftKey: e.shiftKey,
                            key: (e.key.length === 1) ? e.key.toLowerCase() : e.key
                        };

                        tempShortcutConfig[action] = newConfig;
                        input.value = formatShortcut(newConfig);
                        input.blur();
                    }
                });

                input.addEventListener('blur', () => {
                    input.value = formatShortcut(tempShortcutConfig[action]);
                });
                
                row.appendChild(input);
                shortcutsEditor.appendChild(row);
            }
        }

        saveShortcutsBtn.addEventListener('click', () => {
            shortcutConfig = JSON.parse(JSON.stringify(tempShortcutConfig));
            localStorage.setItem('poandaShortcutConfig', JSON.stringify(shortcutConfig));
            showMessage(translations[currentLanguage]['shortcuts_saved']);
            shortcutsModal.classList.add('hidden');
        });
        
        resetShortcutsBtn.addEventListener('click', () => {
            tempShortcutConfig = JSON.parse(JSON.stringify(defaultShortcutConfig));
            renderShortcutsUI();
            showMessage(translations[currentLanguage]['shortcuts_reset']);
        });

        exportShortcutsBtn.addEventListener('click', () => {
            const jsonString = JSON.stringify(shortcutConfig, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'poanda_shortcuts.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        importShortcutsBtn.addEventListener('click', () => {
            importShortcutsInput.click();
        });

        importShortcutsInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedConfig = JSON.parse(e.target.result);
                    // Basic validation
                    if (typeof importedConfig === 'object' && importedConfig.validateAndNext) {
                        tempShortcutConfig = { ...defaultShortcutConfig, ...importedConfig };
                        renderShortcutsUI();
                        showMessage(translations[currentLanguage]['shortcuts_loaded']);
                    } else {
                        throw new Error("Invalid format");
                    }
                } catch (error) {
                    showMessage(translations[currentLanguage]['error_loading_shortcuts']);
                    console.error("Error importing shortcuts:", error);
                } finally {
                    importShortcutsInput.value = ''; // Reset file input
                }
            };
            reader.readAsText(file);
        });


        // --- Terminology Sidebar Logic ---
        terminologyBtn.addEventListener('click', () => {
            const isHidden = !terminologySidebar.classList.contains('show-sidebar');
            if (isHidden) {
                terminologySidebar.classList.add('show-sidebar');
            } else {
                terminologySidebar.classList.remove('show-sidebar');
            }
            updateMainContentOffset();
            updateUtilityButtonStates();
            if (isHidden) {
                if (!glossarySourceLanguage || !glossaryTargetLanguage) {
                    showLanguageConfigSection();
                } else {
                    showGlossaryEditorSection();
                }
            }
        });

        closeTerminologySidebarBtn.addEventListener('click', () => {
            terminologySidebar.classList.remove('show-sidebar');
            updateMainContentOffset();
            updateUtilityButtonStates();
        });

        function populateIsoLanguagesDatalist() {
            isoLanguagesDatalist.innerHTML = '';
            isoLanguagesData.forEach(lang => {
                const option = document.createElement('option');
                option.value = lang.code;
                option.textContent = lang.name;
                isoLanguagesDatalist.appendChild(option);
            });
        }

        function resetGlossary() {
            glossary = [];
            glossarySourceLanguage = '';
            glossaryTargetLanguage = '';
            if (configSrcLang) configSrcLang.value = 'en-US';
            if (configTgtLang) configTgtLang.value = 'es-ES';
            if (srcTermInput) srcTermInput.value = "";
            if (tgtTermInput) tgtTermInput.value = "";
            if (searchTermInput) searchTermInput.value = "";

            if (terminologyLanguageConfigSection && terminologyEditorSection) {
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }

            renderGlossary();
            renderTranslations(poEntries);
            updateStatsDisplay();
        }

        function showLanguageConfigSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection) {
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }
        }

        function showGlossaryEditorSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection && displaySrcLang && displayTgtLang) {
                terminologyLanguageConfigSection.style.display = 'none';
                terminologyEditorSection.style.display = 'block';
                displaySrcLang.value = glossarySourceLanguage;
                displayTgtLang.value = glossaryTargetLanguage;
                renderGlossary();
            }
        }

        function confirmGlossaryLanguages() {
            const srcLang = configSrcLang ? configSrcLang.value.trim() : '';
            const tgtLang = configTgtLang ? configTgtLang.value.trim() : '';

            if (!srcLang || !tgtLang) {
                showMessage(translations[currentLanguage]['lang_config_required']);
                return;
            }

            glossarySourceLanguage = srcLang;
            glossaryTargetLanguage = tgtLang;

            showGlossaryEditorSection();
            renderTranslations(poEntries);
        }

        function addTerm() {
            const srcTerm = srcTermInput ? srcTermInput.value.trim() : '';
            const tgtTerm = tgtTermInput ? tgtTermInput.value.trim() : '';

            if (!srcTerm || !tgtTerm) {
                showMessage(translations[currentLanguage]['both_terms_required']);
                return;
            }

            glossary.push({
                srcLang: glossarySourceLanguage,
                srcTerm: srcTerm,
                tgtLang: glossaryTargetLanguage,
                tgtTerm: tgtTerm
            });
            if (srcTermInput) srcTermInput.value = "";
            if (tgtTermInput) tgtTermInput.value = "";
            renderGlossary();
            renderTranslations(poEntries);
        }

        function deleteTerm(index) {
            glossary.splice(index, 1);
            renderGlossary();
            renderTranslations(poEntries);
        }

        function renderGlossary() {
            if (!glossaryTableBody) {
                console.warn("glossaryTableBody element not found. Cannot render glossary.");
                return;
            }
            const search = searchTermInput ? searchTermInput.value.toLowerCase() : '';
            glossaryTableBody.innerHTML = "";

            const filteredGlossary = glossary.filter(entry =>
                (entry.srcTerm && entry.srcTerm.toLowerCase().includes(search)) ||
                (entry.tgtTerm && entry.tgtTerm.toLowerCase().includes(search))
            );

            const highlightedTerms = [];
            const otherTerms = [];

            filteredGlossary.forEach(entry => {
                if (entry.srcTerm && termsFoundInActiveSegment.has(entry.srcTerm)) {
                    highlightedTerms.push(entry);
                } else {
                    otherTerms.push(entry);
                }
            });

            currentGlossaryLatestResults = [...highlightedTerms, ...otherTerms.sort((a, b) => a.srcTerm.localeCompare(b.srcTerm))];

            highlightedTerms.forEach((entry, i) => {
                const row = document.createElement("tr");
                row.classList.add('glossary-row-highlight');
                row.innerHTML = `
                    <td>${entry.srcTerm}</td>
                    <td>${entry.tgtTerm}</td>
                    <td><button class="glossary-delete-btn" onclick="deleteTerm(${glossary.indexOf(entry)})">${translations[currentLanguage]['delete_button']}</button></td>
                `;
                glossaryTableBody.appendChild(row);
            });

            otherTerms.forEach((entry, i) => {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td>${entry.srcTerm}</td>
                    <td>${entry.tgtTerm}</td>
                    <td><button class="glossary-delete-btn" onclick="deleteTerm(${glossary.indexOf(entry)})">${translations[currentLanguage]['delete_button']}</button></td>
                `;
                glossaryTableBody.appendChild(row);
            });
        }

        function generateTBX() {
            const xml = [`<?xml version="1.0" encoding="UTF-8"?>`,
                `<martif type="TBX" xml:lang="${glossarySourceLanguage}">`,
                `  <text>`,
                `    <body>`];

            glossary.forEach(entry => {
                xml.push(`      <termEntry>`);
                xml.push(`        <LangSet xml:lang="${entry.srcLang}">`);
                xml.push(`          <tig><term>${entry.srcTerm}</term></tig>`);
                xml.push(`        </LangSet>`);
                xml.push(`        <LangSet xml:lang="${entry.tgtLang}">`);
                xml.push(`          <tig><term>${entry.tgtTerm}</term></tig>`);
                xml.push(`        </LangSet>`);
                xml.push(`      </termEntry>`);
            });

            xml.push(`    </body>`, `  </text>`, `</martif>`);
            return xml.join("\n");
        }

        function downloadTBX() {
            if (glossary.length === 0 && (!glossarySourceLanguage || !glossaryTargetLanguage)) {
                showMessage(translations[currentLanguage]['cannot_download_empty_or_unconfigured_glossary']);
                return;
            }
            showLoadingOverlay(translations[currentLanguage]['saving_file']);
            try {
                const blob = new Blob([generateTBX()], { type: "application/xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "glossary.tbx";
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(url);
                showMessage(translations[currentLanguage]['tbx_saved_successfully']);
            } catch (error) {
                showMessage(`${translations[currentLanguage]['error_saving_file']} ${error.message}`);
                console.error("Error downloading TBX:", error);
            } finally {
                hideLoadingOverlay();
            }
        }

        function loadTBX() {
            if (!tbxFileInput) {
                console.warn("tbxFileInput element not found. Cannot load TBX.");
                return;
            }
            tbxFileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const content = await file.text();
                processTBXContent(content);
            };
            tbxFileInput.click();
        }

        function processTBXContent(content) {
            showLoadingOverlay(translations[currentLanguage]['loading_file']);
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, "application/xml");

                if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                    const errorText = xmlDoc.getElementsByTagName("parsererror")[0].textContent;
                    throw new Error("Invalid XML/TBX format: " + errorText);
                }

                if (xmlDoc.getElementsByTagName("tu").length > 0) {
                    showTMInternalMessage(translations[currentLanguage]['tbx_file_expected_tmx_found'], true);
                    throw new Error("Attempted to load TMX into Glossary.");
                }

                const entries = xmlDoc.getElementsByTagName("termEntry");
                glossary = [];
                let firstEntryLangs = { src: '', tgt: '' };

                if (entries.length > 0) {
                    const firstSets = entries[0].getElementsByTagName("LangSet");
                    if (firstSets.length >= 2) {
                        firstEntryLangs.src = firstSets[0].getAttribute("xml:lang");
                        firstEntryLangs.tgt = firstSets[1].getAttribute("xml:lang");
                    }
                }

                for (let entry of entries) {
                    const sets = entry.getElementsByTagName("LangSet");
                    if (sets.length >= 2) {
                        const lang1 = sets[0].getAttribute("xml:lang");
                        const term1 = sets[0].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                        const lang2 = sets[1].getAttribute("xml:lang");
                        const term2 = sets[1].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                        glossary.push({ srcLang: lang1, srcTerm: term1, tgtLang: lang2, tgtTerm: term2 });
                    }
                }

                if (glossary.length > 0 && firstEntryLangs.src && firstEntryLangs.tgt) {
                    glossarySourceLanguage = firstEntryLangs.src;
                    glossaryTargetLanguage = firstEntryLangs.tgt;
                } else if (glossary.length === 0) {
                    showMessage(translations[currentLanguage]['error_loading_tbx_file']);
                }

                showGlossaryEditorSection();
                renderTranslations(poEntries);

            } catch (error) {
                console.error("Error loading TBX file:", error);
                if (!error.message.includes("Attempted to load TMX")) {
                     showMessage(translations[currentLanguage]['error_loading_tbx_file']);
                }
                resetGlossary();
            } finally {
                hideLoadingOverlay();
            }
        }


        // --- Translation Memory (TM) Logic ---

        function levenshteinDistance(a, b) {
            const an = a.length;
            const bn = b.length;
            if (an === 0) return bn;
            if (bn === 0) return an;

            const matrix = [];

            for (let i = 0; i <= bn; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= an; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= bn; i++) {
                for (let j = 1; j <= an; j++) {
                    const cost = (a[j - 1] === b[i - 1]) ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j - 1] + cost
                    );
                }
            }
            return matrix[bn][an];
        }

        function calculateSimilarity(s1, s2) {
            if (!s1 || !s2) return 0;
            const longerLength = Math.max(s1.length, s2.length);
            if (longerLength === 0) return 100;
            const distance = levenshteinDistance(s1, s2);
            return ((longerLength - distance) / longerLength) * 100;
        }


        tmBtn.addEventListener('click', () => {
            const isHidden = !translationMemorySidebar.classList.contains('show-sidebar');
            if (isHidden) {
                translationMemorySidebar.classList.add('show-sidebar');
            } else {
                translationMemorySidebar.classList.remove('show-sidebar');
            }
            updateMainContentOffset();
            updateUtilityButtonStates();
            if (isHidden) {
                if (!tmSourceLanguage || !tmTargetLanguage) {
                    showTMLanguageConfigSection();
                } else {
                    showTMEditorSection();
                    tmSearch();
                }
            }
        });

        closeTranslationMemorySidebarBtn.addEventListener('click', () => {
            translationMemorySidebar.classList.remove('show-sidebar');
            updateMainContentOffset();
            updateUtilityButtonStates();
        });

        tmFileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                 const content = await file.text();
                 processTMXContent(content);
            }
        });

        function showTMInternalMessage(msg, isError = false) {
            if (tmInternalMessage) {
                tmInternalMessage.textContent = msg;
                tmInternalMessage.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'border-red-500', 'bg-blue-100', 'text-blue-800', 'border-blue-500');
                if (isError) {
                    tmInternalMessage.classList.add('bg-red-100', 'text-red-800', 'border-red-500');
                } else {
                    tmInternalMessage.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-500');
                }
                tmInternalMessage.classList.remove('hidden');
            } else {
                console.warn("tmInternalMessage element not found.");
            }
        }

        function hideTMInternalMessage() {
            if (tmInternalMessage) {
                tmInternalMessage.classList.add('hidden');
                tmInternalMessage.textContent = '';
            }
        }

        function resetTM() {
            translationMemory = [];
            tmSourceLanguage = '';
            tmTargetLanguage = '';
            if (tmSearchInput) tmSearchInput.value = '';
            renderTMSearchResults([]);
            showTMLanguageConfigSection();
            showTMInternalMessage(translations[currentLanguage]['tm_initial_message']);
        }

        function showTMLanguageConfigSection() {
            if (tmLanguageConfigSection && tmEditorSection) {
                tmLanguageConfigSection.style.display = 'block';
                tmEditorSection.style.display = 'none';
                if (tmConfigSrcLang) tmConfigSrcLang.value = 'en-US';
                if (tmConfigTgtLang) tmConfigTgtLang.value = 'es-ES';
                hideTMInternalMessage();
            }
        }

        function showTMEditorSection() {
            if (tmLanguageConfigSection && tmEditorSection && displayTmSrcLang && displayTmTgtLang) {
                tmLanguageConfigSection.style.display = 'none';
                tmEditorSection.style.display = 'block';
                displayTmSrcLang.value = tmSourceLanguage;
                displayTmTgtLang.value = tmTargetLanguage;
                tmSearch();
                hideTMInternalMessage();
            }
        }

        function confirmTMLanguages() {
            const srcLang = tmConfigSrcLang ? tmConfigSrcLang.value.trim() : '';
            const tgtLang = tmConfigTgtLang ? tmConfigTgtLang.value.trim() : '';

            if (!srcLang || !tgtLang) {
                showTMInternalMessage(translations[currentLanguage]['lang_config_required'], true);
                return;
            }

            tmSourceLanguage = srcLang;
            tmTargetLanguage = tgtLang;

            showTMEditorSection();
        }

        function processTMXContent(content) {
            showLoadingOverlay(translations[currentLanguage]['loading_file']);
            hideTMInternalMessage();

            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, "application/xml");

                if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                    const errorText = xmlDoc.getElementsByTagName("parsererror")[0].textContent;
                    throw new Error("Invalid XML/TMX format: " + errorText);
                }

                if (xmlDoc.getElementsByTagName("termEntry").length > 0) {
                    showTMInternalMessage(translations[currentLanguage]['tmx_file_expected_tbx_found'], true);
                    throw new Error("Attempted to load TBX into Translation Memory.");
                }

                const tuElements = xmlDoc.getElementsByTagName("tu");
                let newTM = [];
                let detectedSrcLang = '';
                let detectedTgtLang = '';

                if (tuElements.length > 0) {
                    const tuvElements = tuElements[0].getElementsByTagName("tuv");
                    if (tuvElements.length >= 2) {
                        detectedSrcLang = tuvElements[0].getAttribute("xml:lang");
                        detectedTgtLang = tuvElements[1].getAttribute("xml:lang");
                    }
                }

                for (let tu of tuElements) {
                    const tuvElements = tu.getElementsByTagName("tuv");
                    if (tuvElements.length >= 2) {
                        const srcTuv = tuvElements[0];
                        const tgtTuv = tuvElements[1];
                        const srcLang = srcTuv.getAttribute("xml:lang");
                        const tgtLang = tgtTuv.getAttribute("xml:lang");
                        const srcSeg = srcTuv.getElementsByTagName("seg")[0]?.textContent || '';
                        const tgtSeg = tgtTuv.getElementsByTagName("seg")[0]?.textContent || '';

                        newTM.push({
                            srcLang: srcLang, srcText: srcSeg,
                            tgtLang: tgtLang, tgtText: tgtSeg,
                            srcWordCount: countWords(srcSeg), tgtWordCount: countWords(tgtSeg)
                        });
                    }
                }

                translationMemory = newTM;
                tmSourceLanguage = detectedSrcLang || (tmConfigSrcLang ? tmConfigSrcLang.value : 'en-US');
                tmTargetLanguage = detectedTgtLang || (tmConfigTgtLang ? tmConfigTgtLang.value : 'es-ES');

                showTMInternalMessage(`TMX loaded with ${translationMemory.length} translation units.`);
                showTMEditorSection();
                tmSearch();

            } catch (error) {
                console.error("Error loading TMX file:", error);
                if (!error.message.includes("Attempted to load TBX")) {
                     showTMInternalMessage(translations[currentLanguage]['error_loading_tmx_file'], true);
                }
                resetTM();
            } finally {
                hideLoadingOverlay();
            }
        }

        function generateTMX() {
            if (translationMemory.length === 0) {
                return null;
            }

            const header = `<?xml version="1.0" encoding="UTF-8"?>
<tmx version="1.4">
  <header creationtool="Poanda" creationtoolversion="1.0"
          datatype="unknown" segtype="sentence" changeid="PoandaUser"
          srclang="${tmSourceLanguage || 'en-US'}" o-tmf="Poanda"
          adminlang="en-US" `;

            const targetLangAttr = tmTargetLanguage ? `targetlang="${tmTargetLanguage}"` : '';

            const xml = [header + targetLangAttr + `>
  </header>
  <body>`];

            translationMemory.forEach(entry => {
                xml.push(`    <tu>
      <tuv xml:lang="${entry.srcLang}"><seg>${entry.srcText}</seg></tuv>
      <tuv xml:lang="${entry.tgtLang}"><seg>${entry.tgtText}</seg></tuv>
    </tu>`);
            });

            xml.push(`  </body>
</tmx>`);
            return xml.join("\n");
        }

        function downloadTMX() {
            const tmxContent = generateTMX();
            if (!tmxContent) {
                 showTMInternalMessage(translations[currentLanguage]['cannot_download_empty_tm'], true);
                 return;
            }

            showLoadingOverlay(translations[currentLanguage]['saving_file']);
            try {
                const blob = new Blob([tmxContent], { type: "application/xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "translation_memory.tmx";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showTMInternalMessage(translations[currentLanguage]['file_saved_successfully']);
            } catch (error) {
                showTMInternalMessage(`${translations[currentLanguage]['error_saving_file']} ${error.message}`, true);
                console.error("Error downloading TMX:", error);
            } finally {
                hideLoadingOverlay();
            }
        }

        function addOrUpdateTMEntry(original, translation) {
            if (!original || !translation) return;
            if (!tmSourceLanguage || !tmTargetLanguage) {
                console.warn("TM languages not configured. Skipping TM update.");
                return;
            }

            const existingIndex = translationMemory.findIndex(
                entry => entry.srcText === original && entry.srcLang === tmSourceLanguage && entry.tgtLang === tmTargetLanguage
            );

            if (existingIndex !== -1) {
                translationMemory[existingIndex].tgtText = translation;
                translationMemory[existingIndex].tgtWordCount = countWords(translation);
            } else {
                translationMemory.push({
                    srcLang: tmSourceLanguage,
                    srcText: original,
                    tgtLang: tmTargetLanguage,
                    tgtText: translation,
                    srcWordCount: countWords(original),
                    tgtWordCount: countWords(translation)
                });
            }
            tmSearch();
        }

        function findBestTMMatch(sourceSegmentText) {
            if (translationMemory.length === 0 || !sourceSegmentText.trim() || !tmSourceLanguage || !tmTargetLanguage) {
                return null;
            }

            let bestMatch = null;
            let highestScore = 0;
            const MIN_FUZZY_THRESHOLD = 70;

            translationMemory.forEach(entry => {
                if (entry.srcLang === tmSourceLanguage && entry.tgtLang === tmTargetLanguage && entry.srcText.trim()) {
                    const score = calculateSimilarity(sourceSegmentText, entry.srcText);
                    if (score >= MIN_FUZZY_THRESHOLD && score > highestScore) {
                        highestScore = score;
                        bestMatch = { ...entry, score: score.toFixed(0) };
                    }
                }
            });

            return bestMatch;
        }

        function tmSearch() {
            const query = tmSearchInput ? tmSearchInput.value.toLowerCase().trim() : '';
            let resultsToRender = [];

            const currentFocused = getCurrentFocusedIndex();
            let activeSegmentOriginalText = null;
            if (currentFocused && poEntries[currentFocused.entryIndex] && poEntries[currentFocused.entryIndex].sentenceSegments && poEntries[currentFocused.entryIndex].sentenceSegments[currentFocused.segmentIndex]) {
                activeSegmentOriginalText = poEntries[currentFocused.entryIndex].sentenceSegments[currentFocused.segmentIndex].original;
            }

            tmBestMatchForActiveSegment = null;
            if (activeSegmentOriginalText) {
                tmBestMatchForActiveSegment = findBestTMMatch(activeSegmentOriginalText);
            }

            if (tmBestMatchForActiveSegment && (query === '' || tmBestMatchForActiveSegment.srcText.toLowerCase().includes(query))) {
                resultsToRender.push({ ...tmBestMatchForActiveSegment, isBestMatch: true });
            }


            const filteredTM = translationMemory.filter(entry => {
                if (tmBestMatchForActiveSegment && entry.srcText === tmBestMatchForActiveSegment.srcText && entry.tgtText === tmBestMatchForActiveSegment.tgtText) {
                    return false;
                }
                if (query) {
                    return (entry.srcText && entry.srcText.toLowerCase().includes(query)) ||
                           (entry.tgtText && entry.tgtText.toLowerCase().includes(query));
                }
                return true;
            });

            filteredTM.forEach(entry => {
                let score = 0;
                if (query) {
                    score = calculateSimilarity(query, entry.srcText);
                } else if (activeSegmentOriginalText) {
                    score = calculateSimilarity(activeSegmentOriginalText, entry.srcText);
                }
                resultsToRender.push({ ...entry, score: score.toFixed(0) });
            });

            resultsToRender.sort((a, b) => {
                if (a.isBestMatch) return -1;
                if (b.isBestMatch) return 1;
                
                if (b.score !== a.score) {
                    return b.score - a.score;
                }
                return a.srcText.localeCompare(b.srcText);
            });

            currentTMLatestSearchResults = resultsToRender;
            renderTMSearchResults(resultsToRender, activeSegmentOriginalText);
        }


        function renderTMSearchResults(results, activeSegmentOriginalText) {
            if (!tmSearchResultsTableBody) {
                console.warn("tmSearchResultsTableBody element not found. Cannot render TM search results.");
                return;
            }
            tmSearchResultsTableBody.innerHTML = '';
            if (results.length === 0) {
                if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.remove('hidden');
                if (tmInternalMessage && tmInternalMessage.classList.contains('hidden')) {
                    if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.remove('hidden');
                }
                return;
            } else {
                if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.add('hidden');
            }
            hideTMInternalMessage();

            results.forEach(entry => {
                const row = document.createElement('tr');
                if (entry.isBestMatch) {
                    row.classList.add('tm-best-match-highlight');
                }

                let originalCellHtml = '';
                if (activeSegmentOriginalText) {
                    const differences = Diff.diffChars(entry.srcText, activeSegmentOriginalText);
                    originalCellHtml = differences.map(part => {
                        const className = part.added ? 'diff-added' :
                                        part.removed ? 'diff-removed' : 'diff-common';
                        return `<span class="${className}">${part.value}</span>`;
                    }).join('');
                } else {
                    originalCellHtml = entry.srcText;
                }

                row.innerHTML = `
                    <td>${entry.score}%</td>
                    <td><pre class="whitespace-pre-wrap">${originalCellHtml}</pre></td>
                    <td><pre class="whitespace-pre-wrap">${entry.tgtText}</pre></td>
                `;
                row.addEventListener('click', () => {
                    const currentFocused = getCurrentFocusedIndex();
                    if (currentFocused) {
                        const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                        if (targetTextarea && !targetTextarea.readOnly) {
                            targetTextarea.value = entry.tgtText;
                            const event = new Event('input', { bubbles: true });
                            targetTextarea.dispatchEvent(event);
                        }
                    }
                });
                tmSearchResultsTableBody.appendChild(row);
            });
        }


        function showLoadingOverlay(message) {
            if (loadingMessage && loadingOverlay) {
                loadingMessage.textContent = message;
                loadingOverlay.classList.remove('hidden');
            }
        }

        function hideLoadingOverlay() {
            if (loadingOverlay) {
                loadingOverlay.classList.add('hidden');
            }
        }

        if (dropArea) {
            dropArea.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.add('border-red-500');
            });

            dropArea.addEventListener('dragleave', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-red-500');
            });

            dropArea.addEventListener('drop', async (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-red-500');

                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.name.toLowerCase().endsWith('.po')) {
                        await processFile(file);
                    } else if (file.name.toLowerCase().endsWith('.zip') || file.name.toLowerCase().endsWith('.poanda')) {
                        await openProject(file);
                    } else {
                        showMessage('Please drop a valid .po or .poanda project file.');
                    }
                }
            });
        }

        if (addTermHeader && addTermContent && addTermAccordionIcon) {
            addTermHeader.addEventListener('click', () => {
                const isCollapsed = addTermContent.classList.contains('collapsed');
                if (isCollapsed) {
                    addTermContent.classList.remove('collapsed');
                    addTermContent.classList.add('expanded');
                    addTermAccordionIcon.classList.remove('rotated');
                } else {
                    addTermContent.classList.remove('expanded');
                    addTermContent.classList.add('collapsed');
                    addTermAccordionIcon.classList.add('rotated');
                }
            });
        }

        function resetProjectState() {
            poEntries = [];
            currentFileName = 'translations.po';
            renderTranslations([]);
            updateStatsDisplay();

            resetGlossary();
            resetTM();

            terminologySidebar.classList.remove('show-sidebar');
            translationMemorySidebar.classList.remove('show-sidebar');
            statsContainer.classList.remove('show');
            updateMainContentOffset();
            updateUtilityButtonStates();
        }

        function newProject() {
            if (poEntries.length > 0) {
                if (!confirm(translations[currentLanguage]['new_project_confirm'])) {
                    return;
                }
            }
            resetProjectState();
            clearBackup();
        }

        function showSaveProjectModal() {
            if (poEntries.length === 0) {
                showMessage(translations[currentLanguage]['no_project_to_save']);
                return;
            }
            projectFilenameInput.value = currentFileName.replace(/\.po$/i, '');
            saveProjectModal.classList.remove('hidden');
            projectFilenameInput.focus();
        }

        async function executeSaveProject() {
            const filename = projectFilenameInput.value.trim();
            if (!filename) {
                showMessage(translations[currentLanguage]['enter_filename']);
                return;
            }

            showLoadingOverlay(translations[currentLanguage]['saving_file']);
            try {
                const zip = new JSZip();

                const poContent = reconstructPo(poEntries);
                zip.file(currentFileName, poContent);

                const tmxContent = generateTMX();
                if (tmxContent) {
                    zip.file("memory.tmx", tmxContent);
                }

                if (glossary.length > 0) {
                    const tbxContent = generateTBX();
                    zip.file("glossary.tbx", tbxContent);
                }

                const zipBlob = await zip.generateAsync({ type: "blob" });
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `${filename}.poanda`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                saveProjectModal.classList.add('hidden');
                showMessage(translations[currentLanguage]['project_saved']);

            } catch (error) {
                showMessage(translations[currentLanguage]['error_saving_project'] + ': ' + error.message);
                console.error("Error saving project:", error);
            } finally {
                hideLoadingOverlay();
            }
        }

        async function openProject(file) {
            if (!file) return;

            showLoadingOverlay(translations[currentLanguage]['loading_project']);
            try {
                resetProjectState();

                const zip = await JSZip.loadAsync(file);
                let poFileFound = false;

                const promises = [];
                zip.forEach((relativePath, zipEntry) => {
                    const fileNameLower = zipEntry.name.toLowerCase();
                    if (fileNameLower.endsWith('.po')) {
                        poFileFound = true;
                        currentFileName = zipEntry.name;
                        promises.push(zipEntry.async("string").then(processPoContent));
                    } else if (fileNameLower.endsWith('.tmx')) {
                         promises.push(zipEntry.async("string").then(processTMXContent));
                    } else if (fileNameLower.endsWith('.tbx')) {
                         promises.push(zipEntry.async("string").then(processTBXContent));
                    }
                });

                await Promise.all(promises);

                if (!poFileFound) {
                    throw new Error(translations[currentLanguage]['invalid_project_file']);
                }
                showMessage(translations[currentLanguage]['project_loaded']);
                await clearBackup();

            } catch (error) {
                showMessage(translations[currentLanguage]['error_opening_project'] + ': ' + error.message);
                console.error("Error opening project:", error);
                resetProjectState();
            } finally {
                hideLoadingOverlay();
                projectFileInput.value = '';
            }
        }

        // --- Backup and Restore (IndexedDB) ---
        const DB_NAME = 'PoandaBackup';
        const DB_VERSION = 1;
        const STORE_NAME = 'session';
        let db;

        function openDb() {
            return new Promise((resolve, reject) => {
                if (db) {
                    resolve(db);
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject("Error opening IndexedDB.");
                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };
            });
        }

        async function saveBackup() {
            if (!db || poEntries.length === 0) return;
            const sessionData = {
                id: 'currentSession',
                poEntries,
                currentFileName,
                glossary,
                glossarySourceLanguage,
                glossaryTargetLanguage,
                translationMemory,
                tmSourceLanguage,
                tmTargetLanguage,
                timestamp: new Date()
            };
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.put(sessionData);
            request.onsuccess = () => {
                 updateBackupStatusUI();
            };
        }

        async function loadBackup() {
            if (!db) return null;
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get('currentSession');
                request.onerror = () => reject("Error loading backup from DB.");
                request.onsuccess = () => resolve(request.result);
            });
        }

        async function clearBackup() {
            if (!db) return;
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            store.clear();
            updateBackupStatusUI();
        }

        async function checkForBackup() {
            try {
                await openDb();
                const backup = await loadBackup();
                if (backup && backup.poEntries && backup.poEntries.length > 0) {
                    restoreBackupModal.classList.remove('hidden');
                }
                updateBackupStatusUI();
            } catch (error) {
                console.error("Backup check failed:", error);
            }
        }

        async function restoreSession(backupData = null) {
            showLoadingOverlay(translations[currentLanguage]['loading_project']);
            try {
                const backup = backupData || await loadBackup();
                if (backup) {
                    poEntries = backup.poEntries || [];
                    currentFileName = backup.currentFileName || 'translations.po';
                    glossary = backup.glossary || [];
                    glossarySourceLanguage = backup.glossarySourceLanguage || '';
                    glossaryTargetLanguage = backup.glossaryTargetLanguage || '';
                    translationMemory = backup.translationMemory || [];
                    tmSourceLanguage = backup.tmSourceLanguage || '';
                    tmTargetLanguage = backup.tmTargetLanguage || '';

                    renderTranslations(poEntries);
                    
                    if (glossarySourceLanguage && glossaryTargetLanguage) {
                        showGlossaryEditorSection();
                    } else {
                        showLanguageConfigSection();
                    }

                    if (tmSourceLanguage && tmTargetLanguage) {
                        showTMEditorSection();
                    } else {
                        showTMLanguageConfigSection();
                    }
                }
            } catch (error) {
                showMessage("Failed to restore session.");
                console.error(error);
            } finally {
                restoreBackupModal.classList.add('hidden');
                hideLoadingOverlay();
            }
        }

        async function updateBackupStatusUI() {
            try {
                const backup = await loadBackup();
                if (backup) {
                    backupIndicator.style.display = 'inline-block';
                    lastBackupTime.textContent = new Date(backup.timestamp).toLocaleString();
                    loadLocalBackupBtn.disabled = false;
                    saveBackupToDiskBtn.disabled = false;
                    deleteLocalBackupBtn.disabled = false;
                } else {
                    backupIndicator.style.display = 'none';
                    lastBackupTime.textContent = translations[currentLanguage]['no_backup_available'];
                    loadLocalBackupBtn.disabled = true;
                    saveBackupToDiskBtn.disabled = true;
                    deleteLocalBackupBtn.disabled = true;
                }
            } catch (error) {
                console.error("Error updating backup UI:", error);
            }
        }

        // --- PO to MO Converter Logic ---
        function parsePoForMo(poText) {
            const lines = poText.split('\n');
            const messages = [];
            let currentMsg = {};
            let state = '';

            const unescape = (str) => str.replace(/\\n/g, '\n').replace(/\\"/g, '"').replace(/\\\\/g, '\\');

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('#')) continue;

                if (trimmedLine.length === 0) {
                    if (currentMsg.msgid !== undefined) {
                        messages.push(currentMsg);
                    }
                    currentMsg = {};
                    state = '';
                    continue;
                }

                if (trimmedLine.startsWith('msgctxt')) {
                    state = 'msgctxt';
                    currentMsg.msgctxt = unescape(trimmedLine.substring(7).trim().slice(1, -1));
                } else if (trimmedLine.startsWith('msgid_plural')) {
                    state = 'msgid_plural';
                    currentMsg.msgid_plural = unescape(trimmedLine.substring(12).trim().slice(1, -1));
                } else if (trimmedLine.startsWith('msgid')) {
                    state = 'msgid';
                    currentMsg.msgid = unescape(trimmedLine.substring(5).trim().slice(1, -1));
                } else if (trimmedLine.startsWith('msgstr[')) {
                    const match = trimmedLine.match(/msgstr\[(\d+)\]/);
                    state = `msgstr[${match[1]}]`;
                    if (!currentMsg.msgstr) currentMsg.msgstr = [];
                    currentMsg.msgstr[parseInt(match[1], 10)] = unescape(trimmedLine.substring(match[0].length).trim().slice(1, -1));
                } else if (trimmedLine.startsWith('msgstr')) {
                    state = 'msgstr';
                    currentMsg.msgstr = [unescape(trimmedLine.substring(6).trim().slice(1, -1))];
                } else if (trimmedLine.startsWith('"')) {
                    const str = unescape(trimmedLine.slice(1, -1));
                    if (state === 'msgid') currentMsg.msgid += str;
                    else if (state === 'msgid_plural') currentMsg.msgid_plural += str;
                    else if (state === 'msgctxt') currentMsg.msgctxt += str;
                    else if (state === 'msgstr') currentMsg.msgstr[0] += str;
                    else if (state.startsWith('msgstr[')) {
                        const match = state.match(/msgstr\[(\d+)\]/);
                        const index = parseInt(match[1], 10);
                        if(!currentMsg.msgstr[index]) currentMsg.msgstr[index] = '';
                        currentMsg.msgstr[index] += str;
                    }
                }
            }
            if (currentMsg.msgid !== undefined) messages.push(currentMsg);
            return messages;
        }

        function compileMo(messages) {
            const textEncoder = new TextEncoder();
            const MAGIC = 0x950412de;
            const REVISION = 0;
            
            let header = messages.find(m => m.msgid === '');
            if (header && header.msgstr && header.msgstr[0]) {
                 if(!header.msgstr[0].includes('Content-Type')) {
                    header.msgstr[0] += '\nContent-Type: text/plain; charset=UTF-8\n';
                 }
            } else {
                 header = { msgid: "", msgstr: ["Content-Type: text/plain; charset=UTF-8\n"] };
            }

            const translations = messages.filter(m => m.msgid !== '');

            translations.sort((a, b) => {
                const keyA = (a.msgctxt || '') + '\u0004' + a.msgid;
                const keyB = (b.msgctxt || '') + '\u0004' + b.msgid;
                return keyA.localeCompare(keyB);
            });

            const stringCount = translations.length + 1;
            const headerSize = 28;
            const originalsTableOffset = headerSize;
            const translationsTableOffset = headerSize + (stringCount * 8);
            
            let stringData = [];
            let currentOffset = translationsTableOffset + (stringCount * 8);

            stringData.push({
                original: textEncoder.encode(""),
                translation: textEncoder.encode(header.msgstr[0]),
            });

            translations.forEach(msg => {
                let originalStr;
                if (msg.msgid_plural) {
                    originalStr = (msg.msgctxt ? msg.msgctxt + '\u0004' : '') + msg.msgid + '\u0000' + msg.msgid_plural;
                } else {
                    originalStr = (msg.msgctxt ? msg.msgctxt + '\u0004' : '') + msg.msgid;
                }
                const translationStr = (msg.msgstr || []).join('\u0000');
                stringData.push({
                    original: textEncoder.encode(originalStr),
                    translation: textEncoder.encode(translationStr),
                });
            });

            const originalsTable = [];
            const translationsTable = [];

            stringData.forEach(data => {
                originalsTable.push({ length: data.original.length, offset: currentOffset });
                currentOffset += data.original.length + 1;
            });
            stringData.forEach(data => {
                translationsTable.push({ length: data.translation.length, offset: currentOffset });
                currentOffset += data.translation.length + 1;
            });
            
            const buffer = new ArrayBuffer(currentOffset);
            const view = new DataView(buffer);
            let byteOffset = 0;

            view.setUint32(byteOffset, MAGIC, true); byteOffset += 4;
            view.setUint32(byteOffset, REVISION, true); byteOffset += 4;
            view.setUint32(byteOffset, stringCount, true); byteOffset += 4;
            view.setUint32(byteOffset, originalsTableOffset, true); byteOffset += 4;
            view.setUint32(byteOffset, translationsTableOffset, true); byteOffset += 4;
            view.setUint32(byteOffset, 0, true); byteOffset += 4;
            view.setUint32(byteOffset, 0, true); byteOffset += 4;
            
            originalsTable.forEach(entry => {
                view.setUint32(byteOffset, entry.length, true); byteOffset += 4;
                view.setUint32(byteOffset, entry.offset, true); byteOffset += 4;
            });
            translationsTable.forEach(entry => {
                view.setUint32(byteOffset, entry.length, true); byteOffset += 4;
                view.setUint32(byteOffset, entry.offset, true); byteOffset += 4;
            });

            stringData.forEach(data => {
                new Uint8Array(buffer, byteOffset).set(data.original);
                byteOffset += data.original.length + 1;
            });
            stringData.forEach(data => {
                new Uint8Array(buffer, byteOffset).set(data.translation);
                byteOffset += data.translation.length + 1;
            });

            return buffer;
        }

        function makeDraggableAndResizable(sidebar) {
            const header = sidebar.querySelector('.sidebar-header');
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

            if(header) {
                header.onmousedown = dragMouseDown;
            }

function makeModalDraggable(modalElement) {
    const handle = modalElement.querySelector('h2');
    const content = modalElement.querySelector('.modal-content');
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

    if (handle && content) {
        handle.style.cursor = 'move';
        handle.onmousedown = dragMouseDown;
    }

    function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
    }

    function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        content.style.top = (content.offsetTop - pos2) + "px";
        content.style.left = (content.offsetLeft - pos1) + "px";
    }

    function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
    }
}


            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
                sidebar.style.transform = 'none';
            }

            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                sidebar.style.top = (sidebar.offsetTop - pos2) + "px";
                sidebar.style.left = (sidebar.offsetLeft - pos1) + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
            
            const resizers = sidebar.querySelectorAll('.resizer');
            let currentResizer;

            for (let resizer of resizers) {
                resizer.addEventListener('mousedown', initResize, false);
            }

            function initResize(e) {
                e.stopPropagation(); // Stop the event from bubbling up to the header
                currentResizer = e.target;
                let startX = e.clientX;
                let startY = e.clientY;
                let startWidth = parseInt(document.defaultView.getComputedStyle(sidebar).width, 10);
                let startHeight = parseInt(document.defaultView.getComputedStyle(sidebar).height, 10);
                let startLeft = sidebar.offsetLeft;
                let startTop = sidebar.offsetTop;

                function doResize(e) {
                    const rect = sidebar.getBoundingClientRect();
                    if (currentResizer.classList.contains('resizer-r')) {
                        sidebar.style.width = (startWidth + e.clientX - startX) + 'px';
                    } else if (currentResizer.classList.contains('resizer-l')) {
                        sidebar.style.width = (startWidth - (e.clientX - startX)) + 'px';
                        sidebar.style.left = (startLeft + (e.clientX - startX)) + 'px';
                    } else if (currentResizer.classList.contains('resizer-b')) {
                        sidebar.style.height = (startHeight + e.clientY - startY) + 'px';
                    } else if (currentResizer.classList.contains('resizer-t')) {
                        sidebar.style.height = (startHeight - (e.clientY - startY)) + 'px';
                        sidebar.style.top = (startTop + (e.clientY - startY)) + 'px';
                    } else if (currentResizer.classList.contains('resizer-br')) {
                        sidebar.style.width = (startWidth + e.clientX - startX) + 'px';
                        sidebar.style.height = (startHeight + e.clientY - startY) + 'px';
                    } else if (currentResizer.classList.contains('resizer-bl')) {
                        sidebar.style.width = (startWidth - e.clientX + startX) + 'px';
                        sidebar.style.left = (startLeft + e.clientX - startX) + 'px';
                        sidebar.style.height = (startHeight + e.clientY - startY) + 'px';
                    } else if (currentResizer.classList.contains('resizer-tr')) {
                        sidebar.style.width = (startWidth + e.clientX - startX) + 'px';
                        sidebar.style.height = (startHeight - e.clientY + startY) + 'px';
                        sidebar.style.top = (startTop + e.clientY - startY) + 'px';
                    } else if (currentResizer.classList.contains('resizer-tl')) {
                        sidebar.style.width = (startWidth - e.clientX + startX) + 'px';
                        sidebar.style.left = (startLeft + e.clientX - startX) + 'px';
                        sidebar.style.height = (startHeight - e.clientY + startY) + 'px';
                        sidebar.style.top = (startTop + e.clientY - startY) + 'px';
                    }
                    updateMainContentOffset();
                }

                function stopResize() {
                    window.removeEventListener('mousemove', doResize, false);
                    window.removeEventListener('mouseup', stopResize, false);
                }

                window.addEventListener('mousemove', doResize, false);
                window.addEventListener('mouseup', stopResize, false);
            }
            
            const resetBtn = sidebar.querySelector('.reset-panel-btn');
            if(resetBtn) {
                resetBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    sidebar.style.removeProperty('top');
                    sidebar.style.removeProperty('left');
                    sidebar.style.removeProperty('right');
                    sidebar.style.removeProperty('bottom');
                    sidebar.style.removeProperty('width');
                    sidebar.style.removeProperty('height');
                    sidebar.style.removeProperty('transform');
                    
                    if (!sidebar.classList.contains('show-sidebar')) {
                         sidebar.classList.add('show-sidebar');
                    }
                    updateMainContentOffset();
                });
            }

            const resizeObserver = new ResizeObserver(() => {
                updateMainContentOffset();
            });
            resizeObserver.observe(sidebar);
        }


        // --- Initialization on page load ---
        document.addEventListener('DOMContentLoaded', async () => {
            loadShortcuts(); // Load saved or default shortcuts
            populateIsoLanguagesDatalist();
            
            document.getElementById('langEnBtn').addEventListener('click', () => setLanguage('en'));
            document.getElementById('langEsBtn').addEventListener('click', () => setLanguage('es'));

            newProjectBtn.addEventListener('click', newProject);
            saveProjectBtn.addEventListener('click', showSaveProjectModal);
            openProjectBtn.addEventListener('click', () => projectFileInput.click());
            projectFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                openProject(file);
            });

            saveProjectConfirmBtn.addEventListener('click', executeSaveProject);
            saveProjectCancelBtn.addEventListener('click', () => {
                saveProjectModal.classList.add('hidden');
            });

            restoreBackupBtn.addEventListener('click', () => restoreSession());
            discardBackupBtn.addEventListener('click', () => {
                clearBackup();
                restoreBackupModal.classList.add('hidden');
            });
            
            backupBtn.addEventListener('click', () => {
                updateBackupStatusUI();
                backupModal.classList.remove('hidden');
            });

            backupCloseBtn.addEventListener('click', () => {
                backupModal.classList.add('hidden');
            });
            
            loadLocalBackupBtn.addEventListener('click', () => {
                restoreSession();
                backupModal.classList.add('hidden');
            });

            deleteLocalBackupBtn.addEventListener('click', async () => {
                if (confirm(translations[currentLanguage]['delete_local_backup_btn_confirm'])) {
                    await clearBackup();
                    showMessage(translations[currentLanguage]['backup_deleted']);
                }
            });

            saveBackupToDiskBtn.addEventListener('click', async () => {
                const backup = await loadBackup();
                if (backup) {
                    const jsonString = JSON.stringify(backup, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `poanda_backup_${new Date().toISOString().slice(0,10)}.poanda-backup`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            });
            
            loadBackupFromFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.id === 'currentSession' && data.poEntries) {
                            await restoreSession(data);
                            await saveBackup();
                            showMessage(translations[currentLanguage]['backup_loaded_from_file']);
                            backupModal.classList.add('hidden');
                        } else {
                            throw new Error("Invalid backup file format.");
                        }
                    } catch (error) {
                        showMessage(translations[currentLanguage]['error_loading_backup_file']);
                        console.error("Error processing backup file:", error);
                    } finally {
                        loadBackupFromFileInput.value = '';
                    }
                };
                reader.readAsText(file);
            });

            convertToMoButton.addEventListener('click', () => {
                if (poEntries.length > 0) {
                    convertToMoModal.classList.remove('hidden');
                } else {
                    showMessage(translations[currentLanguage]['no_file_to_convert']);
                }
            });

            moConverterCloseBtn.addEventListener('click', () => {
                convertToMoModal.classList.add('hidden');
            });

            moConverterActionBtn.addEventListener('click', () => {
                try {
                    const poContent = reconstructPo(poEntries);
                    const messages = parsePoForMo(poContent);
                    const moArrayBuffer = compileMo(messages);

                    const blob = new Blob([moArrayBuffer], { type: 'application/octet-stream' });
                    const outputFileName = currentFileName.replace(/\.po$/, '.mo');
                    const link = document.createElement('a');

                    link.href = URL.createObjectURL(blob);
                    link.download = outputFileName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);

                    showMessage(translations[currentLanguage]['mo_conversion_success']);
                } catch (error) {
                    showMessage(translations[currentLanguage]['mo_conversion_error']);
                    console.error("Error converting PO to MO:", error);
                } finally {
                    convertToMoModal.classList.add('hidden');
                }
            });

            makeDraggableAndResizable(document.getElementById('terminologySidebar'));
            makeDraggableAndResizable(document.getElementById('translationMemorySidebar'));

            // Add event listeners for the new PO search bar
            poSearchInput.addEventListener('input', filterPOEntries);
            searchInOriginalCheckbox.addEventListener('change', filterPOEntries);
            searchInTranslationCheckbox.addEventListener('change', filterPOEntries);
            searchNextBtn.addEventListener('click', () => navigateToSearchResult(1));
            searchPrevBtn.addEventListener('click', () => navigateToSearchResult(-1));


            setLanguage(currentLanguage);

            resetGlossary();
            resetTM();
            
            statsBtn.addEventListener('click', () => {
                statsContainer.classList.toggle('show');
                updateUtilityButtonStates();
            });

            if (translationsContainer) {
                translationsContainer.innerHTML = `
                    <div data-i18n="no_translations" id="initialMessage" class="text-center text-on-light-contrast p-4 border border-gray-300 rounded-md">
                        ${translations[currentLanguage]['no_translations']}
                    </div>
                `;
            }
            if (savePoButton) savePoButton.disabled = true;
            if (convertToMoButton) convertToMoButton.disabled = true;
            if (poSearchContainer) poSearchContainer.classList.add('hidden');
            if (statsContainer) statsContainer.classList.remove('show');
            updateUtilityButtonStates();

            if (addTermContent && addTermAccordionIcon) {
                addTermContent.classList.add('collapsed');
                addTermContent.classList.remove('expanded');
                addTermAccordionIcon.classList.remove('rotated');
            }

            if (translationMemorySidebar) translationMemorySidebar.classList.remove('show-sidebar');

            updateMainContentOffset();

            await checkForBackup();

 makeModalDraggable(document.getElementById('findReplaceModal'));

            setInterval(saveBackup, 10000);
        });
    </script>
</body>
</html>
