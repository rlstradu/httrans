<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">Poanda</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/diff@5.0.0/dist/diff.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: #f3f4f6;
            color: #202020;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        textarea {
            resize: vertical;
            overflow-y: hidden;
        }
        pre {
            white-space: pre-wrap;
            overflow-wrap: break-word;
        }
        .check-icon {
            display: none;
            margin-left: 8px;
            vertical-align: middle;
            width: 20px;
            height: 20px;
            color: #22c55e;
        }
        .btn-load { background-color: #f48790; color: #000; }
        .btn-load:hover { background-color: #e07a82; transform: scale(1.02); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .btn-save { background-color: #f7cf7e; color: #000; }
        .btn-save:hover { background-color: #e3b76e; transform: scale(1.02); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        /* NEW STYLE FOR MO BUTTON */
        .btn-convert-mo { background-color: #a7f3d0; color: #000; }
        .btn-convert-mo:hover { background-color: #6ee7b7; transform: scale(1.02); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .btn-validate { background-color: #f7cf7e; color: #000; }
        .btn-validate:hover { background-color: #e3b76e; transform: scale(1.02); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .btn-edit { background-color: #f48790; color: #000; }
        .btn-edit:hover { background-color: #e07a82; transform: scale(1.02); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .po-display-code { background-color: #e3e3e3; border: 1px solid #000; color: #202020; }
        .msgstr-textarea { background-color: #ffffff; color: #000000; min-height: 80px; }
        .translation-unit-bg { background-color: #f8f8f8; border-color: #e5e7eb; }
        .text-on-light-contrast { color: #202020; }
        .translation-row { display: flex; flex-direction: column; gap: 1rem; }
        @media (min-width: 768px) {
            .translation-row { flex-direction: row; }
            .original-col, .translation-col { flex: 1; }
        }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: #fff; padding: 2rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); max-width: 90%; width: 500px; }
        #findReplaceModal .modal-content { width: 650px; max-width: 95%; }
        .shortcut-icon { display: inline-block; width: 1em; height: 1em; vertical-align: middle; margin: 0 4px; }
        .main-editor-layout { display: flex; flex-direction: column; gap: 1rem; width: 100%; }
        @media (min-width: 1024px) {
            .main-editor-layout { flex-direction: row; }
            .editor-main-content { flex: 2; }
            .terminology-sidebar, .translation-memory-sidebar { min-width: 300px; max-width: 400px; }
        }
        .sidebar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .sidebar-content { max-height: calc(100vh - 200px); overflow-y: auto; padding-right: 0.5rem; }
        .glossary-input-group label, .tm-input-group label { white-space: nowrap; }
        .glossary-input-group input, .glossary-input-group select, .tm-input-group input, .tm-input-group select { width: 100%; padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9rem; margin-top: 4px; color: #202020; background-color: #fff; }
        .glossary-btn-primary, .tm-btn-primary { background-color: #007bff; color: white; padding: 8px 15px; border-radius: 5px; transition: background-color 0.2s; }
        .glossary-btn-primary:hover, .tm-btn-primary:hover { background-color: #0056b3; }
        .glossary-btn-secondary, .tm-btn-secondary { background-color: #e0e0e0; color: #333; padding: 8px 15px; border-radius: 5px; transition: background-color 0.2s; }
        .glossary-btn-secondary:hover, .tm-btn-secondary:hover { background-color: #d0d0d0; }
        .glossary-delete-btn, .tm-delete-btn { background-color: #f44336; color: white; padding: 6px 12px; border-radius: 4px; font-size: 0.85rem; }
        .glossary-delete-btn:hover, .tm-delete-btn:hover { background-color: #da190b; }
        .glossary-table th, .glossary-table td, .tm-table th, .tm-table td { padding: 8px 12px; border: 1px solid #e0e0e0; font-size: 0.9rem; }
        .glossary-table th, .tm-table th { background-color: #f0f0f0; font-weight: 600; }
        .glossary-info-box, .tm-info-box { background-color: #f0f8ff; border: 1px solid #d0e8f8; padding: 10px; border-radius: 6px; font-size: 0.85rem; color: #333; }
        .glossary-highlight { background-color: #ffcc00; padding: 0 2px; border-radius: 3px; }
        .glossary-row-highlight { background-color: #ffcc00 !important; transition: background-color 0.3s ease; }
        .translation-unit-active { border: 2px solid #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25); }
        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1001; font-size: 1.2rem; color: #333; }
        .loading-spinner { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .tm-table th:nth-child(1), .tm-table td:nth-child(1) { width: 10%; max-width: 60px; text-align: center; }
        .tm-table th:nth-child(2), .tm-table td:nth-child(2) { width: 45%; }
        .tm-table th:nth-child(3), .tm-table td:nth-child(3) { width: 45%; }
        .tm-best-match-highlight { background-color: #d1fae5 !important; border-color: #10b981 !important; border-width: 2px; box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.25); }
        #dropArea { width: 100%; max-width: 90%; transition: none; }
        .terminology-sidebar, .translation-memory-sidebar { position: fixed; top: 60px; bottom: 20px; width: 350px; z-index: 500; background-color: #fff; border: 1px solid #e5e7eb; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out, width 0.3s ease-in-out; opacity: 0; pointer-events: none; resize: horizontal; overflow: auto; min-width: 300px; max-width: 600px; }
        .terminology-sidebar { left: 1rem; transform: translateX(-100%); }
        .terminology-sidebar.show-sidebar { transform: translateX(0); opacity: 1; pointer-events: all; }
        .translation-memory-sidebar { right: 1rem; transform: translateX(100%); }
        .translation-memory-sidebar.show-sidebar { transform: translateX(0); opacity: 1; pointer-events: all; }
        .editor-main-content { padding-left: 1rem; padding-right: 1rem; transition: padding-left 0.3s ease-in-out, padding-right 0.3s ease-in-out; max-height: 70vh; overflow-y: auto; }
        @media (min-width: 1024px) {
            .editor-main-content.left-sidebar-active { padding-left: calc(var(--terminology-sidebar-width, 350px) + 2rem); }
            .editor-main-content.right-sidebar-active { padding-right: calc(var(--translation-memory-sidebar-width, 350px) + 2rem); }
        }
        .po-display-code, .msgstr-textarea { font-size: 1rem; }
        .top-utility-buttons-container { position: absolute; top: 4px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; justify-content: center; gap: 0.75rem; min-width: 400px; }
        .top-utility-buttons-container button, .top-utility-buttons-container .dropdown-btn { font-size: 0.875rem; white-space: nowrap; padding-left: 0.75rem; padding-right: 0.75rem; }
        .dropdown { position: relative; display: inline-block; }
        .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 1; border-radius: 0.375rem; }
        .dropdown-content a { color: black; padding: 12px 16px; text-decoration: none; display: block; font-size: 0.875rem; }
        .dropdown-content a:hover { background-color: #f1f1f1; cursor: pointer; }
        .dropdown:hover .dropdown-content { display: block; }
        .dropdown:hover .dropdown-btn { background-color: #ccc; }
        #statsContainer { transform: translateY(100%); transition: transform 0.3s ease-in-out; }
        #statsContainer.show { transform: translateY(0); }
        .diff-added { background-color: #e6ffed; color: #22863a; padding: 1px 2px; border-radius: 3px; }
        .diff-removed { background-color: #ffebe9; color: #b31d28; text-decoration: line-through; padding: 1px 2px; border-radius: 3px; }
        #backupIndicator {
            display: none;
            width: 8px;
            height: 8px;
            background-color: #22c55e;
            border-radius: 50%;
            margin-left: 8px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">
    <div class="bg-white p-8 rounded-lg shadow-xl w-full relative mb-4" id="dropArea">
        <!-- Language Switcher -->
        <div class="absolute top-4 right-4 space-x-2">
            <button id="langEnBtn" class="px-3 py-1 text-sm font-medium rounded-md transition duration-300">EN</button>
            <button id="langEsBtn" class="px-3 py-1 text-sm font-medium rounded-md transition duration-300">ES</button>
        </div>

        <!-- Top Utility Buttons -->
        <div class="top-utility-buttons-container">
            <div class="dropdown">
                <button id="projectBtn" class="dropdown-btn bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                    <span data-i18n="project_btn">Project</span>
                </button>
                <div class="dropdown-content">
                    <a id="newProjectBtn" data-i18n="new_project_btn">New Project</a>
                    <a id="openProjectBtn" data-i18n="open_project_btn">Open Project</a>
                    <a id="saveProjectBtn" data-i18n="save_project_btn">Save Project</a>
                </div>
            </div>
            <button id="backupBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1 px-3 rounded-md shadow-sm transition duration-300 flex items-center">
                <span data-i18n="backup_btn">Backup</span>
                <span id="backupIndicator"></span>
            </button>
            <button id="shortcutsBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="shortcuts_btn"></span>
            </button>
            <button id="findReplaceBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="find_replace_btn"></span>
            </button>
            <button id="terminologyBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="terminology_btn"></span>
            </button>
            <button id="tmBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="tm_btn"></span>
            </button>
            <button id="statsBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="statistics_btn"></span>
            </button>
        </div>

        <div class="flex flex-col items-center mb-6 mt-12">
            <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/poanda-logo-final.png" alt="Poanda Logo" class="max-w-xs h-auto mb-2">
            <div data-i18n="tool_description" id="toolDescription" class="text-lg text-center text-on-light-contrast"></div>
        </div>

        <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mb-6">
            <label for="poFile" class="block font-medium cursor-pointer py-2 px-4 rounded-md shadow-sm transition duration-300 btn-load">
                <span data-i18n="load_file" id="loadBtnText"></span>
                <input type="file" id="poFile" accept=".po" class="hidden">
                <input type="file" id="projectFile" accept=".zip,.poanda" class="hidden">
                <input type="file" id="backupFile" accept=".json,.poanda-backup" class="hidden">
            </label>
            <button id="savePo" class="font-medium py-2 px-4 rounded-md shadow-sm transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed btn-save" disabled>
                <span data-i18n="save_file" id="saveBtnText"></span>
            </button>
            <!-- NEW: PO to MO Converter Button -->
            <button id="convertToMoButton" class="font-medium py-2 px-4 rounded-md shadow-sm transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed btn-convert-mo" disabled>
                <span data-i18n="convert_to_mo_btn"></span>
            </button>
        </div>

        <div class="main-editor-layout" id="mainEditorLayout">
            <div class="editor-main-content space-y-4 max-h-[70vh] overflow-y-auto pr-2" id="editorMainContent">
                <div id="translationsContainer">
                    <div data-i18n="no_translations" id="initialMessage" class="text-center text-on-light-contrast p-4 border border-gray-300 rounded-md"></div>
                </div>
            </div>
            <div id="terminologySidebar" class="terminology-sidebar p-4 border border-gray-300 rounded-lg shadow-md">
                <div class="sidebar-header">
                    <h3 class="text-lg font-bold text-on-light-contrast" data-i18n="terminology_sidebar_title" id="terminologySidebarTitle"></h3>
                    <button id="closeTerminologySidebarBtn" class="text-gray-500 hover:text-gray-700">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <div class="sidebar-content">
                    <div id="terminologyLanguageConfigSection" class="space-y-4">
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="config_lang_title" id="configLangTitle"></h4>
                        <div class="glossary-info-box mb-4"><p data-i18n="config_lang_info" id="configLangInfo"></p></div>
                        <div class="flex flex-col space-y-2 mb-4">
                            <div class="glossary-input-group"><label for="configSrcLang" data-i18n="source_language" id="sourceLanguageLabel"></label><input id="configSrcLang" list="isoLanguages" value="en-US" class="block w-full" /></div>
                            <div class="glossary-input-group"><label for="configTgtLang" data-i18n="target_language" id="targetLanguageLabel"></label><input id="configTgtLang" list="isoLanguages" value="es-ES" class="block w-full" /></div>
                            <button onclick="confirmGlossaryLanguages()" data-i18n="confirm_languages" id="confirmLanguagesBtn" class="glossary-btn-primary w-full"></button>
                        </div>
                    </div>
                    <div id="terminologyEditorSection" style="display:none;">
                        <div class="flex flex-col sm:flex-row gap-2 mb-4">
                            <button onclick="loadTBX()" data-i18n="import_tbx" id="importTbxBtn" class="glossary-btn-secondary flex-1 text-sm py-2 px-2"></button>
                            <input type="file" id="tbxFileInput" accept=".xml,.tbx" class="hidden" />
                            <button onclick="downloadTBX()" data-i18n="download_tbx" id="downloadTbxBtn" class="glossary-btn-secondary flex-1 text-sm py-2 px-2"></button>
                            <button onclick="resetGlossary()" data-i18n="new_glossary" id="newGlossaryBtn" class="glossary-btn-secondary flex-1 text-sm py-2 px-2"></button>
                        </div>
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="current_lang_title" id="currentLangTitle"></h4>
                        <div class="flex space-x-2 mb-4">
                            <div class="glossary-input-group flex-1"><label data-i18n="source_language" id="displaySourceLanguageLabel"></label><input id="displaySrcLang" disabled class="block w-full" /></div>
                            <div class="glossary-input-group flex-1"><label data-i18n="target_language" id="displayTargetLanguageLabel"></label><input id="displayTgtLang" disabled class="block w-full" /></div>
                        </div>
                        <div class="accordion-item">
                            <div class="accordion-header flex justify-between items-center" id="addTermHeader">
                                <h4 class="text-md font-semibold text-on-light-contrast m-0" data-i18n="add_term_title" id="addTermTitleAccordion"></h4>
                                <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </div>
                            <div class="accordion-content collapsed" id="addTermContent">
                                <div class="flex flex-col space-y-2 mb-4">
                                    <div class="glossary-input-group"><label for="srcTerm" data-i18n="term" id="termLabel"></label><input id="srcTerm" class="block w-full" /></div>
                                    <div class="glossary-input-group"><label for="tgtTerm" data-i18n="translation" id="translationLabel"></label><input id="tgtTerm" class="block w-full" /></div>
                                    <button onclick="addTerm()" data-i18n="add_button" id="addTermBtn" class="glossary-btn-primary w-full"></button>
                                </div>
                            </div>
                        </div>
                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="search_title" id="searchTitle"></h4>
                        <div class="mb-4"><input id="searchTerm" data-i18n-placeholder="search_placeholder" class="block w-full" oninput="renderGlossary()" /></div>
                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="glossary_list_title" id="glossaryListTitle"></h4>
                        <div class="overflow-x-auto"><table class="glossary-table w-full"><thead><tr><th data-i18n="source_term_col" id="sourceTermCol"></th><th data-i18n="target_term_col" id="targetTermCol"></th><th data-i18n="actions_col" id="actionsCol"></th></tr></thead><tbody id="glossaryTableBody"></tbody></table></div>
                    </div>
                </div>
                <datalist id="isoLanguages"></datalist>
            </div>
            <div id="translationMemorySidebar" class="translation-memory-sidebar p-4 border border-gray-300 rounded-lg shadow-md">
                <div class="sidebar-header">
                    <h3 class="text-lg font-bold text-on-light-contrast" data-i18n="tm_sidebar_title" id="tmSidebarTitle"></h3>
                    <button id="closeTranslationMemorySidebarBtn" class="text-gray-500 hover:text-gray-700">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <div class="sidebar-content">
                    <div id="tmInternalMessage" class="tm-info-box mb-4 hidden"></div>
                    <div id="tmLanguageConfigSection" class="space-y-4">
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="tm_config_lang_title" id="tmConfigLangTitle"></h4>
                        <div class="tm-info-box mb-4"><p data-i18n="tm_config_lang_info" id="tmConfigLangInfo"></p></div>
                        <div class="flex flex-col space-y-2 mb-4">
                            <div class="tm-input-group"><label for="tmConfigSrcLang" data-i18n="source_language" id="tmSourceLanguageLabel"></label><input id="tmConfigSrcLang" list="isoLanguages" value="en-US" class="block w-full" /></div>
                            <div class="tm-input-group"><label for="tmConfigTgtLang" data-i18n="target_language" id="tmTargetLanguageLabel"></label><input id="tmConfigTgtLang" list="isoLanguages" value="es-ES" class="block w-full" /></div>
                            <button onclick="confirmTMLanguages()" data-i18n="confirm_languages" id="tmConfirmLanguagesBtn" class="tm-btn-primary w-full"></button>
                        </div>
                    </div>
                    <div id="tmEditorSection" style="display:none;">
                        <div class="flex flex-col sm:flex-row gap-2 mb-4">
                            <button onclick="resetTM()" data-i18n="new_tm" id="newTmBtn" class="tm-btn-secondary flex-1 text-sm py-2 px-2"></button>
                            <label for="tmFileInput" class="block font-medium cursor-pointer py-2 px-4 rounded-md shadow-sm transition duration-300 tm-btn-secondary flex-1 text-sm text-center">
                                <span data-i18n="import_tmx" id="importTmxBtnText"></span><input type="file" id="tmFileInput" accept=".xml,.tmx" class="hidden" />
                            </label>
                            <button onclick="downloadTMX()" data-i18n="download_tmx" id="downloadTmxBtn" class="tm-btn-secondary flex-1 text-sm py-2 px-2"></button>
                        </div>
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="current_tm_lang_title" id="currentTmLangTitle"></h4>
                        <div class="flex space-x-2 mb-4">
                            <div class="tm-input-group flex-1"><label data-i18n="source_language" id="displayTmSourceLanguageLabel"></label><input id="displayTmSrcLang" disabled class="block w-full" /></div>
                            <div class="tm-input-group flex-1"><label data-i18n="target_language" id="displayTmTargetLanguageLabel"></label><input id="displayTmTgtLang" disabled class="block w-full" /></div>
                        </div>
                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="tm_search_title" id="tmSearchTitle"></h4>
                        <div class="mb-4"><input id="tmSearchInput" data-i18n-placeholder="tm_search_placeholder" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white" oninput="tmSearch()" /></div>
                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="tm_search_results_title" id="tmSearchResultsTitle"></h4>
                        <div class="overflow-x-auto mb-4"><table class="tm-table w-full"><thead><tr><th data-i18n="tm_score_col" id="tmScoreCol"></th><th data-i18n="tm_original_col" id="tmOriginalCol"></th><th data-i18n="tm_translation_col" id="tmTranslationCol"></th></tr></thead><tbody id="tmSearchResultsTableBody"></tbody></table></div>
                        <div data-i18n="tm_no_match_found" id="tmNoMatchFoundMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md hidden"></div>
                    </div>
                </div>
                <datalist id="isoLanguages"></datalist>
            </div>
        </div>

        <div id="messageBox" class="modal hidden"><div class="modal-content"><p id="messageText" class="text-lg font-semibold text-on-light-contrast mb-4"></p><button id="messageClose" class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-md transition duration-300"><span data-i18n="ok" id="okBtnText"></span></button></div></div>
        <div id="shortcutsModal" class="modal hidden"><div class="modal-content"><h2 data-i18n="shortcuts_title" id="shortcutsTitle" class="text-xl font-bold mb-4 text-on-light-contrast"></h2><ul class="list-disc list-inside text-on-light-contrast space-y-2"><li id="shortcutValidate"></li><li id="shortcutNext"></li><li id="shortcutPrev"></li><li id="shortcutAlt1"></li><li id="shortcutTmInsert"></li></ul><button data-i18n="close_btn" id="shortcutsCloseBtn" class="mt-6 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-md transition duration-300"><span id="shortcutsCloseBtnText"></span></button></div></div>
        <div id="findReplaceModal" class="modal hidden"><div class="modal-content"><h2 data-i18n="find_replace_title" id="findReplaceTitle" class="text-xl font-bold mb-4 text-on-light-contrast"></h2><div class="space-y-4"><div><label for="findInput" data-i18n="find_label" id="findLabel" class="block text-sm font-medium text-on-light-contrast mb-1"></label><input type="text" id="findInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></div><div><label for="replaceInput" data-i18n="replace_label" id="replaceLabel" class="block text-sm font-medium text-on-light-contrast mb-1"></label><input type="text" id="replaceInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></div><div class="flex items-center space-x-4"><label class="flex items-center text-on-light-contrast"><input type="checkbox" id="caseSensitiveCheckbox" class="mr-2"><span data-i18n="case_sensitive" id="caseSensitiveText"></span></label><label class="flex items-center text-on-light-contrast"><input type="checkbox" id="regexCheckbox" class="mr-2"><span data-i18n="regular_expression" id="regexText"></span></label></div><div class="flex justify-end space-x-2"><button data-i18n="find_prev" id="findPrevBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-4 rounded-md transition duration-300"><span id="findPrevText"></span></button><button data-i18n="find_next" id="findNextBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-4 rounded-md transition duration-300"><span id="findNextText"></span></button><button data-i18n="replace" id="replaceBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-md transition duration-300"><span id="replaceText"></span></button><button data-i18n="replace_all" id="replaceAllBtn" class="bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded-md transition duration-300"><span id="replaceAllText"></span></button></div></div><button data-i18n="close_btn" id="findReplaceCloseBtn" class="mt-6 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-md transition duration-300 w-full"><span id="findReplaceCloseBtnText"></span></button></div></div>
        <div id="saveProjectModal" class="modal hidden"><div class="modal-content"><h2 data-i18n="save_project_title" id="saveProjectTitle" class="text-xl font-bold mb-4 text-on-light-contrast"></h2><div class="space-y-4"><div><label for="projectFilenameInput" data-i18n="filename_label" id="filenameLabel" class="block text-sm font-medium text-on-light-contrast mb-1"></label><input type="text" id="projectFilenameInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></div></div><div class="flex justify-end space-x-2 mt-6"><button id="saveProjectCancelBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-md transition duration-300"><span data-i18n="cancel_button"></span></button><button id="saveProjectConfirmBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-md transition duration-300"><span data-i18n="save_button"></span></button></div></div></div>
        
        <div id="backupModal" class="modal hidden">
            <div class="modal-content">
                <h2 data-i18n="backup_title" class="text-xl font-bold mb-4 text-on-light-contrast"></h2>
                <p data-i18n="backup_info_text" class="text-on-light-contrast mb-4"></p>
                <div class="bg-gray-100 p-3 rounded-md mb-6">
                    <p class="text-sm text-gray-700"><strong data-i18n="last_backup_label"></strong> <span id="lastBackupTime"></span></p>
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <button id="loadLocalBackupBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-md transition duration-300 disabled:opacity-50" disabled><span data-i18n="load_local_backup_btn"></span></button>
                    <button id="saveBackupToDiskBtn" class="bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded-md transition duration-300 disabled:opacity-50" disabled><span data-i18n="save_backup_to_disk_btn"></span></button>
                    <label class="bg-purple-500 hover:bg-purple-600 text-white font-medium py-2 px-4 rounded-md transition duration-300 cursor-pointer text-center"><span data-i18n="load_backup_from_disk_btn"></span><input type="file" id="loadBackupFromFileInput" class="hidden" accept=".json,.poanda-backup"/></label>
                    <button id="deleteLocalBackupBtn" class="bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded-md transition duration-300 disabled:opacity-50" disabled><span data-i18n="delete_local_backup_btn"></span></button>
                </div>
                 <button id="backupCloseBtn" class="mt-6 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-md transition duration-300 w-full"><span data-i18n="close_btn"></span></button>
            </div>
        </div>

        <div id="restoreBackupModal" class="modal hidden"><div class="modal-content"><h2 data-i18n="restore_backup_title" id="restoreBackupTitle" class="text-xl font-bold mb-4 text-on-light-contrast"></h2><p data-i18n="restore_backup_info" id="restoreBackupInfo" class="text-on-light-contrast mb-6"></p><div class="flex justify-end space-x-2"><button id="discardBackupBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-md transition duration-300"><span data-i18n="discard_button"></span></button><button id="restoreBackupBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-md transition duration-300"><span data-i18n="restore_button"></span></button></div></div></div>

        <!-- NEW: PO to MO Converter Modal -->
        <div id="convertToMoModal" class="modal hidden">
            <div class="modal-content">
                <h2 data-i18n="mo_converter_title" class="text-xl font-bold mb-4 text-on-light-contrast"></h2>
                <p data-i18n="mo_converter_info" class="text-on-light-contrast mb-6"></p>
                <div class="flex justify-end space-x-2">
                    <button id="moConverterCloseBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-md transition duration-300"><span data-i18n="close_btn"></span></button>
                    <button id="moConverterActionBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-md transition duration-300"><span data-i18n="mo_converter_action_btn"></span></button>
                </div>
            </div>
        </div>
    </div>

    <div id="statsContainer" class="fixed bottom-0 left-0 right-0 bg-white p-3 border-t border-gray-200 shadow-lg z-[900]"><div class="max-w-7xl mx-auto text-sm text-center text-gray-700 flex flex-wrap justify-center md:justify-around items-center gap-x-6 gap-y-2"><p><strong class="font-semibold" data-i18n="stats_progress_label"></strong> <span id="segmentsProgress">0/0 segments (0%)</span></p><p><strong class="font-semibold" data-i18n="stats_words_label"></strong> <span id="wordsTranslated">0</span> / <span id="wordsTotal">0</span></p><p><strong class="font-semibold" data-i18n="stats_remaining_label"></strong> <span id="wordsRemaining">0</span></p></div></div>
    <div id="loadingOverlay" class="loading-overlay hidden"><div class="loading-spinner"></div><p id="loadingMessage"></p></div>

    <script>
        // Global variables for Poanda editor
        let poEntries = [];
        let currentFileName = 'translations.po';
        let currentLanguage = 'en'; // Default language set to English
        let findState = {
            query: '',
            replace: '',
            caseSensitive: false,
            useRegex: false,
            lastFound: null,
        };

        // Global variable to keep track of terms found in the currently active/focused segment's original text
        let termsFoundInActiveSegment = new Set(); // Stores terms found in the currently focused original segment

        // Global variables for Terminology (Glossary)
        let glossary = [];
        let glossarySourceLanguage = '';
        let glossaryTargetLanguage = '';
        let currentGlossaryLatestResults = []; // Stores the last set of results rendered in glossary table for shortcuts


        // Global variables for Translation Memory (TM)
        let translationMemory = []; // Stores {srcLang, srcText, tgtLang, tgtText, srcWordCount, tgtWordCount}
        let tmSourceLanguage = ''; // Will typically be the source language of the PO file
        let tmTargetLanguage = ''; // Will typically be the target language of the PO file
        let tmBestMatchForActiveSegment = null; // Stores the best TM match for the currently focused segment
        let currentTMLatestSearchResults = []; // Stores the last set of results rendered in TM search table


        // DOM elements for Poanda editor
        const poFile = document.getElementById('poFile');
        const savePoButton = document.getElementById('savePo');
        const translationsContainer = document.getElementById('translationsContainer');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageClose = document.getElementById('messageClose');
        const poandaLogo = document.querySelector('.max-w-xs');
        const dropArea = document.getElementById('dropArea');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const mainEditorLayout = document.getElementById('mainEditorLayout');

        // Project DOM elements
        const projectFileInput = document.getElementById('projectFile');
        const newProjectBtn = document.getElementById('newProjectBtn');
        const openProjectBtn = document.getElementById('openProjectBtn');
        const saveProjectBtn = document.getElementById('saveProjectBtn');
        
        // Save Project Modal DOM elements
        const saveProjectModal = document.getElementById('saveProjectModal');
        const projectFilenameInput = document.getElementById('projectFilenameInput');
        const saveProjectConfirmBtn = document.getElementById('saveProjectConfirmBtn');
        const saveProjectCancelBtn = document.getElementById('saveProjectCancelBtn');

        // Restore Backup Modal DOM elements
        const restoreBackupModal = document.getElementById('restoreBackupModal');
        const restoreBackupBtn = document.getElementById('restoreBackupBtn');
        const discardBackupBtn = document.getElementById('discardBackupBtn');
        
        // Backup Modal DOM elements
        const backupBtn = document.getElementById('backupBtn');
        const backupIndicator = document.getElementById('backupIndicator');
        const backupModal = document.getElementById('backupModal');
        const lastBackupTime = document.getElementById('lastBackupTime');
        const loadLocalBackupBtn = document.getElementById('loadLocalBackupBtn');
        const saveBackupToDiskBtn = document.getElementById('saveBackupToDiskBtn');
        const loadBackupFromFileInput = document.getElementById('loadBackupFromFileInput');
        const deleteLocalBackupBtn = document.getElementById('deleteLocalBackupBtn');
        const backupCloseBtn = document.getElementById('backupCloseBtn');
        const backupFileInput = document.getElementById('backupFile');


        // Statistics DOM elements
        const statsBtn = document.getElementById('statsBtn');
        const statsContainer = document.getElementById('statsContainer');
        const segmentsProgress = document.getElementById('segmentsProgress');
        const wordsTranslated = document.getElementById('wordsTranslated');
        const wordsTotal = document.getElementById('wordsTotal');
        const wordsRemaining = document.getElementById('wordsRemaining');


        // Poanda Modals
        const shortcutsBtn = document.getElementById('shortcutsBtn');
        const shortcutsModal = document.getElementById('shortcutsModal');
        const shortcutsCloseBtn = document.getElementById('shortcutsCloseBtn');
        const findReplaceBtn = document.getElementById('findReplaceBtn');
        const findReplaceModal = document.getElementById('findReplaceModal');
        const findInput = document.getElementById('findInput');
        const replaceInput = document.getElementById('replaceInput');
        const caseSensitiveCheckbox = document.getElementById('caseSensitiveCheckbox');
        const regexCheckbox = document.getElementById('regexCheckbox');
        const findPrevBtn = document.getElementById('findPrevBtn');
        const findNextBtn = document.getElementById('findNextBtn');
        const replaceBtn = document.getElementById('replaceBtn');
        const replaceAllBtn = document.getElementById('replaceAllBtn');
        const findReplaceCloseBtn = document.getElementById('findReplaceCloseBtn');

        // Terminology Sidebar DOM elements
        const terminologyBtn = document.getElementById('terminologyBtn');
        const terminologySidebar = document.getElementById('terminologySidebar');
        const closeTerminologySidebarBtn = document.getElementById('closeTerminologySidebarBtn');
        const terminologyLanguageConfigSection = document.getElementById('terminologyLanguageConfigSection');
        const terminologyEditorSection = document.getElementById('terminologyEditorSection');
        const configSrcLang = document.getElementById('configSrcLang');
        const configTgtLang = document.getElementById('configTgtLang');
        const displaySrcLang = document.getElementById('displaySrcLang');
        const displayTgtLang = document.getElementById('displayTgtLang');
        const srcTermInput = document.getElementById('srcTerm');
        const tgtTermInput = document.getElementById('tgtTerm');
        const searchTermInput = document.getElementById('searchTerm');
        const glossaryTableBody = document.getElementById('glossaryTableBody');
        const tbxFileInput = document.getElementById('tbxFileInput');
        const isoLanguagesDatalist = document.getElementById('isoLanguages');

        // Buttons directly in config/editor sections for TBX
        const importTbxBtn = document.getElementById('importTbxBtn');
        const newGlossaryBtn = document.getElementById('newGlossaryBtn');
        const addTermHeader = document.getElementById('addTermHeader');
        const addTermContent = addTermHeader ? addTermHeader.nextElementSibling : null;
        const addTermAccordionIcon = addTermHeader ? addTermHeader.querySelector('.accordion-icon') : null;

        // Translation Memory Sidebar DOM elements
        const tmBtn = document.getElementById('tmBtn');
        const translationMemorySidebar = document.getElementById('translationMemorySidebar');
        const closeTranslationMemorySidebarBtn = document.getElementById('closeTranslationMemorySidebarBtn');
        const tmFileInput = document.getElementById('tmFileInput');
        const tmSearchInput = document.getElementById('tmSearchInput');
        const tmSearchResultsTableBody = document.getElementById('tmSearchResultsTableBody');
        const tmNoMatchFoundMessage = document.getElementById('tmNoMatchFoundMessage');
        // New TM config DOM elements
        const tmLanguageConfigSection = document.getElementById('tmLanguageConfigSection');
        const tmEditorSection = document.getElementById('tmEditorSection');
        const tmConfigSrcLang = document.getElementById('tmConfigSrcLang');
        const tmConfigTgtLang = document.getElementById('tmConfigTgtLang');
        const displayTmSrcLang = document.getElementById('displayTmSrcLang');
        const displayTmTgtLang = document.getElementById('displayTmTgtLang');
        const tmInternalMessage = document.getElementById('tmInternalMessage'); // New TM internal message element

        // DOM element for main content editor, needed for padding adjustments
        const editorMainContent = document.getElementById('editorMainContent');

        // NEW: PO to MO Converter DOM Elements
        const convertToMoButton = document.getElementById('convertToMoButton');
        const convertToMoModal = document.getElementById('convertToMoModal');
        const moConverterCloseBtn = document.getElementById('moConverterCloseBtn');
        const moConverterActionBtn = document.getElementById('moConverterActionBtn');

        // Translations object for EN and ES
        const translations = {
            'en': {
                'title': 'Poanda',
                'load_file': 'Load .po file',
                'save_file': 'Save .po file',
                'convert_to_mo_btn': 'Convert to .mo', // New
                'original_msgid': 'Original (msgid):',
                'translation_msgstr': 'Translation (msgstr):',
                'context_msgctxt': 'Context (msgctxt):',
                'validate': 'Validate',
                'edit': 'Edit',
                'fuzzy': 'Fuzzy',
                'char_count_original': 'Original: ',
                'char_count_translation': 'Translation: ',
                'char_units': ' characters',
                'no_translations': 'Load a .po file or open a project to start editing.',
                'error_reading_file': 'Error reading or parsing .po file: ',
                'error_saving_file': 'Error saving .po file: ',
                'file_saved_successfully': '.po file saved successfully.',
                'no_translations_to_save': 'No translations to save. Load a .po file first.',
                'reached_last': 'You have reached the last translation.',
                'reached_first': 'You are already at the first translation.',
                'file_processing_error': 'Error! Could not process the file. Make sure it is a valid .po file.',
                'tool_description': 'A simple tool for editing .po files.',
                'ok': 'OK',
                'shortcuts_btn': 'Shortcuts',
                'shortcuts_title': 'Keyboard Shortcuts',
                'shortcut_validate': 'Ctrl + Enter: Validate translation and go to the next one.',
                'shortcut_next': 'Ctrl + Arrow Down: Go to the next translation.',
                'shortcut_prev': 'Ctrl + Arrow Up: Go to the previous translation.',
                'shortcut_alt_1': 'Alt + [1-5]: Insert translation memory suggestion.',
                'shortcut_tm_insert': 'Ctrl + Alt + [1-5]: Insert highlighted glossary term.',
                'close_btn': 'Close',
                'find_replace_btn': 'Find & Replace',
                'find_replace_title': 'Find and Replace',
                'find_label': 'Find:',
                'replace_label': 'Replace with:',
                'case_sensitive': 'Case sensitive',
                'regular_expression': 'Regular expression',
                'find_prev': 'Find previous',
                'find_next': 'Find next',
                'replace': 'Replace',
                'replace_all': 'Replace all',
                'no_match_found': 'No match found.',
                'replaced_all': 'All occurrences replaced.',
                'no_find_query': 'Please enter text to find.',
                'loading_file': 'Loading file...',
                'saving_file': 'Saving file...',
                'terminology_btn': 'Terminology',
                'terminology_sidebar_title': 'Terminology',
                'config_lang_title': 'Configure Glossary Languages',
                'config_lang_info': 'Define the source and target languages for your glossary. You can enter the ISO code directly or select from the suggestions. It is crucial that the ISO code is correct for it to work properly with your CAT tool.',
                'source_language': 'Source Language:',
                'target_language': 'Target Language:',
                'confirm_languages': 'Confirm Languages',
                'current_lang_title': 'Current Glossary Languages',
                'add_term_title': 'Add Term',
                'term': 'Term:',
                'translation': 'Translation:',
                'add_button': 'Add',
                'search_title': 'Search',
                'search_placeholder': 'Search term...',
                'import_tbx': 'Import TBX',
                'download_tbx': 'Download TBX',
                'new_glossary': 'New Glossary',
                'glossary_list_title': 'Glossary',
                'source_term_col': 'Source Term',
                'target_term_col': 'Target Term',
                'actions_col': 'Actions',
                'delete_button': 'Delete',
                'both_terms_required': 'Both terms are required.',
                'lang_config_required': 'Please configure the source and target languages for the glossary.',
                'cannot_download_empty_or_unconfigured_glossary': 'Cannot download an empty or unconfigured glossary.',
                'error_loading_tbx_file': 'Error loading TBX file. Make sure it is a valid XML/TBX.',
                'no_valid_language_pairs_found_in_tbx': 'No valid language pairs were found in the TBX file. Default values (en-US, es-ES) will be used.',
                'statistics_btn': 'Statistics',
                'stats_progress_label': 'Progress:',
                'stats_words_label': 'Words (Translated / Total):',
                'stats_remaining_label': 'Remaining Words:',
                'tm_btn': 'Translation Memory',
                'tm_sidebar_title': 'Translation Memory (TM)',
                'new_tm': 'New TM',
                'import_tmx': 'Import TMX',
                'download_tmx': 'Download TMX',
                'no_tm_data': 'No data in the translation memory.',
                'tm_source_segment': 'Original:',
                'tm_target_segment': 'Translation:',
                'tm_match_score': 'Match:',
                'tm_no_match_found': 'No matches found in the TM.',
                'tm_insert_match': 'Insert match',
                'error_loading_tmx_file': 'Error loading TMX file. Make sure it is a valid XML/TMX.',
                'cannot_download_empty_tm': 'Cannot download an empty translation memory.',
                'tm_best_match': 'Best TM match:',
                'tm_search_title': 'Search in TM',
                'tm_search_placeholder': 'Search in memory...',
                'tm_search_results_title': 'TM Search Results',
                'tm_score_col': '%',
                'tm_original_col': 'Original',
                'tm_translation_col': 'Translation',
                'tm_config_lang_title': 'Configure TM Languages',
                'tm_config_lang_info': 'Define the source and target languages for your Translation Memory. It is crucial that the ISO code is correct for matching to work properly.',
                'current_tm_lang_title': 'Current TM Languages',
                'tm_initial_message': 'Create a new TM or import a TMX file to start working with the translation memory.',
                'tmx_file_expected_tbx_found': 'This file appears to be a glossary (TBX). Please use the "Import TBX" option in the Terminology panel.',
                'tbx_file_expected_tmx_found': 'This file appears to be a translation memory (TMX). Please use the "Import TMX" option in the Translation Memory panel.',
                'project_btn': 'Project',
                'new_project_btn': 'New Project',
                'open_project_btn': 'Open Project',
                'save_project_btn': 'Save Project',
                'project_saved': 'Project saved successfully.',
                'error_saving_project': 'Error saving project.',
                'no_project_to_save': 'There is no active .po file to save as a project.',
                'loading_project': 'Loading project...',
                'project_loaded': 'Project loaded successfully.',
                'error_opening_project': 'Error opening project file.',
                'invalid_project_file': 'Invalid project file. The zip must contain a .po file.',
                'new_project_confirm': 'Are you sure you want to start a new project? All unsaved progress will be lost.',
                'save_project_title': 'Save Project',
                'filename_label': 'Filename:',
                'save_button': 'Save',
                'cancel_button': 'Cancel',
                'enter_filename': 'Please enter a filename.',
                'restore_backup_title': 'Restore Session',
                'restore_backup_info': 'We found a backup of your previous session. Would you like to restore it?',
                'restore_button': 'Restore',
                'discard_button': 'Discard',
                'backup_btn': 'Backup',
                'backup_title': 'Backup Management',
                'backup_info_text': 'Poanda automatically saves a local backup of your entire session (PO file, TM, and glossary) to your browser every 10 seconds. You can restore this backup here or save it to a file for safekeeping.',
                'last_backup_label': 'Last backup:',
                'no_backup_available': 'No backup available.',
                'load_local_backup_btn': 'Load Local Backup',
                'save_backup_to_disk_btn': 'Save Backup to Disk',
                'load_backup_from_disk_btn': 'Load Backup from Disk',
                'delete_local_backup_btn': 'Delete Local Backup',
                'backup_deleted': 'Local backup has been deleted.',
                'backup_loaded_from_file': 'Backup loaded successfully from file.',
                'error_loading_backup_file': 'Error loading backup file. Ensure it is a valid .poanda-backup file.',
                'delete_local_backup_btn_confirm': 'Are you sure you want to delete the local backup? This action cannot be undone.',
                'mo_converter_title': 'PO to MO Converter', // New
                'mo_converter_info': 'This will compile the current .po file into a binary .mo file. The conversion happens entirely in your browser.', // New
                'mo_converter_action_btn': 'Convert and Download .mo', // New
                'mo_conversion_success': 'MO file converted and downloaded successfully.', // New
                'mo_conversion_error': 'Error during MO conversion. Check the browser console (F12) for details.', // New
                'no_file_to_convert': 'No .po file loaded to convert.', // New
            },
            'es': {
                'title': 'Poanda',
                'load_file': 'Cargar archivo .po',
                'save_file': 'Guardar archivo .po',
                'convert_to_mo_btn': 'Convertir a .mo', // New
                'original_msgid': 'Original (msgid):',
                'translation_msgstr': 'Traducción (msgstr):',
                'context_msgctxt': 'Contexto (msgctxt):',
                'validate': 'Validar',
                'edit': 'Editar',
                'fuzzy': 'Difuso',
                'char_count_original': 'Original: ',
                'char_count_translation': 'Traducción: ',
                'char_units': ' caracteres',
                'no_translations': 'Carga un archivo .po o abre un proyecto para empezar a editar.',
                'error_reading_file': 'Error al leer o analizar archivo .po: ',
                'error_saving_file': 'Error al guardar archivo .po: ',
                'file_saved_successfully': 'Archivo .po guardado con éxito.',
                'no_translations_to_save': 'No hay traducciones para guardar. Carga un archivo .po primero.',
                'reached_last': 'Has llegado a la última traducción.',
                'reached_first': 'Ya estás en la primera traducción.',
                'file_processing_error': '¡Error! No se pudo procesar el archivo. Asegúrate de que es un archivo .po válido.',
                'tool_description': 'Una herramienta sencilla para editar archivos .po.',
                'ok': 'OK',
                'shortcuts_btn': 'Atajos',
                'shortcuts_title': 'Atajos de teclado',
                'shortcut_validate': 'Ctrl + Enter: Validar traducción y pasar a la siguiente.',
                'shortcut_next': 'Ctrl + Flecha abajo: Ir a la siguiente traducción.',
                'shortcut_prev': 'Ctrl + Flecha arriba: Ir a la traducción anterior.',
                'shortcut_alt_1': 'Alt + [1-5]: Insertar sugerencia de la memoria de traducción.',
                'shortcut_tm_insert': 'Ctrl + Alt + [1-5]: Insertar término traducido resaltado en glosario.',
                'close_btn': 'Cerrar',
                'find_replace_btn': 'Buscar y reemplazar',
                'find_replace_title': 'Buscar y reemplazar',
                'find_label': 'Buscar:',
                'replace_label': 'Reemplazar con:',
                'case_sensitive': 'Distinguir mayúsculas y minúsculas',
                'regular_expression': 'Expresión regular',
                'find_prev': 'Buscar anterior',
                'find_next': 'Buscar siguiente',
                'replace': 'Reemplazar',
                'replace_all': 'Reemplazar todo',
                'no_match_found': 'No se encontró ninguna coincidencia.',
                'replaced_all': 'Todas las ocurrencias reemplazadas.',
                'no_find_query': 'Por favor, introduce el texto a buscar.',
                'loading_file': 'Cargando archivo...',
                'saving_file': 'Guardando archivo...',
                'terminology_btn': 'Terminología',
                'terminology_sidebar_title': 'Terminología',
                'config_lang_title': 'Configurar idiomas del glosario',
                'config_lang_info': 'Define los idiomas de origen y destino de tu glosario. Puedes introducir el código ISO directamente o seleccionarlo de las sugerencias. Es fundamental que el código ISO sea correcto para que funcione correctamente con tu herramienta TAO.',
                'source_language': 'Idioma de origen:',
                'target_language': 'Idioma de destino:',
                'confirm_languages': 'Confirmar idiomas',
                'current_lang_title': 'Idiomas actuales del glosario',
                'add_term_title': 'Añadir término',
                'term': 'Término:',
                'translation': 'Traducción:',
                'add_button': 'Añadir',
                'search_title': 'Buscar',
                'search_placeholder': 'Buscar término...',
                'import_tbx': 'Importar TBX',
                'download_tbx': 'Descargar TBX',
                'new_glossary': 'Nuevo glosario',
                'glossary_list_title': 'Glosario',
                'source_term_col': 'Término de origen',
                'target_term_col': 'Término de destino',
                'actions_col': 'Acciones',
                'delete_button': 'Eliminar',
                'both_terms_required': 'Ambos términos son requeridos.',
                'lang_config_required': 'Por favor, configura los idiomas de origen y destino para el glosario.',
                'cannot_download_empty_or_unconfigured_glossary': 'No se puede descargar un glosario vacío o sin configurar.',
                'error_loading_tbx_file': 'Error al cargar el archivo TBX. Asegúrate de que sea un XML/TBX válido.',
                'no_valid_language_pairs_found_in_tbx': 'No se encontraron pares de idiomas válidos en el archivo TBX. Se usarán los valores por defecto (en-US, es-ES).',
                'statistics_btn': 'Estadísticas',
                'stats_progress_label': 'Progreso:',
                'stats_words_label': 'Palabras (Traducidas / Totales):',
                'stats_remaining_label': 'Palabras Pendientes:',
                'tm_btn': 'Memoria de traducción',
                'tm_sidebar_title': 'Memoria de Traducción (TM)',
                'new_tm': 'Nueva TM',
                'import_tmx': 'Importar TMX',
                'download_tmx': 'Descargar TMX',
                'no_tm_data': 'No hay datos en la memoria de traducción.',
                'tm_source_segment': 'Original:',
                'tm_target_segment': 'Traducción:',
                'tm_match_score': 'Coincidencia:',
                'tm_no_match_found': 'No se encontraron coincidencias en la TM.',
                'tm_insert_match': 'Insertar coincidencia',
                'error_loading_tmx_file': 'Error al cargar el archivo TMX. Asegúrate de que sea un XML/TMX válido.',
                'cannot_download_empty_tm': 'No se puede descargar una memoria de traducción vacía.',
                'tm_best_match': 'Mejor coincidencia de TM:',
                'tm_search_title': 'Buscar en TM',
                'tm_search_placeholder': 'Buscar en la memoria...',
                'tm_search_results_title': 'Resultados de búsqueda en TM',
                'tm_score_col': '%',
                'tm_original_col': 'Original',
                'tm_translation_col': 'Traducción',
                'tm_config_lang_title': 'Configurar idiomas de la TM',
                'tm_config_lang_info': 'Define los idiomas de origen y destino de tu Memoria de Traducción. Es fundamental que el código ISO sea correcto para que la coincidencia funcione correctamente.',
                'current_tm_lang_title': 'Idiomas actuales de la TM',
                'tm_initial_message': 'Crea una nueva TM o importa un archivo TMX para empezar a trabajar con la memoria de traducción.',
                'tmx_file_expected_tbx_found': 'Este archivo parece ser un glosario (TBX). Por favor, usa la opción "Importar TBX" en el panel de Terminología.',
                'tbx_file_expected_tmx_found': 'Este archivo parece ser una memoria de traducción (TMX). Por favor, usa la opción "Importar TMX" en el panel de Memoria de Traducción.',
                'project_btn': 'Proyecto',
                'new_project_btn': 'Nuevo proyecto',
                'open_project_btn': 'Abrir proyecto',
                'save_project_btn': 'Guardar proyecto',
                'project_saved': 'Proyecto guardado con éxito.',
                'error_saving_project': 'Error al guardar el proyecto.',
                'no_project_to_save': 'No hay ningún archivo .po activo para guardar como proyecto.',
                'loading_project': 'Cargando proyecto...',
                'project_loaded': 'Proyecto cargado con éxito.',
                'error_opening_project': 'Error al abrir el archivo del proyecto.',
                'invalid_project_file': 'Archivo de proyecto no válido. El zip debe contener un archivo .po.',
                'new_project_confirm': '¿Seguro que quieres iniciar un nuevo proyecto? Se perderá todo el progreso no guardado.',
                'save_project_title': 'Guardar Proyecto',
                'filename_label': 'Nombre del archivo:',
                'save_button': 'Guardar',
                'cancel_button': 'Cancelar',
                'enter_filename': 'Por favor, introduce un nombre de archivo.',
                'restore_backup_title': 'Restaurar sesión',
                'restore_backup_info': 'Hemos encontrado una copia de seguridad de tu sesión anterior. ¿Quieres restaurarla?',
                'restore_button': 'Restaurar',
                'discard_button': 'Descartar',
                'backup_btn': 'Copia de seguridad',
                'backup_title': 'Gestión de Copias de Seguridad',
                'backup_info_text': 'Poanda guarda automáticamente una copia de seguridad local de toda tu sesión (archivo PO, MT y glosario) en tu navegador cada 10 segundos. Puedes restaurar esta copia aquí o guardarla en un archivo para mayor seguridad.',
                'last_backup_label': 'Última copia:',
                'no_backup_available': 'No hay ninguna copia de seguridad disponible.',
                'load_local_backup_btn': 'Cargar copia local',
                'save_backup_to_disk_btn': 'Guardar copia en disco',
                'load_backup_from_disk_btn': 'Cargar copia del disco',
                'delete_local_backup_btn': 'Eliminar copia local',
                'backup_deleted': 'La copia de seguridad local ha sido eliminada.',
                'backup_loaded_from_file': 'Copia de seguridad cargada con éxito desde el archivo.',
                'error_loading_backup_file': 'Error al cargar el archivo de copia de seguridad. Asegúrate de que es un archivo .poanda-backup válido.',
                'delete_local_backup_btn_confirm': '¿Seguro que quieres eliminar la copia de seguridad local? Esta acción no se puede deshacer.',
                'mo_converter_title': 'Convertidor de PO a MO', // New
                'mo_converter_info': 'Esto compilará el archivo .po actual a un archivo binario .mo. La conversión se realiza completamente en tu navegador.', // New
                'mo_converter_action_btn': 'Convertir y Descargar .mo', // New
                'mo_conversion_success': 'Archivo .mo convertido y descargado con éxito.', // New
                'mo_conversion_error': 'Error durante la conversión a MO. Revisa la consola del navegador (F12) para más detalles.', // New
                'no_file_to_convert': 'No hay ningún archivo .po cargado para convertir.', // New
            }
        };

        // SVG icons for shortcuts
        const arrowDownIcon = `<svg class="shortcut-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 12a1 1 0 01-.707-.293l-4-4a1 1 0 011.414-1.414L10 9.586l3.293-3.293a1 1 0 111.414 1.414l-4 4A1 1 0 0110 12z" clip-rule="evenodd"></path></svg>`;
        const arrowUpIcon = `<svg class="shortcut-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 8a1 1 0 01.707.293l4 4a1 1 0 01-1.414 1.414L10 10.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4A1 1 0 0110 8z" clip-rule="evenodd"></path></svg>`;

        // List of common ISO 639-1 language codes for the datalist (for Terminology)
        const isoLanguagesData = [
          { code: "en", name: "English" }, { code: "en-US", name: "English (United States)" }, { code: "en-GB", name: "English (United Kingdom)" },
          { code: "es", name: "Español" }, { code: "es-ES", name: "Español (España)" }, { code: "es-MX", name: "Español (México)" },
          { code: "fr", name: "Français" }, { code: "de", name: "Deutsch" }, { code: "it", name: "Italiano" }, { code: "pt", name: "Português" },
          { code: "ja", name: "日本語 (Japanese)" }, { code: "zh", name: "中文 (Chinese)" }, { code: "ar", name: "العربية (Arabic)" },
          { code: "ru", name: "Русский (Russian)" }, { code: "ko", name: "한국어 (Korean)" }, { code: "nl", name: "Nederlands" },
          { code: "sv", name: "Svenska" }, { code: "da", name: "Dansk" }, { code: "no", name: "Norsk" }, { code: "fi", name: "Suomi" },
          { code: "tr", name: "Türkçe" }, { code: "pl", name: "Polski" }, { code: "cs", name: "Čeština" }, { code: "hu", name: "Magyar" },
          { code: "el", name: "Ελληνικά (Greek)" }, { code: "he", name: "עברית (Hebrew)" }, { code: "th", name: "ไทย (Thai)" },
          { code: "vi", name: "Tiếng Việt (Vietnamese)" }, { code: "id", name: "Bahasa Indonesia" }, { code: "ms", name: "Bahasa Melayu" },
          { code: "ca", name: "Català" }, { code: "eu", name: "Euskara" }, { code: "gl", name: "Galego" }, { code: "ro", name: "Română" },
          { code: "uk", name: "Українська (Ukrainian)" }, { code: "bg", name: "Български (Bulgarian)" }, { code: "hr", name: "Hrvatski" },
          { code: "sr", name: "Srpski" }, { code: "sk", name: "Slovenčina" }, { code: "sl", name: "Slovenščina" }, { code: "lt", name: "Lietuvių" },
          { code: "lv", name: "Latviešu" }, { code: "et", name: "Eesti" }, { code: "is", name: "Íslenska" }, { code: "ga", name: "Gaeilge" },
          { code: "mt", name: "Malti" },
        ];


        /**
         * Counts words in a given text string.
         * @param {string} text The text to count words from.
         * @returns {number} The number of words.
         */
        function countWords(text) {
            if (!text) return 0;
            // Trim leading/trailing whitespace and split by one or more whitespace characters
            const words = text.trim().split(/\s+/);
            // Filter out empty strings that might result from multiple spaces
            return words.filter(word => word.length > 0).length;
        }

        /**
         * Unescapes a string from PO format.
         * Removes start/end quotes and handles escaped characters like \n, \t, \", \\.
         * Also converts <br> and &lt;br&gt; to newlines for better display.
         * @param {string} s The PO string to unescape.
         * @returns {string} The unescaped string.
         */
        function unescapePoString(s) {
            if (s.startsWith('"') && s.endsWith('"')) {
                s = s.substring(1, s.length - 1);
            }
            s = s.replace(/\\n/g, '\n')
                 .replace(/\\t/g, '\t')
                 .replace(/\\"/g, '"')
                 .replace(/\\\\/g, '\\');
            s = s.replace(/&lt;br&gt;/gi, '\n');
            s = s.replace(/<br\s*\/?>/gi, '\n');

            return s;
        }

        /**
         * Escapes a string for PO format.
         * Adds start/end quotes and escapes special characters like ", \, \n, \t.
         * @param {string} s The string to escape.
         * @returns {string} The escaped string in PO format.
         */
        function escapePoString(s) {
            let escaped = s.replace(/\\/g, '\\\\')
                             .replace(/"/g, '\\"')
                             .replace(/\n/g, '\\n')
                             .replace(/\t/g, '\\t');
            return `"${escaped}"`;
        }

        /**
         * Heuristic to split text into "sentences" for display.
         * @param {string} text The text to split.
         * @returns {Array<string>} An array of text segments.
         */
        function splitTextIntoSentences(text) {
            if (!text || typeof text !== 'string' || text.trim() === '') {
                return [''];
            }
            // Use a regex that keeps the delimiters to re-assemble them correctly
            const sentenceDelimiters = /([.?!]+[\s\r\n]*)/g;
            const parts = text.split(sentenceDelimiters);

            const sentences = [];
            let currentSentence = '';

            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                if (part === null || part === undefined) continue;

                if (part.match(sentenceDelimiters)) { // If it's a delimiter
                    if (currentSentence.trim() !== '') {
                        sentences.push(currentSentence.trim() + part);
                        currentSentence = '';
                    } else if (part.trim() !== '') { // Handle cases where a delimiter might start a segment
                        sentences.push(part.trim());
                    }
                } else { // If it's a sentence part
                    currentSentence += part;
                }
            }
            if (currentSentence.trim() !== '') {
                sentences.push(currentSentence.trim());
            }

            return sentences.filter(s => s.length > 0 || text === '');
        }

        /**
         * Parses the content of a .po file.
         * @param {string} content The full content of the .po file.
         * @returns {Array<Object>} An array of PO entry objects.
         */
        function parsePoContent(content) {
            const entries = [];
            let currentEntry = null;
            const lines = content.split('\n');

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();

                if (trimmedLine.startsWith('#')) {
                    if (currentEntry) {
                        currentEntry.comments = currentEntry.comments || [];
                        currentEntry.comments.push(trimmedLine);
                        if (trimmedLine.includes('#, fuzzy')) {
                            currentEntry.fuzzy = true;
                        }
                    } else {
                        // Header comments before any msgid/msgstr block
                        if (entries.length === 0 || entries[entries.length - 1].comments.length === 0) {
                            // If no entries or the last entry doesn't have comments,
                            // this might be part of a global header comment.
                            // A more robust solution would distinguish global header from entry-specific comments.
                            if (entries.length === 0) {
                                // Create a dummy entry for header comments if no entries exist yet
                                entries.push({ comments: [trimmedLine], msgid: '', msgstr: '' });
                                currentEntry = entries[0];
                            } else {
                                // Add to previous entry's comments
                                entries[entries.length - 1].comments.push(trimmedLine);
                            }
                        }
                    }
                    continue;
                }

                if (trimmedLine.startsWith('msgctxt ')) {
                    if (currentEntry && currentEntry.msgid !== undefined) {
                        entries.push(currentEntry);
                        currentEntry = { comments: [] };
                    } else if (!currentEntry) {
                         currentEntry = { comments: [] };
                    }
                    currentEntry.msgctxt = unescapePoString(trimmedLine.substring(8));
                } else if (trimmedLine.startsWith('msgid ')) {
                    if (currentEntry && currentEntry.msgid !== undefined) {
                        entries.push(currentEntry);
                        currentEntry = { comments: [] };
                    } else if (!currentEntry) {
                         currentEntry = { comments: [] };
                    }
                    currentEntry.msgid = unescapePoString(trimmedLine.substring(6));
                } else if (trimmedLine.startsWith('msgstr ')) {
                    if (!currentEntry) {
                        currentEntry = { comments: [] };
                    }
                    currentEntry.msgstr = unescapePoString(trimmedLine.substring(7));
                    entries.push(currentEntry);
                    currentEntry = null; // Reset for next entry
                } else if (trimmedLine.startsWith('"') && trimmedLine.endsWith('"')) {
                    // Continuation of a multi-line msgid or msgstr
                    if (currentEntry) {
                        const unescapedPart = unescapePoString(trimmedLine);
                        if (currentEntry.msgstr === undefined) {
                            currentEntry.msgid = (currentEntry.msgid || '') + unescapedPart;
                        } else {
                            currentEntry.msgstr = (currentEntry.msgstr || '') + unescapedPart;
                        }
                    }
                } else if (trimmedLine === '') {
                    // Empty line separates entries. If there's an active entry being built, finalize it.
                    if (currentEntry && currentEntry.msgid !== undefined && currentEntry.msgstr !== undefined) {
                        entries.push(currentEntry);
                        currentEntry = null;
                    }
                     // If msgid is present but msgstr is not, and we hit an empty line, save it.
                    else if (currentEntry && currentEntry.msgid !== undefined && currentEntry.msgstr === undefined) {
                         // This case might happen at EOF or if msgstr is missing
                         entries.push(currentEntry);
                         currentEntry = null;
                    }
                    // For comments not associated with an entry, we ensure a fresh start for the next entry
                    if (!currentEntry && lines[i+1] && !lines[i+1].startsWith('#')) { // Only create new if next line isn't a comment
                         currentEntry = { comments: [] };
                    }
                }
            }
            // Add the last entry if it wasn't added (e.g., file ends without a blank line)
            if (currentEntry && (currentEntry.msgid !== undefined || currentEntry.msgctxt !== undefined)) {
                if (currentEntry.msgstr === undefined) { // Ensure msgstr is at least an empty string if not present
                    currentEntry.msgstr = '';
                }
                entries.push(currentEntry);
            }

            // Post-processing for sentence segmentation, word counts, and translation status
            entries.forEach(entry => {
                // Handle the special header entry (msgid "")
                if (entry.msgid === '' && entry.msgctxt === undefined) {
                    entry.isHeader = true;
                    entry.sentenceSegments = [{
                        original: entry.msgid,
                        translation: entry.msgstr,
                        wordCountOriginal: countWords(entry.msgid),
                        wordCountTranslation: countWords(entry.msgstr),
                        isTranslated: entry.msgstr.trim() !== ''
                    }];
                } else {
                    entry.isHeader = false;
                    const originalSegments = splitTextIntoSentences(entry.msgid || '');
                    const translatedSegments = splitTextIntoSentences(entry.msgstr || '');

                    entry.sentenceSegments = [];
                    const maxLength = Math.max(originalSegments.length, translatedSegments.length);
                    for (let j = 0; j < maxLength; j++) {
                        const originalText = originalSegments[j] || '';
                        const translationText = translatedSegments[j] || '';
                        entry.sentenceSegments.push({
                            original: originalText,
                            translation: translationText,
                            wordCountOriginal: countWords(originalText),
                            wordCountTranslation: countWords(translationText),
                            isTranslated: translationText.trim() !== ''
                        });
                    }
                }
            });
            return entries;
        }


        /**
         * Reconstructs the content of a PO file from an array of entries.
         * @param {Array<Object>} entries The array of translation objects.
         * @returns {string} The reconstructed PO file content.
         */
        function reconstructPo(entries) {
            let poContent = '';
            entries.forEach(entry => {
                if (entry.comments && entry.comments.length > 0) {
                    // Filter out fuzzy comment if msgstr is not empty
                    const commentsToKeep = entry.fuzzy && entry.msgstr && entry.msgstr.trim() !== '' 
                        ? entry.comments.filter(c => !c.includes('#, fuzzy')) 
                        : entry.comments;
                    if(commentsToKeep.length > 0) {
                        poContent += commentsToKeep.join('\n') + '\n';
                    }
                }
                if (entry.msgctxt !== undefined) {
                    poContent += `msgctxt ${escapePoString(entry.msgctxt)}\n`;
                }
                if (entry.msgid !== undefined) {
                    poContent += `msgid ${escapePoString(entry.msgid)}\n`;
                }

                let fullMsgstr = '';
                if (entry.sentenceSegments && entry.sentenceSegments.length > 0) {
                    // For header, directly use the stored msgstr
                    if (entry.isHeader) {
                        fullMsgstr = entry.msgstr || '';
                    } else {
                        // For regular entries, join segmented translations
                        fullMsgstr = entry.sentenceSegments.map(s => s.translation).join(' ').trim();
                    }
                } else {
                    fullMsgstr = entry.msgstr || ''; // Fallback if no segments
                }

                if (fullMsgstr !== undefined) {
                    poContent += `msgstr ${escapePoString(fullMsgstr)}\n`;
                }
                poContent += '\n';
            });
            return poContent;
        }

        /**
         * Adjusts the height of a textarea to fit its content.
         * If the translation textarea is empty, it matches the height of the original textarea.
         * @param {HTMLTextAreaElement} textarea The textarea element (msgstr).
         * @param {HTMLElement} [originalElement] The original element (msgid pre) for height comparison.
         */
        function autoResizeTextarea(textarea, originalElement) {
            textarea.style.height = 'auto';
            if (textarea.value.trim() === '' && originalElement) {
                // If textarea is empty, set its height to match the original element's scroll height
                textarea.style.height = originalElement.scrollHeight + 'px';
            } else {
                // Otherwise, let it expand to its own content
                textarea.style.height = textarea.scrollHeight + 'px';
            }
        }

        /**
         * Updates the character count for a specific textarea.
         * @param {HTMLTextAreaElement} textarea The textarea element.
         * @param {number} originalLength The length of the original string segment.
         */
        function updateCharCount(textarea, originalLength) {
            const entryIndex = parseInt(textarea.dataset.entryIndex);
            const segmentIndex = parseInt(textarea.dataset.segmentIndex);
            const charCountSpan = document.getElementById(`charCount-${entryIndex}-${segmentIndex}`);
            if (charCountSpan) {
                charCountSpan.textContent = `${translations[currentLanguage]['char_count_original']}${originalLength} ${translations[currentLanguage]['char_units']} | ${translations[currentLanguage]['char_count_translation']}${textarea.value.length} ${translations[currentLanguage]['char_units']}`;
            }
        }

        /**
         * Configures the editable state of a translation entry (editable/read-only).
         * @param {number} entryIndex The index of the main PO entry.
         * @param {number} segmentIndex The index of the sentence segment.
         * @param {boolean} isEditable True to make it editable, false for read-only.
         */
        function setTranslationEditableState(entryIndex, segmentIndex, isEditable) {
            const msgstrTextarea = document.getElementById(`msgstr-${entryIndex}-${segmentIndex}`);
            const validateButton = document.getElementById(`validateBtn-${entryIndex}-${segmentIndex}`);
            const editButton = document.getElementById(`editBtn-${entryIndex}-${segmentIndex}`);
            const checkIcon = document.getElementById(`checkIcon-${entryIndex}-${segmentIndex}`);
            const translationUnit = document.getElementById(`translation-unit-${entryIndex}`); // Get the parent unit


            if (!msgstrTextarea || !validateButton || !editButton || !checkIcon || !translationUnit) {
                console.error(`Elements not found for index ${entryIndex}-${segmentIndex}`);
                return;
            }

            msgstrTextarea.readOnly = !isEditable;
            if (!isEditable) {
                msgstrTextarea.classList.add('bg-gray-200');
                translationUnit.classList.remove('translation-unit-active'); // Remove active highlight on validate

                // Update translation status and words when segment is validated
                const segment = poEntries[entryIndex].sentenceSegments[segmentIndex];
                segment.isTranslated = msgstrTextarea.value.trim() !== '';
                segment.wordCountTranslation = countWords(msgstrTextarea.value);
                updateStatsDisplay(); // Update stats
                addOrUpdateTMEntry(segment.original, segment.translation); // Add/Update TM
            } else {
                msgstrTextarea.classList.remove('bg-gray-200');
                translationUnit.classList.add('translation-unit-active'); // Add active highlight on edit/focus
            }

            validateButton.style.display = isEditable ? 'inline-block' : 'none';
            editButton.style.display = isEditable ? 'none' : 'inline-block';
            checkIcon.style.display = isEditable ? 'none' : 'inline-block';

            if (isEditable) {
                msgstrTextarea.focus();
                // Ensure cursor is at the end of the text
                msgstrTextarea.setSelectionRange(msgstrTextarea.value.length, msgstrTextarea.value.length);
            }
        }

        /**
         * Applies glossary term highlighting to a given text segment.
         * Collects terms that were successfully highlighted.
         * @param {string} text The original text to highlight.
         * @returns {{html: string, foundTerms: Set<string>}} Object with HTML string and set of found terms.
         */
        function applyGlossaryHighlightToText(text) {
            let highlightedHtml = text;
            const currentFoundTerms = new Set(); // Terms found in *this specific* segment

            // Ensure glossarySourceLanguage is set and matches the original's implicit language
            if (!glossarySourceLanguage) {
                return { html: text, foundTerms: currentFoundTerms }; // Cannot highlight without source language
            }

            // Sort glossary terms by length in descending order to match longer terms first
            const sortedGlossary = [...glossary].sort((a, b) => b.srcTerm.length - a.srcTerm.length);


            sortedGlossary.forEach(glossaryEntry => {
                // Only highlight if the glossary entry's source language matches the current editor's source language
                // Assuming poEntries are implicitly in poanda's current source language.
                // For a more robust solution, each poEntry might need a source language field.
                // For now, we assume the glossary source language is the relevant source for highlighting.
                // Also, ensure the glossary entry has a source term.
                if (glossarySourceLanguage && glossaryEntry.srcTerm) {
                    const term = glossaryEntry.srcTerm;
                    // Use word boundaries \b to avoid partial word matches
                    // Escape special regex characters in the term
                    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    // 'g' for global, 'i' for case-insensitive
                    const regex = new RegExp(`\\b(${escapedTerm})\\b`, 'gi'); // Added word boundaries


                    // Only replace if the term is found (to avoid unnecessary string manipulations)
                    if (highlightedHtml.match(regex)) {
                        highlightedHtml = highlightedHtml.replace(regex, (match, p1) => {
                            // p1 is the captured group, which is the actual matched term (case-preserved)
                            currentFoundTerms.add(term); // Add the actual term from the glossary (case-preserved)
                            return `<span class="glossary-highlight">${p1}</span>`; // Highlight the matched part
                        });
                    }
                }
            });
            return { html: highlightedHtml, foundTerms: currentFoundTerms };
        }

        /**
         * Updates highlighting in the glossary table based on terms found in the editor.
         * This function is implicitly called via renderGlossary() after termsFoundInActiveSegment is updated.
         */
        function updateGlossaryTableHighlights() {
            renderGlossary(); // Re-render glossary, which applies highlights based on termsFoundInActiveSegment
        }


        /**
         * Renders translation entries in the user interface, including sentence segmentation.
         * @param {Array<Object>} entries The array of translation objects to render.
         */
        function renderTranslations(entries) {
            translationsContainer.innerHTML = '';
            termsFoundInActiveSegment.clear(); // Clear terms when re-rendering all translations

            if (entries.length === 0) {
                translationsContainer.innerHTML = `
                    <div data-i18n="no_translations" id="initialMessage" class="text-center text-on-light-contrast p-4 border border-gray-300 rounded-md">
                        ${translations[currentLanguage]['no_translations']}
                    </div>
                `;
                savePoButton.disabled = true;
                convertToMoButton.disabled = true; // NEW
                statsContainer.classList.remove('show'); // Hide stats if no translations
                return;
            }

            entries.forEach((entry, entryIndex) => {
                // Skip rendering header entry explicitly in the main editor area, but keep in poEntries
                if (entry.isHeader) {
                    return;
                }

                const translationUnit = document.createElement('div');
                translationUnit.id = `translation-unit-${entryIndex}`; // Added ID for highlighting
                translationUnit.className = 'translation-unit-bg p-4 rounded-lg shadow-sm border border-gray-200 mb-6';

                if (entry.comments && entry.comments.length > 0) {
                    const commentsDiv = document.createElement('div');
                    commentsDiv.className = 'text-xs text-gray-500 mb-2 whitespace-pre-wrap';
                    commentsDiv.textContent = entry.comments.join('\n');
                    translationUnit.appendChild(commentsDiv);
                }
                if (entry.msgctxt) {
                    const msgctxtLabel = document.createElement('label');
                    msgctxtLabel.className = 'block text-sm font-medium text-on-light-contrast mb-1';
                    msgctxtLabel.textContent = translations[currentLanguage]['context_msgctxt'];
                    translationUnit.appendChild(msgctxtLabel);

                    const msgctxtPre = document.createElement('pre');
                    msgctxtPre.className = 'po-display-code p-2 rounded-md text-base overflow-auto max-h-32'; /* Changed text-sm to text-base */
                    msgctxtPre.textContent = entry.msgctxt;
                    translationUnit.appendChild(msgctxtPre);
                }

                entry.sentenceSegments.forEach((segment, segmentIndex) => {

                    const segmentRow = document.createElement('div');
                    segmentRow.className = 'translation-row mb-4';

                    const originalCol = document.createElement('div');
                    originalCol.className = 'original-col';

                    const msgidLabel = document.createElement('label');
                    msgidLabel.className = 'block text-sm font-medium text-on-light-contrast mb-1';
                    msgidLabel.textContent = translations[currentLanguage]['original_msgid'];
                    originalCol.appendChild(msgidLabel);

                    const msgidPre = document.createElement('pre');
                    msgidPre.id = `msgid-pre-${entryIndex}-${segmentIndex}`; // Added ID for easier lookup
                    msgidPre.className = 'po-display-code p-2 rounded-md text-base overflow-auto max-h-32'; /* Changed text-sm to text-base */
                    msgidPre.textContent = segment.original; // Initial text without highlight
                    originalCol.appendChild(msgidPre);
                    segmentRow.appendChild(originalCol);

                    const translationCol = document.createElement('div');
                    translationCol.className = 'translation-col';

                    const msgstrLabel = document.createElement('label');
                    msgstrLabel.className = 'block text-sm font-medium text-on-light-contrast mb-1';
                    msgstrLabel.textContent = translations[currentLanguage]['translation_msgstr'];
                    translationCol.appendChild(msgstrLabel);

                    const msgstrTextarea = document.createElement('textarea');
                    msgstrTextarea.id = `msgstr-${entryIndex}-${segmentIndex}`;
                    msgstrTextarea.className = 'msgstr-textarea mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500 text-base'; /* Changed text-sm to text-base */
                    msgstrTextarea.value = segment.translation;
                    msgstrTextarea.dataset.entryIndex = entryIndex;
                    msgstrTextarea.dataset.segmentIndex = segmentIndex;
                    msgstrTextarea.dataset.originalLength = segment.original.length;

                    translationCol.appendChild(msgstrTextarea);
                    segmentRow.appendChild(translationCol);
                    translationUnit.appendChild(segmentRow);

                    const controlsContainer = document.createElement('div');
                    controlsContainer.className = 'flex items-center justify-between mt-2 w-full';

                    const charCountSpan = document.createElement('span');
                    charCountSpan.id = `charCount-${entryIndex}-${segmentIndex}`;
                    charCountSpan.className = 'inline-block text-sm font-semibold text-on-light-contrast'; /* Added inline-block for persistent visibility */
                    controlsContainer.appendChild(charCountSpan);

                    const actionButtonsContainer = document.createElement('div');
                    actionButtonsContainer.className = 'flex items-center space-x-2';

                    const checkIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    checkIcon.setAttribute("id", `checkIcon-${entryIndex}-${segmentIndex}`);
                    checkIcon.setAttribute("class", "check-icon text-green-500");
                    checkIcon.setAttribute("fill", "none");
                    checkIcon.setAttribute("viewBox", "0 0 24 24");
                    checkIcon.setAttribute("stroke", "currentColor");
                    checkIcon.innerHTML = `
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                    `;
                    actionButtonsContainer.appendChild(checkIcon);

                    const validateButton = document.createElement('button');
                    validateButton.id = `validateBtn-${entryIndex}-${segmentIndex}`;
                    validateButton.className = 'validate-button font-medium py-1 px-3 rounded-md shadow-sm transition duration-300 btn-validate';
                    validateButton.textContent = translations[currentLanguage]['validate'];
                    validateButton.dataset.entryIndex = entryIndex;
                    validateButton.dataset.segmentIndex = segmentIndex;
                    actionButtonsContainer.appendChild(validateButton);

                    const editButton = document.createElement('button');
                    editButton.id = `editBtn-${entryIndex}-${segmentIndex}`;
                    editButton.className = 'edit-button font-medium py-1 px-3 rounded-md shadow-sm transition duration-300 btn-edit';
                    editButton.textContent = translations[currentLanguage]['edit'];
                    editButton.dataset.entryIndex = entryIndex;
                    editButton.dataset.segmentIndex = segmentIndex;
                    editButton.style.display = 'none';
                    actionButtonsContainer.appendChild(editButton);

                    controlsContainer.appendChild(actionButtonsContainer);
                    translationUnit.appendChild(controlsContainer);

                    msgstrTextarea.addEventListener('input', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        const segment = poEntries[currentEntryIndex].sentenceSegments[currentSegmentIndex];

                        segment.translation = event.target.value;
                        segment.wordCountTranslation = countWords(event.target.value);
                        segment.isTranslated = event.target.value.trim() !== ''; // Update translation status

                        const originalSegmentPre = originalCol.querySelector('pre');
                        autoResizeTextarea(event.target, originalSegmentPre);
                        updateCharCount(event.target, parseInt(event.target.dataset.originalLength));
                        updateStatsDisplay(); // Update stats on every input

                        // Re-evaluate glossary highlights on input as content changes
                        if (document.activeElement === msgstrTextarea) {
                            // Force re-highlight by simulating blur then focus
                            const tempOriginalText = segment.original; // Save original text
                            originalCol.querySelector('pre').textContent = tempOriginalText; // Clear highlight
                            termsFoundInActiveSegment.clear(); // Clear terms
                            const highlightResult = applyGlossaryHighlightToText(tempOriginalText); // Re-apply highlight
                            originalCol.querySelector('pre').innerHTML = highlightResult.html;
                            highlightResult.foundTerms.forEach(term => termsFoundInActiveSegment.add(term));
                            updateGlossaryTableHighlights(); // Update glossary table
                        }
                    });

                    // Add focus and blur event listeners for dynamic highlighting and active unit
                    msgstrTextarea.addEventListener('focus', (event) => {
                        // Remove highlight from any previously active unit
                        document.querySelectorAll('.translation-unit-active').forEach(unit => {
                            unit.classList.remove('translation-unit-active');
                        });
                        // Add highlight to the current unit
                        translationUnit.classList.add('translation-unit-active');

                        termsFoundInActiveSegment.clear(); // Clear previous terms
                        const originalSegmentPre = document.getElementById(`msgid-pre-${entryIndex}-${segmentIndex}`);
                        if (originalSegmentPre && glossarySourceLanguage && glossary.length > 0) {
                            const highlightResult = applyGlossaryHighlightToText(segment.original);
                            originalSegmentPre.innerHTML = highlightResult.html;
                            highlightResult.foundTerms.forEach(term => termsFoundInActiveSegment.add(term));
                        }
                        updateGlossaryTableHighlights(); // Update glossary table based on current terms
                        autoResizeTextarea(event.target, originalCol.querySelector('pre')); // Ensure resize on focus
                        event.target.scrollIntoView({ behavior: 'smooth', block: 'center' }); // Scroll into view

                        // TM: Find best match when segment is focused and update TM search results
                        const currentSegmentOriginal = poEntries[entryIndex].sentenceSegments[segmentIndex].original;
                        tmBestMatchForActiveSegment = findBestTMMatch(currentSegmentOriginal); // Update global
                        tmSearch(); // Re-render TM results, which will now show the active segment match
                    });

                    msgstrTextarea.addEventListener('blur', (event) => {
                        const originalSegmentPre = document.getElementById(`msgid-pre-${entryIndex}-${segmentIndex}`);
                        if (originalSegmentPre) {
                            originalSegmentPre.textContent = segment.original; // Revert to plain text on blur
                        }
                        // Only remove active unit highlight if moving focus outside this unit.
                        termsFoundInActiveSegment.clear(); // Clear terms when segment loses focus
                        updateGlossaryTableHighlights(); // Remove table highlights
                        // TM: Clear active segment match and refresh TM search results
                        tmBestMatchForActiveSegment = null;
                        tmSearch(); // Refresh TM search results to remove the active segment match
                    });


                    msgstrTextarea.addEventListener('click', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        if (event.target.readOnly) {
                            setTranslationEditableState(currentEntryIndex, currentSegmentIndex, true);
                        }
                    });

                    validateButton.addEventListener('click', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        setTranslationEditableState(currentEntryIndex, currentSegmentIndex, false);
                        goToNextTranslation(currentEntryIndex, currentSegmentIndex);
                        // Stats and TM update are handled inside setTranslationEditableState now
                    });

                    editButton.addEventListener('click', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        setTranslationEditableState(currentEntryIndex, currentSegmentIndex, true);
                    });

                    // Call autoResizeTextarea on initial render for correct default height
                    autoResizeTextarea(msgstrTextarea, msgidPre);
                    updateCharCount(msgstrTextarea, segment.original.length);
                });

                if (entry.fuzzy) {
                    const fuzzyIndicator = document.createElement('span');
                    fuzzyIndicator.className = 'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800 mt-2';
                    fuzzyIndicator.textContent = translations[currentLanguage]['fuzzy'];
                    translationUnit.appendChild(fuzzyIndicator);
                }

                translationsContainer.appendChild(translationUnit);
            });
            savePoButton.disabled = false;
            convertToMoButton.disabled = false; // NEW
            statsContainer.classList.add('show'); // Show stats container
            updateStatsDisplay(); // Initial stats display after rendering

            // Initial focus on the first editable translation if any (this will trigger its focus listener for highlight)
            const firstEditableSegment = getFirstEditableSegment();
            if (firstEditableSegment) {
                navigateToTranslation(firstEditableSegment.entryIndex, firstEditableSegment.segmentIndex);
            }
            // The glossary table highlights will be updated by the initial navigateToTranslation call's focus event.
        }

        /**
         * Updates the display of translation progress and word counts.
         */
        function updateStatsDisplay() {
            let totalSegments = 0;
            let translatedSegments = 0;
            let totalWordsOriginal = 0;
            let totalWordsTranslated = 0;

            poEntries.forEach(entry => {
                // Skip header entry
                if (entry.isHeader) {
                    return;
                }
                if (entry.sentenceSegments) {
                    entry.sentenceSegments.forEach(segment => {
                        totalSegments++;
                        totalWordsOriginal += segment.wordCountOriginal;
                        if (segment.isTranslated) {
                            translatedSegments++;
                            totalWordsTranslated += segment.wordCountTranslation;
                        }
                    });
                }
            });

            const percentage = totalSegments > 0 ? ((translatedSegments / totalSegments) * 100).toFixed(0) : 0;
            segmentsProgress.textContent = `${translatedSegments}/${totalSegments} segments (${percentage}%)`;
            wordsTranslated.textContent = `${totalWordsTranslated}`;
            wordsTotal.textContent = `${totalWordsOriginal}`;
            wordsRemaining.textContent = `${totalWordsOriginal - totalWordsTranslated}`;
        }


        /**
         * Gets the index of the currently focused translation textarea, including the segment index.
         * @returns {{entryIndex: number, segmentIndex: number} | null} The object with indices, or null.
         */
        function getCurrentFocusedIndex() {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.classList.contains('msgstr-textarea')) {
                return {
                    entryIndex: parseInt(activeElement.dataset.entryIndex),
                    segmentIndex: parseInt(activeElement.dataset.segmentIndex)
                };
            }
            return null;
        }

        /**
         * Finds the first editable segment (not a header).
         * @returns {{entryIndex: number, segmentIndex: number} | null} The object with indices, or null.
         */
        function getFirstEditableSegment() {
            for (let i = 0; i < poEntries.length; i++) {
                const entry = poEntries[i];
                if (!entry.isHeader && entry.sentenceSegments && entry.sentenceSegments.length > 0) {
                    return { entryIndex: i, segmentIndex: 0 };
                }
            }
            return null;
        }


        /**
         * Navigates to and focuses a specific translation field (segment).
         * @param {number} entryIndex The index of the PO entry.
         * @param {number} segmentIndex The index of the sentence segment.
         */
        function navigateToTranslation(entryIndex, segmentIndex) {
            const targetTextarea = document.getElementById(`msgstr-${entryIndex}-${segmentIndex}`);
            if (targetTextarea) {
                // Blur the previously focused textarea to trigger its blur event if it's different
                const currentlyFocusedTextarea = document.activeElement;
                if (currentlyFocusedTextarea && currentlyFocusedTextarea.classList.contains('msgstr-textarea') && currentlyFocusedTextarea !== targetTextarea) {
                    currentlyFocusedTextarea.blur(); // This will trigger the blur event listener
                }
                setTranslationEditableState(entryIndex, segmentIndex, true); // Make it editable and focus
                targetTextarea.scrollIntoView({ behavior: 'smooth', block: 'center' }); // Scroll into view
            }
        }

        /**
         * Moves focus to the next translation field (segment).
         * @param {number} currentEntryIndex The current index of the PO entry.
         * @param {number} currentSegmentIndex The current index of the sentence segment.
         */
        function goToNextTranslation(currentEntryIndex, currentSegmentIndex) {
            if (poEntries.length === 0) return;

            let nextEntryIndex = currentEntryIndex;
            let nextSegmentIndex = currentSegmentIndex + 1;

            // Loop to find the next *editable* segment
            while (true) {
                if (nextEntryIndex >= poEntries.length) {
                    showMessage(translations[currentLanguage]['reached_last']);
                    return;
                }

                const currentEntry = poEntries[nextEntryIndex];
                if (currentEntry.isHeader || !currentEntry.sentenceSegments || currentEntry.sentenceSegments.length === 0) {
                    // Skip header or entries with no segments
                    nextEntryIndex++;
                    nextSegmentIndex = 0;
                    continue;
                }

                if (nextSegmentIndex < currentEntry.sentenceSegments.length) {
                    navigateToTranslation(nextEntryIndex, nextSegmentIndex);
                    return;
                } else {
                    // Move to the next entry
                    nextEntryIndex++;
                    nextSegmentIndex = 0;
                }
            }
        }

        /**
         * Moves focus to the previous translation field (segment).
         * @param {number} currentEntryIndex The current index of the PO entry.
         * @param {number} currentSegmentIndex The current index of the sentence segment.
         */
        function goToPreviousTranslation(currentEntryIndex, currentSegmentIndex) {
            if (poEntries.length === 0) return;

            let prevEntryIndex = currentEntryIndex;
            let prevSegmentIndex = currentSegmentIndex - 1;

            // Loop to find the previous *editable* segment
            while (true) {
                if (prevEntryIndex < 0) {
                    showMessage(translations[currentLanguage]['reached_first']);
                    return;
                }

                const currentEntry = poEntries[prevEntryIndex];
                if (currentEntry.isHeader || !currentEntry.sentenceSegments || currentEntry.sentenceSegments.length === 0) {
                    // Skip header or entries with no segments
                    prevEntryIndex--;
                    prevSegmentIndex = (prevEntryIndex >= 0 && poEntries[prevEntryIndex].sentenceSegments) ? poEntries[prevEntryIndex].sentenceSegments.length - 1 : 0;
                    continue;
                }

                if (prevSegmentIndex >= 0) {
                    navigateToTranslation(prevEntryIndex, prevSegmentIndex);
                    return;
                } else {
                    // Move to the previous entry's last segment
                    prevEntryIndex--;
                    prevSegmentIndex = (prevEntryIndex >= 0 && poEntries[prevEntryIndex].sentenceSegments) ? poEntries[prevEntryIndex].sentenceSegments.length - 1 : 0;
                }
            }
        }

        // --- Event Handlers ---

        poFile.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                currentFileName = file.name;
                const content = await file.text();
                processPoContent(content);
            }
        });

        // REFACTORED: Process PO file from content string
        function processPoContent(content) {
             showLoadingOverlay(translations[currentLanguage]['loading_file']);
             try {
                poEntries = parsePoContent(content); // Now only calls parsePoContent
                renderTranslations(poEntries);
                updateStatsDisplay(); // Ensure stats are updated after parsing and rendering
             } catch (error) {
                showMessage(`${translations[currentLanguage]['error_reading_file']} ${error.message}`);
                console.error("Error parsing file:", error);
                translationsContainer.innerHTML = `
                    <div class="text-center text-red-500 p-4 border border-red-300 rounded-md">
                        ${translations[currentLanguage]['file_processing_error']}
                    </div>
                `;
                savePoButton.disabled = true;
                convertToMoButton.disabled = true; // NEW
                statsContainer.classList.remove('show'); // Hide stats on error
             } finally {
                hideLoadingOverlay();
             }
        }

        savePoButton.addEventListener('click', async () => {
            if (poEntries.length === 0) {
                showMessage(translations[currentLanguage]['no_translations_to_save']);
                return;
            }
            showLoadingOverlay(translations[currentLanguage]['saving_file']);
            try {
                const updatedPoContent = reconstructPo(poEntries);
                const blob = new Blob([updatedPoContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = currentFileName.replace(/\.po$/i, '') + '.po';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showMessage(translations[currentLanguage]['file_saved_successfully']);
            } catch (error) {
                showMessage(`${translations[currentLanguage]['error_saving_file']} ${error.message}`);
                console.error("Error saving file:", error);
            } finally {
                hideLoadingOverlay();
            }
        });

        async function processFile(file) {
            currentFileName = file.name;
            const content = await file.text();
            processPoContent(content);
        }

        document.addEventListener('keydown', (event) => {
            // Check if any modal is open. If so, prevent default shortcuts to avoid interference.
            if (!shortcutsModal.classList.contains('hidden') || !findReplaceModal.classList.contains('hidden') || !messageBox.classList.contains('hidden') || !saveProjectModal.classList.contains('hidden')) {
                return;
            }

            const isNumberKey = event.key >= '1' && event.key <= '5';
            const indexToInsert = parseInt(event.key) - 1; // 0-indexed

            if (event.altKey && !event.ctrlKey) { // Only Alt + [1-5]
                if (isNumberKey) {
                    event.preventDefault(); // Prevent browser default action (e.g., opening dev tools)
                    const currentFocused = getCurrentFocusedIndex();
                    if (!currentFocused) return; // Only if a textarea is focused

                    const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                    if (!targetTextarea || targetTextarea.readOnly) return; // Only if editable textarea

                    // ALT + [1-5]: Insert TM suggestion
                    if (currentTMLatestSearchResults.length > indexToInsert) {
                        const tmToInsert = currentTMLatestSearchResults[indexToInsert];
                        const textToInsert = tmToInsert.tgtText;

                        const start = targetTextarea.selectionStart;
                        const end = targetTextarea.selectionEnd;
                        const currentValue = targetTextarea.value;

                        targetTextarea.value = currentValue.substring(0, start) +
                                               textToInsert +
                                               currentValue.substring(end);

                        // Move cursor to the end of inserted text
                        targetTextarea.selectionStart = targetTextarea.selectionEnd = start + textToInsert.length;

                        // Trigger input event manually to update stats and char counts
                        const inputEvent = new Event('input', { bubbles: true });
                        targetTextarea.dispatchEvent(inputEvent);
                    } else {
                        showMessage(translations[currentLanguage]['tm_no_match_found']);
                    }
                }
            } else if (event.ctrlKey && event.altKey) { // Only Ctrl + Alt + [1-5]
                 if (isNumberKey) {
                    event.preventDefault(); // Prevent browser default action
                    const currentFocused = getCurrentFocusedIndex();
                    if (!currentFocused) return; // Only if a textarea is focused

                    const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                    if (!targetTextarea || targetTextarea.readOnly) return; // Only if editable textarea

                    // CTRL + ALT + [1-5]: Insert Glossary term
                    if (currentGlossaryLatestResults.length > indexToInsert) {
                        const glossaryTermToInsert = currentGlossaryLatestResults[indexToInsert];
                        const termTextToInsert = glossaryTermToInsert.tgtTerm;

                        const start = targetTextarea.selectionStart;
                        const end = targetTextarea.selectionEnd;
                        const currentValue = targetTextarea.value;

                        targetTextarea.value = currentValue.substring(0, start) +
                                               termTextToInsert +
                                               currentValue.substring(end);

                        // Move cursor to the end of inserted text
                        targetTextarea.selectionStart = targetTextarea.selectionEnd = start + termTextToInsert.length;

                        // Trigger input event manually to update stats and char counts
                        const inputEvent = new Event('input', { bubbles: true });
                        targetTextarea.dispatchEvent(inputEvent);
                    } else {
                        showMessage(translations[currentLanguage]['no_match_found']); // Reusing generic "no match found" for glossary
                    }
                }
            } else if (event.ctrlKey) { // Standard Ctrl shortcuts (not Alt)
                const currentFocused = getCurrentFocusedIndex();
                if (!currentFocused) return;

                switch (event.key) {
                    case 'Enter':
                        event.preventDefault();
                        setTranslationEditableState(currentFocused.entryIndex, currentFocused.segmentIndex, false);
                        goToNextTranslation(currentFocused.entryIndex, currentFocused.segmentIndex);
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        goToNextTranslation(currentFocused.entryIndex, currentFocused.segmentIndex);
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        goToPreviousTranslation(currentFocused.entryIndex, currentFocused.segmentIndex);
                        break;
                }
            }
        });

        // --- Message Box Functions ---
        function showMessage(msg) {
            messageText.textContent = msg;
            messageBox.classList.remove('hidden');
        }

        messageClose.addEventListener('click', () => {
            messageBox.classList.add('hidden');
        });

        // --- Keyboard Shortcuts Modal ---
        shortcutsBtn.addEventListener('click', () => {
            shortcutsModal.classList.remove('hidden');
        });

        shortcutsCloseBtn.addEventListener('click', () => {
            shortcutsModal.classList.add('hidden');
        });

        // --- Find and Replace Modal ---
        findReplaceBtn.addEventListener('click', () => {
            findReplaceModal.classList.remove('hidden');
            findInput.focus();
        });

        findReplaceCloseBtn.addEventListener('click', () => {
            findReplaceModal.classList.add('hidden');
            findState.lastFound = null; // Clear last found state on close
            // Clear any active selections
            const currentFocused = getCurrentFocusedIndex();
            if (currentFocused) {
                const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                if (targetTextarea) {
                    targetTextarea.setSelectionRange(targetTextarea.value.length, targetTextarea.value.length);
                }
            }
        });

        // Find Next / Find Previous Logic
        findNextBtn.addEventListener('click', () => findAndNavigate(true));
        findPrevBtn.addEventListener('click', () => findAndNavigate(false));
        replaceBtn.addEventListener('click', replaceCurrentMatch);
        replaceAllBtn.addEventListener('click', replaceAllMatches);

        function findAndNavigate(forward = true) {
            const query = findInput.value;
            if (!query) {
                showMessage(translations[currentLanguage]['no_find_query']);
                return;
            }

            findState.query = query;
            findState.caseSensitive = caseSensitiveCheckbox.checked;
            findState.useRegex = regexCheckbox.checked;

            let regex;
            try {
                regex = findState.useRegex ? new RegExp(findState.query, findState.caseSensitive ? '' : 'i') : null;
            } catch (e) {
                showMessage(`Regular expression error: ${e.message}`);
                return;
            }

            let startEntryIndex = 0;
            let startSegmentIndex = 0;
            let startMatchIndex = 0; // Where to start searching within a segment

            // If a previous match exists, start from there
            if (findState.lastFound) {
                startEntryIndex = findState.lastFound.entryIndex;
                startSegmentIndex = findState.lastFound.segmentIndex;
                startMatchIndex = forward ? findState.lastFound.matchEnd : findState.lastFound.matchStart - 1; // Start after for next, before for prev
            } else {
                // If no previous match, start from beginning (forward) or end (backward)
                if (!forward) {
                    startEntryIndex = poEntries.length - 1;
                    if (poEntries[startEntryIndex] && poEntries[startEntryIndex].sentenceSegments) {
                        startSegmentIndex = poEntries[startEntryIndex].sentenceSegments.length - 1;
                    } else {
                        startSegmentIndex = 0;
                    }
                    startMatchIndex = Infinity; // For backward search, search from end of string
                }
            }

            let found = false;
            let currentEntryIndex = startEntryIndex;
            let currentSegmentIndex = startSegmentIndex;
            const totalEntries = poEntries.length;

            for (let i = 0; i < totalEntries; i++) { // Outer loop for entries
                const entry = poEntries[currentEntryIndex];
                if (!entry || entry.isHeader || !entry.sentenceSegments) { // Skip headers
                    currentEntryIndex = (currentEntryIndex + (forward ? 1 : -1) + totalEntries) % totalEntries;
                    currentSegmentIndex = forward ? 0 : (entry && entry.sentenceSegments ? entry.sentenceSegments.length - 1 : 0);
                    continue;
                }

                const totalSegments = entry.sentenceSegments.length;
                let segmentLoopStart = forward ? 0 : totalSegments - 1;
                let segmentLoopEnd = forward ? totalSegments : -1;
                let segmentLoopStep = forward ? 1 : -1;

                if (currentEntryIndex === startEntryIndex) { // Adjust segment loop start if in the initial entry
                    segmentLoopStart = startSegmentIndex;
                }


                for (let j = segmentLoopStart; forward ? (j < segmentLoopEnd) : (j >= segmentLoopEnd); j += segmentLoopStep) { // Inner loop for segments
                    const segment = entry.sentenceSegments[j];
                    const text = segment.translation;
                    let match;

                    if (findState.useRegex) {
                        regex.lastIndex = 0; // Always reset for new segment/start position
                        if (forward) {
                            // If current segment is the start segment, begin search from startMatchIndex
                            let searchFrom = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : 0;
                            // Search only within the relevant part of the string
                            const subText = text.substring(searchFrom);
                            match = regex.exec(subText);
                            if (match) {
                                match.index += searchFrom; // Adjust index relative to full string
                            }
                        } else {
                            // Backward regex search is complex. Find all matches and then pick the relevant one.
                            let allMatches = [];
                            let tempRegex = new RegExp(regex.source, regex.flags.includes('g') ? regex.flags : regex.flags + 'g');
                            let tempMatch;
                            while((tempMatch = tempRegex.exec(text)) !== null) {
                                allMatches.push(tempMatch);
                            }
                            // If current segment is the start segment, search up to startMatchIndex
                            let searchUntil = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : text.length;
                            match = allMatches.reverse().find(m => m.index < searchUntil);
                        }
                    } else {
                        const searchText = findState.caseSensitive ? text : text.toLowerCase();
                        const queryLower = findState.caseSensitive ? findState.query : findState.query.toLowerCase();

                        if (forward) {
                            let searchFrom = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : 0;
                            const foundIndex = searchText.indexOf(queryLower, searchFrom);
                            if (foundIndex !== -1) {
                                match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                            }
                        } else {
                            let searchUntil = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : text.length;
                            const foundIndex = searchText.lastIndexOf(queryLower, searchUntil);
                            if (foundIndex !== -1) {
                                match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                            }
                        }
                    }

                    if (match) {
                        findState.lastFound = {
                            entryIndex: currentEntryIndex,
                            segmentIndex: j,
                            matchStart: match.index,
                            matchEnd: match.index + match[0].length,
                        };
                        navigateToTranslation(currentEntryIndex, j);
                        const targetTextarea = document.getElementById(`msgstr-${currentEntryIndex}-${j}`);
                        if (targetTextarea) {
                            targetTextarea.setSelectionRange(findState.lastFound.matchStart, findState.lastFound.matchEnd);
                        }
                        found = true;
                        return; // Exit all loops
                    }
                }
                if (found) break; // Exit outer loop if found

                // Move to next/previous entry
                currentEntryIndex = (currentEntryIndex + (forward ? 1 : -1) + totalEntries) % totalEntries;
                currentSegmentIndex = forward ? 0 : (poEntries[currentEntryIndex].sentenceSegments ? poEntries[currentEntryIndex].sentenceSegments.length - 1 : 0);
                // The `entry` in `entry && entry.sentenceSegments` above will be `poEntries[currentEntryIndex]`
                // after the assignment.
            }

            if (!found) {
                showMessage(translations[currentLanguage]['no_match_found']);
                findState.lastFound = null;
            }
        }


        function replaceCurrentMatch() {
            if (!findState.lastFound || !findState.query) {
                showMessage(translations[currentLanguage]['no_match_found']);
                return;
            }

            const { entryIndex, segmentIndex, matchStart, matchEnd } = findState.lastFound;
            const segment = poEntries[entryIndex].sentenceSegments[segmentIndex];
            let originalText = segment.translation;
            let replacedText;

            if (findState.useRegex) {
                 // Create a non-global regex for single replacement
                 const regex = new RegExp(findState.query, findState.caseSensitive ? '' : 'i');
                 replacedText = originalText.substring(0, matchStart) +
                                originalText.substring(matchStart, matchEnd).replace(regex, findState.replace) +
                                originalText.substring(Math.min(matchEnd, originalText.length)); // Ensure substring is within bounds

            } else {
                replacedText = originalText.substring(0, matchStart) +
                               findState.replace +
                               originalText.substring(Math.min(matchEnd, originalText.length)); // Ensure substring is within bounds
            }

            segment.translation = replacedText;
            segment.wordCountTranslation = countWords(replacedText); // Update word count
            segment.isTranslated = replacedText.trim() !== ''; // Update translation status

            renderTranslations(poEntries); // Re-render to update UI
            navigateToTranslation(entryIndex, segmentIndex); // Re-focus and scroll
            updateStatsDisplay(); // Update stats

            // After replacement, clear lastFound to ensure next 'Find' starts fresh,
            // or perform another 'Find Next' to select the next occurrence immediately.
            // For now, clearing seems more straightforward for single replacement.
            findState.lastFound = null;
        }

        function replaceAllMatches() {
            const query = findInput.value;
            const replaceWith = replaceInput.value;
            if (!query) {
                showMessage(translations[currentLanguage]['no_find_query']);
                return;
            }

            let replacedCount = 0;
            let regex;
            try {
                // Ensure global flag 'g' for replaceAll
                regex = new RegExp(query, (caseSensitiveCheckbox.checked ? '' : 'i') + 'g' + (regexCheckbox.checked ? '' : ''));
            } catch (e) {
                showMessage(`Regular expression error: ${e.message}`);
                return;
            }

            poEntries.forEach(entry => {
                // Skip header entry
                if (entry.isHeader) {
                    return;
                }

                entry.sentenceSegments.forEach(segment => {
                    let originalTranslation = segment.translation;
                    let newTranslation;

                    if (regexCheckbox.checked) {
                        newTranslation = originalTranslation.replace(regex, replaceWith);
                    } else {
                        // For non-regex, a simple replaceAll (using regex internally with 'g' flag for simplicity)
                        const searchStr = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // Escape query for regex
                        const nonRegexRegex = new RegExp(searchStr, (caseSensitiveCheckbox.checked ? '' : 'i') + 'g');
                        newTranslation = originalTranslation.replace(nonRegexRegex, replaceWith);
                    }

                    if (originalTranslation !== newTranslation) {
                        segment.translation = newTranslation;
                        segment.wordCountTranslation = countWords(newTranslation); // Update word count
                        segment.isTranslated = newTranslation.trim() !== ''; // Update translation status
                        replacedCount++;
                    }
                });
            });

            renderTranslations(poEntries); // Re-render the whole thing to reflect all changes
            showMessage(`${replacedCount} ${translations[currentLanguage]['replaced_all']}`);
            findState.lastFound = null; // Clear last found state after replace all
            updateStatsDisplay(); // Update stats after replace all
        }


        // --- Language Change ---
        function setLanguage(lang) {
            currentLanguage = lang;
            document.documentElement.lang = lang;
            updateTextContent();
            renderTranslations(poEntries);
            renderGlossary();

            const langEnBtn = document.getElementById('langEnBtn');
            const langEsBtn = document.getElementById('langEsBtn');
            
            langEnBtn.classList.remove('bg-blue-500', 'text-white');
            langEsBtn.classList.remove('bg-blue-500', 'text-white');
            langEnBtn.classList.add('bg-gray-200', 'text-gray-800');
            langEsBtn.classList.add('bg-gray-200', 'text-gray-800');

            if (lang === 'en') {
                langEnBtn.classList.add('bg-blue-500', 'text-white');
                langEnBtn.classList.remove('bg-gray-200', 'text-gray-800');
            } else {
                langEsBtn.classList.add('bg-blue-500', 'text-white');
                langEsBtn.classList.remove('bg-gray-200', 'text-gray-800');
            }
        }

        function updateTextContent() {
            const lang = translations[currentLanguage];

            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (lang[key]) {
                    if (element.tagName === 'INPUT' && element.hasAttribute('data-i18n-placeholder')) {
                        element.placeholder = lang[key];
                    } else {
                        element.textContent = lang[key];
                    }
                }
            });

            // Special cases for elements with dynamic content or innerHTML
            const shortcutValidateElement = document.getElementById('shortcutValidate');
            if (shortcutValidateElement) shortcutValidateElement.innerHTML = `<strong>Ctrl + Enter:</strong> ${lang['shortcut_validate'].substring(lang['shortcut_validate'].indexOf(':') + 1).trim()}`;

            const shortcutNextElement = document.getElementById('shortcutNext');
            if (shortcutNextElement) shortcutNextElement.innerHTML = `<strong>Ctrl + ${arrowDownIcon}</strong>: ${lang['shortcut_next'].substring(lang['shortcut_next'].indexOf(':') + 1).trim()}`;
            
            const shortcutPrevElement = document.getElementById('shortcutPrev');
            if (shortcutPrevElement) shortcutPrevElement.innerHTML = `<strong>Ctrl + ${arrowUpIcon}</strong>: ${lang['shortcut_prev'].substring(lang['shortcut_prev'].indexOf(':') + 1).trim()}`;

            const shortcutAlt1Element = document.getElementById('shortcutAlt1');
            if (shortcutAlt1Element) shortcutAlt1Element.innerHTML = `<strong>Alt + [1-5]:</strong> ${lang['shortcut_alt_1'].substring(lang['shortcut_alt_1'].indexOf(':') + 1).trim()}`;

            const shortcutTmInsertElement = document.getElementById('shortcutTmInsert');
            if (shortcutTmInsertElement) shortcutTmInsertElement.innerHTML = `<strong>Ctrl + Alt + [1-5]:</strong> ${lang['shortcut_tm_insert'].substring(lang['shortcut_tm_insert'].indexOf(':') + 1).trim()}`;
            
            // Labels that were missed
            const displaySourceLanguageLabel = document.getElementById('displaySourceLanguageLabel');
            if (displaySourceLanguageLabel) displaySourceLanguageLabel.textContent = lang['source_language'];
            
            const displayTargetLanguageLabel = document.getElementById('displayTargetLanguageLabel');
            if (displayTargetLanguageLabel) displayTargetLanguageLabel.textContent = lang['target_language'];

            const displayTmSourceLanguageLabel = document.getElementById('displayTmSourceLanguageLabel');
            if (displayTmSourceLanguageLabel) displayTmSourceLanguageLabel.textContent = lang['source_language'];

            const displayTmTargetLanguageLabel = document.getElementById('displayTmTargetLanguageLabel');
            if (displayTmTargetLanguageLabel) displayTmTargetLanguageLabel.textContent = lang['target_language'];

            // Button texts inside other elements
            const shortcutsCloseBtnText = document.getElementById('shortcutsCloseBtnText');
            if(shortcutsCloseBtnText) shortcutsCloseBtnText.textContent = lang['close_btn'];
            
            const findReplaceCloseBtnText = document.getElementById('findReplaceCloseBtnText');
            if(findReplaceCloseBtnText) findReplaceCloseBtnText.textContent = lang['close_btn'];
        }

        /**
         * Adjusts the padding of the main editor content based on open sidebars.
         * Applies only on screens wider than 1024px.
         */
        function updateMainContentOffset() {
            const isTerminologyOpen = terminologySidebar.classList.contains('show-sidebar');
            const isTranslationMemoryOpen = translationMemorySidebar.classList.contains('show-sidebar');

            // Remove existing padding classes first
            if (editorMainContent) { // Added null check for editorMainContent
                editorMainContent.classList.remove('left-sidebar-active', 'right-sidebar-active');

                // Apply new padding classes based on open sidebars
                if (isTerminologyOpen) {
                    editorMainContent.classList.add('left-sidebar-active');
                    // Set CSS variable for current width
                    document.documentElement.style.setProperty('--terminology-sidebar-width', terminologySidebar.offsetWidth + 'px');
                }
                if (isTranslationMemoryOpen) {
                    editorMainContent.classList.add('right-sidebar-active');
                    // Set CSS variable for current width
                    document.documentElement.style.setProperty('--translation-memory-sidebar-width', translationMemorySidebar.offsetWidth + 'px');
                }
            } else {
                console.warn("editorMainContent element not found for offset update.");
            }
        }


        // --- Terminology Sidebar Logic ---
        terminologyBtn.addEventListener('click', () => {
            const isHidden = !terminologySidebar.classList.contains('show-sidebar'); // Check current state
            if (isHidden) {
                terminologySidebar.classList.add('show-sidebar');
            } else {
                terminologySidebar.classList.remove('show-sidebar');
            }
            updateMainContentOffset(); // Update offset
            // When sidebar opens, decide which section to show
            if (isHidden) { // If it was hidden and now shown
                if (!glossarySourceLanguage || !glossaryTargetLanguage) {
                    showLanguageConfigSection(); // Show language config if not set
                } else {
                    showGlossaryEditorSection(); // Show editor if languages are already set
                }
            }
        });

        closeTerminologySidebarBtn.addEventListener('click', () => {
            terminologySidebar.classList.remove('show-sidebar'); // Use show-sidebar
            updateMainContentOffset(); // Update offset
        });

        /**
         * Populates the datalist with ISO language codes.
         */
        function populateIsoLanguagesDatalist() {
            isoLanguagesDatalist.innerHTML = '';
            isoLanguagesData.forEach(lang => {
                const option = document.createElement('option');
                option.value = lang.code;
                option.textContent = lang.name;
                isoLanguagesDatalist.appendChild(option);
            });
        }

        /**
         * Resets the glossary and UI to the initial "New Glossary" state.
         */
        function resetGlossary() {
            glossary = [];
            glossarySourceLanguage = '';
            glossaryTargetLanguage = '';
            if (configSrcLang) configSrcLang.value = 'en-US'; // Added null check
            if (configTgtLang) configTgtLang.value = 'es-ES'; // Added null check
            if (srcTermInput) srcTermInput.value = ""; // Added null check
            if (tgtTermInput) tgtTermInput.value = ""; // Added null check
            if (searchTermInput) searchTermInput.value = ""; // Added null check

            if (terminologyLanguageConfigSection && terminologyEditorSection) { // Added null checks
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }

            renderGlossary(); // Clear table
            renderTranslations(poEntries); // Re-render main editor to remove any old highlights
            updateStatsDisplay(); // Update stats display if glossary reset clears highlighting
        }

        /**
         * Shows the language configuration section and hides others.
         */
        function showLanguageConfigSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection) { // Added null checks
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }
        }

        /**
         * Shows the glossary editor section and hides others.
         */
        function showGlossaryEditorSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection && displaySrcLang && displayTgtLang) { // Added null checks
                terminologyLanguageConfigSection.style.display = 'none';
                terminologyEditorSection.style.display = 'block';
                displaySrcLang.value = glossarySourceLanguage; // Set input value
                displayTgtLang.value = glossaryTargetLanguage; // Set input value
                renderGlossary();
            }
        }

        /**
         * Confirms the glossary's source and target languages from user input.
         * Enables the main editor section if languages are valid.
         */
        function confirmGlossaryLanguages() {
            const srcLang = configSrcLang ? configSrcLang.value.trim() : ''; // Added null check
            const tgtLang = configTgtLang ? configTgtLang.value.trim() : ''; // Added null check

            if (!srcLang || !tgtLang) {
                showMessage(translations[currentLanguage]['lang_config_required']);
                return;
            }

            glossarySourceLanguage = srcLang;
            glossaryTargetLanguage = tgtLang;

            showGlossaryEditorSection(); // Show editor after confirming languages
            renderTranslations(poEntries); // Re-render main editor to apply new highlights based on glossary
        }

        /**
         * Adds a new term to the glossary. Uses the globally configured languages.
         */
        function addTerm() {
            const srcTerm = srcTermInput ? srcTermInput.value.trim() : ''; // Added null check
            const tgtTerm = tgtTermInput ? tgtTermInput.value.trim() : ''; // Added null check

            if (!srcTerm || !tgtTerm) {
                showMessage(translations[currentLanguage]['both_terms_required']);
                return;
            }

            glossary.push({
                srcLang: glossarySourceLanguage,
                srcTerm: srcTerm,
                tgtLang: glossaryTargetLanguage,
                tgtTerm: tgtTerm
            });
            if (srcTermInput) srcTermInput.value = ""; // Added null check
            if (tgtTermInput) tgtTermInput.value = ""; // Added null check
            renderGlossary();
            renderTranslations(poEntries); // Re-render main editor to apply new highlights based on new term
        }

        /**
         * Deletes a term from the glossary at the specified index.
         * @param {number} index - The index of the term to delete.
         */
        function deleteTerm(index) {
            glossary.splice(index, 1);
            renderGlossary();
            renderTranslations(poEntries); // Re-render main editor to update highlights
        }

        /**
         * Renders the glossary table, filtering terms based on the search input.
         */
        function renderGlossary() {
            if (!glossaryTableBody) { // Added null check
                console.warn("glossaryTableBody element not found. Cannot render glossary.");
                return;
            }
            const search = searchTermInput ? searchTermInput.value.toLowerCase() : ''; // Added null check
            glossaryTableBody.innerHTML = "";

            // Filter the glossary first based on the search term
            const filteredGlossary = glossary.filter(entry =>
                (entry.srcTerm && entry.srcTerm.toLowerCase().includes(search)) || // Added null check
                (entry.tgtTerm && entry.tgtTerm.toLowerCase().includes(search)) // Added null check
            );

            const highlightedTerms = [];
            const otherTerms = [];

            // Separate terms into highlighted and non-highlighted groups based on termsFoundInActiveSegment
            filteredGlossary.forEach(entry => {
                if (entry.srcTerm && termsFoundInActiveSegment.has(entry.srcTerm)) { // Added null check
                    highlightedTerms.push(entry);
                } else {
                    otherTerms.push(entry);
                }
            });

            // Combine and sort all glossary results for shortcut access
            currentGlossaryLatestResults = [...highlightedTerms, ...otherTerms.sort((a, b) => a.srcTerm.localeCompare(b.srcTerm))];

            // Render highlighted terms first
            highlightedTerms.forEach((entry, i) => {
                const row = document.createElement("tr");
                row.classList.add('glossary-row-highlight'); // Always highlight these
                row.innerHTML = `
                    <td>${entry.srcTerm}</td>
                    <td>${entry.tgtTerm}</td>
                    <td><button class="glossary-delete-btn" onclick="deleteTerm(${glossary.indexOf(entry)})">${translations[currentLanguage]['delete_button']}</button></td>
                `;
                glossaryTableBody.appendChild(row);
            });

            // Then render other terms
            otherTerms.forEach((entry, i) => {
                const row = document.createElement("tr");
                // No highlight class for these
                row.innerHTML = `
                    <td>${entry.srcTerm}</td>
                    <td>${entry.tgtTerm}</td>
                    <td><button class="glossary-delete-btn" onclick="deleteTerm(${glossary.indexOf(entry)})">${translations[currentLanguage]['delete_button']}</button></td>
                `;
                glossaryTableBody.appendChild(row);
            });
        }

        /**
         * Generates a TBX XML string from the current glossary data.
         * @returns {string} The TBX XML content.
         */
        function generateTBX() {
            const xml = [`<?xml version="1.0" encoding="UTF-8"?>`,
                `<martif type="TBX" xml:lang="${glossarySourceLanguage}">`,
                `  <text>`,
                `    <body>`];

            glossary.forEach(entry => {
                xml.push(`      <termEntry>`);
                xml.push(`        <LangSet xml:lang="${entry.srcLang}">`);
                xml.push(`          <tig><term>${entry.srcTerm}</term></tig>`);
                xml.push(`        </LangSet>`);
                xml.push(`        <LangSet xml:lang="${entry.tgtLang}">`);
                xml.push(`          <tig><term>${entry.tgtTerm}</term></tig>`);
                xml.push(`        </LangSet>`);
                xml.push(`      </termEntry>`);
            });

            xml.push(`    </body>`, `  </text>`, `</martif>`);
            return xml.join("\n");
        }

        /**
         * Triggers a download of the generated TBX XML file.
         */
        function downloadTBX() {
            if (glossary.length === 0 && (!glossarySourceLanguage || !glossaryTargetLanguage)) {
                showMessage(translations[currentLanguage]['cannot_download_empty_or_unconfigured_glossary']);
                return;
            }
            showLoadingOverlay(translations[currentLanguage]['saving_file']);
            try {
                const blob = new Blob([generateTBX()], { type: "application/xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "glossary.tbx";
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(url);
                showMessage(translations[currentLanguage]['file_saved_successfully']); // Reuse generic save success message
            } catch (error) {
                showMessage(`${translations[currentLanguage]['error_saving_file']} ${error.message}`);
                console.error("Error downloading TBX:", error);
            } finally {
                hideLoadingOverlay();
            }
        }

        /**
         * Loads TBX data from a user-selected XML/TBX file.
         */
        function loadTBX() {
            if (!tbxFileInput) { // Added null check
                console.warn("tbxFileInput element not found. Cannot load TBX.");
                return;
            }
            tbxFileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const content = await file.text();
                processTBXContent(content);
            };
            tbxFileInput.click(); // Trigger file input click
        }

        // REFACTORED: Process TBX file from content string
        function processTBXContent(content) {
            showLoadingOverlay(translations[currentLanguage]['loading_file']);
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, "application/xml");

                if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                    const errorText = xmlDoc.getElementsByTagName("parsererror")[0].textContent;
                    throw new Error("Invalid XML/TBX format: " + errorText);
                }

                if (xmlDoc.getElementsByTagName("tu").length > 0) {
                    showTMInternalMessage(translations[currentLanguage]['tbx_file_expected_tmx_found'], true);
                    throw new Error("Attempted to load TMX into Glossary.");
                }

                const entries = xmlDoc.getElementsByTagName("termEntry");
                glossary = [];
                let firstEntryLangs = { src: '', tgt: '' };

                if (entries.length > 0) {
                    const firstSets = entries[0].getElementsByTagName("LangSet");
                    if (firstSets.length >= 2) {
                        firstEntryLangs.src = firstSets[0].getAttribute("xml:lang");
                        firstEntryLangs.tgt = firstSets[1].getAttribute("xml:lang");
                    }
                }

                for (let entry of entries) {
                    const sets = entry.getElementsByTagName("LangSet");
                    if (sets.length >= 2) {
                        const lang1 = sets[0].getAttribute("xml:lang");
                        const term1 = sets[0].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                        const lang2 = sets[1].getAttribute("xml:lang");
                        const term2 = sets[1].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                        glossary.push({ srcLang: lang1, srcTerm: term1, tgtLang: lang2, tgtTerm: term2 });
                    }
                }

                if (glossary.length > 0 && firstEntryLangs.src && firstEntryLangs.tgt) {
                    glossarySourceLanguage = firstEntryLangs.src;
                    glossaryTargetLanguage = firstEntryLangs.tgt;
                } else if (glossary.length === 0) {
                    showMessage(translations[currentLanguage]['error_loading_tbx_file']);
                }

                showGlossaryEditorSection();
                renderTranslations(poEntries);

            } catch (error) {
                console.error("Error loading TBX file:", error);
                if (!error.message.includes("Attempted to load TMX")) {
                     showMessage(translations[currentLanguage]['error_loading_tbx_file']);
                }
                resetGlossary();
            } finally {
                hideLoadingOverlay();
            }
        }


        // --- Translation Memory (TM) Logic ---

        // Levenshtein distance function for fuzzy matching
        function levenshteinDistance(a, b) {
            const an = a.length;
            const bn = b.length;
            if (an === 0) return bn;
            if (bn === 0) return an;

            const matrix = [];

            // increment along the first column of each row
            for (let i = 0; i <= bn; i++) {
                matrix[i] = [i];
            }

            // increment each column in the first row
            for (let j = 0; j <= an; j++) {
                matrix[0][j] = j;
            }

            // Fill in the rest of the matrix
            for (let i = 1; i <= bn; i++) {
                for (let j = 1; j <= an; j++) {
                    const cost = (a[j - 1] === b[i - 1]) ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1, // deletion
                        matrix[i][j - 1] + 1, // insertion
                        matrix[i - 1][j - 1] + cost // substitution
                    );
                }
            }
            return matrix[bn][an];
        }

        // Calculate similarity percentage based on Levenshtein distance
        function calculateSimilarity(s1, s2) {
            if (!s1 || !s2) return 0;
            const longerLength = Math.max(s1.length, s2.length);
            if (longerLength === 0) return 100;
            const distance = levenshteinDistance(s1, s2);
            return ((longerLength - distance) / longerLength) * 100;
        }


        tmBtn.addEventListener('click', () => {
            const isHidden = !translationMemorySidebar.classList.contains('show-sidebar'); // Check current state
            if (isHidden) {
                translationMemorySidebar.classList.add('show-sidebar');
            } else {
                translationMemorySidebar.classList.remove('show-sidebar');
            }
            updateMainContentOffset(); // Update offset
            // When sidebar opens, decide which section to show
            if (isHidden) { // If it was hidden and now shown
                if (!tmSourceLanguage || !tmTargetLanguage) {
                    showTMLanguageConfigSection(); // Show language config if not set
                } else {
                    showTMEditorSection(); // Show editor if languages are already set
                    tmSearch(); // Perform initial search when opening
                }
            }
        });

        closeTranslationMemorySidebarBtn.addEventListener('click', () => {
            translationMemorySidebar.classList.remove('show-sidebar'); // Use show-sidebar
            updateMainContentOffset(); // Update offset
        });

        tmFileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                 const content = await file.text();
                 processTMXContent(content);
            }
        });

        /**
         * Displays an internal message within the TM sidebar.
         * @param {string} msg The message to display.
         * @param {boolean} isError If true, styles the message as an error.
         */
        function showTMInternalMessage(msg, isError = false) {
            if (tmInternalMessage) { // Added null check
                tmInternalMessage.textContent = msg;
                tmInternalMessage.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'border-red-500', 'bg-blue-100', 'text-blue-800', 'border-blue-500'); // Clear previous styles
                if (isError) {
                    tmInternalMessage.classList.add('bg-red-100', 'text-red-800', 'border-red-500');
                } else {
                    tmInternalMessage.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-500'); // Default info style
                }
                tmInternalMessage.classList.remove('hidden');
            } else {
                console.warn("tmInternalMessage element not found.");
            }
        }

        /**
         * Hides the internal TM message.
         */
        function hideTMInternalMessage() {
            if (tmInternalMessage) { // Added null check
                tmInternalMessage.classList.add('hidden');
                tmInternalMessage.textContent = '';
            }
        }

        /**
         * Resets the translation memory.
         */
        function resetTM() {
            translationMemory = [];
            tmSourceLanguage = '';
            tmTargetLanguage = '';
            if (tmSearchInput) tmSearchInput.value = ''; // Added null check
            renderTMSearchResults([]); // Clear search results table
            // Show config section for new TM
            showTMLanguageConfigSection();
            showTMInternalMessage(translations[currentLanguage]['tm_initial_message']); // Inform user TM is empty
        }

        /**
         * Shows the TM language configuration section and hides others.
         */
        function showTMLanguageConfigSection() {
            if (tmLanguageConfigSection && tmEditorSection) { // Added null checks
                tmLanguageConfigSection.style.display = 'block';
                tmEditorSection.style.display = 'none';
                // Reset config inputs to default values for a new setup
                if (tmConfigSrcLang) tmConfigSrcLang.value = 'en-US'; // Added null check
                if (tmConfigTgtLang) tmConfigTgtLang.value = 'es-ES'; // Added null check
                hideTMInternalMessage(); // Clear message when showing config
            }
        }

        /**
         * Shows the TM editor section and hides others.
         */
        function showTMEditorSection() {
            if (tmLanguageConfigSection && tmEditorSection && displayTmSrcLang && displayTmTgtLang) { // Added null checks
                tmLanguageConfigSection.style.display = 'none';
                tmEditorSection.style.display = 'block';
                displayTmSrcLang.value = tmSourceLanguage;
                displayTmTgtLang.value = tmTargetLanguage;
                tmSearch(); // Perform initial search when opening
                hideTMInternalMessage(); // Clear message when showing editor
            }
        }

        /**
         * Confirms the TM's source and target languages from user input.
         * Enables the main TM editor section if languages are valid.
         */
        function confirmTMLanguages() {
            const srcLang = tmConfigSrcLang ? tmConfigSrcLang.value.trim() : ''; // Added null check
            const tgtLang = tmConfigTgtLang ? tmConfigTgtLang.value.trim() : ''; // Added null check

            if (!srcLang || !tgtLang) {
                showTMInternalMessage(translations[currentLanguage]['lang_config_required'], true); // Show error message
                return;
            }

            tmSourceLanguage = srcLang;
            tmTargetLanguage = tgtLang;

            showTMEditorSection(); // Show editor after confirming languages
            // No need to renderTranslations or updateStats here, as it's not directly affected by TM language change.
        }

        /**
         * Parses a TMX file content and populates the translationMemory array.
         * @param {string} content The TMX file content string.
         */
        function processTMXContent(content) {
            showLoadingOverlay(translations[currentLanguage]['loading_file']);
            hideTMInternalMessage(); // Hide any previous internal message

            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, "application/xml");

                if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                    const errorText = xmlDoc.getElementsByTagName("parsererror")[0].textContent;
                    throw new Error("Invalid XML/TMX format: " + errorText);
                }

                if (xmlDoc.getElementsByTagName("termEntry").length > 0) {
                    showTMInternalMessage(translations[currentLanguage]['tmx_file_expected_tbx_found'], true);
                    throw new Error("Attempted to load TBX into Translation Memory.");
                }

                const tuElements = xmlDoc.getElementsByTagName("tu");
                let newTM = [];
                let detectedSrcLang = '';
                let detectedTgtLang = '';

                if (tuElements.length > 0) {
                    const tuvElements = tuElements[0].getElementsByTagName("tuv");
                    if (tuvElements.length >= 2) {
                        detectedSrcLang = tuvElements[0].getAttribute("xml:lang");
                        detectedTgtLang = tuvElements[1].getAttribute("xml:lang");
                    }
                }

                for (let tu of tuElements) {
                    const tuvElements = tu.getElementsByTagName("tuv");
                    if (tuvElements.length >= 2) {
                        const srcTuv = tuvElements[0];
                        const tgtTuv = tuvElements[1];
                        const srcLang = srcTuv.getAttribute("xml:lang");
                        const tgtLang = tgtTuv.getAttribute("xml:lang");
                        const srcSeg = srcTuv.getElementsByTagName("seg")[0]?.textContent || '';
                        const tgtSeg = tgtTuv.getElementsByTagName("seg")[0]?.textContent || '';

                        newTM.push({
                            srcLang: srcLang, srcText: srcSeg,
                            tgtLang: tgtLang, tgtText: tgtSeg,
                            srcWordCount: countWords(srcSeg), tgtWordCount: countWords(tgtSeg)
                        });
                    }
                }

                translationMemory = newTM;
                tmSourceLanguage = detectedSrcLang || (tmConfigSrcLang ? tmConfigSrcLang.value : 'en-US');
                tmTargetLanguage = detectedTgtLang || (tmConfigTgtLang ? tmConfigTgtLang.value : 'es-ES');

                showTMInternalMessage(`TMX loaded with ${translationMemory.length} translation units.`);
                showTMEditorSection();
                tmSearch();

            } catch (error) {
                console.error("Error loading TMX file:", error);
                if (!error.message.includes("Attempted to load TBX")) {
                     showTMInternalMessage(translations[currentLanguage]['error_loading_tmx_file'], true);
                }
                resetTM();
            } finally {
                hideLoadingOverlay();
            }
        }

        /**
         * Generates a TMX XML string from the current translation memory data.
         * @returns {string} The TMX XML content.
         */
        function generateTMX() {
            if (translationMemory.length === 0) {
                return null; // Return null if nothing to generate
            }

            const header = `<?xml version="1.0" encoding="UTF-8"?>
<tmx version="1.4">
  <header creationtool="Poanda" creationtoolversion="1.0"
          datatype="unknown" segtype="sentence" changeid="PoandaUser"
          srclang="${tmSourceLanguage || 'en-US'}" o-tmf="Poanda"
          adminlang="en-US" `;

            const targetLangAttr = tmTargetLanguage ? `targetlang="${tmTargetLanguage}"` : '';

            const xml = [header + targetLangAttr + `>
  </header>
  <body>`];

            translationMemory.forEach(entry => {
                xml.push(`    <tu>
      <tuv xml:lang="${entry.srcLang}"><seg>${entry.srcText}</seg></tuv>
      <tuv xml:lang="${entry.tgtLang}"><seg>${entry.tgtText}</seg></tuv>
    </tu>`);
            });

            xml.push(`  </body>
</tmx>`);
            return xml.join("\n");
        }

        /**
         * Triggers a download of the generated TMX XML file.
         */
        function downloadTMX() {
            const tmxContent = generateTMX();
            if (!tmxContent) {
                 showTMInternalMessage(translations[currentLanguage]['cannot_download_empty_tm'], true);
                 return;
            }

            showLoadingOverlay(translations[currentLanguage]['saving_file']);
            try {
                const blob = new Blob([tmxContent], { type: "application/xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "translation_memory.tmx";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showTMInternalMessage(translations[currentLanguage]['file_saved_successfully']);
            } catch (error) {
                showTMInternalMessage(`${translations[currentLanguage]['error_saving_file']} ${error.message}`, true);
                console.error("Error downloading TMX:", error);
            } finally {
                hideLoadingOverlay();
            }
        }

        /**
         * Adds or updates an entry in the translation memory.
         * @param {string} original The original segment text.
         * @param {string} translation The translated segment text.
         */
        function addOrUpdateTMEntry(original, translation) {
            if (!original || !translation) return; // Only add valid pairs
            if (!tmSourceLanguage || !tmTargetLanguage) {
                console.warn("TM languages not configured. Skipping TM update.");
                return; // Cannot add/update without configured languages
            }

            const existingIndex = translationMemory.findIndex(
                entry => entry.srcText === original && entry.srcLang === tmSourceLanguage && entry.tgtLang === tmTargetLanguage
            );

            if (existingIndex !== -1) {
                // Update existing entry
                translationMemory[existingIndex].tgtText = translation;
                translationMemory[existingIndex].tgtWordCount = countWords(translation);
            } else {
                // Add new entry
                translationMemory.push({
                    srcLang: tmSourceLanguage,
                    srcText: original,
                    tgtLang: tmTargetLanguage,
                    tgtText: translation,
                    srcWordCount: countWords(original),
                    tgtWordCount: countWords(translation)
                });
            }
            tmSearch(); // Re-render TM search results to reflect changes
        }

        /**
         * Finds the best matching TM entry for a given source segment.
         * @param {string} sourceSegmentText The text of the current source segment.
         * @returns {Object|null} The best matching TM entry with a score, or null if no match >= 70%.
         */
        function findBestTMMatch(sourceSegmentText) {
            if (translationMemory.length === 0 || !sourceSegmentText.trim() || !tmSourceLanguage || !tmTargetLanguage) {
                return null; // Return null if no TM data or languages not configured
            }

            let bestMatch = null;
            let highestScore = 0;
            const MIN_FUZZY_THRESHOLD = 70; // 70% threshold

            translationMemory.forEach(entry => {
                // Only compare if languages match and source text is available
                if (entry.srcLang === tmSourceLanguage && entry.tgtLang === tmTargetLanguage && entry.srcText.trim()) {
                    const score = calculateSimilarity(sourceSegmentText, entry.srcText);
                    if (score >= MIN_FUZZY_THRESHOLD && score > highestScore) {
                        highestScore = score;
                        bestMatch = { ...entry, score: score.toFixed(0) }; // Store score with entry
                    }
                }
            });

            return bestMatch;
        }

        /**
         * Performs a search on the translation memory and renders results.
         * Integrates best match for active segment.
         */
        function tmSearch() {
            const query = tmSearchInput ? tmSearchInput.value.toLowerCase().trim() : ''; // Added null check
            let resultsToRender = [];

            // Get the current active segment's original text
            const currentFocused = getCurrentFocusedIndex();
            let activeSegmentOriginalText = null;
            if (currentFocused && poEntries[currentFocused.entryIndex] && poEntries[currentFocused.entryIndex].sentenceSegments && poEntries[currentFocused.entryIndex].sentenceSegments[currentFocused.segmentIndex]) { // Added null checks
                activeSegmentOriginalText = poEntries[currentFocused.entryIndex].sentenceSegments[currentFocused.segmentIndex].original;
            }

            // Find the best match for the active segment if any
            tmBestMatchForActiveSegment = null; // Reset global best match
            if (activeSegmentOriginalText) {
                tmBestMatchForActiveSegment = findBestTMMatch(activeSegmentOriginalText);
            }

            // If there's a best match for the active segment AND no specific search query is entered,
            // or if the search query matches the best match exactly, display it as the primary result.
            // This prioritizes the segment-focused match over general search if applicable.
            if (tmBestMatchForActiveSegment && (query === '' || tmBestMatchForActiveSegment.srcText.toLowerCase().includes(query))) {
                resultsToRender.push({ ...tmBestMatchForActiveSegment, isBestMatch: true });
            }


            // Filter the entire TM based on the search query
            const filteredTM = translationMemory.filter(entry => {
                // Exclude the best match if it's already added as the primary result AND
                // it matches the primary result that's already in `resultsToRender`
                if (tmBestMatchForActiveSegment && entry.srcText === tmBestMatchForActiveSegment.srcText && entry.tgtText === tmBestMatchForActiveSegment.tgtText) {
                    return false;
                }
                // Filter by query if a query is present
                if (query) {
                    return (entry.srcText && entry.srcText.toLowerCase().includes(query)) ||
                           (entry.tgtText && entry.tgtText.toLowerCase().includes(query));
                }
                return true; // If no query, include all remaining entries
            });

            // Add filtered results. Calculate score against search query if query exists.
            filteredTM.forEach(entry => {
                let score = 0;
                if (query) {
                    score = calculateSimilarity(query, entry.srcText); // Score against the actual search query
                } else if (activeSegmentOriginalText) {
                    score = calculateSimilarity(activeSegmentOriginalText, entry.srcText); // Score against active segment if no query
                }
                resultsToRender.push({ ...entry, score: score.toFixed(0) });
            });

            // Sort the search results (excluding the active best match if it's already first)
            // Sort by score (descending) first, then alphabetically by source text for consistency
            resultsToRender.sort((a, b) => {
                // Ensure best match stays at top if it was intentionally placed there
                if (a.isBestMatch) return -1;
                if (b.isBestMatch) return 1;
                
                if (b.score !== a.score) {
                    return b.score - a.score; // Higher score first
                }
                return a.srcText.localeCompare(b.srcText); // Alphabetical secondary sort
            });

            currentTMLatestSearchResults = resultsToRender; // Store for shortcut
            renderTMSearchResults(resultsToRender, activeSegmentOriginalText);
        }


        /**
         * Renders the TM search results in the table.
         * @param {Array<Object>} results Array of TM entries to display.
         * @param {string|null} activeSegmentOriginalText The original text of the currently active segment.
         */
        function renderTMSearchResults(results, activeSegmentOriginalText) {
            if (!tmSearchResultsTableBody) {
                console.warn("tmSearchResultsTableBody element not found. Cannot render TM search results.");
                return;
            }
            tmSearchResultsTableBody.innerHTML = '';
            if (results.length === 0) {
                if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.remove('hidden');
                if (tmInternalMessage && tmInternalMessage.classList.contains('hidden')) {
                    if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.remove('hidden');
                }
                return;
            } else {
                if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.add('hidden');
            }
            hideTMInternalMessage();

            results.forEach(entry => {
                const row = document.createElement('tr');
                if (entry.isBestMatch) {
                    row.classList.add('tm-best-match-highlight');
                }

                let originalCellHtml = '';
                // If an active segment is focused, perform a diff. Otherwise, show plain text.
                if (activeSegmentOriginalText) {
                    const differences = Diff.diffChars(entry.srcText, activeSegmentOriginalText);
                    originalCellHtml = differences.map(part => {
                        const className = part.added ? 'diff-added' :
                                        part.removed ? 'diff-removed' : 'diff-common';
                        return `<span class="${className}">${part.value}</span>`;
                    }).join('');
                } else {
                    originalCellHtml = entry.srcText;
                }

                row.innerHTML = `
                    <td>${entry.score}%</td>
                    <td><pre class="whitespace-pre-wrap">${originalCellHtml}</pre></td>
                    <td><pre class="whitespace-pre-wrap">${entry.tgtText}</pre></td>
                `;
                row.addEventListener('click', () => {
                    const currentFocused = getCurrentFocusedIndex();
                    if (currentFocused) {
                        const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                        if (targetTextarea && !targetTextarea.readOnly) {
                            targetTextarea.value = entry.tgtText;
                            const event = new Event('input', { bubbles: true });
                            targetTextarea.dispatchEvent(event);
                        }
                    }
                });
                tmSearchResultsTableBody.appendChild(row);
            });
        }


        // --- Loading Overlay Functions ---
        function showLoadingOverlay(message) {
            if (loadingMessage && loadingOverlay) { // Added null check
                loadingMessage.textContent = message;
                loadingOverlay.classList.remove('hidden');
            }
        }

        function hideLoadingOverlay() {
            if (loadingOverlay) { // Added null check
                loadingOverlay.classList.add('hidden');
            }
        }

        // --- Drag and Drop functionality ---
        if (dropArea) { // Added null check
            dropArea.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.add('border-blue-500'); // Visual feedback for drag over
            });

            dropArea.addEventListener('dragleave', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-blue-500');
            });

            dropArea.addEventListener('drop', async (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-blue-500');

                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.name.toLowerCase().endsWith('.po')) {
                        await processFile(file);
                    } else if (file.name.toLowerCase().endsWith('.zip') || file.name.toLowerCase().endsWith('.poanda')) {
                        await openProject(file);
                    } else {
                        showMessage('Please drop a valid .po or .poanda project file.');
                    }
                }
            });
        }

        // --- Accordion Logic for Add Term ---
        if (addTermHeader && addTermContent && addTermAccordionIcon) {
            addTermHeader.addEventListener('click', () => {
                const isCollapsed = addTermContent.classList.contains('collapsed');
                if (isCollapsed) {
                    addTermContent.classList.remove('collapsed');
                    addTermContent.classList.add('expanded');
                    addTermAccordionIcon.classList.remove('rotated');
                } else {
                    addTermContent.classList.remove('expanded');
                    addTermContent.classList.add('collapsed');
                    addTermAccordionIcon.classList.add('rotated');
                }
            });
        }


        /**
         * Adjusts the padding of the main editor content based on open sidebars.
         * Applies only on screens wider than 1024px.
         */
        function updateMainContentOffset() {
            const isTerminologyOpen = terminologySidebar.classList.contains('show-sidebar');
            const isTranslationMemoryOpen = translationMemorySidebar.classList.contains('show-sidebar');

            // Remove existing padding classes first
            if (editorMainContent) { // Added null check for editorMainContent
                editorMainContent.classList.remove('left-sidebar-active', 'right-sidebar-active');

                // Apply new padding classes based on open sidebars
                if (isTerminologyOpen) {
                    editorMainContent.classList.add('left-sidebar-active');
                    // Set CSS variable for current width
                    document.documentElement.style.setProperty('--terminology-sidebar-width', terminologySidebar.offsetWidth + 'px');
                }
                if (isTranslationMemoryOpen) {
                    editorMainContent.classList.add('right-sidebar-active');
                    // Set CSS variable for current width
                    document.documentElement.style.setProperty('--translation-memory-sidebar-width', translationMemorySidebar.offsetWidth + 'px');
                }
            } else {
                console.warn("editorMainContent element not found for offset update.");
            }
        }

        // --- Project Management Functions ---

        /**
         * Resets the entire application to a clean state, without confirmation.
         */
        function resetProjectState() {
            // Reset PO file data
            poEntries = [];
            currentFileName = 'translations.po';
            renderTranslations([]); // Clears the editor
            updateStatsDisplay();

            // Reset sidebars
            resetGlossary();
            resetTM();

            // Hide sidebars if they are open
            terminologySidebar.classList.remove('show-sidebar');
            translationMemorySidebar.classList.remove('show-sidebar');
            updateMainContentOffset();
        }

        /**
         * Starts a new project, asking for confirmation if there's unsaved work.
         */
        function newProject() {
            if (poEntries.length > 0) {
                if (!confirm(translations[currentLanguage]['new_project_confirm'])) {
                    return;
                }
            }
            resetProjectState();
            clearBackup(); // Clear backup when starting a new project
        }

        /**
         * Shows the modal to get a filename before saving the project.
         */
        function showSaveProjectModal() {
            if (poEntries.length === 0) {
                showMessage(translations[currentLanguage]['no_project_to_save']);
                return;
            }
            // Suggest a filename based on the current .po file name, without extension
            projectFilenameInput.value = currentFileName.replace(/\.po$/i, '');
            saveProjectModal.classList.remove('hidden');
            projectFilenameInput.focus();
        }

        /**
         * Executes the project save logic after getting the filename from the modal.
         */
        async function executeSaveProject() {
            const filename = projectFilenameInput.value.trim();
            if (!filename) {
                showMessage(translations[currentLanguage]['enter_filename']);
                return;
            }

            showLoadingOverlay(translations[currentLanguage]['saving_file']);
            try {
                const zip = new JSZip();

                // 1. Add .po file
                const poContent = reconstructPo(poEntries);
                zip.file(currentFileName, poContent);

                // 2. Add .tmx file if TM has content
                const tmxContent = generateTMX();
                if (tmxContent) {
                    zip.file("memory.tmx", tmxContent);
                }

                // 3. Add .tbx file if glossary has content
                if (glossary.length > 0) {
                    const tbxContent = generateTBX();
                    zip.file("glossary.tbx", tbxContent);
                }

                // Generate and download zip with .poanda extension
                const zipBlob = await zip.generateAsync({ type: "blob" });
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `${filename}.poanda`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                saveProjectModal.classList.add('hidden');
                showMessage(translations[currentLanguage]['project_saved']);

            } catch (error) {
                showMessage(translations[currentLanguage]['error_saving_project'] + ': ' + error.message);
                console.error("Error saving project:", error);
            } finally {
                hideLoadingOverlay();
            }
        }

        /**
         * Opens a project from a .zip or .poanda file.
         * @param {File} file The project file to open.
         */
        async function openProject(file) {
            if (!file) return;

            showLoadingOverlay(translations[currentLanguage]['loading_project']);
            try {
                // Reset current state silently before loading the new project
                resetProjectState();

                const zip = await JSZip.loadAsync(file);
                let poFileFound = false;

                const promises = [];
                zip.forEach((relativePath, zipEntry) => {
                    const fileNameLower = zipEntry.name.toLowerCase();
                    if (fileNameLower.endsWith('.po')) {
                        poFileFound = true;
                        currentFileName = zipEntry.name;
                        promises.push(zipEntry.async("string").then(processPoContent));
                    } else if (fileNameLower.endsWith('.tmx')) {
                         promises.push(zipEntry.async("string").then(processTMXContent));
                    } else if (fileNameLower.endsWith('.tbx')) {
                         promises.push(zipEntry.async("string").then(processTBXContent));
                    }
                });

                await Promise.all(promises);

                if (!poFileFound) {
                    throw new Error(translations[currentLanguage]['invalid_project_file']);
                }
                showMessage(translations[currentLanguage]['project_loaded']);
                await clearBackup(); // Clear old backup after a new project is successfully loaded

            } catch (error) {
                showMessage(translations[currentLanguage]['error_opening_project'] + ': ' + error.message);
                console.error("Error opening project:", error);
                // Reset again if loading failed, to ensure a clean state
                resetProjectState();
            } finally {
                hideLoadingOverlay();
                // Reset file input value to allow opening the same file again
                projectFileInput.value = '';
            }
        }

        // --- Backup and Restore (IndexedDB) ---
        const DB_NAME = 'PoandaBackup';
        const DB_VERSION = 1;
        const STORE_NAME = 'session';
        let db;

        function openDb() {
            return new Promise((resolve, reject) => {
                if (db) {
                    resolve(db);
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject("Error opening IndexedDB.");
                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };
            });
        }

        async function saveBackup() {
            if (!db || poEntries.length === 0) return; // Don't save if DB isn't open or no data
            const sessionData = {
                id: 'currentSession',
                poEntries,
                currentFileName,
                glossary,
                glossarySourceLanguage,
                glossaryTargetLanguage,
                translationMemory,
                tmSourceLanguage,
                tmTargetLanguage,
                timestamp: new Date()
            };
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.put(sessionData);
            request.onsuccess = () => {
                 updateBackupStatusUI(); // Update indicator after successful save
            };
        }

        async function loadBackup() {
            if (!db) return null;
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get('currentSession');
                request.onerror = () => reject("Error loading backup from DB.");
                request.onsuccess = () => resolve(request.result);
            });
        }

        async function clearBackup() {
            if (!db) return;
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            store.clear();
            updateBackupStatusUI();
        }

        async function checkForBackup() {
            try {
                await openDb();
                const backup = await loadBackup();
                if (backup && backup.poEntries && backup.poEntries.length > 0) {
                    restoreBackupModal.classList.remove('hidden');
                }
                updateBackupStatusUI();
            } catch (error) {
                console.error("Backup check failed:", error);
            }
        }

        async function restoreSession(backupData = null) {
            showLoadingOverlay(translations[currentLanguage]['loading_project']);
            try {
                const backup = backupData || await loadBackup();
                if (backup) {
                    poEntries = backup.poEntries || [];
                    currentFileName = backup.currentFileName || 'translations.po';
                    glossary = backup.glossary || [];
                    glossarySourceLanguage = backup.glossarySourceLanguage || '';
                    glossaryTargetLanguage = backup.glossaryTargetLanguage || '';
                    translationMemory = backup.translationMemory || [];
                    tmSourceLanguage = backup.tmSourceLanguage || '';
                    tmTargetLanguage = backup.tmTargetLanguage || '';

                    // Restore UI
                    renderTranslations(poEntries);
                    
                    if (glossarySourceLanguage && glossaryTargetLanguage) {
                        showGlossaryEditorSection();
                    } else {
                        showLanguageConfigSection();
                    }

                    if (tmSourceLanguage && tmTargetLanguage) {
                        showTMEditorSection();
                    } else {
                        showTMLanguageConfigSection();
                    }
                }
            } catch (error) {
                showMessage("Failed to restore session.");
                console.error(error);
            } finally {
                restoreBackupModal.classList.add('hidden');
                hideLoadingOverlay();
            }
        }

        async function updateBackupStatusUI() {
            try {
                const backup = await loadBackup();
                if (backup) {
                    backupIndicator.style.display = 'inline-block';
                    lastBackupTime.textContent = new Date(backup.timestamp).toLocaleString();
                    loadLocalBackupBtn.disabled = false;
                    saveBackupToDiskBtn.disabled = false;
                    deleteLocalBackupBtn.disabled = false;
                } else {
                    backupIndicator.style.display = 'none';
                    lastBackupTime.textContent = translations[currentLanguage]['no_backup_available'];
                    loadLocalBackupBtn.disabled = true;
                    saveBackupToDiskBtn.disabled = true;
                    deleteLocalBackupBtn.disabled = true;
                }
            } catch (error) {
                console.error("Error updating backup UI:", error);
            }
        }

        // --- NEW: PO to MO Converter Logic ---

        /**
         * Parses a PO file string specifically for MO compilation.
         * Handles msgctxt, msgid_plural, and msgstr arrays correctly.
         * @param {string} poText The full PO content as a string.
         * @returns {Array<Object>} An array of message objects for the compiler.
         */
        function parsePoForMo(poText) {
            const lines = poText.split('\n');
            const messages = [];
            let currentMsg = {};
            let state = '';

            const unescape = (str) => str.replace(/\\n/g, '\n').replace(/\\"/g, '"').replace(/\\\\/g, '\\');

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('#')) continue;

                if (trimmedLine.length === 0) {
                    if (currentMsg.msgid !== undefined) {
                        messages.push(currentMsg);
                    }
                    currentMsg = {};
                    state = '';
                    continue;
                }

                if (trimmedLine.startsWith('msgctxt')) {
                    state = 'msgctxt';
                    currentMsg.msgctxt = unescape(trimmedLine.substring(7).trim().slice(1, -1));
                } else if (trimmedLine.startsWith('msgid_plural')) {
                    state = 'msgid_plural';
                    currentMsg.msgid_plural = unescape(trimmedLine.substring(12).trim().slice(1, -1));
                } else if (trimmedLine.startsWith('msgid')) {
                    state = 'msgid';
                    currentMsg.msgid = unescape(trimmedLine.substring(5).trim().slice(1, -1));
                } else if (trimmedLine.startsWith('msgstr[')) {
                    const match = trimmedLine.match(/msgstr\[(\d+)\]/);
                    state = `msgstr[${match[1]}]`;
                    if (!currentMsg.msgstr) currentMsg.msgstr = [];
                    currentMsg.msgstr[parseInt(match[1], 10)] = unescape(trimmedLine.substring(match[0].length).trim().slice(1, -1));
                } else if (trimmedLine.startsWith('msgstr')) {
                    state = 'msgstr';
                    currentMsg.msgstr = [unescape(trimmedLine.substring(6).trim().slice(1, -1))];
                } else if (trimmedLine.startsWith('"')) { // continuation line
                    const str = unescape(trimmedLine.slice(1, -1));
                    if (state === 'msgid') currentMsg.msgid += str;
                    else if (state === 'msgid_plural') currentMsg.msgid_plural += str;
                    else if (state === 'msgctxt') currentMsg.msgctxt += str;
                    else if (state === 'msgstr') currentMsg.msgstr[0] += str;
                    else if (state.startsWith('msgstr[')) {
                        const match = state.match(/msgstr\[(\d+)\]/);
                        const index = parseInt(match[1], 10);
                        if(!currentMsg.msgstr[index]) currentMsg.msgstr[index] = '';
                        currentMsg.msgstr[index] += str;
                    }
                }
            }
            if (currentMsg.msgid !== undefined) messages.push(currentMsg);
            return messages;
        }

        /**
         * Compiles an array of parsed PO messages into a binary MO file ArrayBuffer.
         * @param {Array<Object>} messages The parsed messages from parsePoForMo.
         * @returns {ArrayBuffer} The binary data of the .mo file.
         */
        function compileMo(messages) {
            const textEncoder = new TextEncoder();
            const MAGIC = 0x950412de;
            const REVISION = 0;
            
            let header = messages.find(m => m.msgid === '');
            if (header && header.msgstr && header.msgstr[0]) {
                 if(!header.msgstr[0].includes('Content-Type')) {
                    header.msgstr[0] += '\nContent-Type: text/plain; charset=UTF-8\n';
                 }
            } else {
                 header = { msgid: "", msgstr: ["Content-Type: text/plain; charset=UTF-8\n"] };
            }

            const translations = messages.filter(m => m.msgid !== '');

            translations.sort((a, b) => {
                const keyA = (a.msgctxt || '') + '\u0004' + a.msgid;
                const keyB = (b.msgctxt || '') + '\u0004' + b.msgid;
                return keyA.localeCompare(keyB);
            });

            const stringCount = translations.length + 1; // +1 for header
            const headerSize = 28;
            const originalsTableOffset = headerSize;
            const translationsTableOffset = headerSize + (stringCount * 8);
            
            let stringData = [];
            let currentOffset = translationsTableOffset + (stringCount * 8);

            // Header entry
            stringData.push({
                original: textEncoder.encode(""),
                translation: textEncoder.encode(header.msgstr[0]),
            });

            // Translation entries
            translations.forEach(msg => {
                let originalStr;
                if (msg.msgid_plural) {
                    originalStr = (msg.msgctxt ? msg.msgctxt + '\u0004' : '') + msg.msgid + '\u0000' + msg.msgid_plural;
                } else {
                    originalStr = (msg.msgctxt ? msg.msgctxt + '\u0004' : '') + msg.msgid;
                }
                const translationStr = (msg.msgstr || []).join('\u0000');
                stringData.push({
                    original: textEncoder.encode(originalStr),
                    translation: textEncoder.encode(translationStr),
                });
            });

            const originalsTable = [];
            const translationsTable = [];

            stringData.forEach(data => {
                originalsTable.push({ length: data.original.length, offset: currentOffset });
                currentOffset += data.original.length + 1; // +1 for null terminator
            });
            stringData.forEach(data => {
                translationsTable.push({ length: data.translation.length, offset: currentOffset });
                currentOffset += data.translation.length + 1; // +1 for null terminator
            });
            
            const buffer = new ArrayBuffer(currentOffset);
            const view = new DataView(buffer);
            let byteOffset = 0;

            // Write header
            view.setUint32(byteOffset, MAGIC, true); byteOffset += 4;
            view.setUint32(byteOffset, REVISION, true); byteOffset += 4;
            view.setUint32(byteOffset, stringCount, true); byteOffset += 4;
            view.setUint32(byteOffset, originalsTableOffset, true); byteOffset += 4;
            view.setUint32(byteOffset, translationsTableOffset, true); byteOffset += 4;
            view.setUint32(byteOffset, 0, true); byteOffset += 4; // hash table size
            view.setUint32(byteOffset, 0, true); byteOffset += 4; // hash table offset
            
            // Write tables
            originalsTable.forEach(entry => {
                view.setUint32(byteOffset, entry.length, true); byteOffset += 4;
                view.setUint32(byteOffset, entry.offset, true); byteOffset += 4;
            });
            translationsTable.forEach(entry => {
                view.setUint32(byteOffset, entry.length, true); byteOffset += 4;
                view.setUint32(byteOffset, entry.offset, true); byteOffset += 4;
            });

            // Write string data
            stringData.forEach(data => {
                new Uint8Array(buffer, byteOffset).set(data.original);
                byteOffset += data.original.length + 1;
            });
            stringData.forEach(data => {
                new Uint8Array(buffer, byteOffset).set(data.translation);
                byteOffset += data.translation.length + 1;
            });

            return buffer;
        }

        // --- Initialization on page load ---
        document.addEventListener('DOMContentLoaded', async () => {
            populateIsoLanguagesDatalist();
            
            // Add event listeners for language buttons
            document.getElementById('langEnBtn').addEventListener('click', () => setLanguage('en'));
            document.getElementById('langEsBtn').addEventListener('click', () => setLanguage('es'));

            // Add event listeners for project buttons
            newProjectBtn.addEventListener('click', newProject);
            saveProjectBtn.addEventListener('click', showSaveProjectModal);
            openProjectBtn.addEventListener('click', () => projectFileInput.click());
            projectFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                openProject(file);
            });

            // Add event listeners for the save project modal
            saveProjectConfirmBtn.addEventListener('click', executeSaveProject);
            saveProjectCancelBtn.addEventListener('click', () => {
                saveProjectModal.classList.add('hidden');
            });

            // Add event listeners for the restore backup modal
            restoreBackupBtn.addEventListener('click', restoreSession);
            discardBackupBtn.addEventListener('click', () => {
                clearBackup();
                restoreBackupModal.classList.add('hidden');
            });
            
            // Add event listeners for the backup modal
            backupBtn.addEventListener('click', () => {
                updateBackupStatusUI();
                backupModal.classList.remove('hidden');
            });

            backupCloseBtn.addEventListener('click', () => {
                backupModal.classList.add('hidden');
            });
            
            loadLocalBackupBtn.addEventListener('click', () => {
                restoreSession();
                backupModal.classList.add('hidden');
            });

            deleteLocalBackupBtn.addEventListener('click', async () => {
                if (confirm(translations[currentLanguage]['delete_local_backup_btn_confirm'])) {
                    await clearBackup();
                    showMessage(translations[currentLanguage]['backup_deleted']);
                }
            });

            saveBackupToDiskBtn.addEventListener('click', async () => {
                const backup = await loadBackup();
                if (backup) {
                    const jsonString = JSON.stringify(backup, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `poanda_backup_${new Date().toISOString().slice(0,10)}.poanda-backup`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            });
            
            loadBackupFromFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.id === 'currentSession' && data.poEntries) {
                            await restoreSession(data);
                            await saveBackup();
                            showMessage(translations[currentLanguage]['backup_loaded_from_file']);
                            backupModal.classList.add('hidden');
                        } else {
                            throw new Error("Invalid backup file format.");
                        }
                    } catch (error) {
                        showMessage(translations[currentLanguage]['error_loading_backup_file']);
                        console.error("Error processing backup file:", error);
                    } finally {
                        loadBackupFromFileInput.value = '';
                    }
                };
                reader.readAsText(file);
            });

            // NEW: Add event listeners for the MO converter modal
            convertToMoButton.addEventListener('click', () => {
                if (poEntries.length > 0) {
                    convertToMoModal.classList.remove('hidden');
                } else {
                    showMessage(translations[currentLanguage]['no_file_to_convert']);
                }
            });

            moConverterCloseBtn.addEventListener('click', () => {
                convertToMoModal.classList.add('hidden');
            });

            moConverterActionBtn.addEventListener('click', () => {
                try {
                    const poContent = reconstructPo(poEntries);
                    const messages = parsePoForMo(poContent);
                    const moArrayBuffer = compileMo(messages);

                    const blob = new Blob([moArrayBuffer], { type: 'application/octet-stream' });
                    const outputFileName = currentFileName.replace(/\.po$/, '.mo');
                    const link = document.createElement('a');

                    link.href = URL.createObjectURL(blob);
                    link.download = outputFileName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);

                    showMessage(translations[currentLanguage]['mo_conversion_success']);
                } catch (error) {
                    showMessage(translations[currentLanguage]['mo_conversion_error']);
                    console.error("Error converting PO to MO:", error);
                } finally {
                    convertToMoModal.classList.add('hidden');
                }
            });


            setLanguage(currentLanguage); // Apply initial language (en) and content

            resetGlossary(); // Start in the new glossary configuration mode (first step)
            resetTM(); // Initialize TM - this will now show the language config for TM and its initial message
            
            // Add event listener for the new stats button
            statsBtn.addEventListener('click', () => {
                statsContainer.classList.toggle('show');
            });

            // For first load, we ensure the "no_translations" message is shown.
            if (translationsContainer) { // Added null check
                translationsContainer.innerHTML = `
                    <div data-i18n="no_translations" id="initialMessage" class="text-center text-on-light-contrast p-4 border border-gray-300 rounded-md">
                        ${translations[currentLanguage]['no_translations']}
                    </div>
                `;
            }
            if (savePoButton) savePoButton.disabled = true; // Added null check
            if (convertToMoButton) convertToMoButton.disabled = true; // NEW
            if (statsContainer) statsContainer.classList.remove('show'); // Ensure stats are hidden on load

            // Ensure accordions are collapsed on initial load
            if (addTermContent && addTermAccordionIcon) {
                addTermContent.classList.add('collapsed');
                addTermContent.classList.remove('expanded');
                addTermAccordionIcon.classList.remove('rotated'); // Ensure it's not rotated initially
            }

            // Ensure TM sidebar is hidden initially
            if (translationMemorySidebar) translationMemorySidebar.classList.remove('show-sidebar'); // Added null check

            updateMainContentOffset(); // Set initial padding based on hidden state of sidebars

            // Check for a backup on load
            await checkForBackup();

            // Start automatic backup interval
            setInterval(saveBackup, 10000); // Save every 10 seconds
        });
    </script>
</body>
</html>
