<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">Poanda</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/diff@5.0.0/dist/diff.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- THEME COLORS --- */
        :root {
            --color-primary: #F48790; /* Pink */
            --color-secondary: #F7CF7E; /* Yellow */
            --color-dark: #373737; /* Dark Gray */
            --color-light-gray: #f3f4f6;
            --color-white: #ffffff;
            --color-medium-gray: #e5e7eb;
            --color-neutral-gray: #6b7280;
        }
        
        /* --- MODO OSCURO FINAL (V3) --- */
        body.dark-mode {
            --color-dark: #f3f4f6;
            --color-light-gray: #111827; /* Fondo muy oscuro */
            --color-white: #1f2937;      /* Gris oscuro para contenedores */
            --color-medium-gray: #374151;
            --color-neutral-gray: #9ca3af;
            background-color: var(--color-light-gray) !important;
            color: #e5e7eb;
        }

        /* 1. Contenedores principales */
        body.dark-mode #dropArea,
        body.dark-mode .modal-content,
        body.dark-mode #statsContainer,
        body.dark-mode #poSearchContainer,
        body.dark-mode .terminology-sidebar,
        body.dark-mode .translation-memory-sidebar,
        body.dark-mode .ai-sidebar {
            background-color: var(--color-white) !important;
            color: #e5e7eb !important;
            border-color: var(--color-medium-gray) !important;
        }
        
        /* Ajuste de textos dentro del buscador */
        body.dark-mode #poSearchContainer span,
        body.dark-mode #poSearchContainer label {
            color: #e5e7eb !important;
        }

        /* 2. Unidades de Traducci√≥n y Editor */
        body.dark-mode .translation-unit-bg {
            background-color: #1f2937 !important;
            border-color: #4b5563 !important;
        }
        body.dark-mode .po-display-code {
            background-color: #111827 !important;
            color: #d1d5db !important;
            border-color: #374151 !important;
        }
        body.dark-mode input, 
        body.dark-mode select, 
        body.dark-mode textarea,
        body.dark-mode .ai-textarea {
            background-color: #374151 !important;
            color: #f3f4f6 !important;
            border-color: #4b5563 !important;
        }

        /* 3. COLORES DE BOTONES (Est√°ndar) */
        body.dark-mode .btn-load,
        body.dark-mode .btn-edit,
        body.dark-mode .btn-modal-primary,
        body.dark-mode .glossary-btn-primary,
        body.dark-mode .tm-btn-primary {
            background-color: #be123c !important; /* Rose-700 */
            color: #ffffff !important;
        }
        body.dark-mode .btn-load:hover,
        body.dark-mode .btn-edit:hover,
        body.dark-mode .btn-modal-primary:hover {
            background-color: #9f1239 !important; /* Rose-800 */
        }

        body.dark-mode .btn-validate,
        body.dark-mode .btn-save,
        body.dark-mode .btn-modal-secondary {
            background-color: #b45309 !important; /* Amber-700 */
            color: #ffffff !important;
        }
        body.dark-mode .btn-validate:hover,
        body.dark-mode .btn-save:hover {
            background-color: #92400e !important;
        }

        /* Avisos Info */
        body.dark-mode .glossary-info-box,
        body.dark-mode .tm-info-box {
            background-color: #451a03 !important;
            color: #fbbf24 !important;
            border-color: #b45309 !important;
        }
        body.dark-mode .glossary-highlight {
            background-color: #b45309 !important;
            color: white !important;
            padding: 2px 4px;
        }

        /* Botones Neutros/Secundarios */
        body.dark-mode .glossary-btn-secondary,
        body.dark-mode .tm-btn-secondary,
        body.dark-mode .btn-modal-neutral,
        body.dark-mode .btn-modal-dark {
            background-color: #374151 !important;
            color: #e5e7eb !important;
            border: 1px solid #4b5563 !important;
        }
        body.dark-mode .glossary-btn-secondary:hover,
        body.dark-mode .tm-btn-secondary:hover {
            background-color: #4b5563 !important;
        }

        /* 4. TABLAS */
        body.dark-mode .glossary-table th,
        body.dark-mode .glossary-table td,
        body.dark-mode .tm-table th,
        body.dark-mode .tm-table td {
            background-color: #1f2937 !important;
            border-color: #374151 !important;
            color: #d1d5db !important;
        }
        body.dark-mode .glossary-table th,
        body.dark-mode .tm-table th {
            background-color: #111827 !important;
        }
        body.dark-mode .glossary-row-highlight {
            background-color: #3f2c22 !important;
        }

        /* 5. MEN√öS SUPERIORES Y DROPDOWNS */
        body.dark-mode .top-utility-buttons-container button,
        body.dark-mode .top-utility-buttons-container .dropdown-btn {
            background-color: #374151 !important;
            color: #e5e7eb !important;
            border-color: #4b5563 !important;
        }
        body.dark-mode .top-utility-buttons-container button:hover,
        body.dark-mode .top-utility-buttons-container .dropdown-btn:hover {
            background-color: #4b5563 !important;
        }
        body.dark-mode .dropdown-content {
            background-color: #374151 !important;
            border: 1px solid #4b5563;
        }
        body.dark-mode .dropdown-content a {
            color: #e5e7eb !important;
        }
        body.dark-mode .dropdown-content a:hover {
            background-color: #4b5563 !important;
        }

        /* 6. ESTADOS ACTIVOS Y DESHABILITADOS (Correcci√≥n Clave) */
        
        /* Bot√≥n Activo (Cuando el panel est√° abierto) */
        body.dark-mode .utility-btn-active {
            background-color: #1f2937 !important; /* Fondo oscuro */
            color: #F48790 !important; /* Texto Rosa Primario */
            border-color: #F48790 !important; /* Borde Rosa */
            box-shadow: inset 0 0 5px rgba(244, 135, 144, 0.2);
        }

        /* Botones Deshabilitados */
        body.dark-mode button:disabled,
        body.dark-mode .disabled-link {
            background-color: #1f2937 !important;
            color: #6b7280 !important; /* Gris apagado */
            border-color: #374151 !important;
            cursor: not-allowed;
            opacity: 0.6;
        }
        body.dark-mode .dropdown-content a.disabled-link:hover {
            background-color: #1f2937 !important;
        }

        /* 7. CHAT Y AI QUICK ACTIONS */
        body.dark-mode #aiChatContainer {
            background-color: #111827 !important;
        }
        body.dark-mode .ai-message-bot {
            background-color: #374151 !important;
            border-color: #4b5563 !important;
            color: #e5e7eb !important;
        }
        body.dark-mode .sidebar-header {
            background-color: #374151 !important;
            border-bottom-color: #4b5563 !important;
        }
        body.dark-mode .sidebar-header h3 {
            color: #f3f4f6 !important;
        }
        
        /* Barra de acciones r√°pidas de IA */
        body.dark-mode .ai-quick-actions {
            background-color: #1f2937 !important; /* Fondo igual que sidebar */
            border-bottom-color: #374151 !important;
        }
        /* Botones de acciones r√°pidas */
        body.dark-mode .ai-quick-btn {
            background-color: #374151 !important;
            color: #e5e7eb !important;
            border-color: #4b5563 !important;
        }
        body.dark-mode .ai-quick-btn:hover {
            background-color: #b45309 !important; /* Ocre al pasar rat√≥n */
            color: white !important;
            border-color: #b45309 !important;
        }
        
        body.dark-mode .text-on-light-contrast {
            color: #e5e7eb !important;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--color-light-gray);
            color: var(--color-dark);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        textarea {
            resize: vertical;
            overflow-y: hidden;
        }
        pre {
            white-space: pre-wrap;
            overflow-wrap: break-word;
        }
        .check-icon {
            display: none;
            margin-left: 8px;
            vertical-align: middle;
            width: 20px;
            height: 20px;
            color: #22c55e;
        }
        /* --- THEMED BUTTONS --- */
        .btn-load, .btn-edit { background-color: var(--color-primary); color: var(--color-dark); }
        .btn-load:hover, .btn-edit:hover { background-color: #e07a82; transform: scale(1.02); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        
        .btn-save, .btn-validate { background-color: var(--color-secondary); color: var(--color-dark); }
        .btn-save:hover, .btn-validate:hover { background-color: #e3b76e; transform: scale(1.02); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        
        .btn-convert-mo { background-color: var(--color-dark); color: var(--color-white); }
        .btn-convert-mo:hover { background-color: #555555; transform: scale(1.02); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        
        /* --- MODAL BUTTONS --- */
        .btn-modal-primary { background-color: var(--color-primary); color: var(--color-dark); }
        .btn-modal-primary:hover { background-color: #e07a82; }
        .btn-modal-secondary { background-color: var(--color-secondary); color: var(--color-dark); }
        .btn-modal-secondary:hover { background-color: #e3b76e; }
        .btn-modal-dark { background-color: var(--color-dark); color: var(--color-white); }
        .btn-modal-dark:hover { background-color: #555555; }
        .btn-modal-neutral { background-color: var(--color-medium-gray); color: var(--color-dark); }
        .btn-modal-neutral:hover { background-color: #d1d5db; }
        
        .po-display-code { background-color: var(--color-medium-gray); border: 1px solid #d1d5db; color: var(--color-dark); }
        .msgstr-textarea { background-color: var(--color-white); color: var(--color-dark); min-height: 80px; }
        .translation-unit-bg { 
            background-color: var(--color-white); 
            border-color: var(--color-medium-gray); 
            content-visibility: auto; 
            contain-intrinsic-size: 200px; 
        }
        .text-on-light-contrast { color: var(--color-dark); }
        .translation-row { display: flex; flex-direction: column; gap: 1rem; }
        @media (min-width: 768px) {
            .translation-row { flex-direction: row; }
            .original-col, .translation-col { flex: 1; }
        }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--color-white); padding: 2rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); max-width: 90%; width: 500px;  position: relative; }
 #findReplaceModal .modal-content { width: 650px; max-width: 95%; }
        #shortcutsModal .modal-content { width: 550px; max-width: 95%; }
        .shortcut-icon { display: inline-block; width: 1em; height: 1em; vertical-align: middle; margin: 0 4px; }
        .main-editor-layout { display: flex; flex-direction: column; gap: 1rem; width: 100%; }
        @media (min-width: 1024px) {
            .main-editor-layout { flex-direction: row; }
            #central-column { flex: 2; }
            .terminology-sidebar, .translation-memory-sidebar { min-width: 300px; max-width: 400px; }
        }
        .sidebar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; cursor: move; user-select: none; }
        .sidebar-content { height: calc(100% - 60px); overflow-y: auto; padding-right: 0.5rem; }
        .glossary-input-group label, .tm-input-group label { white-space: nowrap; }
        .glossary-input-group input, .glossary-input-group select, .tm-input-group input, .tm-input-group select { width: 100%; padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9rem; margin-top: 4px; color: var(--color-dark); background-color: var(--color-white); }
        .glossary-btn-primary, .tm-btn-primary { background-color: var(--color-primary); color: var(--color-dark); padding: 8px 15px; border-radius: 5px; transition: background-color 0.2s; }
        .glossary-btn-primary:hover, .tm-btn-primary:hover { background-color: #e07a82; }
        .glossary-btn-secondary, .tm-btn-secondary { background-color: #e0e0e0; color: #333; padding: 8px 15px; border-radius: 5px; transition: background-color 0.2s; }
        .glossary-btn-secondary:hover, .tm-btn-secondary:hover { background-color: #d0d0d0; }
        .glossary-delete-btn, .tm-delete-btn { background-color: #f44336; color: white; padding: 6px 12px; border-radius: 4px; font-size: 0.85rem; }
        .glossary-delete-btn:hover, .tm-delete-btn:hover { background-color: #da190b; }
        .glossary-table th, .glossary-table td, .tm-table th, .tm-table td { padding: 8px 12px; border: 1px solid #e0e0e0; font-size: 0.9rem; }
        .glossary-table th, .tm-table th { background-color: #f0f0f0; font-weight: 600; }
        
        .tm-table {
            table-layout: fixed;
            width: 100%;
        }

        .glossary-info-box, .tm-info-box { background-color: #fef3c7; border: 1px solid var(--color-secondary); padding: 10px; border-radius: 6px; font-size: 0.85rem; color: var(--color-dark); }
        .glossary-highlight { background-color: var(--color-secondary); padding: 0 2px; border-radius: 3px; }
        .glossary-row-highlight { background-color: #fde68a !important; transition: background-color 0.3s ease; }
        .translation-unit-active { border: 2px solid var(--color-primary); box-shadow: 0 0 0 3px rgba(244, 135, 144, 0.25); }
        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1001; font-size: 1.2rem; color: #333; }
        .loading-spinner { border: 4px solid #f3f3f3; border-top: 4px solid var(--color-primary); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .tm-table th:nth-child(1), .tm-table td:nth-child(1) { width: 70px; text-align: center; }
.tm-table th:nth-child(2), .tm-table td:nth-child(2) { width: 50%; }
.tm-table th:nth-child(3), .tm-table td:nth-child(3) { width: 50%; }
        .tm-best-match-highlight { background-color: #fce7f3 !important; border-color: var(--color-primary) !important; border-width: 2px; box-shadow: 0 0 0 3px rgba(244, 135, 144, 0.25); }
        #dropArea { width: 100%; max-width: 90%; transition: none; }
        .terminology-sidebar, .translation-memory-sidebar { 
            position: fixed; 
            top: 60px; 
            bottom: 20px; 
            width: 350px; 
            z-index: 500; 
            background-color: var(--color-white); 
            border: 1px solid var(--color-medium-gray); 
            border-radius: 0.5rem; 
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); 
            transition: opacity 0.3s ease-in-out; 
            opacity: 0; 
            pointer-events: none; 
            overflow: hidden;
            min-width: 300px; 
            max-width: 80vw;
            min-height: 200px;
            max-height: 90vh;
        }
        .terminology-sidebar { left: 1rem; transform: translateX(-110%); }
        .terminology-sidebar.show-sidebar { transform: translateX(0); opacity: 1; pointer-events: all; }
        .translation-memory-sidebar { right: 1rem; transform: translateX(110%); }
        .translation-memory-sidebar.show-sidebar { transform: translateX(0); opacity: 1; pointer-events: all; }
        
        #central-column { padding-left: 1rem; padding-right: 1rem; transition: padding-left 0.3s ease-in-out, padding-right 0.3s ease-in-out; }
        .translations-container-scrolling { max-height: calc(70vh - 50px); overflow-y: auto; } /* Adjusted height */

        @media (min-width: 1024px) {
            #central-column.left-sidebar-active { padding-left: calc(var(--terminology-sidebar-width, 350px) + 2rem); }
            #central-column.right-sidebar-active { padding-right: calc(var(--translation-memory-sidebar-width, 350px) + 2rem); }
        }
        .po-display-code, .msgstr-textarea { font-size: 1rem; }
        .top-utility-buttons-container { position: absolute; top: 4px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; justify-content: center; gap: 0.75rem; min-width: 400px; }
        .top-utility-buttons-container button, .top-utility-buttons-container .dropdown-btn { font-size: 0.875rem; white-space: nowrap; padding-left: 0.75rem; padding-right: 0.75rem; background-color: var(--color-white); color: var(--color-dark); border: 1px solid #d1d5db; }
        .top-utility-buttons-container button:hover, .top-utility-buttons-container .dropdown-btn:hover { background-color: #f9fafb; }
        .utility-btn-active { background-color: var(--color-dark) !important; color: var(--color-white) !important; border-color: var(--color-dark) !important; }
        .dropdown { position: relative; display: inline-block; }
        .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 1; border-radius: 0.375rem; }
        .dropdown-content a { color: black; padding: 12px 16px; text-decoration: none; display: block; font-size: 0.875rem; }
        .dropdown-content a:hover { background-color: #f1f1f1; cursor: pointer; }
        .dropdown:hover .dropdown-content { display: block; }
        .dropdown:hover .dropdown-btn { background-color: #f9fafb; }
        #statsContainer { transform: translateY(100%); transition: transform 0.3s ease-in-out; }
        #statsContainer.show { transform: translateY(0); }
        .diff-added { background-color: #e6ffed; color: #22863a; padding: 1px 2px; border-radius: 3px; }
        .diff-removed { background-color: #ffebe9; color: #b31d28; text-decoration: line-through; padding: 1px 2px; border-radius: 3px; }
        #backupIndicator {
            display: none;
            width: 8px;
            height: 8px;
            background-color: #22c55e;
            border-radius: 50%;
            margin-left: 8px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
        }
        .search-highlight {
            background-color: yellow;
        }
        .current-search-highlight {
            background-color: orange;
        }
        .resizer {
            position: absolute;
            background: transparent;
            z-index: 10;
        }
        .resizer-t { top: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .resizer-r { top: 0; right: -5px; bottom: 0; width: 10px; cursor: ew-resize; }
        .resizer-b { bottom: -5px; left: 0; right: 0; height: 10px; cursor: ns-resize; }
        .resizer-l { top: 0; left: -5px; bottom: 0; width: 10px; cursor: ew-resize; }
        .resizer-tl { top: -5px; left: -5px; width: 10px; height: 10px; cursor: nwse-resize; }
        .resizer-tr { top: -5px; right: -5px; width: 10px; height: 10px; cursor: nesw-resize; }
        .resizer-bl { bottom: -5px; left: -5px; width: 10px; height: 10px; cursor: nesw-resize; }
        .resizer-br { bottom: -5px; right: -5px; width: 10px; height: 10px; cursor: nwse-resize; }

        /* --- AI ASSISTANT STYLES --- */
        .ai-sidebar {
            position: fixed; top: 60px; right: 1rem; width: 350px; bottom: 20px;
            z-index: 500; background-color: var(--color-white); border: 1px solid var(--color-medium-gray);
            border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: opacity 0.3s ease-in-out; opacity: 0; pointer-events: none; overflow: hidden;
            display: flex; flex-direction: column;
            transform: translateX(110%); /* Start hidden off-screen */
        }
        .ai-sidebar.show-sidebar { transform: translateX(0); opacity: 1; pointer-events: all; }
        
        .ai-chat-container { flex: 1; overflow-y: auto; padding: 1rem; display: flex; flex-direction: column; gap: 0.75rem; background-color: #f9fafb; }
        /* Estilos para el contenido Markdown de la IA */
        .ai-message p { margin-bottom: 0.5rem; }
        .ai-message ul { list-style-type: disc; padding-left: 1.5rem; margin-bottom: 0.5rem; }
        .ai-message ol { list-style-type: decimal; padding-left: 1.5rem; margin-bottom: 0.5rem; }
        .ai-message strong { font-weight: 700; }
        .ai-message li { margin-bottom: 0.25rem; }
        .ai-message-user { align-self: flex-end; background-color: var(--color-primary); color: var(--color-dark); border-bottom-right-radius: 0; }
        .ai-message-bot { align-self: flex-start; background-color: var(--color-white); border: 1px solid #e5e7eb; border-bottom-left-radius: 0; color: #374151; }
        
        .ai-input-area { padding: 0.75rem; border-top: 1px solid #e5e7eb; background-color: var(--color-white); }
        .ai-textarea { width: 100%; resize: none; border: 1px solid #d1d5db; border-radius: 0.375rem; padding: 0.5rem; font-size: 0.9rem; height: 50px; }
        .ai-textarea:focus { outline: none; border-color: var(--color-primary); ring: 1px solid var(--color-primary); }
        
        .ai-quick-actions { display: flex; gap: 0.5rem; padding: 0.5rem 1rem; overflow-x: auto; background-color: #fff; border-bottom: 1px solid #eee; }
        .ai-quick-btn { font-size: 0.75rem; padding: 0.25rem 0.75rem; border-radius: 1rem; background-color: #f3f4f6; color: #4b5563; border: 1px solid #e5e7eb; white-space: nowrap; transition: all 0.2s; }
        .ai-quick-btn:hover { background-color: var(--color-secondary); color: var(--color-dark); border-color: var(--color-secondary); }
        
        .ai-config-panel { background-color: #fffbeb; padding: 0.75rem; border-bottom: 1px solid #fcd34d; font-size: 0.85rem; }
        .ai-insert-btn { display: block; margin-top: 5px; font-size: 0.75rem; color: var(--color-primary); font-weight: 600; cursor: pointer; text-decoration: underline; }
        
        /* Estilo para enlaces de fuente */
        .ai-source-link {
            display: inline-block;
            background-color: #e5e7eb;
            color: #374151;
            font-size: 0.75rem;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 12px;
            text-decoration: none;
            border: 1px solid #d1d5db;
            margin: 0 2px;
            transition: all 0.2s;
            cursor: pointer;
        }
        .ai-source-link:hover {
            background-color: var(--color-secondary);
            color: var(--color-dark);
            border-color: #d97706;
        }
    
        .shortcut-input {
            background-color: #f9fafb;
            border: 1px solid #d1d5db;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            width: 100%;
            text-align: center;
            font-weight: 500;
            cursor: pointer;
        }
        .shortcut-input:focus {
            outline: 2px solid var(--color-primary);
            border-color: var(--color-primary);
        }


   #shortcutsEditor {
            max-height: 50vh; /* Limita la altura al 50% de la ventana */
            overflow-y: auto; /* Muestra el scrollbar vertical si el contenido se desborda */
            padding-right: 1rem; /* A√±ade un peque√±o espacio para que el scrollbar no tape el contenido */
        }

#messageBox {
    z-index: 1001;
}

.dropdown-content a.disabled-link {
        color: #9ca3af; /* Lighter gray text */
        cursor: not-allowed;
        background-color: #f9fafb; /* Match normal background */
    }
    .dropdown-content a.disabled-link:hover {
        background-color: #f9fafb; /* Prevent hover effect */
    }

    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">
    
    <!-- Language Switcher -->
    <div class="absolute top-4 right-4 space-x-2 z-10 flex items-center">
        <button id="langEnBtn" class="px-3 py-1 text-sm font-medium rounded-md transition duration-300">EN</button>
        <button id="langEsBtn" class="px-3 py-1 text-sm font-medium rounded-md transition duration-300">ES</button>
        <button id="darkModeToggle" class="ml-2 p-1 rounded-full hover:bg-gray-200 transition duration-300" title="Dark Mode">üåô</button>
    </div>

    <div class="bg-white p-8 rounded-lg shadow-xl w-full relative mb-4" id="dropArea">
        <!-- Top Utility Buttons -->
        <div class="top-utility-buttons-container">
            <div class="dropdown">
                <button id="projectBtn" class="dropdown-btn font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                    <span data-i18n="project_btn">Project</span>
                </button>
                <div class="dropdown-content">
                    <a id="newProjectBtn" data-i18n="new_project_btn">New Project</a>
                    <a id="openProjectBtn" data-i18n="open_project_btn">Open Project</a>
                    <a id="saveProjectBtn" data-i18n="save_project_btn">Save Project</a>
                </div>
            </div>
            <div class="dropdown">
            <button id="fileBtn" class="dropdown-btn font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="file_menu_btn">File</span> </button>
            <div class="dropdown-content">
                <a id="loadFilePoBtn" data-i18n="load_po_menu">Load .po File</a> <a id="saveFilePoBtn" data-i18n="save_po_menu" class="disabled-link">Save .po File</a> <hr class="my-1 border-gray-200"> <a id="loadFileJsonBtn" data-i18n="load_json_menu">Load JSON Project</a> <a id="saveFileJsonBtn" data-i18n="save_json_menu" class="disabled-link">Save JSON File</a> <hr class="my-1 border-gray-200"><a id="loadFileHtmlBtn">Load .html File</a> <a id="saveFileHtmlBtn" class="disabled-link">Save .html File</a> <hr class="my-1 border-gray-200"> <a id="convertFileMoBtn" data-i18n="convert_mo_menu" class="disabled-link">Convert to .mo</a> </div>
        </div>
            <button id="backupBtn" class="font-medium py-1 px-3 rounded-md shadow-sm transition duration-300 flex items-center">
                <span data-i18n="backup_btn">Backup</span>
                <span id="backupIndicator"></span>
            </button>
            <div class="dropdown">
                <button id="toolsBtn" class="dropdown-btn font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                    <span data-i18n="tools_menu_btn">Tools</span>
                </button>
                <div class="dropdown-content">
                    <a id="findReplaceBtn" data-i18n="find_replace_btn">Find & Replace</a>
                    <a id="shortcutsBtn" data-i18n="shortcuts_btn">Shortcuts</a>
                    <a id="statsBtn" data-i18n="statistics_btn">Statistics</a>
                </div>
            </div>

            <button id="terminologyBtn" class="font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="terminology_btn"></span>
            </button>
            <button id="tmBtn" class="font-medium py-1 px-3 rounded-md shadow-sm transition duration-300">
                <span data-i18n="tm_btn"></span>
            </button>
            <button id="aiBtn" class="font-medium py-1 px-3 rounded-md shadow-sm transition duration-300 flex items-center gap-1">
                <span>üêº</span> <span data-i18n="ai_btn">AI Assistant</span>
            </button>
        </div>

        <div class="flex flex-col items-center mb-6 mt-12">
            <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/poanda-logo-final.png" alt="Poanda Logo" class="max-w-xs h-auto mb-2">
            <div data-i18n="tool_description" id="toolDescription" class="text-lg text-center text-on-light-contrast"></div>
        </div>

        <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mb-6">
            <label for="poFile" class="block font-medium cursor-pointer py-2 px-4 rounded-md shadow-sm transition duration-300 btn-load">
                <span data-i18n="load_file" id="loadBtnText"></span>
                <input type="file" id="poFile" accept=".po" class="hidden">
                <input type="file" id="projectFile" accept=".zip,.poanda" class="hidden">
                <input type="file" id="backupFile" accept=".json,.poanda-backup" class="hidden">
                <input type="file" id="jsonSourceFile" accept=".json" class="hidden">
                <input type="file" id="jsonTargetFile" accept=".json" class="hidden">
                <input type="file" id="htmlSourceFile" accept=".html,.htm" class="hidden">
            </label>
            <button id="savePo" class="font-medium py-2 px-4 rounded-md shadow-sm transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed btn-save" disabled>
                <span data-i18n="save_file" id="saveBtnText"></span>
            </button>
            <button id="convertToMoButton" class="font-medium py-2 px-4 rounded-md shadow-sm transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed btn-convert-mo" disabled>
                <span data-i18n="convert_to_mo_btn"></span>
            </button>
        </div>

        <div class="main-editor-layout" id="mainEditorLayout">
            <!-- Central Column Wrapper -->
            <div id="central-column" class="flex-1 flex flex-col min-w-0">
                <!-- PO Editor Search Bar -->
                <div id="poSearchContainer" class="mb-4 p-4 bg-gray-50 rounded-lg border border-gray-200 hidden">
                    <div class="flex items-center gap-2">
                        <input type="text" id="poSearchInput" data-i18n-placeholder="po_search_placeholder" class="flex-grow p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white">
                        <button id="searchPrevBtn" class="p-1 rounded-md hover:bg-gray-200 disabled:opacity-50" disabled>
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>
                        </button>
                        <button id="searchNextBtn" class="p-1 rounded-md hover:bg-gray-200 disabled:opacity-50" disabled>
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
                        </button>
                        <span id="searchResultCounter" class="text-sm text-gray-600 whitespace-nowrap">0 / 0</span>
                    </div>
                    
                    <div class="flex flex-wrap items-center gap-4 text-sm text-gray-600 mt-2">
                        <label class="flex items-center cursor-pointer">
                            <input type="checkbox" id="searchInOriginalCheckbox" checked class="mr-2">
                            <span data-i18n="search_in_original">Search in original</span>
                        </label>
                        <label class="flex items-center cursor-pointer">
                            <input type="checkbox" id="searchInTranslationCheckbox" checked class="mr-2">
                            <span data-i18n="search_in_translation">Search in translation</span>
                        </label>
                        
                        <div class="hidden sm:block w-px h-4 bg-gray-300 mx-2"></div>
                        
                        <label class="flex items-center cursor-pointer select-none" title="Automatically translate identical segments">
                            <input type="checkbox" id="autoPropagateCheckbox" class="mr-2">
                            <span data-i18n="auto_propagate_label">Auto-propagate translations</span>
                        </label>
                    </div>
                </div>
                <!-- Scrolling Content Area -->
                <div class="translations-container-scrolling pr-2">
                    <div id="translationsContainer" class="space-y-4">
                        <div data-i18n="no_translations" id="initialMessage" class="text-center text-on-light-contrast p-4 border border-gray-300 rounded-md"></div>
                    </div>
                </div>
            </div>
            
            <!-- Sidebars -->
            <div id="terminologySidebar" class="terminology-sidebar p-4 border border-gray-300 rounded-lg shadow-md">
                <div class="resizer resizer-t"></div><div class="resizer resizer-r"></div><div class="resizer resizer-b"></div><div class="resizer resizer-l"></div>
                <div class="resizer resizer-tl"></div><div class="resizer resizer-tr"></div><div class="resizer resizer-bl"></div><div class="resizer resizer-br"></div>
                <div class="sidebar-header">
                    <h3 class="text-lg font-bold text-on-light-contrast" data-i18n="terminology_sidebar_title" id="terminologySidebarTitle"></h3>
                    <div class="flex items-center gap-2">
                        <button class="reset-panel-btn text-gray-500 hover:text-gray-700">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 8.812A9.024 9.024 0 0112 4.5c4.97 0 9 4.03 9 9s-4.03 9-9 9a9.006 9.006 0 01-8.35-5.786"></path></svg>
                        </button>
                        <button id="closeTerminologySidebarBtn" class="text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    </div>
                </div>
                <div class="sidebar-content">
                    <div id="terminologyLanguageConfigSection" class="space-y-4">
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="config_lang_title" id="configLangTitle"></h4>
                        <div class="glossary-info-box mb-4"><p data-i18n="config_lang_info" id="configLangInfo"></p></div>
                        <div class="flex flex-col space-y-2 mb-4">
                            <div class="glossary-input-group"><label for="configSrcLang" data-i18n="source_language" id="sourceLanguageLabel"></label><input id="configSrcLang" list="isoLanguages" value="en-US" class="block w-full" /></div>
                            <div class="glossary-input-group"><label for="configTgtLang" data-i18n="target_language" id="targetLanguageLabel"></label><input id="configTgtLang" list="isoLanguages" value="es-ES" class="block w-full" /></div>
                            <button onclick="confirmGlossaryLanguages()" data-i18n="confirm_languages" id="confirmLanguagesBtn" class="glossary-btn-primary w-full"></button>
                        </div>
                    </div>
                    <div id="terminologyEditorSection" style="display:none;">
                        <div class="flex flex-col sm:flex-row gap-2 mb-4">
                            <button onclick="loadTBX()" data-i18n="import_tbx" id="importTbxBtn" class="glossary-btn-secondary flex-1 text-sm py-2 px-2"></button>
                            <input type="file" id="tbxFileInput" accept=".xml,.tbx" class="hidden" />
                            <button onclick="downloadTBX()" data-i18n="download_tbx" id="downloadTbxBtn" class="glossary-btn-secondary flex-1 text-sm py-2 px-2"></button>
                            <button onclick="resetGlossary()" data-i18n="new_glossary" id="newGlossaryBtn" class="glossary-btn-secondary flex-1 text-sm py-2 px-2"></button>
                        </div>
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="current_lang_title" id="currentLangTitle"></h4>
                        <div class="flex space-x-2 mb-4">
                            <div class="glossary-input-group flex-1"><label data-i18n="source_language" id="displaySourceLanguageLabel"></label><input id="displaySrcLang" disabled class="block w-full" /></div>
                            <div class="glossary-input-group flex-1"><label data-i18n="target_language" id="displayTargetLanguageLabel"></label><input id="displayTgtLang" disabled class="block w-full" /></div>
                        </div>
                        <div class="accordion-item">
                            <div class="accordion-header flex justify-between items-center" id="addTermHeader">
                                <h4 class="text-md font-semibold text-on-light-contrast m-0" data-i18n="add_term_title" id="addTermTitleAccordion"></h4>
                                <svg class="w-5 h-5 accordion-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </div>
                            <div class="accordion-content collapsed" id="addTermContent">
                                <div class="flex flex-col space-y-2 mb-4">
                                    <div class="glossary-input-group"><label for="srcTerm" data-i18n="term" id="termLabel"></label><input id="srcTerm" class="block w-full" /></div>
                                    <div class="glossary-input-group"><label for="tgtTerm" data-i18n="translation" id="translationLabel"></label><input id="tgtTerm" class="block w-full" /></div>
                                    <button onclick="addTerm()" data-i18n="add_button" id="addTermBtn" class="glossary-btn-primary w-full"></button>
                                </div>
                            </div>
                        </div>
                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="search_title" id="searchTitle"></h4>
                        <div class="mb-4"><input id="searchTerm" data-i18n-placeholder="search_placeholder" class="block w-full" oninput="renderGlossary()" /></div>
                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="glossary_list_title" id="glossaryListTitle"></h4>
                        <div class="overflow-x-auto"><table class="glossary-table w-full"><thead><tr><th data-i18n="source_term_col" id="sourceTermCol"></th><th data-i18n="target_term_col" id="targetTermCol"></th><th data-i18n="actions_col" id="actionsCol"></th></tr></thead><tbody id="glossaryTableBody"></tbody></table></div>
                    </div>
                </div>
                <datalist id="isoLanguages"></datalist>
            </div>
            <div id="translationMemorySidebar" class="translation-memory-sidebar p-4 border border-gray-300 rounded-lg shadow-md">
                <div class="resizer resizer-t"></div><div class="resizer resizer-r"></div><div class="resizer resizer-b"></div><div class="resizer resizer-l"></div>
                <div class="resizer resizer-tl"></div><div class="resizer resizer-tr"></div><div class="resizer resizer-bl"></div><div class="resizer resizer-br"></div>
                <div class="sidebar-header">
                    <h3 class="text-lg font-bold text-on-light-contrast" data-i18n="tm_sidebar_title" id="tmSidebarTitle"></h3>
                    <div class="flex items-center gap-2">
                        <button class="reset-panel-btn text-gray-500 hover:text-gray-700">
                             <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 8.812A9.024 9.024 0 0112 4.5c4.97 0 9 4.03 9 9s-4.03 9-9 9a9.006 9.006 0 01-8.35-5.786"></path></svg>
                        </button>
                        <button id="closeTranslationMemorySidebarBtn" class="text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    </div>
                </div>
                <div class="sidebar-content">
                    <div id="tmInternalMessage" class="tm-info-box mb-4 hidden"></div>
                    <div id="tmLanguageConfigSection" class="space-y-4">
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="tm_config_lang_title" id="tmConfigLangTitle"></h4>
                        <div class="tm-info-box mb-4"><p data-i18n="tm_config_lang_info" id="tmConfigLangInfo"></p></div>
                        <div class="flex flex-col space-y-2 mb-4">
                            <div class="tm-input-group"><label for="tmConfigSrcLang" data-i18n="source_language" id="tmSourceLanguageLabel"></label><input id="tmConfigSrcLang" list="isoLanguages" value="en-US" class="block w-full" /></div>
                            <div class="tm-input-group"><label for="tmConfigTgtLang" data-i18n="target_language" id="tmTargetLanguageLabel"></label><input id="tmConfigTgtLang" list="isoLanguages" value="es-ES" class="block w-full" /></div>
                            <button onclick="confirmTMLanguages()" data-i18n="confirm_languages" id="tmConfirmLanguagesBtn" class="tm-btn-primary w-full"></button>
                        </div>
                    </div>
                    <div id="tmEditorSection" style="display:none;">
                        <div class="flex flex-col sm:flex-row gap-2 mb-4">
                            <button onclick="resetTM()" data-i18n="new_tm" id="newTmBtn" class="tm-btn-secondary flex-1 text-sm py-2 px-2"></button>
                            <label for="tmFileInput" class="block font-medium cursor-pointer py-2 px-4 rounded-md shadow-sm transition duration-300 tm-btn-secondary flex-1 text-sm text-center">
                                <span data-i18n="import_tmx" id="importTmxBtnText"></span><input type="file" id="tmFileInput" accept=".xml,.tmx" class="hidden" />
                            </label>
                            <button onclick="downloadTMX()" data-i18n="download_tmx" id="downloadTmxBtn" class="tm-btn-secondary flex-1 text-sm py-2 px-2"></button>
                        </div>
                        <h4 class="text-md font-semibold text-on-light-contrast mb-2" data-i18n="current_tm_lang_title" id="currentTmLangTitle"></h4>
                        <div class="flex space-x-2 mb-4">
                            <div class="tm-input-group flex-1"><label data-i18n="source_language" id="displayTmSourceLanguageLabel"></label><input id="displayTmSrcLang" disabled class="block w-full" /></div>
                            <div class="tm-input-group flex-1"><label data-i18n="target_language" id="displayTmTargetLanguageLabel"></label><input id="displayTmTgtLang" disabled class="block w-full" /></div>
                        </div>
                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="tm_search_title" id="tmSearchTitle"></h4>
                        <div class="mb-4"><input id="tmSearchInput" data-i18n-placeholder="tm_search_placeholder" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm text-black bg-white" oninput="tmSearch()" /></div>
                        <h4 class="text-md font-semibold text-on-light-contrast mt-4 mb-2" data-i18n="tm_search_results_title" id="tmSearchResultsTitle"></h4>
                        <div class="overflow-x-auto mb-4"><table class="tm-table w-full"><thead><tr><th data-i18n="tm_score_col" id="tmScoreCol"></th><th data-i18n="tm_original_col" id="tmOriginalCol"></th><th data-i18n="tm_translation_col" id="tmTranslationCol"></th></tr></thead><tbody id="tmSearchResultsTableBody"></tbody></table></div>
                        <div data-i18n="tm_no_match_found" id="tmNoMatchFoundMessage" class="text-center text-gray-500 p-4 border border-gray-300 rounded-md hidden"></div>
                    </div>
                </div>
            </div>
            <div id="aiSidebar" class="ai-sidebar shadow-xl">
                <div class="resizer resizer-t"></div><div class="resizer resizer-r"></div><div class="resizer resizer-b"></div><div class="resizer resizer-l"></div>
                <div class="resizer resizer-tl"></div><div class="resizer resizer-tr"></div><div class="resizer resizer-bl"></div><div class="resizer resizer-br"></div>
                
                <div class="sidebar-header p-3 border-b border-gray-200 bg-gray-50 flex justify-between items-center cursor-move">
                    <h3 class="text-md font-bold text-gray-700 flex items-center gap-2">ü§ñ PandaBot AI</h3>
                    <div class="flex items-center gap-2">
                        <button id="aiConfigToggleBtn" class="text-gray-500 hover:text-gray-700" data-i18n-title="ai_config_title" title="Configurar API">‚öôÔ∏è</button>
                        <button class="reset-panel-btn text-gray-500 hover:text-gray-700">‚Ü∫</button>
                        <button id="closeAiSidebarBtn" class="text-gray-500 hover:text-gray-700">‚úï</button>
                    </div>
                </div>

                <div id="aiConfigPanel" class="ai-config-panel hidden">
                    <label class="block mb-1 font-bold" data-i18n="ai_api_key_label">Google Gemini API Key:</label>
                    <input type="password" id="geminiApiKeyInput" class="w-full border rounded p-1 mb-2" data-i18n-placeholder="ai_api_key_placeholder" placeholder="Pegar API Key aqu√≠...">
                    <div class="flex justify-end gap-2">
                        <button id="saveApiKeyBtn" class="px-2 py-1 bg-green-500 text-white rounded text-xs hover:bg-green-600" data-i18n="save_button">Guardar</button>
                    </div>
                    <p class="text-xs text-gray-500 mt-1" data-i18n="ai_api_key_info">La clave se guarda localmente en tu navegador.</p>
                </div>

                <div class="ai-quick-actions">
                    <button class="ai-quick-btn" onclick="triggerQuickAI('translate')" data-i18n="ai_quick_translate">Traducir</button>
                    <button class="ai-quick-btn" onclick="triggerQuickAI('improve')" data-i18n="ai_quick_improve">Mejorar</button>
                    <button class="ai-quick-btn" onclick="triggerQuickAI('explain')" data-i18n="ai_quick_explain">Explicar</button>
                    <button class="ai-quick-btn" onclick="triggerQuickAI('fix')" data-i18n="ai_quick_fix">Corregir</button>
                </div>

                <div id="aiChatContainer" class="ai-chat-container">
                    </div>

                <div class="ai-input-area">
                    <div class="flex gap-2">
                        <textarea id="aiUserInput" class="ai-textarea" data-i18n-placeholder="ai_input_placeholder" placeholder="Escribe tu consulta... (Enter para enviar)"></textarea>
                        <button id="aiSendBtn" class="bg-red-400 text-white px-3 rounded hover:bg-red-500">‚û§</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="messageBox" class="modal hidden"><div class="modal-content"><p id="messageText" class="text-lg font-semibold text-on-light-contrast mb-4"></p><button id="messageClose" class="py-2 px-4 rounded-md transition duration-300 btn-modal-primary"><span data-i18n="ok" id="okBtnText"></span></button></div></div>
        
        <div id="shortcutsModal" class="modal hidden">
            <div class="modal-content">
                <h2 data-i18n="shortcuts_title" class="text-xl font-bold mb-4 text-on-light-contrast"></h2>
                <div id="shortcutsEditor" class="space-y-4">
                    <!-- Shortcut editor content will be generated here by JS -->
                </div>
                <div class="flex flex-wrap justify-end gap-2 mt-6">
                    <button id="importShortcutsBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-secondary"><span data-i18n="import_shortcuts_btn"></span></button>
                    <input type="file" id="importShortcutsInput" class="hidden" accept=".json">
                    <button id="exportShortcutsBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-secondary"><span data-i18n="export_shortcuts_btn"></span></button>
                    <button id="resetShortcutsBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-dark"><span data-i18n="reset_defaults_btn"></span></button>
                </div>
                <div class="flex justify-end gap-2 mt-4">
                    <button id="shortcutsCloseBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-neutral"><span data-i18n="cancel_button"></span></button>
                    <button id="saveShortcutsBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-primary"><span data-i18n="save_button"></span></button>
                </div>
            </div>
        </div>

        <div id="findReplaceModal" class="modal hidden"><div class="modal-content"><h2 data-i18n="find_replace_title" id="findReplaceTitle" class="text-xl font-bold mb-4 text-on-light-contrast"></h2><div class="space-y-4"><div><label for="findInput" data-i18n="find_label" id="findLabel" class="block text-sm font-medium text-on-light-contrast mb-1"></label><input type="text" id="findInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></div><div><label for="replaceInput" data-i18n="replace_label" id="replaceLabel" class="block text-sm font-medium text-on-light-contrast mb-1"></label><input type="text" id="replaceInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></div><div class="flex items-center space-x-4"><label class="flex items-center text-on-light-contrast"><input type="checkbox" id="caseSensitiveCheckbox" class="mr-2"><span data-i18n="case_sensitive" id="caseSensitiveText"></span></label><label class="flex items-center text-on-light-contrast"><input type="checkbox" id="regexCheckbox" class="mr-2"><span data-i18n="regular_expression" id="regexText"></span></label></div><div class="flex justify-end space-x-2"><button data-i18n="find_prev" id="findPrevBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-neutral"><span id="findPrevText"></span></button><button data-i18n="find_next" id="findNextBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-neutral"><span id="findNextText"></span></button><button data-i18n="replace" id="replaceBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-secondary"><span id="replaceText"></span></button><button data-i18n="replace_all" id="replaceAllBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-primary"><span id="replaceAllText"></span></button></div></div><button data-i18n="close_btn" id="findReplaceCloseBtn" class="mt-6 py-2 px-4 rounded-md transition duration-300 w-full btn-modal-dark"><span id="findReplaceCloseBtnText"></span></button></div></div>
        <div id="saveProjectModal" class="modal hidden"><div class="modal-content"><h2 data-i18n="save_project_title" id="saveProjectTitle" class="text-xl font-bold mb-4 text-on-light-contrast"></h2><div class="space-y-4"><div><label for="projectFilenameInput" data-i18n="filename_label" id="filenameLabel" class="block text-sm font-medium text-on-light-contrast mb-1"></label><input type="text" id="projectFilenameInput" class="w-full border border-gray-300 rounded-md shadow-sm p-2 text-black bg-white"></div></div><div class="flex justify-end space-x-2 mt-6"><button id="saveProjectCancelBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-neutral"><span data-i18n="cancel_button"></span></button><button id="saveProjectConfirmBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-primary"><span data-i18n="save_button"></span></button></div></div></div>
        
        <div id="backupModal" class="modal hidden">
            <div class="modal-content">
                <h2 data-i18n="backup_title" class="text-xl font-bold mb-4 text-on-light-contrast"></h2>
                <p data-i18n="backup_info_text" class="text-on-light-contrast mb-4"></p>
                <div class="bg-gray-100 p-3 rounded-md mb-6">
                    <p class="text-sm text-gray-700"><strong data-i18n="last_backup_label"></strong> <span id="lastBackupTime"></span></p>
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <button id="loadLocalBackupBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 disabled:opacity-50 btn-modal-primary" disabled><span data-i18n="load_local_backup_btn"></span></button>
                    <button id="saveBackupToDiskBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 disabled:opacity-50 btn-modal-secondary" disabled><span data-i18n="save_backup_to_disk_btn"></span></button>
                    <label class="font-medium py-2 px-4 rounded-md transition duration-300 cursor-pointer text-center btn-modal-secondary"><span data-i18n="load_backup_from_disk_btn"></span><input type="file" id="loadBackupFromFileInput" class="hidden" accept=".json,.poanda-backup"/></label>
                    <button id="deleteLocalBackupBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 disabled:opacity-50 btn-modal-dark" disabled><span data-i18n="delete_local_backup_btn"></span></button>
                </div>
                 <button id="backupCloseBtn" class="mt-6 py-2 px-4 rounded-md transition duration-300 w-full btn-modal-neutral"><span data-i18n="close_btn"></span></button>
            </div>
        </div>

        <div id="restoreBackupModal" class="modal hidden"><div class="modal-content"><h2 data-i18n="restore_backup_title" id="restoreBackupTitle" class="text-xl font-bold mb-4 text-on-light-contrast"></h2><p data-i18n="restore_backup_info" id="restoreBackupInfo" class="text-on-light-contrast mb-6"></p><div class="flex justify-end space-x-2"><button id="discardBackupBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-neutral"><span data-i18n="discard_button"></span></button><button id="restoreBackupBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-primary"><span data-i18n="restore_button"></span></button></div></div></div>

        <div id="convertToMoModal" class="modal hidden">
            <div class="modal-content">
                <h2 data-i18n="mo_converter_title" class="text-xl font-bold mb-4 text-on-light-contrast"></h2>
                <p data-i18n="mo_converter_info" class="text-on-light-contrast mb-6"></p>
                <div class="flex justify-end space-x-2">
                    <button id="moConverterCloseBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-neutral"><span data-i18n="close_btn"></span></button>
                    <button id="moConverterActionBtn" class="font-medium py-2 px-4 rounded-md transition duration-300 btn-modal-primary"><span data-i18n="mo_converter_action_btn"></span></button>
                </div>
            </div>
        </div>
    </div>

    <div id="statsContainer" class="fixed bottom-0 left-0 right-0 bg-white p-3 border-t border-gray-200 shadow-lg z-[900]"><div class="max-w-7xl mx-auto text-sm text-center text-gray-700 flex flex-wrap justify-center md:justify-around items-center gap-x-6 gap-y-2"><p><strong class="font-semibold" data-i18n="stats_progress_label"></strong> <span id="segmentsProgress">0/0 segments (0%)</span></p><p><strong class="font-semibold" data-i18n="stats_words_label"></strong> <span id="wordsTranslated">0</span> / <span id="wordsTotal">0</span></p><p><strong class="font-semibold" data-i18n="stats_remaining_label"></strong> <span id="wordsRemaining">0</span></p></div></div>
    <div id="loadingOverlay" class="loading-overlay hidden"><div class="loading-spinner"></div><p id="loadingMessage"></p></div>

    <script>
        // Global variables for Poanda editor
        let poEntries = [];
        let currentFileName = 'translations.po';
        let currentLanguage = 'en'; // Default language set to English
        let findState = {
            query: '',
            replace: '',
            caseSensitive: false,
            useRegex: false,
            lastFound: null,
        };
        let searchResults = [];
        let currentSearchIndex = -1;
        let currentFileType = null; // Can be 'po', 'json', or null
        let currentJsonSourceFileName = null;
        let currentJsonTargetFileName = null;
        // Global variables for HTML handling
        let currentHtmlDoc = null; 
        let htmlNodeMap = [];
        let currentRawHtml = "";

        // Global variable to keep track of terms found in the currently active/focused segment's original text
        let termsFoundInActiveSegment = new Set(); // Stores terms found in the currently focused original segment

        // Global variables for Terminology (Glossary)
        let glossary = [];
        let glossarySourceLanguage = '';
        let glossaryTargetLanguage = '';
        let currentGlossaryLatestResults = []; // Stores the last set of results rendered in glossary table for shortcuts


        // Global variables for Translation Memory (TM)
        let translationMemory = []; // Stores {srcLang, srcText, tgtLang, tgtText, srcWordCount, tgtWordCount}
        let tmSourceLanguage = ''; // Will typically be the source language of the PO file
        let tmTargetLanguage = ''; // Will typically be the target language of the PO file
        let tmBestMatchForActiveSegment = null; // Stores the best TM match for the currently focused segment
        let currentTMLatestSearchResults = []; // Stores the last set of results rendered in TM search table
        let lastFocusedSegment = null; // Stores the last active segment for AI context

        // Global variables for AI Assistant
        let aiApiKey = localStorage.getItem('poanda_gemini_key') || '';
        const aiSidebar = document.getElementById('aiSidebar');
        const aiChatContainer = document.getElementById('aiChatContainer');
        let lastAiResponseText = ""; // Almacena la √∫ltima respuesta para el atajo

        // DOM elements for Poanda editor
        const poFile = document.getElementById('poFile');
        const savePoButton = document.getElementById('savePo');
        const translationsContainer = document.getElementById('translationsContainer');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageClose = document.getElementById('messageClose');
        const poandaLogo = document.querySelector('.max-w-xs');
        const dropArea = document.getElementById('dropArea');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const mainEditorLayout = document.getElementById('mainEditorLayout');

        // PO Editor Search DOM elements
        const poSearchContainer = document.getElementById('poSearchContainer');
        const poSearchInput = document.getElementById('poSearchInput');
        const searchInOriginalCheckbox = document.getElementById('searchInOriginalCheckbox');
        const searchInTranslationCheckbox = document.getElementById('searchInTranslationCheckbox');
        const searchPrevBtn = document.getElementById('searchPrevBtn');
        const searchNextBtn = document.getElementById('searchNextBtn');
        const searchResultCounter = document.getElementById('searchResultCounter');


        // Project DOM elements
        const projectFileInput = document.getElementById('projectFile');
        const newProjectBtn = document.getElementById('newProjectBtn');
        const openProjectBtn = document.getElementById('openProjectBtn');
        const saveProjectBtn = document.getElementById('saveProjectBtn');
        
        // Save Project Modal DOM elements
        const saveProjectModal = document.getElementById('saveProjectModal');
        const projectFilenameInput = document.getElementById('projectFilenameInput');
        const saveProjectConfirmBtn = document.getElementById('saveProjectConfirmBtn');
        const saveProjectCancelBtn = document.getElementById('saveProjectCancelBtn');

        // Restore Backup Modal DOM elements
        const restoreBackupModal = document.getElementById('restoreBackupModal');
        const restoreBackupBtn = document.getElementById('restoreBackupBtn');
        const discardBackupBtn = document.getElementById('discardBackupBtn');
        
        // Backup Modal DOM elements
        const backupBtn = document.getElementById('backupBtn');
        const backupIndicator = document.getElementById('backupIndicator');
        const backupModal = document.getElementById('backupModal');
        const lastBackupTime = document.getElementById('lastBackupTime');
        const loadLocalBackupBtn = document.getElementById('loadLocalBackupBtn');
        const saveBackupToDiskBtn = document.getElementById('saveBackupToDiskBtn');
        const loadBackupFromFileInput = document.getElementById('loadBackupFromFileInput');
        const deleteLocalBackupBtn = document.getElementById('deleteLocalBackupBtn');
        const backupCloseBtn = document.getElementById('backupCloseBtn');
        const backupFileInput = document.getElementById('backupFile');


        // Statistics DOM elements
        const statsBtn = document.getElementById('statsBtn');
        const statsContainer = document.getElementById('statsContainer');
        const segmentsProgress = document.getElementById('segmentsProgress');
        const wordsTranslated = document.getElementById('wordsTranslated');
        const wordsTotal = document.getElementById('wordsTotal');
        const wordsRemaining = document.getElementById('wordsRemaining');


        // Poanda Modals
        const shortcutsBtn = document.getElementById('shortcutsBtn');
        const shortcutsModal = document.getElementById('shortcutsModal');
        const shortcutsCloseBtn = document.getElementById('shortcutsCloseBtn');
        const findReplaceBtn = document.getElementById('findReplaceBtn');
        const findReplaceModal = document.getElementById('findReplaceModal');
        const findInput = document.getElementById('findInput');
        const replaceInput = document.getElementById('replaceInput');
        const caseSensitiveCheckbox = document.getElementById('caseSensitiveCheckbox');
        const regexCheckbox = document.getElementById('regexCheckbox');
        const findPrevBtn = document.getElementById('findPrevBtn');
        const findNextBtn = document.getElementById('findNextBtn');
        const replaceBtn = document.getElementById('replaceBtn');
        const replaceAllBtn = document.getElementById('replaceAllBtn');
        const findReplaceCloseBtn = document.getElementById('findReplaceCloseBtn');

        // Shortcuts Modal DOM elements
        const shortcutsEditor = document.getElementById('shortcutsEditor');
        const saveShortcutsBtn = document.getElementById('saveShortcutsBtn');
        const importShortcutsBtn = document.getElementById('importShortcutsBtn');
        const importShortcutsInput = document.getElementById('importShortcutsInput');
        const exportShortcutsBtn = document.getElementById('exportShortcutsBtn');
        const resetShortcutsBtn = document.getElementById('resetShortcutsBtn');

        // Terminology Sidebar DOM elements
        const terminologyBtn = document.getElementById('terminologyBtn');
        const terminologySidebar = document.getElementById('terminologySidebar');
        const closeTerminologySidebarBtn = document.getElementById('closeTerminologySidebarBtn');
        const terminologyLanguageConfigSection = document.getElementById('terminologyLanguageConfigSection');
        const terminologyEditorSection = document.getElementById('terminologyEditorSection');
        const configSrcLang = document.getElementById('configSrcLang');
        const configTgtLang = document.getElementById('configTgtLang');
        const displaySrcLang = document.getElementById('displaySrcLang');
        const displayTgtLang = document.getElementById('displayTgtLang');
        const srcTermInput = document.getElementById('srcTerm');
        const tgtTermInput = document.getElementById('tgtTerm');
        const searchTermInput = document.getElementById('searchTerm');
        const glossaryTableBody = document.getElementById('glossaryTableBody');
        const tbxFileInput = document.getElementById('tbxFileInput');
        const isoLanguagesDatalist = document.getElementById('isoLanguages');

        // Buttons directly in config/editor sections for TBX
        const importTbxBtn = document.getElementById('importTbxBtn');
        const newGlossaryBtn = document.getElementById('newGlossaryBtn');
        const addTermHeader = document.getElementById('addTermHeader');
        const addTermContent = addTermHeader ? addTermHeader.nextElementSibling : null;
        const addTermAccordionIcon = addTermHeader ? addTermHeader.querySelector('.accordion-icon') : null;

        // Translation Memory Sidebar DOM elements
        const tmBtn = document.getElementById('tmBtn');
        const translationMemorySidebar = document.getElementById('translationMemorySidebar');
        const closeTranslationMemorySidebarBtn = document.getElementById('closeTranslationMemorySidebarBtn');
        const tmFileInput = document.getElementById('tmFileInput');
        const tmSearchInput = document.getElementById('tmSearchInput');
        const tmSearchResultsTableBody = document.getElementById('tmSearchResultsTableBody');
        const tmNoMatchFoundMessage = document.getElementById('tmNoMatchFoundMessage');
        // New TM config DOM elements
        const tmLanguageConfigSection = document.getElementById('tmLanguageConfigSection');
        const tmEditorSection = document.getElementById('tmEditorSection');
        const tmConfigSrcLang = document.getElementById('tmConfigSrcLang');
        const tmConfigTgtLang = document.getElementById('tmConfigTgtLang');
        const displayTmSrcLang = document.getElementById('displayTmSrcLang');
        const displayTmTgtLang = document.getElementById('displayTmTgtLang');
        const tmInternalMessage = document.getElementById('tmInternalMessage'); // New TM internal message element

        // DOM element for main content editor, needed for padding adjustments
        const centralColumn = document.getElementById('central-column');

        // NEW: PO to MO Converter DOM Elements
        const convertToMoButton = document.getElementById('convertToMoButton');
        const convertToMoModal = document.getElementById('convertToMoModal');
        const moConverterCloseBtn = document.getElementById('moConverterCloseBtn');
        const moConverterActionBtn = document.getElementById('moConverterActionBtn');

        // Translations object for EN and ES
        const translations = {
            'en': {
                'title': 'Poanda',
                'load_file': 'Load .po file',
                'save_file': 'Save .po file',
                'convert_to_mo_btn': 'Convert to .mo',
                'original_msgid': 'Original (msgid):',
                'translation_msgstr': 'Translation (msgstr):',
                'context_msgctxt': 'Context (msgctxt):',
                'validate': 'Validate',
                'edit': 'Edit',
                'fuzzy': 'Fuzzy',
                'char_count_original': 'Original: ',
                'char_count_translation': 'Translation: ',
                'char_units': ' characters',
                'no_translations': 'Welcome to Poanda! You are in a new, empty project. Load a `.po` file to edit it or open an existing `.poanda` project.',
                'error_reading_file': 'Error reading or parsing .po file: ',
                'error_saving_file': 'Error saving .po file: ',
                'file_saved_successfully': '.po file saved successfully.',
                'tbx_saved_successfully': 'TBX file saved successfully.',
                'no_translations_to_save': 'No translations to save. Load a .po file first.',
                'reached_last': 'You have reached the last translation.',
                'reached_first': 'You are already at the first translation.',
                'file_processing_error': 'Error! Could not process the file. Make sure it is a valid .po file.',
                'tool_description': 'A simple tool for editing .po files.',
                'ok': 'OK',
                'shortcuts_btn': 'Shortcuts',
                'shortcuts_title': 'Keyboard Shortcuts',
                'shortcut_validate': 'Validate & Next Segment',
                'shortcut_next': 'Next Segment',
                'shortcut_prev': 'Previous Segment',
                'shortcut_tm_insert_1': 'Insert TM Match 1',
                'shortcut_tm_insert_2': 'Insert TM Match 2',
                'shortcut_tm_insert_3': 'Insert TM Match 3',
                'shortcut_tm_insert_4': 'Insert TM Match 4',
                'shortcut_tm_insert_5': 'Insert TM Match 5',
                'shortcut_glossary_insert_1': 'Insert Glossary Term 1',
                'shortcut_glossary_insert_2': 'Insert Glossary Term 2',
                'shortcut_glossary_insert_3': 'Insert Glossary Term 3',
                'shortcut_glossary_insert_4': 'Insert Glossary Term 4',
                'shortcut_glossary_insert_5': 'Insert Glossary Term 5',
                'shortcut_toggleAI': 'Toggle AI Assistant',
                'save_shortcuts_btn': 'Save Shortcuts',
                'import_shortcuts_btn': 'Import',
                'export_shortcuts_btn': 'Export',
                'reset_defaults_btn': 'Reset to Defaults',
                'shortcuts_saved': 'Shortcuts saved successfully!',
                'shortcuts_loaded': 'Shortcuts imported successfully!',
                'shortcuts_reset': 'Shortcuts have been reset to default.',
                'error_loading_shortcuts': 'Error loading shortcuts file. Ensure it is a valid JSON configuration.',
                'click_to_set_shortcut': 'Click and press the desired key combination',
                'close_btn': 'Close',
                'find_replace_btn': 'Find & Replace',
                'find_replace_title': 'Find and Replace',
                'find_label': 'Find:',
                'replace_label': 'Replace with:',
                'case_sensitive': 'Case sensitive',
                'regular_expression': 'Regular expression',
                'find_prev': 'Find previous',
                'find_next': 'Find next',
                'replace': 'Replace',
                'replace_all': 'Replace all',
                'no_match_found': 'No match found.',
                'replaced_all': 'All occurrences replaced.',
                'no_find_query': 'Please enter text to find.',
                'loading_file': 'Loading file...',
                'saving_file': 'Saving file...',
                'terminology_btn': 'Terminology',
                'terminology_sidebar_title': 'Terminology',
                'config_lang_title': 'Configure Glossary Languages',
                'config_lang_info': 'Define the source and target languages for your glossary. You can enter the ISO code directly or select from the suggestions. It is crucial that the ISO code is correct for it to work properly with your CAT tool.',
                'source_language': 'Source Language:',
                'target_language': 'Target Language:',
                'confirm_languages': 'Confirm Languages',
                'current_lang_title': 'Current Glossary Languages',
                'add_term_title': 'Add Term',
                'term': 'Term:',
                'translation': 'Translation:',
                'add_button': 'Add',
                'search_title': 'Search',
                'search_placeholder': 'Search term...',
                'import_tbx': 'Import TBX',
                'download_tbx': 'Download TBX',
                'new_glossary': 'New Glossary',
                'glossary_list_title': 'Glossary',
                'source_term_col': 'Source Term',
                'target_term_col': 'Target Term',
                'actions_col': 'Actions',
                'delete_button': 'Delete',
                'both_terms_required': 'Both terms are required.',
                'lang_config_required': 'Please configure the source and target languages for the glossary.',
                'cannot_download_empty_or_unconfigured_glossary': 'Cannot download an empty or unconfigured glossary.',
                'error_loading_tbx_file': 'Error loading TBX file. Make sure it is a valid XML/TBX.',
                'no_valid_language_pairs_found_in_tbx': 'No valid language pairs were found in the TBX file. Default values (en-US, es-ES) will be used.',
                'statistics_btn': 'Statistics',
                'stats_progress_label': 'Progress:',
                'stats_words_label': 'Words (Translated / Total):',
                'stats_remaining_label': 'Remaining Words:',
                'tm_btn': 'Translation Memory',
                'tm_sidebar_title': 'Translation Memory (TM)',
                'new_tm': 'New TM',
                'import_tmx': 'Import TMX',
                'download_tmx': 'Download TMX',
                'no_tm_data': 'No data in the translation memory.',
                'tm_source_segment': 'Original:',
                'tm_target_segment': 'Translation:',
                'tm_match_score': 'Match:',
                'tm_no_match_found': 'No matches found in the TM.',
                'tm_insert_match': 'Insert match',
                'error_loading_tmx_file': 'Error loading TMX file. Make sure it is a valid XML/TMX.',
                'cannot_download_empty_tm': 'Cannot download an empty translation memory.',
                'tm_best_match': 'Best TM match:',
                'tm_search_title': 'Search in TM',
                'tm_search_placeholder': 'Search in memory...',
                'tm_search_results_title': 'TM Search Results',
                'tm_score_col': '%',
                'tm_original_col': 'Original',
                'tm_translation_col': 'Translation',
                'tm_config_lang_title': 'Configure TM Languages',
                'tm_config_lang_info': 'Define the source and target languages for your Translation Memory. It is crucial that the ISO code is correct for matching to work properly.',
                'current_tm_lang_title': 'Current TM Languages',
                'tm_initial_message': 'Create a new TM or import a TMX file to start working with the translation memory.',
                'tmx_file_expected_tbx_found': 'This file appears to be a glossary (TBX). Please use the "Import TBX" option in the Terminology panel.',
                'tbx_file_expected_tmx_found': 'This file appears to be a translation memory (TMX). Please use the "Import TMX" option in the Translation Memory panel.',
                'project_btn': 'Project',
                'new_project_btn': 'New Project',
                'open_project_btn': 'Open Project',
                'save_project_btn': 'Save Project',
                'project_saved': 'Project saved successfully.',
                'error_saving_project': 'Error saving project.',
                'no_project_to_save': 'There is no active .po file to save as a project.',
                'loading_project': 'Loading project...',
                'project_loaded': 'Project loaded successfully.',
                'error_opening_project': 'Error opening project file.',
                'invalid_project_file': 'Invalid project file. The zip must contain a .po file.',
                'new_project_confirm': 'Are you sure you want to start a new project? All unsaved progress will be lost.',
                'save_project_title': 'Save Project',
                'filename_label': 'Filename:',
                'save_button': 'Save',
                'cancel_button': 'Cancel',
                'enter_filename': 'Please enter a filename.',
                'restore_backup_title': 'Restore Session',
                'restore_backup_info': 'We found a backup of your previous session. Would you like to restore it?',
                'restore_button': 'Restore',
                'discard_button': 'Discard',
                'backup_btn': 'Backup',
                'backup_title': 'Backup Management',
                'backup_info_text': 'Poanda automatically saves a local backup of your entire session (PO file, TM, and glossary) to your browser every 10 seconds. You can restore this backup here or save it to a file for safekeeping.',
                'last_backup_label': 'Last backup:',
                'no_backup_available': 'No backup available.',
                'load_local_backup_btn': 'Load Local Backup',
                'save_backup_to_disk_btn': 'Save Backup to Disk',
                'load_backup_from_disk_btn': 'Load Backup from Disk',
                'delete_local_backup_btn': 'Delete Local Backup',
                'backup_deleted': 'Local backup has been deleted.',
                'backup_loaded_from_file': 'Backup loaded successfully from file.',
                'error_loading_backup_file': 'Error loading backup file. Ensure it is a valid .poanda-backup file.',
                'delete_local_backup_btn_confirm': 'Are you sure you want to delete the local backup? This action cannot be undone.',
                'mo_converter_title': 'PO to MO Converter',
                'mo_converter_info': 'This will compile the current .po file into a binary .mo file. The conversion happens entirely in your browser.',
                'mo_converter_action_btn': 'Convert and download .mo',
                'mo_conversion_success': 'MO file converted and downloaded successfully.',
                'mo_conversion_error': 'Error during MO conversion. Check the browser console (F12) for details.',
                'no_file_to_convert': 'No .po file loaded to convert.',
                'po_search_placeholder': 'Search in file...',
                'search_in_original': 'Search in original',
                'search_in_translation': 'Search in translation',
                'auto_propagate_label': 'Auto-propagate translations',
                'file_menu_btn': 'File',
                'tools_menu_btn': 'Tools',
                'load_po_menu': 'Load .po file',
                'save_po_menu': 'Save .po file',
                'load_json_menu': 'Load .json file',
                'save_json_menu': 'Save .json file',
                'convert_mo_menu': 'Convert to .mo',
                'prompt_select_source_json': 'Please select the SOURCE language JSON file (e.g., en.json)',
                'prompt_select_target_json': 'Please select the TARGET language JSON file (e.g., es.json). Cancel if this is a new translation.',
                'error_loading_json': 'Error reading or parsing JSON file: ',
                'json_loaded_success': 'JSON project loaded successfully.',
                'json_save_filename_prompt': 'Enter filename for the target JSON (e.g., es.json):',
                'error_saving_json': 'Error saving JSON file: ',
                'json_saved_success': 'JSON file saved successfully.',
                'not_a_json_project': 'Cannot save as JSON. Please load a JSON project first.',
                'not_a_po_project': 'Cannot save as PO/MO. Please load a .po file first.',
                'select_file_error': 'File selection failed or cancelled.',
                'copy_original_btn': 'Copy original text to translation field',
                'copy_error': 'Failed to copy text.', 
                'edit_first_message': 'Please click Edit before copying.',
                'ai_btn': 'AI Assistant',
                'ai_no_api_key': 'Please configure your Gemini API Key in the settings (‚öôÔ∏è) icon above.',
                'ai_no_segment': 'Please select/edit a segment first to give me context.',
                'ai_thinking': 'PandaBot is thinking... üêº',
                'ai_error': 'Error connecting to AI: ',
                'ai_inserted': 'Translation inserted!',
                'ai_prompt_translate': 'Translate this text accurately considering the context.',
                'ai_prompt_improve': 'Improve the style and flow of the current translation.',
                'ai_prompt_explain': 'Explain the meaning and nuances of the source text.',
                'ai_prompt_fix': 'Fix grammar, spelling, or consistency errors in the translation.',
                'ai_quick_translate': 'Translate',
                'ai_quick_improve': 'Improve',
                'ai_quick_explain': 'Explain',
                'ai_quick_fix': 'Fix',
                'ai_initial_message': 'Hi, I\'m PandaBot üêº. Configure your Gemini API Key and select a segment to start.',
                'ai_link_source': 'Source',
                'shortcut_insertLastAI': 'Insert Last AI Response',
                'no_ai_response_yet': 'No AI response to insert yet.',
                'ai_input_placeholder': 'Type your query... (Enter to send)',
                'ai_api_key_label': 'Google Gemini API Key:',
                'ai_api_key_placeholder': 'Paste API Key here...',
                'ai_api_key_info': 'The key is saved locally in your browser.',
                'ai_config_title': 'Configure API',
                'ai_input_placeholder': 'Type your query... (Enter to send)',
                'ai_api_key_label': 'Google Gemini API Key:',
                'ai_api_key_placeholder': 'Paste API Key here...',
                'ai_api_key_info': 'The key is saved locally in your browser.',
                'ai_config_title': 'Configure API',
                'ai_quick_translate': 'Translate',
                'ai_quick_improve': 'Improve',
                'ai_quick_explain': 'Explain',
                'ai_quick_fix': 'Fix',
                'ai_initial_message': 'Hi, I\'m PandaBot üêº. Configure your Gemini API Key and select a segment to start.',
                'ai_link_source': 'Source',
                'shortcut_insertLastAI': 'Insert Last AI Response',
                'no_ai_response_yet': 'No AI response to insert yet.',
                
            },
            'es': {
                'title': 'Poanda',
                'load_file': 'Cargar archivo .po',
                'save_file': 'Guardar archivo .po',
                'convert_to_mo_btn': 'Convertir a .mo',
                'original_msgid': 'Original (msgid):',
                'translation_msgstr': 'Traducci√≥n (msgstr):',
                'context_msgctxt': 'Contexto (msgctxt):',
                'validate': 'Validar',
                'edit': 'Editar',
                'fuzzy': 'Difuso',
                'char_count_original': 'Original: ',
                'char_count_translation': 'Traducci√≥n: ',
                'char_units': ' caracteres',
                'no_translations': '¬°Te damos la bienvenida a Poanda! Ya te encuentras en un proyecto nuevo y vac√≠o. Carga un archivo `.po` o abre un proyecto para empezar a trabajar.',
                'error_reading_file': 'Error al leer o analizar archivo .po: ',
                'error_saving_file': 'Error al guardar archivo .po: ',
                'file_saved_successfully': 'Archivo .po guardado con √©xito.',
                'tbx_saved_successfully': 'Archivo TBX guardado con √©xito.',
                'no_translations_to_save': 'No hay traducciones para guardar. Carga un archivo .po primero.',
                'reached_last': 'Has llegado a la √∫ltima traducci√≥n.',
                'reached_first': 'Ya est√°s en la primera traducci√≥n.',
                'file_processing_error': '¬°Error! No se pudo procesar el archivo. Aseg√∫rate de que es un archivo .po v√°lido.',
                'tool_description': 'Una herramienta sencilla para editar archivos .po.',
                'ok': 'OK',
                'shortcuts_btn': 'Atajos',
                'shortcuts_title': 'Atajos de teclado',
                'shortcut_validate': 'Validar e ir al siguiente segmento',
                'shortcut_next': 'Siguiente segmento',
                'shortcut_prev': 'Segmento anterior',
                'shortcut_tm_insert_1': 'Insertar concordancia de MT 1',
                'shortcut_tm_insert_2': 'Insertar concordancia de MT 2',
                'shortcut_tm_insert_3': 'Insertar concordancia de MT 3',
                'shortcut_tm_insert_4': 'Insertar concordancia de MT 4',
                'shortcut_tm_insert_5': 'Insertar concordancia de MT 5',
                'shortcut_glossary_insert_1': 'Insertar t√©rmino del glosario 1',
                'shortcut_glossary_insert_2': 'Insertar t√©rmino del glosario 2',
                'shortcut_glossary_insert_3': 'Insertar t√©rmino del glosario 3',
                'shortcut_glossary_insert_4': 'Insertar t√©rmino del glosario 4',
                'shortcut_glossary_insert_5': 'Insertar t√©rmino del glosario 5',
                'shortcut_toggleAI': 'Alternar Asistente de IA',
                'save_shortcuts_btn': 'Guardar atajos',
                'import_shortcuts_btn': 'Importar',
                'export_shortcuts_btn': 'Exportar',
                'reset_defaults_btn': 'Restablecer',
                'shortcuts_saved': '¬°Atajos guardados correctamente!',
                'shortcuts_loaded': '¬°Atajos importados correctamente!',
                'shortcuts_reset': 'Los atajos se han restablecido a los valores por defecto.',
                'error_loading_shortcuts': 'Error al cargar el archivo de atajos. Aseg√∫rate de que es un archivo de configuraci√≥n JSON v√°lido.',
                'click_to_set_shortcut': 'Haz clic y presiona la combinaci√≥n de teclas deseada',
                'close_btn': 'Cerrar',
                'find_replace_btn': 'Buscar y reemplazar',
                'find_replace_title': 'Buscar y reemplazar',
                'find_label': 'Buscar:',
                'replace_label': 'Reemplazar con:',
                'case_sensitive': 'Distinguir may√∫sculas y min√∫sculas',
                'regular_expression': 'Expresi√≥n regular',
                'find_prev': 'Buscar anterior',
                'find_next': 'Buscar siguiente',
                'replace': 'Reemplazar',
                'replace_all': 'Reemplazar todo',
                'no_match_found': 'No se encontr√≥ ninguna coincidencia.',
                'replaced_all': 'Todas las ocurrencias reemplazadas.',
                'no_find_query': 'Por favor, introduce el texto a buscar.',
                'loading_file': 'Cargando archivo...',
                'saving_file': 'Guardando archivo...',
                'terminology_btn': 'Terminolog√≠a',
                'terminology_sidebar_title': 'Terminolog√≠a',
                'config_lang_title': 'Configurar idiomas del glosario',
                'config_lang_info': 'Define los idiomas de origen y destino de tu glosario. Puedes introducir el c√≥digo ISO directamente o seleccionarlo de las sugerencias. Es fundamental que el c√≥digo ISO sea correcto para que funcione correctamente con tu herramienta TAO.',
                'source_language': 'Idioma de origen:',
                'target_language': 'Idioma de destino:',
                'confirm_languages': 'Confirmar idiomas',
                'current_lang_title': 'Idiomas actuales del glosario',
                'add_term_title': 'A√±adir t√©rmino',
                'term': 'T√©rmino:',
                'translation': 'Traducci√≥n:',
                'add_button': 'A√±adir',
                'search_title': 'Buscar',
                'search_placeholder': 'Buscar t√©rmino...',
                'import_tbx': 'Importar TBX',
                'download_tbx': 'Descargar TBX',
                'new_glossary': 'Nuevo glosario',
                'glossary_list_title': 'Glosario',
                'source_term_col': 'T√©rmino de origen',
                'target_term_col': 'T√©rmino de destino',
                'actions_col': 'Acciones',
                'delete_button': 'Eliminar',
                'both_terms_required': 'Ambos t√©rminos son requeridos.',
                'lang_config_required': 'Por favor, configura los idiomas de origen y destino para el glosario.',
                'cannot_download_empty_or_unconfigured_glossary': 'No se puede descargar un glosario vac√≠o o sin configurar.',
                'error_loading_tbx_file': 'Error al cargar el archivo TBX. Aseg√∫rate de que sea un XML/TBX v√°lido.',
                'no_valid_language_pairs_found_in_tbx': 'No se encontraron pares de idiomas v√°lidos en el archivo TBX. Se usar√°n los valores por defecto (en-US, es-ES).',
                'statistics_btn': 'Estad√≠sticas',
                'stats_progress_label': 'Progreso:',
                'stats_words_label': 'Palabras (Traducidas / Totales):',
                'stats_remaining_label': 'Palabras Pendientes:',
                'tm_btn': 'Memoria de traducci√≥n',
                'tm_sidebar_title': 'Memoria de Traducci√≥n (TM)',
                'new_tm': 'Nueva TM',
                'import_tmx': 'Importar TMX',
                'download_tmx': 'Descargar TMX',
                'no_tm_data': 'No hay datos en la memoria de traducci√≥n.',
                'tm_source_segment': 'Original:',
                'tm_target_segment': 'Traducci√≥n:',
                'tm_match_score': 'Coincidencia:',
                'tm_no_match_found': 'No se encontraron coincidencias en la TM.',
                'tm_insert_match': 'Insertar coincidencia',
                'error_loading_tmx_file': 'Error al cargar el archivo TMX. Aseg√∫rate de que sea un XML/TMX v√°lido.',
                'cannot_download_empty_tm': 'No se puede descargar una memoria de traducci√≥n vac√≠a.',
                'tm_best_match': 'Mejor coincidencia de TM:',
                'tm_search_title': 'Buscar en TM',
                'tm_search_placeholder': 'Buscar en la memoria...',
                'tm_search_results_title': 'Resultados de b√∫squeda en TM',
                'tm_score_col': '%',
                'tm_original_col': 'Original',
                'tm_translation_col': 'Traducci√≥n',
                'tm_config_lang_title': 'Configurar idiomas de la TM',
                'tm_config_lang_info': 'Define los idiomas de origen y destino de tu Memoria de Traducci√≥n. Es fundamental que el c√≥digo ISO sea correcto para que la coincidencia funcione correctamente.',
                'current_tm_lang_title': 'Idiomas actuales de la TM',
                'tm_initial_message': 'Crea una nueva TM o importa un archivo TMX para empezar a trabajar con la memoria de traducci√≥n.',
                'tmx_file_expected_tbx_found': 'Este archivo parece ser un glosario (TBX). Por favor, usa la opci√≥n "Importar TBX" en el panel de Terminolog√≠a.',
                'tbx_file_expected_tmx_found': 'Este archivo parece ser una memoria de traducci√≥n (TMX). Por favor, usa la opci√≥n "Importar TMX" en el panel de Memoria de Traducci√≥n.',
                'project_btn': 'Proyecto',
                'new_project_btn': 'Nuevo proyecto',
                'open_project_btn': 'Abrir proyecto',
                'save_project_btn': 'Guardar proyecto',
                'project_saved': 'Proyecto guardado con √©xito.',
                'error_saving_project': 'Error al guardar el proyecto.',
                'no_project_to_save': 'No hay ning√∫n archivo .po activo para guardar como proyecto.',
                'loading_project': 'Cargando proyecto...',
                'project_loaded': 'Proyecto cargado con √©xito.',
                'error_opening_project': 'Error al abrir el archivo del proyecto.',
                'invalid_project_file': 'Archivo de proyecto no v√°lido. El zip debe contener un archivo .po.',
                'new_project_confirm': '¬øSeguro que quieres iniciar un nuevo proyecto? Se perder√° todo el progreso no guardado.',
                'save_project_title': 'Guardar Proyecto',
                'filename_label': 'Nombre del archivo:',
                'save_button': 'Guardar',
                'cancel_button': 'Cancelar',
                'enter_filename': 'Por favor, introduce un nombre de archivo.',
                'restore_backup_title': 'Restaurar sesi√≥n',
                'restore_backup_info': 'Hemos encontrado una copia de seguridad de tu sesi√≥n anterior. ¬øQuieres restaurarla?',
                'restore_button': 'Restaurar',
                'discard_button': 'Descartar',
                'backup_btn': 'Copia de seguridad',
                'backup_title': 'Gesti√≥n de Copias de Seguridad',
                'backup_info_text': 'Poanda guarda autom√°ticamente una copia de seguridad local de toda tu sesi√≥n (archivo PO, MT y glosario) en tu navegador cada 10 segundos. Puedes restaurar esta copia aqu√≠ o guardarla en un archivo para mayor seguridad.',
                'last_backup_label': '√öltima copia:',
                'no_backup_available': 'No hay ninguna copia de seguridad disponible.',
                'load_local_backup_btn': 'Cargar copia local',
                'save_backup_to_disk_btn': 'Guardar copia en disco',
                'load_backup_from_disk_btn': 'Cargar copia del disco',
                'delete_local_backup_btn': 'Eliminar copia local',
                'backup_deleted': 'La copia de seguridad local ha sido eliminada.',
                'backup_loaded_from_file': 'Copia de seguridad cargada con √©xito desde el archivo.',
                'error_loading_backup_file': 'Error al cargar el archivo de copia de seguridad. Aseg√∫rate de que es un archivo .poanda-backup v√°lido.',
                'delete_local_backup_btn_confirm': '¬øSeguro que quieres eliminar la copia de seguridad local? Esta acci√≥n no se puede deshacer.',
                'mo_converter_title': 'Convertidor de PO a MO',
                'mo_converter_info': 'Esto compilar√° el archivo .po actual a un archivo binario .mo. La conversi√≥n se realiza completamente en tu navegador.',
                'mo_converter_action_btn': 'Convertir y Descargar .mo',
                'mo_conversion_success': 'Archivo .mo convertido y descargado con √©xito.',
                'mo_conversion_error': 'Error durante la conversi√≥n a MO. Revisa la consola del navegador (F12) para m√°s detalles.',
                'no_file_to_convert': 'No hay ning√∫n archivo .po cargado para convertir.',
                'po_search_placeholder': 'Buscar en el archivo...',
                'search_in_original': 'Buscar en original',
                'search_in_translation': 'Buscar en traducci√≥n',
                'auto_propagate_label': 'Autopropagar traducciones',
                'file_menu_btn': 'Archivo',
                'tools_menu_btn': 'Herramientas',
                'load_po_menu': 'Cargar archivo .po',
                'save_po_menu': 'Guardar archivo .po',
                'load_json_menu': 'Cargar archivo .json',
                'save_json_menu': 'Guardar archivo .json',
                'convert_mo_menu': 'Convertir a .mo',
                'prompt_select_source_json': 'Selecciona el archivo JSON del idioma ORIGEN (ej: en.json)',
                'prompt_select_target_json': 'Selecciona el archivo JSON del idioma DESTINO (ej: es.json). Cancela si es una traducci√≥n nueva.',
                'error_loading_json': 'Error al leer o analizar el archivo JSON: ',
                'json_loaded_success': 'Proyecto JSON cargado con √©xito.',
                'json_save_filename_prompt': 'Introduce el nombre para el JSON de destino (ej: es.json):',
                'error_saving_json': 'Error al guardar el archivo JSON: ',
                'json_saved_success': 'Archivo JSON guardado con √©xito.',
                'not_a_json_project': 'No se puede guardar como JSON. Carga primero un archivo JSON.',
                'not_a_po_project': 'No se puede guardar como PO/MO. Carga primero un archivo .po.',
                'select_file_error': 'Selecci√≥n de archivo fallida o cancelada.',
                'copy_original_btn': 'Copiar texto original al campo de traducci√≥n',
                'copy_error': 'Error al copiar el texto.',
                'edit_first_message': 'Haz clic en Editar antes de copiar.',
                'ai_btn': 'Asistente IA',
                'ai_no_api_key': 'Por favor, configura tu API Key de Gemini en el icono de engranaje (‚öôÔ∏è).',
                'ai_no_segment': 'Por favor, selecciona o edita un segmento primero para darme contexto.',
                'ai_thinking': 'PandaBot est√° pensando... üêº',
                'ai_error': 'Error al conectar con la IA: ',
                'ai_inserted': '¬°Traducci√≥n insertada!',
                'ai_prompt_translate': 'Traduce este texto con precisi√≥n considerando el contexto.',
                'ai_prompt_improve': 'Mejora el estilo y la fluidez de la traducci√≥n actual.',
                'ai_prompt_explain': 'Explica el significado y los matices del texto original.',
                'ai_prompt_fix': 'Corrige errores gramaticales, ortogr√°ficos o de consistencia.',
                'ai_quick_translate': 'Traducir',
                'ai_quick_improve': 'Mejorar',
                'ai_quick_explain': 'Explicar',
                'ai_quick_fix': 'Corregir',
                'ai_initial_message': 'Hola, soy PandaBot üêº. Configura tu API Key de Gemini y selecciona un segmento para empezar.',
                'ai_link_source': 'Fuente',
                'shortcut_insertLastAI': 'Insertar √∫ltima respuesta de IA',
                'no_ai_response_yet': 'A√∫n no hay respuesta de la IA para insertar.',
                'ai_input_placeholder': 'Escribe tu consulta... (Enter para enviar)',
                'ai_api_key_label': 'Google Gemini API Key:',
                'ai_api_key_placeholder': 'Pegar API Key aqu√≠...',
                'ai_api_key_info': 'La clave se guarda localmente en tu navegador.',
                'ai_config_title': 'Configurar API',
                'ai_input_placeholder': 'Escribe tu consulta... (Enter para enviar)',
                'ai_api_key_label': 'Google Gemini API Key:',
                'ai_api_key_placeholder': 'Pegar API Key aqu√≠...',
                'ai_api_key_info': 'La clave se guarda localmente en tu navegador.',
                'ai_config_title': 'Configurar API',
                'ai_quick_translate': 'Traducir',
                'ai_quick_improve': 'Mejorar',
                'ai_quick_explain': 'Explicar',
                'ai_quick_fix': 'Corregir',
                'ai_initial_message': 'Hola, soy PandaBot üêº. Configura tu API Key de Gemini y selecciona un segmento para empezar.',
                'ai_link_source': 'Fuente',
                'shortcut_insertLastAI': 'Insertar √∫ltima respuesta de IA',
                'no_ai_response_yet': 'A√∫n no hay respuesta de la IA para insertar.',


            }
        };

        // --- Shortcut Configuration ---
      const defaultShortcutConfig = {
            validateAndNext: { ctrlKey: true, altKey: false, shiftKey: false, key: 'Enter' },
            nextSegment: { ctrlKey: true, altKey: false, shiftKey: false, key: 'ArrowDown' },
            prevSegment: { ctrlKey: true, altKey: false, shiftKey: false, key: 'ArrowUp' },
 insertTMMatch1: { ctrlKey: true, altKey: true, shiftKey: false, key: '1' },
        insertTMMatch2: { ctrlKey: true, altKey: true, shiftKey: false, key: '2' },
        insertTMMatch3: { ctrlKey: true, altKey: true, shiftKey: false, key: '3' },
        insertTMMatch4: { ctrlKey: true, altKey: true, shiftKey: false, key: '4' },
        insertTMMatch5: { ctrlKey: true, altKey: true, shiftKey: false, key: '5' },
            insertGlossaryTerm1: { ctrlKey: true, altKey: false, shiftKey: false, key: '1' },
            insertGlossaryTerm2: { ctrlKey: true, altKey: false, shiftKey: false, key: '2' },
            insertGlossaryTerm3: { ctrlKey: true, altKey: false, shiftKey: false, key: '3' },
            insertGlossaryTerm4: { ctrlKey: true, altKey: false, shiftKey: false, key: '4' },
            insertGlossaryTerm5: { ctrlKey: true, altKey: false, shiftKey: false, key: '5' },
            toggleAI: { ctrlKey: true, altKey: false, shiftKey: true, key: 'A' },
            insertLastAI: { ctrlKey: false, altKey: true, shiftKey: true, key: 'I' }
        };

        let shortcutConfig = {};
        let tempShortcutConfig = {}; // To hold changes before saving

        // --- Helper function to load shortcuts ---
      function loadShortcuts() {
            const savedShortcuts = localStorage.getItem('poandaShortcutConfig');
            let finalConfig = { ...defaultShortcutConfig }; // Empezamos con los valores por defecto

            if (savedShortcuts) {
                const savedConfig = JSON.parse(savedShortcuts);
                // Recorremos los atajos guardados y solo aplicamos los que siguen siendo v√°lidos
                for (const action in savedConfig) {
                    // Si la acci√≥n del archivo guardado existe en nuestra configuraci√≥n por defecto, la usamos.
                    if (defaultShortcutConfig.hasOwnProperty(action)) {
                        finalConfig[action] = savedConfig[action];
                    }
                }
            }
            shortcutConfig = finalConfig;
        }


        // SVG icons for shortcuts
        const arrowDownIcon = `<svg class="shortcut-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 12a1 1 0 01-.707-.293l-4-4a1 1 0 011.414-1.414L10 9.586l3.293-3.293a1 1 0 111.414 1.414l-4 4A1 1 0 0110 12z" clip-rule="evenodd"></path></svg>`;
        const arrowUpIcon = `<svg class="shortcut-icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 8a1 1 0 01.707.293l4 4a1 1 0 01-1.414 1.414L10 10.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4A1 1 0 0110 8z" clip-rule="evenodd"></path></svg>`;

const copyIconSVG = `<svg class="w-4 h-4 inline-block" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z"></path><path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z"></path></svg>`;
      
// List of common ISO 639-1 language codes for the datalist (for Terminology)
        const isoLanguagesData = [
          { code: "en", name: "English" }, { code: "en-US", name: "English (United States)" }, { code: "en-GB", name: "English (United Kingdom)" },
          { code: "es", name: "Espa√±ol" }, { code: "es-ES", name: "Espa√±ol (Espa√±a)" }, { code: "es-MX", name: "Espa√±ol (M√©xico)" },
          { code: "fr", name: "Fran√ßais" }, { code: "de", name: "Deutsch" }, { code: "it", name: "Italiano" }, { code: "pt", name: "Portugu√™s" },
          { code: "ja", name: "Êó•Êú¨Ë™û (Japanese)" }, { code: "zh", name: "‰∏≠Êñá (Chinese)" }, { code: "ar", name: "ÿßŸÑÿπÿ±ÿ®Ÿäÿ© (Arabic)" },
          { code: "ru", name: "–†—É—Å—Å–∫–∏–π (Russian)" }, { code: "ko", name: "ÌïúÍµ≠Ïñ¥ (Korean)" }, { code: "nl", name: "Nederlands" },
          { code: "sv", name: "Svenska" }, { code: "da", name: "Dansk" }, { code: "no", name: "Norsk" }, { code: "fi", name: "Suomi" },
          { code: "tr", name: "T√ºrk√ße" }, { code: "pl", name: "Polski" }, { code: "cs", name: "ƒåe≈°tina" }, { code: "hu", name: "Magyar" },
          { code: "el", name: "ŒïŒªŒªŒ∑ŒΩŒπŒ∫Œ¨ (Greek)" }, { code: "he", name: "◊¢◊ë◊®◊ô◊™ (Hebrew)" }, { code: "th", name: "‡πÑ‡∏ó‡∏¢ (Thai)" },
          { code: "vi", name: "Ti·∫øng Vi·ªát (Vietnamese)" }, { code: "id", name: "Bahasa Indonesia" }, { code: "ms", name: "Bahasa Melayu" },
          { code: "ca", name: "Catal√†" }, { code: "eu", name: "Euskara" }, { code: "gl", name: "Galego" }, { code: "ro", name: "Rom√¢nƒÉ" },
          { code: "uk", name: "–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞ (Ukrainian)" }, { code: "bg", name: "–ë—ä–ª–≥–∞—Ä—Å–∫–∏ (Bulgarian)" }, { code: "hr", name: "Hrvatski" },
          { code: "sr", name: "Srpski" }, { code: "sk", name: "Slovenƒçina" }, { code: "sl", name: "Sloven≈°ƒçina" }, { code: "lt", name: "Lietuvi≈≥" },
          { code: "lv", name: "Latvie≈°u" }, { code: "et", name: "Eesti" }, { code: "is", name: "√çslenska" }, { code: "ga", name: "Gaeilge" },
          { code: "mt", name: "Malti" },
        ];


        /**
         * Counts words in a given text string.
         * @param {string} text The text to count words from.
         * @returns {number} The number of words.
         */
        function countWords(text) {
            if (!text) return 0;
            // Trim leading/trailing whitespace and split by one or more whitespace characters
            const words = text.trim().split(/\s+/);
            // Filter out empty strings that might result from multiple spaces
            return words.filter(word => word.length > 0).length;
        }

        /**
         * Unescapes a string from PO format.
         * Removes start/end quotes and handles escaped characters like \n, \t, \", \\.
         * Also converts <br> and &lt;br&gt; to newlines for better display.
         * @param {string} s The PO string to unescape.
         * @returns {string} The unescaped string.
         */
        function unescapePoString(s) {
            if (s.startsWith('"') && s.endsWith('"')) {
                s = s.substring(1, s.length - 1);
            }
            s = s.replace(/\\n/g, '\n')
                 .replace(/\\t/g, '\t')
                 .replace(/\\"/g, '"')
                 .replace(/\\\\/g, '\\');
            s = s.replace(/&lt;br&gt;/gi, '\n');
            s = s.replace(/<br\s*\/?>/gi, '\n');

            return s;
        }

        /**
         * Escapes a string for PO format.
         * Adds start/end quotes and escapes special characters like ", \, \n, \t.
         * @param {string} s The string to escape.
         * @returns {string} The escaped string in PO format.
         */
        function escapePoString(s) {
            let escaped = s.replace(/\\/g, '\\\\')
                             .replace(/"/g, '\\"')
                             .replace(/\n/g, '\\n')
                             .replace(/\t/g, '\\t');
            return `"${escaped}"`;
        }

        /**
         * Heuristic to split text into "sentences" for display.
         * @param {string} text The text to split.
         * @returns {Array<string>} An array of text segments.
         */
        function splitTextIntoSentences(text) {
            if (!text || typeof text !== 'string' || text.trim() === '') {
                return [''];
            }
            // Use a regex that keeps the delimiters to re-assemble them correctly
            const sentenceDelimiters = /([.?!]+[\s\r\n]*)/g;
            const parts = text.split(sentenceDelimiters);

            const sentences = [];
            let currentSentence = '';

            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                if (part === null || part === undefined) continue;

                if (part.match(sentenceDelimiters)) { // If it's a delimiter
                    if (currentSentence.trim() !== '') {
                        sentences.push(currentSentence.trim() + part);
                        currentSentence = '';
                    } else if (part.trim() !== '') { // Handle cases where a delimiter might start a segment
                        sentences.push(part.trim());
                    }
                } else { // If it's a sentence part
                    currentSentence += part;
                }
            }
            if (currentSentence.trim() !== '') {
                sentences.push(currentSentence.trim());
            }

            return sentences.filter(s => s.length > 0 || text === '');
        }

        /**
         * Parses the content of a .po file.
         * @param {string} content The full content of the .po file.
         * @returns {Array<Object>} An array of PO entry objects.
         */
        function parsePoContent(content) {
            const entries = [];
            let currentEntry = null;
            const lines = content.split('\n');

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();

                if (trimmedLine.startsWith('#')) {
                    if (currentEntry) {
                        currentEntry.comments = currentEntry.comments || [];
                        currentEntry.comments.push(trimmedLine);
                        if (trimmedLine.includes('#, fuzzy')) {
                            currentEntry.fuzzy = true;
                        }
                    } else {
                        // Header comments before any msgid/msgstr block
                        if (entries.length === 0 || entries[entries.length - 1].comments.length === 0) {
                            // If no entries or the last entry doesn't have comments,
                            // this might be part of a global header comment.
                            // A more robust solution would distinguish global header from entry-specific comments.
                            if (entries.length === 0) {
                                // Create a dummy entry for header comments if no entries exist yet
                                entries.push({ comments: [trimmedLine], msgid: '', msgstr: '' });
                                currentEntry = entries[0];
                            } else {
                                // Add to previous entry's comments
                                entries[entries.length - 1].comments.push(trimmedLine);
                            }
                        }
                    }
                    continue;
                }

                if (trimmedLine.startsWith('msgctxt ')) {
                    if (currentEntry && currentEntry.msgid !== undefined) {
                        entries.push(currentEntry);
                        currentEntry = { comments: [] };
                    } else if (!currentEntry) {
                         currentEntry = { comments: [] };
                    }
                    currentEntry.msgctxt = unescapePoString(trimmedLine.substring(8));
                } else if (trimmedLine.startsWith('msgid ')) {
                    if (currentEntry && currentEntry.msgid !== undefined) {
                        entries.push(currentEntry);
                        currentEntry = { comments: [] };
                    } else if (!currentEntry) {
                         currentEntry = { comments: [] };
                    }
                    currentEntry.msgid = unescapePoString(trimmedLine.substring(6));
                } else if (trimmedLine.startsWith('msgstr ')) {
                    if (!currentEntry) {
                        currentEntry = { comments: [] };
                    }
                    currentEntry.msgstr = unescapePoString(trimmedLine.substring(7));
                    entries.push(currentEntry);
                    currentEntry = null; // Reset for next entry
                } else if (trimmedLine.startsWith('"') && trimmedLine.endsWith('"')) {
                    // Continuation of a multi-line msgid or msgstr
                    if (currentEntry) {
                        const unescapedPart = unescapePoString(trimmedLine);
                        if (currentEntry.msgstr === undefined) {
                            currentEntry.msgid = (currentEntry.msgid || '') + unescapedPart;
                        } else {
                            currentEntry.msgstr = (currentEntry.msgstr || '') + unescapedPart;
                        }
                    }
                } else if (trimmedLine === '') {
                    // Empty line separates entries. If there's an active entry being built, finalize it.
                    if (currentEntry && currentEntry.msgid !== undefined && currentEntry.msgstr !== undefined) {
                        entries.push(currentEntry);
                        currentEntry = null;
                    }
                     // If msgid is present but msgstr is not, and we hit an empty line, save it.
                    else if (currentEntry && currentEntry.msgid !== undefined && currentEntry.msgstr === undefined) {
                         // This case might happen at EOF or if msgstr is missing
                         entries.push(currentEntry);
                         currentEntry = null;
                    }
                    // For comments not associated with an entry, we ensure a fresh start for the next entry
                    if (!currentEntry && lines[i+1] && !lines[i+1].startsWith('#')) { // Only create new if next line isn't a comment
                         currentEntry = { comments: [] };
                    }
                }
            }
            // Add the last entry if it wasn't added (e.g., file ends without a blank line)
            if (currentEntry && (currentEntry.msgid !== undefined || currentEntry.msgctxt !== undefined)) {
                if (currentEntry.msgstr === undefined) { // Ensure msgstr is at least an empty string if not present
                    currentEntry.msgstr = '';
                }
                entries.push(currentEntry);
            }

            // Post-processing for sentence segmentation, word counts, and translation status
            entries.forEach(entry => {
                // Handle the special header entry (msgid "")
                if (entry.msgid === '' && entry.msgctxt === undefined) {
                    entry.isHeader = true;
                    entry.sentenceSegments = [{
                        original: entry.msgid,
                        translation: entry.msgstr,
                        wordCountOriginal: countWords(entry.msgid),
                        wordCountTranslation: countWords(entry.msgstr),
                        isTranslated: entry.msgstr.trim() !== ''
                    }];
                } else {
                    entry.isHeader = false;
                    const originalSegments = splitTextIntoSentences(entry.msgid || '');
                    const translatedSegments = splitTextIntoSentences(entry.msgstr || '');

                    entry.sentenceSegments = [];
                    const maxLength = Math.max(originalSegments.length, translatedSegments.length);
                    for (let j = 0; j < maxLength; j++) {
                        const originalText = originalSegments[j] || '';
                        const translationText = translatedSegments[j] || '';
                        entry.sentenceSegments.push({
                            original: originalText,
                            translation: translationText,
                            wordCountOriginal: countWords(originalText),
                            wordCountTranslation: countWords(translationText),
                            isTranslated: translationText.trim() !== ''
                        });
                    }
                }
            });
            return entries;
        }

/**
         * Parses a single JSON content into the poEntries structure.
         * Key -> msgctxt, Value -> msgid AND initial msgstr.
         * @param {string} jsonContent Content of the JSON file.
         * @returns {Array<Object>} An array of PO entry-like objects.
         */
        function parseJsonProject(jsonContent) {
            const jsonData = JSON.parse(jsonContent);
            const entries = [];
            const sortedKeys = Object.keys(jsonData).sort(); // Sort keys

            for (const key of sortedKeys) {
                if (Object.hasOwnProperty.call(jsonData, key)) {
                    const value = String(jsonData[key] || ''); // Ensure it's a string

                    const entry = {
                        comments: [],
                        msgctxt: key,      // Key -> Context
                        msgid: value,      // Value -> Original (for reference)
                        msgstr: '',         // <-- CAMBIADO a cadena vac√≠a
                        isHeader: false,
                        fuzzy: false,
                        sentenceSegments: [{ // Maintain segment structure
                            original: value,    // Value goes here too
                            translation: '',    // <-- CAMBIADO a cadena vac√≠a
                            wordCountOriginal: countWords(value),
                            wordCountTranslation: 0, // <-- CAMBIADO a 0
                            isTranslated: false      // <-- CAMBIADO a false
                        }]
                    };
                    entries.push(entry);
                }
            }
            return entries;
        }

        /**
         * Reconstructs the content of a PO file from an array of entries.
         * @param {Array<Object>} entries The array of translation objects.
         * @returns {string} The reconstructed PO file content.
         */
        function reconstructPo(entries) {
            let poContent = '';
            entries.forEach(entry => {
                if (entry.comments && entry.comments.length > 0) {
                    // Filter out fuzzy comment if msgstr is not empty
                    const commentsToKeep = entry.fuzzy && entry.msgstr && entry.msgstr.trim() !== '' 
                        ? entry.comments.filter(c => !c.includes('#, fuzzy')) 
                        : entry.comments;
                    if(commentsToKeep.length > 0) {
                        poContent += commentsToKeep.join('\n') + '\n';
                    }
                }
                if (entry.msgctxt !== undefined) {
                    poContent += `msgctxt ${escapePoString(entry.msgctxt)}\n`;
                }
                if (entry.msgid !== undefined) {
                    poContent += `msgid ${escapePoString(entry.msgid)}\n`;
                }

                let fullMsgstr = '';
                if (entry.sentenceSegments && entry.sentenceSegments.length > 0) {
                    // For header, directly use the stored msgstr
                    if (entry.isHeader) {
                        fullMsgstr = entry.msgstr || '';
                    } else {
                        // For regular entries, join segmented translations
                        fullMsgstr = entry.sentenceSegments.map(s => s.translation).join(' ').trim();
                    }
                } else {
                    fullMsgstr = entry.msgstr || ''; // Fallback if no segments
                }

                if (fullMsgstr !== undefined) {
                    poContent += `msgstr ${escapePoString(fullMsgstr)}\n`;
                }
                poContent += '\n';
            });
            return poContent;
        }

/**
     * Reconstructs a JSON translation object from an array of entries.
     * Uses msgctxt as the key and the combined msgstr from segments as the value.
     * @param {Array<Object>} entries The array of translation objects.
     * @returns {string} The JSON string content.
     */
    function reconstructJson(entries) {
        const translations = {};
        entries.forEach(entry => {
            // Only process entries that likely came from JSON (have msgctxt)
            if (entry.msgctxt && !entry.isHeader) {
                // Reconstruct the full translation string from segments
                const fullMsgstr = (entry.sentenceSegments || [])
                                     .map(s => s.translation || '') // Ensure segments exist
                                     .join(' ') // Join segments back (simple join, might need refinement for complex cases)
                                     .trim();
                translations[entry.msgctxt] = fullMsgstr;
            }
        });
        return JSON.stringify(translations, null, 2); // Pretty print JSON
    }

// --- HTML PARSING & RECONSTRUCTION LOGIC ---
    
    function parseHtmlProject(htmlContent) {
        const parser = new DOMParser();
        currentHtmlDoc = parser.parseFromString(htmlContent, 'text/html');
        const entries = [];
        htmlNodeMap = []; 
        
        let nodeCounter = 0;

        function traverse(node) {
            if (node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE' || node.nodeName === 'NOSCRIPT') return;

            if (node.nodeType === Node.ELEMENT_NODE) {
                // 1. Content Translation (innerHTML logic)
                const hasDirectText = Array.from(node.childNodes).some(child => 
                    child.nodeType === Node.TEXT_NODE && child.textContent.trim().length > 0
                );

                if (hasDirectText) {
                    const originalText = node.innerHTML.trim();
                    nodeCounter++;
                    const entry = {
                        msgctxt: `${node.tagName.toLowerCase()}_${nodeCounter}`, 
                        msgid: originalText,
                        msgstr: '', 
                        sentenceSegments: [{
                            original: originalText,
                            translation: '',
                            wordCountOriginal: countWords(originalText),
                            wordCountTranslation: 0,
                            isTranslated: false
                        }]
                    };
                    htmlNodeMap.push({ type: 'element', node: node }); 
                    entries.push(entry);
                }
                
                // 2. Attribute Translation
                ['alt', 'title', 'placeholder', 'aria-label', 'meta[content]'].forEach(attr => {
                    let attrVal = '';
                    let attrName = attr;
                    
                    // Handle meta description specifically
                    if(attr === 'meta[content]' && node.tagName === 'META' && node.getAttribute('name') === 'description') {
                        attrVal = node.getAttribute('content');
                        attrName = 'content';
                    } else if (attr !== 'meta[content]' && node.hasAttribute(attr)) {
                        attrVal = node.getAttribute(attr);
                    }

                    if (attrVal && attrVal.trim()) {
                        nodeCounter++;
                        const entry = {
                            msgctxt: `${node.tagName.toLowerCase()}_attr_${attrName}_${nodeCounter}`,
                            msgid: attrVal,
                            msgstr: '',
                            sentenceSegments: [{
                                original: attrVal,
                                translation: '',
                                wordCountOriginal: countWords(attrVal),
                                wordCountTranslation: 0,
                                isTranslated: false
                            }]
                        };
                        htmlNodeMap.push({ type: 'attribute', node: node, attr: attrName });
                        entries.push(entry);
                    }
                });
            }

            for (let i = 0; i < node.children.length; i++) {
                traverse(node.children[i]);
            }
        }

        traverse(currentHtmlDoc.body); // Start body
        // Optionally parse head for title/meta
        if(currentHtmlDoc.head) {
             const titleNode = currentHtmlDoc.head.querySelector('title');
             if(titleNode) {
                 const text = titleNode.innerText;
                 htmlNodeMap.push({ type: 'element_text', node: titleNode });
                 entries.push({
                    msgctxt: 'title_tag', msgid: text, msgstr: '',
                    sentenceSegments: [{original: text, translation: '', wordCountOriginal: countWords(text), wordCountTranslation: 0, isTranslated: false}]
                 });
             }
             // Trigger meta logic
             Array.from(currentHtmlDoc.head.children).forEach(child => traverse(child));
        }

        return entries;
    }

    function reconstructHtml(entries) {
        if (!currentHtmlDoc || htmlNodeMap.length === 0) return null;

        entries.forEach((entry, index) => {
            let translatedText = entry.sentenceSegments.map(s => s.translation).join(' ').trim();
            if (!translatedText) return; 

            const mapItem = htmlNodeMap[index];
            if (!mapItem) return;

            if (mapItem.type === 'element') {
                mapItem.node.innerHTML = translatedText; 
            } else if (mapItem.type === 'element_text') {
                mapItem.node.innerText = translatedText;
            } else if (mapItem.type === 'attribute') {
                mapItem.node.setAttribute(mapItem.attr, translatedText);
            }
        });
        return "<!DOCTYPE html>\n" + currentHtmlDoc.documentElement.outerHTML;
    }

    async function loadHtmlFile() {
        showLoadingOverlay(translations[currentLanguage]['loading_file']);
        try {
            const fileData = await selectFile('htmlSourceFile', 'Select HTML file');
            
            // --- CAMBIO IMPORTANTE ---
            currentRawHtml = fileData.content; 
            console.log("HTML cargado en memoria, longitud:", currentRawHtml.length); // <--- DEBUG
            // -------------------------

            poEntries = parseHtmlProject(fileData.content);
            currentFileType = 'html'; 
            currentFileName = fileData.name;
            
            renderTranslations(poEntries);
            updateStatsDisplay();
            updateSaveButtonsState();
            showMessage("HTML file loaded successfully.");
            
            // Forzar un backup inicial manual para probar
            setTimeout(saveBackup, 1000); 

        } catch (e) {
            console.error(e);
            showMessage("Error loading HTML: " + e.message);
        } finally {
            hideLoadingOverlay();
            document.getElementById('htmlSourceFile').value = '';
        }
    }

    async function saveHtmlFile() {
        if (poEntries.length === 0) return;
        const targetFileName = prompt("Enter filename for HTML", currentFileName);
        if (!targetFileName) return;

        showLoadingOverlay(translations[currentLanguage]['saving_file']);
        try {
            const htmlContent = reconstructHtml(poEntries);
            const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = targetFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage("HTML saved successfully.");
        } catch (error) {
             showMessage("Error saving HTML: " + error.message);
        } finally {
            hideLoadingOverlay();
        }
    }

    /**
     * Saves the current translations as a JSON file.
     */
    /**
         * Saves the current translations as a JSON file. Always prompts for filename.
         */
        async function saveJsonFile() {
            // Allow saving if ANY entries exist, regardless of original file type
            if (poEntries.length === 0) {
                showMessage(translations[currentLanguage]['no_translations_to_save']);
                return;
            }

            // Always prompt for filename in this simplified flow
            let targetFileName = prompt(translations[currentLanguage]['json_save_filename_prompt'], `translations_${currentLanguage}.json`);
            if (!targetFileName) {
                showMessage(translations[currentLanguage]['select_file_error']); // User cancelled prompt
                return;
            }
            // Ensure it ends with .json
            if (!targetFileName.toLowerCase().endsWith('.json')) {
                targetFileName += '.json';
            }

        showLoadingOverlay(translations[currentLanguage]['saving_file']);
        try {
            const updatedJsonContent = reconstructJson(poEntries);
            const blob = new Blob([updatedJsonContent], { type: 'application/json;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = targetFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
             showMessage(translations[currentLanguage]['json_saved_success']);
        } catch (error) {
             showMessage(`${translations[currentLanguage]['error_saving_json']} ${error.message}`);
            console.error("Error saving JSON file:", error);
        } finally {
            hideLoadingOverlay();
        }
    }

/**
     * Updates the enabled/disabled state of save buttons and menu items.
     */
    function updateSaveButtonsState() {
        const hasEntries = poEntries.length > 0;
        const isJson = currentFileType === 'json';
        const isHtml = currentFileType === 'html';
        
        // Solo se puede guardar PO/MO si NO es json Y NO es html
        const canSavePo = hasEntries && !isJson && !isHtml;

        // Menu items handling
        const savePoMenuItem = document.getElementById('saveFilePoBtn');
        const saveJsonMenuItem = document.getElementById('saveFileJsonBtn');
        const saveHtmlMenuItem = document.getElementById('saveFileHtmlBtn'); // NEW
        const convertMoMenuItem = document.getElementById('convertFileMoBtn');

        // Reset states
        savePoButton.disabled = !canSavePo;
        convertToMoButton.disabled = !canSavePo;
        
        if (savePoMenuItem) savePoMenuItem.classList.toggle('disabled-link', !canSavePo);
        if (convertMoMenuItem) convertMoMenuItem.classList.toggle('disabled-link', !canSavePo);
        
        if (saveJsonMenuItem) saveJsonMenuItem.classList.toggle('disabled-link', !(hasEntries && isJson));
        if (saveHtmlMenuItem) saveHtmlMenuItem.classList.toggle('disabled-link', !(hasEntries && isHtml));
    }

function processPoContent(content) {
         showLoadingOverlay(translations[currentLanguage]['loading_file']);
         try {
            poEntries = parsePoContent(content);
           // --- CORRECCI√ìN: Definir tipo PO y actualizar botones ---
            currentFileType = 'po';
            currentJsonSourceFileName = null;
            currentJsonTargetFileName = null;
            updateSaveButtonsState(); 
            // -------------------------------------------------------

            setTimeout(() => { // Keep the timeout if needed for rendering large files
                renderTranslations(poEntries);
                updateStatsDisplay();
            }, 0);
            poSearchInput.value = '';
            filterPOEntries();
            updateSaveButtonsState(); // ADD THIS CALL

         } catch (error) {
             // ... (existing error handling) ...
            updateSaveButtonsState(); // ADD THIS CALL
         } finally {
            hideLoadingOverlay();
         }
    }

    /**
     * Handles the process of loading source and target JSON files.
     */
   /**
         * Handles loading a single JSON file for translation.
         */
        async function loadSingleJsonFile() {
            showLoadingOverlay(translations[currentLanguage]['loading_file']);
            try {
                // Use the 'jsonSourceFile' input, but treat it as the main file
                const fileData = await selectFile('jsonSourceFile', translations[currentLanguage]['load_json_menu']);

                poEntries = parseJsonProject(fileData.content);
                currentFileType = 'json'; // Mark as JSON type
                currentFileName = fileData.name; // Use the loaded filename
                // Reset other JSON names as they aren't relevant in this flow
                currentJsonSourceFileName = fileData.name;
                currentJsonTargetFileName = null;


                renderTranslations(poEntries);
                updateStatsDisplay();
                updateSaveButtonsState(); // Enable JSON saving
                showMessage(translations[currentLanguage]['json_loaded_success']);

            } catch (error) {
                showMessage(`${translations[currentLanguage]['error_loading_json']} ${error.message || error}`);
                console.error("Error loading single JSON file:", error);
                // Consider resetting if load fails
                 // resetProjectState();
            } finally {
                hideLoadingOverlay();
                 // Ensure file input is reset
                 document.getElementById('jsonSourceFile').value = '';
            }
        }

    

        /**
         * Adjusts the height of a textarea to fit its content.
         * If the translation textarea is empty, it matches the height of the original textarea.
         * @param {HTMLTextAreaElement} textarea The textarea element (msgstr).
         * @param {HTMLElement} [originalElement] The original element (msgid pre) for height comparison.
         */
        function autoResizeTextarea(textarea, originalElement) {
            textarea.style.height = 'auto';
            if (textarea.value.trim() === '' && originalElement) {
                // If textarea is empty, set its height to match the original element's scroll height
                textarea.style.height = originalElement.scrollHeight + 'px';
            } else {
                // Otherwise, let it expand to its own content
                textarea.style.height = textarea.scrollHeight + 'px';
            }
        }

        /**
         * Updates the character count for a specific textarea.
         * @param {HTMLTextAreaElement} textarea The textarea element.
         * @param {number} originalLength The length of the original string segment.
         */
      

function updateCharCount(textarea, originalLength, charCountSpan) {
    if (charCountSpan) {
        charCountSpan.textContent = `${translations[currentLanguage]['char_count_original']}${originalLength} ${translations[currentLanguage]['char_units']} | ${translations[currentLanguage]['char_count_translation']}${textarea.value.length} ${translations[currentLanguage]['char_units']}`;
    }
}

        /**
         * Configures the editable state of a translation entry (editable/read-only).
         * @param {number} entryIndex The index of the main PO entry.
         * @param {number} segmentIndex The index of the sentence segment.
         * @param {boolean} isEditable True to make it editable, false for read-only.
         */
        function setTranslationEditableState(entryIndex, segmentIndex, isEditable) {
            const msgstrTextarea = document.getElementById(`msgstr-${entryIndex}-${segmentIndex}`);
            const validateButton = document.getElementById(`validateBtn-${entryIndex}-${segmentIndex}`);
            const editButton = document.getElementById(`editBtn-${entryIndex}-${segmentIndex}`);
            const checkIcon = document.getElementById(`checkIcon-${entryIndex}-${segmentIndex}`);
            const translationUnit = document.getElementById(`translation-unit-${entryIndex}`); // Get the parent unit


            if (!msgstrTextarea || !validateButton || !editButton || !checkIcon || !translationUnit) {
                console.error(`Elements not found for index ${entryIndex}-${segmentIndex}`);
                return;
            }

            msgstrTextarea.readOnly = !isEditable;
            if (!isEditable) {
                msgstrTextarea.classList.add('bg-gray-200');
                translationUnit.classList.remove('translation-unit-active'); // Remove active highlight on validate

                // Update translation status and words when segment is validated
                const segment = poEntries[entryIndex].sentenceSegments[segmentIndex];
                segment.isTranslated = msgstrTextarea.value.trim() !== '';
                segment.wordCountTranslation = countWords(msgstrTextarea.value);
                updateStatsDisplay(); // Update stats
                addOrUpdateTMEntry(segment.original, segment.translation); // Add/Update TM
            } else {
                msgstrTextarea.classList.remove('bg-gray-200');
                translationUnit.classList.add('translation-unit-active'); // Add active highlight on edit/focus
            }

            validateButton.style.display = isEditable ? 'inline-block' : 'none';
            editButton.style.display = isEditable ? 'none' : 'inline-block';
            checkIcon.style.display = isEditable ? 'none' : 'inline-block';

            if (isEditable) {
                msgstrTextarea.focus();
                // Ensure cursor is at the end of the text
                msgstrTextarea.setSelectionRange(msgstrTextarea.value.length, msgstrTextarea.value.length);
            }
        }

// --- AUTO-PROPAGATION LOGIC ---
        function performAutoPropagation(originalText, translationText, sourceEntryIndex, sourceSegmentIndex) {
            // Si la casilla no est√° marcada o el texto est√° vac√≠o, no hacemos nada
            const checkbox = document.getElementById('autoPropagateCheckbox');
            if (!checkbox || !checkbox.checked || !translationText) return;

            let propagatedCount = 0;

            poEntries.forEach((entry, eIdx) => {
                if (entry.isHeader) return;

                entry.sentenceSegments.forEach((segment, sIdx) => {
                    // 1. No nos sobrescribimos a nosotros mismos
                    if (eIdx === sourceEntryIndex && sIdx === sourceSegmentIndex) return;

                    // 2. Verificamos si el original es id√©ntico
                    if (segment.original === originalText) {
                        
                        // 3. Actualizamos los datos
                        segment.translation = translationText;
                        segment.wordCountTranslation = countWords(translationText);
                        segment.isTranslated = true;
                        propagatedCount++;

                        // 4. Actualizamos lo visual (el textarea) si est√° renderizado en pantalla
                        const textarea = document.getElementById(`msgstr-${eIdx}-${sIdx}`);
                        if (textarea) {
                            textarea.value = translationText;
                            // Disparamos input para que se recalculen alturas y contadores de ese textarea
                            textarea.dispatchEvent(new Event('input', { bubbles: true })); 
                            
                            // Efecto visual para saber que ha cambiado (flash amarillo r√°pido)
                            textarea.classList.add('bg-yellow-100');
                            setTimeout(() => textarea.classList.remove('bg-yellow-100'), 500);
                        }
                    }
                });
            });
            
            // Si quieres notificar cu√°ntos se cambiaron, descomenta la siguiente l√≠nea:
            // if (propagatedCount > 0) console.log(`Propagated to ${propagatedCount} segments.`);
        }

        /**
         * Applies glossary term highlighting to a given text segment.
         * Collects terms that were successfully highlighted.
         * @param {string} text The original text to highlight.
         * @returns {{html: string, foundTerms: Set<string>}} Object with HTML string and set of found terms.
         */
        function applyGlossaryHighlightToText(text) {
            let highlightedHtml = text;
            const currentFoundTerms = new Set(); // Terms found in *this specific* segment

            // Ensure glossarySourceLanguage is set and matches the original's implicit language
            if (!glossarySourceLanguage) {
                return { html: text, foundTerms: currentFoundTerms }; // Cannot highlight without source language
            }

            // Sort glossary terms by length in descending order to match longer terms first
            const sortedGlossary = [...glossary].sort((a, b) => b.srcTerm.length - a.srcTerm.length);


            sortedGlossary.forEach(glossaryEntry => {
                // Only highlight if the glossary entry's source language matches the current editor's source language
                // Assuming poEntries are implicitly in poanda's current source language.
                // For a more robust solution, each poEntry might need a source language field.
                // For now, we assume the glossary source language is the relevant source for highlighting.
                // Also, ensure the glossary entry has a source term.
                if (glossarySourceLanguage && glossaryEntry.srcTerm) {
                    const term = glossaryEntry.srcTerm;
                    // Use word boundaries \b to avoid partial word matches
                    // Escape special regex characters in the term
                    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    // 'g' for global, 'i' for case-insensitive
                    const regex = new RegExp(`\\b(${escapedTerm})\\b`, 'gi'); // Added word boundaries


                    // Only replace if the term is found (to avoid unnecessary string manipulations)
                    if (highlightedHtml.match(regex)) {
                        highlightedHtml = highlightedHtml.replace(regex, (match, p1) => {
                            // p1 is the captured group, which is the actual matched term (case-preserved)
                            currentFoundTerms.add(term); // Add the actual term from the glossary (case-preserved)
                            return `<span class="glossary-highlight">${p1}</span>`; // Highlight the matched part
                        });
                    }
                }
            });
            return { html: highlightedHtml, foundTerms: currentFoundTerms };
        }

        /**
         * Updates highlighting in the glossary table based on terms found in the editor.
         * This function is implicitly called via renderGlossary() after termsFoundInActiveSegment is updated.
         */
        function updateGlossaryTableHighlights() {
            renderGlossary(); // Re-render glossary, which applies highlights based on termsFoundInActiveSegment
        }


        /**
         * Renders translation entries in the user interface, including sentence segmentation.
         * @param {Array<Object>} entries The array of translation objects to render.
         */
        function renderTranslations(entries) {
            translationsContainer.innerHTML = '';
            termsFoundInActiveSegment.clear(); // Clear terms when re-rendering all translations
            lastFocusedSegment = null; // Reset AI context memory

            if (entries.length === 0) {
                translationsContainer.innerHTML = `
                    <div data-i18n="no_translations" id="initialMessage" class="text-center text-on-light-contrast p-4 border border-gray-300 rounded-md">
                        ${translations[currentLanguage]['no_translations']}
                    </div>
                `;
                savePoButton.disabled = true;
                convertToMoButton.disabled = true; 
                poSearchContainer.classList.add('hidden'); // Hide search bar
                statsContainer.classList.remove('show'); // Hide stats if no translations
                updateUtilityButtonStates(); 
                updateSaveButtonsState(); // Sincronizar men√∫ File
                return;
            }

            poSearchContainer.classList.remove('hidden'); // Show search bar

            entries.forEach((entry, entryIndex) => {
                // Skip rendering header entry explicitly in the main editor area, but keep in poEntries
                if (entry.isHeader) {
                    return;
                }

                const translationUnit = document.createElement('div');
                translationUnit.id = `translation-unit-${entryIndex}`; // Added ID for highlighting
                translationUnit.className = 'translation-unit-bg p-4 rounded-lg shadow-sm border';

                if (entry.comments && entry.comments.length > 0) {
                    const commentsDiv = document.createElement('div');
                    commentsDiv.className = 'text-xs text-gray-500 mb-2 whitespace-pre-wrap';
                    commentsDiv.textContent = entry.comments.join('\n');
                    translationUnit.appendChild(commentsDiv);
                }
                if (entry.msgctxt) {
                    const msgctxtLabel = document.createElement('label');
                    msgctxtLabel.className = 'block text-sm font-medium text-on-light-contrast mb-1';
                    msgctxtLabel.textContent = translations[currentLanguage]['context_msgctxt'];
                    translationUnit.appendChild(msgctxtLabel);

                    const msgctxtPre = document.createElement('pre');
                    msgctxtPre.className = 'po-display-code p-2 rounded-md text-base overflow-auto max-h-32';
                    msgctxtPre.textContent = entry.msgctxt;
                    translationUnit.appendChild(msgctxtPre);
                }

                entry.sentenceSegments.forEach((segment, segmentIndex) => {

                    const segmentRow = document.createElement('div');
                    segmentRow.className = 'translation-row mb-4';

                    const originalCol = document.createElement('div');
                    originalCol.className = 'original-col';

                    const msgidLabel = document.createElement('label');
                    msgidLabel.className = 'block text-sm font-medium text-on-light-contrast mb-1';
                    msgidLabel.textContent = translations[currentLanguage]['original_msgid'];
                    originalCol.appendChild(msgidLabel);

                    const msgidPre = document.createElement('pre');
                    msgidPre.id = `msgid-pre-${entryIndex}-${segmentIndex}`; // Added ID for easier lookup
                    msgidPre.className = 'po-display-code p-2 rounded-md text-base overflow-auto max-h-32';
                    msgidPre.textContent = segment.original; // Initial text without highlight
                    originalCol.appendChild(msgidPre);
                    segmentRow.appendChild(originalCol);

                    const translationCol = document.createElement('div');
                    translationCol.className = 'translation-col';

                    // --- NUEVO: Contenedor de cabecera para Label + Etiqueta Amarilla ---
                    const translationHeader = document.createElement('div');
                    translationHeader.className = 'flex justify-between items-center mb-1';

                    const msgstrLabel = document.createElement('label');
                    msgstrLabel.className = 'block text-sm font-medium text-on-light-contrast'; 
                    msgstrLabel.textContent = translations[currentLanguage]['translation_msgstr'];
                    translationHeader.appendChild(msgstrLabel);

                    // La etiqueta amarilla (oculta por defecto)
                    const glossaryBadge = document.createElement('span');
                    glossaryBadge.id = `glossary-match-${entryIndex}-${segmentIndex}`;
                    glossaryBadge.className = 'hidden flex items-center gap-1 text-xs font-semibold text-black bg-yellow-300 px-2 py-0.5 rounded-md whitespace-normal h-auto';                    
                    translationHeader.appendChild(glossaryBadge);

                    translationCol.appendChild(translationHeader);
                    // --- FIN NUEVO BLOQUE ---

                    const msgstrTextarea = document.createElement('textarea');
                    msgstrTextarea.id = `msgstr-${entryIndex}-${segmentIndex}`;
                    msgstrTextarea.className = 'msgstr-textarea mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-red-500 focus:border-red-500 text-base';
                    msgstrTextarea.value = segment.translation;
                    msgstrTextarea.dataset.entryIndex = entryIndex;
                    msgstrTextarea.dataset.segmentIndex = segmentIndex;
                    msgstrTextarea.dataset.originalLength = segment.original.length;

                    translationCol.appendChild(msgstrTextarea);
                    segmentRow.appendChild(translationCol);
                    translationUnit.appendChild(segmentRow);

                    const controlsContainer = document.createElement('div');
                    controlsContainer.className = 'flex items-center justify-between mt-2 w-full';

                    const charCountSpan = document.createElement('span');
                    charCountSpan.id = `charCount-${entryIndex}-${segmentIndex}`;
                    charCountSpan.className = 'inline-block text-sm font-semibold text-on-light-contrast';
                    controlsContainer.appendChild(charCountSpan);

                    const actionButtonsContainer = document.createElement('div');
                    actionButtonsContainer.className = 'flex items-center space-x-2';

                    const checkIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    checkIcon.setAttribute("id", `checkIcon-${entryIndex}-${segmentIndex}`);
                    checkIcon.setAttribute("class", "check-icon text-green-500");
                    checkIcon.setAttribute("fill", "none");
                    checkIcon.setAttribute("viewBox", "0 0 24 24");
                    checkIcon.setAttribute("stroke", "currentColor");
                    checkIcon.innerHTML = `
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                    `;
                    actionButtonsContainer.appendChild(checkIcon);

                    // --- START: UPDATED COPY ORIGINAL BUTTON ---
                    const copyOriginalButton = document.createElement('button');
                    copyOriginalButton.id = `copyOriginalBtn-${entryIndex}-${segmentIndex}`;
                    // Adjusted classes for padding with icon
                    copyOriginalButton.className = 'copy-original-button font-medium py-1 px-2 rounded-md shadow-sm transition duration-300 btn-modal-neutral';
                    copyOriginalButton.dataset.entryIndex = entryIndex;
                    copyOriginalButton.dataset.segmentIndex = segmentIndex;

                    // Set tooltip text using the title attribute and translation key
                    const tooltipText = translations[currentLanguage]['copy_original_btn'] || 'Copy Original';
                    copyOriginalButton.setAttribute('title', tooltipText);

                    // Set the button content to the SVG icon
                    copyOriginalButton.innerHTML = copyIconSVG;

                    actionButtonsContainer.appendChild(copyOriginalButton); // Add BEFORE validate button
                    // --- END: UPDATED COPY ORIGINAL BUTTON ---

                    const validateButton = document.createElement('button');
                    validateButton.id = `validateBtn-${entryIndex}-${segmentIndex}`;
                    validateButton.className = 'validate-button font-medium py-1 px-3 rounded-md shadow-sm transition duration-300 btn-validate';
                    validateButton.textContent = translations[currentLanguage]['validate'];
                    validateButton.dataset.entryIndex = entryIndex;
                    validateButton.dataset.segmentIndex = segmentIndex;
                    actionButtonsContainer.appendChild(validateButton);

                    const editButton = document.createElement('button');
                    editButton.id = `editBtn-${entryIndex}-${segmentIndex}`;
                    editButton.className = 'edit-button font-medium py-1 px-3 rounded-md shadow-sm transition duration-300 btn-edit';
                    editButton.textContent = translations[currentLanguage]['edit'];
                    editButton.dataset.entryIndex = entryIndex;
                    editButton.dataset.segmentIndex = segmentIndex;
                    editButton.style.display = 'none';
                    actionButtonsContainer.appendChild(editButton);

                    controlsContainer.appendChild(actionButtonsContainer);
                    translationUnit.appendChild(controlsContainer);

                    // --- START: UPDATED EVENT LISTENER FOR COPY BUTTON ---
                    copyOriginalButton.addEventListener('click', (event) => {
                        // Use currentTarget to ensure we get the button, even if SVG is clicked
                        const btn = event.currentTarget;
                        const currentEntryIndex = parseInt(btn.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(btn.dataset.segmentIndex);
                        const originalText = poEntries[currentEntryIndex]?.sentenceSegments[currentSegmentIndex]?.original;
                        const targetTextarea = document.getElementById(`msgstr-${currentEntryIndex}-${currentSegmentIndex}`);

                        if (originalText !== undefined && targetTextarea && !targetTextarea.readOnly) {
                            // Paste original text into the translation textarea
                            targetTextarea.value = originalText;

                            // Trigger input event to update counts, stats, etc.
                            const inputEvent = new Event('input', { bubbles: true });
                            targetTextarea.dispatchEvent(inputEvent);

                            // Optional: Briefly focus the textarea
                            targetTextarea.focus();
                            // Optional: Move cursor to the end
                            targetTextarea.setSelectionRange(targetTextarea.value.length, targetTextarea.value.length);
                        } else if (targetTextarea && targetTextarea.readOnly) {
                            // Optional: Inform user if textarea is read-only
                            showMessage(translations[currentLanguage]['edit_first_message'] || 'Click Edit first'); // Need a new translation string
                        }
                    });
                    // --- END: UPDATED EVENT LISTENER ---

                   // Variable para el temporizador (Debounce)
                    let inputDebounceTimer;

                    msgstrTextarea.addEventListener('input', (event) => {
                        // --- A. ACCIONES VISUALES INMEDIATAS (Lo que el ojo ve) ---
                        // Usamos la variable 'msgidPre' que ya existe en el √°mbito, 
                        // en lugar de buscarla en el DOM con querySelector (m√°s lento).
                        autoResizeTextarea(event.target, msgidPre);
                        
                        const charCountSpan = document.getElementById(`charCount-${entryIndex}-${segmentIndex}`);
                        updateCharCount(event.target, parseInt(event.target.dataset.originalLength), charCountSpan);

                        // --- B. L√ìGICA PESADA (Retardada 300ms) ---
                        // Si el usuario sigue escribiendo, cancelamos el c√°lculo anterior
                        clearTimeout(inputDebounceTimer);

                        inputDebounceTimer = setTimeout(() => {
                            const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                            const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                            const segment = poEntries[currentEntryIndex].sentenceSegments[currentSegmentIndex];

                            // 1. Guardar estado ANTERIOR
                            const oldWordCount = segment.wordCountTranslation;
                            const wasTranslated = segment.isTranslated;

                            // 2. Actualizar modelo con NUEVOS datos
                            const newText = event.target.value;
                            segment.translation = newText;
                            segment.wordCountTranslation = countWords(newText);
                            segment.isTranslated = newText.trim() !== '';

                            // 3. C√°lculo Diferencial (Optimizado)
                            if (wasTranslated !== segment.isTranslated) {
                                updateStatsDisplay(); 
                            } else {
                                const diffWords = segment.wordCountTranslation - oldWordCount;
                                if (diffWords !== 0) {
                                    const currentTotal = parseInt(wordsTranslated.textContent) || 0;
                                    wordsTranslated.textContent = currentTotal + diffWords;
                                }
                                updateSaveButtonsState();
                            }
                        }, 300); // Espera 300ms despu√©s de la √∫ltima pulsaci√≥n
                    });
                        
                    msgstrTextarea.addEventListener('focus', (event) => {
                        document.querySelectorAll('.translation-unit-active').forEach(unit => {
                            unit.classList.remove('translation-unit-active');
                        });
                        lastFocusedSegment = { entryIndex, segmentIndex }; // Remember this segment for AI
                        translationUnit.classList.add('translation-unit-active');

                        termsFoundInActiveSegment.clear();
                        const originalSegmentPre = document.getElementById(`msgid-pre-${entryIndex}-${segmentIndex}`);
                        if (originalSegmentPre && glossarySourceLanguage && glossary.length > 0) {
                            const highlightResult = applyGlossaryHighlightToText(segment.original);
                            originalSegmentPre.innerHTML = highlightResult.html;
                            highlightResult.foundTerms.forEach(term => termsFoundInActiveSegment.add(term));
                        }

                        // --- NUEVO: Mostrar etiqueta de glosario ---
                        const glossaryMatchContainer = document.getElementById(`glossary-match-${entryIndex}-${segmentIndex}`);
                        if (glossaryMatchContainer) {
                            glossaryMatchContainer.innerHTML = '';
                            glossaryMatchContainer.title = '';
                            glossaryMatchContainer.classList.add('hidden');

                            if (termsFoundInActiveSegment.size > 0) {
                                let hintText = '';
                                let fullHintText = '';

                                termsFoundInActiveSegment.forEach(foundTerm => {
                                    const glossaryEntry = glossary.find(g => g.srcTerm === foundTerm);
                                    if (glossaryEntry) {
                                        const part = `${glossaryEntry.srcTerm} -> ${glossaryEntry.tgtTerm}`;
                                        hintText += part + ' | ';
                                        fullHintText += part + ' | ';
                                    }
                                });

                                if (hintText) {
                                    glossaryMatchContainer.innerHTML = `
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg>
                                        <span>${hintText.slice(0, -3)}</span>
                                    `;
                                    glossaryMatchContainer.title = `Glosario: ${fullHintText.slice(0, -3)}`;
                                    glossaryMatchContainer.classList.remove('hidden');
                                }
                            }
                        }
                        // --- FIN NUEVO BLOQUE ---

                        updateGlossaryTableHighlights();
                        autoResizeTextarea(event.target, originalCol.querySelector('pre'));
                        event.target.scrollIntoView({ behavior: 'smooth', block: 'center' });

                        const currentSegmentOriginal = poEntries[entryIndex].sentenceSegments[segmentIndex].original;
                        tmBestMatchForActiveSegment = findBestTMMatch(currentSegmentOriginal);
                        tmSearch();
                    });

                    msgstrTextarea.addEventListener('blur', (event) => {
                        // 1. Disparar Autopropagaci√≥n al salir del campo
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        const segmentData = poEntries[currentEntryIndex].sentenceSegments[currentSegmentIndex];
                        
                        // Llamamos a la funci√≥n que creamos en el Paso 2
                        performAutoPropagation(segmentData.original, event.target.value, currentEntryIndex, currentSegmentIndex);
                        // --- NUEVO: Ocultar etiqueta ---
                        const glossaryMatchContainer = document.getElementById(`glossary-match-${entryIndex}-${segmentIndex}`);
                        if (glossaryMatchContainer) {
                            glossaryMatchContainer.classList.add('hidden');
                            glossaryMatchContainer.innerHTML = '';
                        }
                        // --- FIN NUEVO BLOQUE ---

                        const originalSegmentPre = document.getElementById(`msgid-pre-${entryIndex}-${segmentIndex}`);
                        if (originalSegmentPre) {
                            originalSegmentPre.textContent = segment.original;
                        }
                        termsFoundInActiveSegment.clear();
                        updateGlossaryTableHighlights();
                        tmBestMatchForActiveSegment = null;
                        tmSearch();
                    });


                    msgstrTextarea.addEventListener('click', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        if (event.target.readOnly) {
                            setTranslationEditableState(currentEntryIndex, currentSegmentIndex, true);
                        }
                    });

                    validateButton.addEventListener('click', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        // Disparar Autopropagaci√≥n al validar
                        const txtArea = document.getElementById(`msgstr-${currentEntryIndex}-${currentSegmentIndex}`);
                        const segOriginal = poEntries[currentEntryIndex].sentenceSegments[currentSegmentIndex].original;
                        performAutoPropagation(segOriginal, txtArea.value, currentEntryIndex, currentSegmentIndex);
                        setTranslationEditableState(currentEntryIndex, currentSegmentIndex, false);
                        goToNextTranslation(currentEntryIndex, currentSegmentIndex);
                    });

                    editButton.addEventListener('click', (event) => {
                        const currentEntryIndex = parseInt(event.target.dataset.entryIndex);
                        const currentSegmentIndex = parseInt(event.target.dataset.segmentIndex);
                        setTranslationEditableState(currentEntryIndex, currentSegmentIndex, true);
                    });

                    autoResizeTextarea(msgstrTextarea, msgidPre);
updateCharCount(msgstrTextarea, segment.original.length, charCountSpan);
                });

                if (entry.fuzzy) {
                    const fuzzyIndicator = document.createElement('span');
                    fuzzyIndicator.className = 'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800 mt-2';
                    fuzzyIndicator.textContent = translations[currentLanguage]['fuzzy'];
                    translationUnit.appendChild(fuzzyIndicator);
                }

                translationsContainer.appendChild(translationUnit);
            });
            savePoButton.disabled = false;
            convertToMoButton.disabled = false;
            statsContainer.classList.add('show');
            updateStatsDisplay();
            updateUtilityButtonStates();
            updateSaveButtonsState(); // Sincronizar men√∫ File

            const firstEditableSegment = getFirstEditableSegment();
            if (firstEditableSegment) {
                navigateToTranslation(firstEditableSegment.entryIndex, firstEditableSegment.segmentIndex);
            }
        }

        /**
         * Filters and highlights PO entries based on the search input.
         */
        function filterPOEntries() {
            const query = poSearchInput.value.trim();
            const searchInOriginal = searchInOriginalCheckbox.checked;
            const searchInTranslation = searchInTranslationCheckbox.checked;
            
            // Clear previous search state
            searchResults = [];
            currentSearchIndex = -1;
            document.querySelectorAll('.search-highlight, .current-search-highlight').forEach(el => {
                const parent = el.parentNode;
                if (parent) {
                    parent.innerHTML = parent.textContent; // Revert to plain text
                }
            });

            if (!query) {
                poEntries.forEach((entry, index) => {
                    const unit = document.getElementById(`translation-unit-${index}`);
                    if (unit) unit.style.display = 'block';
                });
                updateSearchCounter();
                return;
            }

            const queryRegex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            
            poEntries.forEach((entry, index) => {
                if (entry.isHeader) return;

                const unit = document.getElementById(`translation-unit-${index}`);
                if (!unit) return;

                let matchFound = false;
                const fullMsgstr = entry.sentenceSegments.map(s => s.translation).join(' ');

                // Highlight in original
                if (searchInOriginal) {
                    const msgidElements = unit.querySelectorAll('.original-col pre');
                    msgidElements.forEach(el => {
                        const originalText = el.textContent;
                        if (originalText.match(queryRegex)) {
                            matchFound = true;
                            el.innerHTML = originalText.replace(queryRegex, match => `<span class="search-highlight">${match}</span>`);
                        }
                    });
                }

                // Check for match in translation (without highlighting the textarea)
                if (searchInTranslation && fullMsgstr.match(queryRegex)) {
                    matchFound = true;
                }

                unit.style.display = matchFound ? 'block' : 'none';
            });

            // Populate searchResults array with all new highlights
            searchResults = document.querySelectorAll('.search-highlight');
            updateSearchCounter();
        }
        
        /**
         * Updates the search result counter and button states.
         */
        function updateSearchCounter() {
            const total = searchResults.length;
            const current = total > 0 ? currentSearchIndex + 1 : 0;
            searchResultCounter.textContent = `${current} / ${total}`;
            
            searchPrevBtn.disabled = total === 0;
            searchNextBtn.disabled = total === 0;
        }

        /**
         * Navigates to the next or previous search result.
         * @param {number} direction - 1 for next, -1 for previous.
         */
        function navigateToSearchResult(direction) {
            if (searchResults.length === 0) return;

            // Remove highlight from the current result
            if (currentSearchIndex >= 0 && searchResults[currentSearchIndex]) {
                searchResults[currentSearchIndex].classList.remove('current-search-highlight');
                searchResults[currentSearchIndex].classList.add('search-highlight');
            }

            // Update index
            currentSearchIndex += direction;

            // Loop around
            if (currentSearchIndex >= searchResults.length) {
                currentSearchIndex = 0;
            }
            if (currentSearchIndex < 0) {
                currentSearchIndex = searchResults.length - 1;
            }

            // Highlight the new current result
            const currentResult = searchResults[currentSearchIndex];
            if (currentResult) {
                currentResult.classList.remove('search-highlight');
                currentResult.classList.add('current-search-highlight');
                currentResult.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            
            updateSearchCounter();
        }


        /**
         * Updates the display of translation progress and word counts.
         */
  function updateStatsDisplay() {
    let totalSegments = 0;
    let translatedSegments = 0;
    let totalWordsOriginal = 0;
    let totalWordsTranslated = 0;
    let originalWordsInTranslatedSegments = 0; // Variable clave para el c√°lculo correcto

    poEntries.forEach(entry => {
        if (entry.isHeader) return;
        
        if (entry.sentenceSegments) {
            entry.sentenceSegments.forEach(segment => {
                totalSegments++;
                totalWordsOriginal += segment.wordCountOriginal;
                
                // Comprueba si el segmento est√° validado
                if (segment.isTranslated) {
                    translatedSegments++;
                    totalWordsTranslated += segment.wordCountTranslation;
                    // Acumula las palabras del ORIGINAL del segmento ya traducido
                    originalWordsInTranslatedSegments += segment.wordCountOriginal;
                }
            });
        }
    });

    const percentage = totalSegments > 0 ? ((translatedSegments / totalSegments) * 100).toFixed(0) : 0;
    segmentsProgress.textContent = `${translatedSegments} / ${totalSegments} segments (${percentage}%)`;
    wordsTranslated.textContent = `${totalWordsTranslated}`;
    wordsTotal.textContent = `${totalWordsOriginal}`;
    
    // El c√°lculo correcto para las palabras restantes
    wordsRemaining.textContent = `${totalWordsOriginal - originalWordsInTranslatedSegments}`;
    // --- CORRECCI√ìN FINAL: Asegurar que los botones se activen tras cada cambio ---
    updateSaveButtonsState();
}


        /**
         * Gets the index of the currently focused translation textarea, including the segment index.
         * @returns {{entryIndex: number, segmentIndex: number} | null} The object with indices, or null.
         */
        function getCurrentFocusedIndex() {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.classList.contains('msgstr-textarea')) {
                return {
                    entryIndex: parseInt(activeElement.dataset.entryIndex),
                    segmentIndex: parseInt(activeElement.dataset.segmentIndex)
                };
            }
            return null;
        }

        /**
         * Finds the first editable segment (not a header).
         * @returns {{entryIndex: number, segmentIndex: number} | null} The object with indices, or null.
         */
        function getFirstEditableSegment() {
            for (let i = 0; i < poEntries.length; i++) {
                const entry = poEntries[i];
                if (!entry.isHeader && entry.sentenceSegments && entry.sentenceSegments.length > 0) {
                    return { entryIndex: i, segmentIndex: 0 };
                }
            }
            return null;
        }


        /**
         * Navigates to and focuses a specific translation field (segment).
         * @param {number} entryIndex The index of the PO entry.
         * @param {number} segmentIndex The index of the sentence segment.
         */
        function navigateToTranslation(entryIndex, segmentIndex) {
            const targetTextarea = document.getElementById(`msgstr-${entryIndex}-${segmentIndex}`);
            if (targetTextarea) {
                const currentlyFocusedTextarea = document.activeElement;
                if (currentlyFocusedTextarea && currentlyFocusedTextarea.classList.contains('msgstr-textarea') && currentlyFocusedTextarea !== targetTextarea) {
                    currentlyFocusedTextarea.blur();
                }
                setTranslationEditableState(entryIndex, segmentIndex, true);
                targetTextarea.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        /**
         * Moves focus to the next translation field (segment).
         * @param {number} currentEntryIndex The current index of the PO entry.
         * @param {number} currentSegmentIndex The current index of the sentence segment.
         */
        function goToNextTranslation(currentEntryIndex, currentSegmentIndex) {
            if (poEntries.length === 0) return;

            let nextEntryIndex = currentEntryIndex;
            let nextSegmentIndex = currentSegmentIndex + 1;

            while (true) {
                if (nextEntryIndex >= poEntries.length) {
                    showMessage(translations[currentLanguage]['reached_last']);
                    return;
                }

                const currentEntry = poEntries[nextEntryIndex];
                if (currentEntry.isHeader || !currentEntry.sentenceSegments || currentEntry.sentenceSegments.length === 0) {
                    nextEntryIndex++;
                    nextSegmentIndex = 0;
                    continue;
                }

                if (nextSegmentIndex < currentEntry.sentenceSegments.length) {
                    navigateToTranslation(nextEntryIndex, nextSegmentIndex);
                    return;
                } else {
                    nextEntryIndex++;
                    nextSegmentIndex = 0;
                }
            }
        }

        /**
         * Moves focus to the previous translation field (segment).
         * @param {number} currentEntryIndex The current index of the PO entry.
         * @param {number} currentSegmentIndex The current index of the sentence segment.
         */
        function goToPreviousTranslation(currentEntryIndex, currentSegmentIndex) {
            if (poEntries.length === 0) return;

            let prevEntryIndex = currentEntryIndex;
            let prevSegmentIndex = currentSegmentIndex - 1;

            while (true) {
                if (prevEntryIndex < 0) {
                    showMessage(translations[currentLanguage]['reached_first']);
                    return;
                }

                const currentEntry = poEntries[prevEntryIndex];
                if (currentEntry.isHeader || !currentEntry.sentenceSegments || currentEntry.sentenceSegments.length === 0) {
                    prevEntryIndex--;
                    prevSegmentIndex = (prevEntryIndex >= 0 && poEntries[prevEntryIndex].sentenceSegments) ? poEntries[prevEntryIndex].sentenceSegments.length - 1 : 0;
                    continue;
                }

                if (prevSegmentIndex >= 0) {
                    navigateToTranslation(prevEntryIndex, prevSegmentIndex);
                    return;
                } else {
                    prevEntryIndex--;
                    prevSegmentIndex = (prevEntryIndex >= 0 && poEntries[prevEntryIndex].sentenceSegments) ? poEntries[prevEntryIndex].sentenceSegments.length - 1 : 0;
                }
            }
        }

        // --- Event Handlers ---

        poFile.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                currentFileName = file.name;
                const content = await file.text();
                processPoContent(content);
            }
        });

        function processPoContent(content) {
             showLoadingOverlay(translations[currentLanguage]['loading_file']);
             try {
                poEntries = parsePoContent(content);
setTimeout(() => {
    renderTranslations(poEntries);
    updateStatsDisplay();
}, 0);
                poSearchInput.value = ''; // Clear search on new file
                filterPOEntries(); // Apply empty filter to reset view
             } catch (error) {
                showMessage(`${translations[currentLanguage]['error_reading_file']} ${error.message}`);
                console.error("Error parsing file:", error);
                translationsContainer.innerHTML = `
                    <div class="text-center text-red-500 p-4 border border-red-300 rounded-md">
                        ${translations[currentLanguage]['file_processing_error']}
                    </div>
                `;
                savePoButton.disabled = true;
                convertToMoButton.disabled = true;
                poSearchContainer.classList.add('hidden');
                statsContainer.classList.remove('show');
                updateUtilityButtonStates();
             } finally {
                hideLoadingOverlay();
             }
        }

        savePoButton.addEventListener('click', async () => {
            if (poEntries.length === 0) {
                showMessage(translations[currentLanguage]['no_translations_to_save']);
                return;
            }
            showLoadingOverlay(translations[currentLanguage]['saving_file']);
            try {
                const updatedPoContent = reconstructPo(poEntries);
                const blob = new Blob([updatedPoContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = currentFileName.replace(/\.po$/i, '') + '.po';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showMessage(translations[currentLanguage]['file_saved_successfully']);
            } catch (error) {
                showMessage(`${translations[currentLanguage]['error_saving_file']} ${error.message}`);
                console.error("Error saving file:", error);
            } finally {
                hideLoadingOverlay();
            }
        });

        async function processFile(file) {
            currentFileName = file.name;
            const content = await file.text();
            processPoContent(content);
        }

        // Main keydown listener
        document.addEventListener('keydown', (event) => {
            // Ignore keydown events if a modal is open or if the event originates from an input field not part of the main translation flow
            const activeElement = document.activeElement;
            const isModalOpen = !shortcutsModal.classList.contains('hidden') || 
                                !findReplaceModal.classList.contains('hidden') || 
                                !messageBox.classList.contains('hidden') || 
                                !saveProjectModal.classList.contains('hidden') ||
                                !backupModal.classList.contains('hidden') ||
                                !restoreBackupModal.classList.contains('hidden');

            if (isModalOpen && activeElement.id !== 'findInput' && activeElement.id !== 'replaceInput') {
                 // Exception for find/replace inputs inside their modal
                if (activeElement.closest('.modal') && !activeElement.classList.contains('shortcut-input')) {
                   return;
                }
            }

            // Check if the event matches any configured shortcut
            for (const action in shortcutConfig) {
                const config = shortcutConfig[action];

                if (event.ctrlKey === config.ctrlKey &&
                    event.altKey === config.altKey &&
                    event.shiftKey === config.shiftKey &&
                    event.key.toLowerCase() === config.key.toLowerCase()) {
                    
                    event.preventDefault();
                    handleShortcutAction(action, event.key);
                    return; 
                }
            }
        });

        function handleShortcutAction(action, pressedKey) {
            const currentFocused = getCurrentFocusedIndex();

            // La mayor√≠a de las acciones requieren un segmento activo (excepto abrir proyecto o la IA)
            if (!currentFocused && !action.startsWith('open') && action !== 'toggleAI') return;

            // Manejo din√°mico para acciones numeradas
            if (action.startsWith('insertTMMatch') || action.startsWith('insertGlossaryTerm')) {
                const isTM = action.startsWith('insertTMMatch');
                const items = isTM ? currentTMLatestSearchResults : currentGlossaryLatestResults;
                const index = parseInt(action.slice(-1)) - 1; // Extrae el n√∫mero del final de la acci√≥n

                if (items.length > index) {
                    const itemToInsert = items[index];
                    const textToInsert = isTM ? itemToInsert.tgtText : itemToInsert.tgtTerm;
                    const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                    
                    if (targetTextarea && !targetTextarea.readOnly) {
                        const start = targetTextarea.selectionStart;
                        const end = targetTextarea.selectionEnd;
                        targetTextarea.value = targetTextarea.value.substring(0, start) + textToInsert + targetTextarea.value.substring(end);
                        targetTextarea.selectionStart = targetTextarea.selectionEnd = start + textToInsert.length;
                        
                        // Dispara el evento 'input' para actualizar contadores
                        targetTextarea.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                } else {
                    showMessage(translations[currentLanguage][isTM ? 'tm_no_match_found' : 'no_match_found']);
                }
                return; // Acci√≥n manejada
            }
// Manejo para el resto de acciones
        switch (action) {
            case 'toggleAI':
                const aiButton = document.getElementById('aiBtn');
                if (aiButton) aiButton.click();
                break;
            
            case 'insertLastAI':
                if (lastAiResponseText) {
                    insertAiResponse(lastAiResponseText);
                } else {
                    showMessage(translations[currentLanguage]['no_ai_response_yet']);
                }
                break;

            case 'validateAndNext':
                // Es importante verificar que currentFocused existe antes de usarlo
                if (currentFocused) {
                    setTranslationEditableState(currentFocused.entryIndex, currentFocused.segmentIndex, false);
                    goToNextTranslation(currentFocused.entryIndex, currentFocused.segmentIndex);
                }
                break;

            case 'nextSegment':
                if (currentFocused) {
                    goToNextTranslation(currentFocused.entryIndex, currentFocused.segmentIndex);
                }
                break;

            case 'prevSegment':
                if (currentFocused) {
                    goToPreviousTranslation(currentFocused.entryIndex, currentFocused.segmentIndex);
                }
                break;
        }
    } // Cierre de la funci√≥n handleShortcutAction


        function showMessage(msg) {
            messageText.textContent = msg;
            messageBox.classList.remove('hidden');
        }

        /**
     * Prompts the user to select a file and returns its content and name.
     * @param {string} inputId The ID of the hidden file input element.
     * @param {string} promptMessage A message to show the user (optional).
     * @returns {Promise<{content: string, name: string}>}
     */
    function selectFile(inputId, promptMessage = 'Please select a file:') {
        return new Promise((resolve, reject) => {
            const fileInput = document.getElementById(inputId);
            if (!fileInput) {
                return reject(`File input with ID "${inputId}" not found.`);
            }

            // Optional: Show a message if needed (could use your showMessage modal)
            // alert(promptMessage); // Simple alert for now

            const changeHandler = async (event) => {
                const file = event.target.files[0];
                if (file) {
                    try {
                        const content = await file.text();
                        resolve({ content: content, name: file.name });
                    } catch (error) {
                        reject(`Error reading file: ${error.message}`);
                    }
                } else {
                    reject(translations[currentLanguage]['select_file_error'] || 'File selection failed or cancelled.');
                }
                // Clean up listener and reset input
                fileInput.removeEventListener('change', changeHandler);
                fileInput.value = ''; // Allows selecting the same file again
            };

            fileInput.addEventListener('change', changeHandler);
            fileInput.click();
        });
    }

        messageClose.addEventListener('click', () => {
            messageBox.classList.add('hidden');
        });

        shortcutsBtn.addEventListener('click', () => {
            tempShortcutConfig = JSON.parse(JSON.stringify(shortcutConfig)); // Create a deep copy for editing
            renderShortcutsUI();
            shortcutsModal.classList.remove('hidden');
        });

        shortcutsCloseBtn.addEventListener('click', () => {
            shortcutsModal.classList.add('hidden');
        });

        findReplaceBtn.addEventListener('click', () => {
            findReplaceModal.classList.remove('hidden');
            findInput.focus();
        });

        findReplaceCloseBtn.addEventListener('click', () => {
            findReplaceModal.classList.add('hidden');
            findState.lastFound = null;
            const currentFocused = getCurrentFocusedIndex();
            if (currentFocused) {
                const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                if (targetTextarea) {
                    targetTextarea.setSelectionRange(targetTextarea.value.length, targetTextarea.value.length);
                }
            }
        });

        findNextBtn.addEventListener('click', () => findAndNavigate(true));
        findPrevBtn.addEventListener('click', () => findAndNavigate(false));
        replaceBtn.addEventListener('click', replaceCurrentMatch);
        replaceAllBtn.addEventListener('click', replaceAllMatches);

        function findAndNavigate(forward = true) {
            const query = findInput.value;
            if (!query) {
                showMessage(translations[currentLanguage]['no_find_query']);
                return;
            }

            findState.query = query;
            findState.caseSensitive = caseSensitiveCheckbox.checked;
            findState.useRegex = regexCheckbox.checked;

            let regex;
            try {
                regex = findState.useRegex ? new RegExp(findState.query, findState.caseSensitive ? '' : 'i') : null;
            } catch (e) {
                showMessage(`Regular expression error: ${e.message}`);
                return;
            }

            let startEntryIndex = 0;
            let startSegmentIndex = 0;
            let startMatchIndex = 0;

            if (findState.lastFound) {
                startEntryIndex = findState.lastFound.entryIndex;
                startSegmentIndex = findState.lastFound.segmentIndex;
                startMatchIndex = forward ? findState.lastFound.matchEnd : findState.lastFound.matchStart - 1;
            } else {
                if (!forward) {
                    startEntryIndex = poEntries.length - 1;
                    if (poEntries[startEntryIndex] && poEntries[startEntryIndex].sentenceSegments) {
                        startSegmentIndex = poEntries[startEntryIndex].sentenceSegments.length - 1;
                    } else {
                        startSegmentIndex = 0;
                    }
                    startMatchIndex = Infinity;
                }
            }

            let found = false;
            let currentEntryIndex = startEntryIndex;
            let currentSegmentIndex = startSegmentIndex;
            const totalEntries = poEntries.length;

            for (let i = 0; i < totalEntries; i++) {
                const entry = poEntries[currentEntryIndex];
                if (!entry || entry.isHeader || !entry.sentenceSegments) {
                    currentEntryIndex = (currentEntryIndex + (forward ? 1 : -1) + totalEntries) % totalEntries;
                    currentSegmentIndex = forward ? 0 : (entry && entry.sentenceSegments ? entry.sentenceSegments.length - 1 : 0);
                    continue;
                }

                const totalSegments = entry.sentenceSegments.length;
                let segmentLoopStart = forward ? 0 : totalSegments - 1;
                let segmentLoopEnd = forward ? totalSegments : -1;
                let segmentLoopStep = forward ? 1 : -1;

                if (currentEntryIndex === startEntryIndex) {
                    segmentLoopStart = startSegmentIndex;
                }


                for (let j = segmentLoopStart; forward ? (j < segmentLoopEnd) : (j >= segmentLoopEnd); j += segmentLoopStep) {
                    const segment = entry.sentenceSegments[j];
                    const text = segment.translation;
                    let match;

                    if (findState.useRegex) {
                        regex.lastIndex = 0;
                        if (forward) {
                            let searchFrom = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : 0;
                            const subText = text.substring(searchFrom);
                            match = regex.exec(subText);
                            if (match) {
                                match.index += searchFrom;
                            }
                        } else {
                            let allMatches = [];
                            let tempRegex = new RegExp(regex.source, regex.flags.includes('g') ? regex.flags : regex.flags + 'g');
                            let tempMatch;
                            while((tempMatch = tempRegex.exec(text)) !== null) {
                                allMatches.push(tempMatch);
                            }
                            let searchUntil = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : text.length;
                            match = allMatches.reverse().find(m => m.index < searchUntil);
                        }
                    } else {
                        const searchText = findState.caseSensitive ? text : text.toLowerCase();
                        const queryLower = findState.caseSensitive ? findState.query : findState.query.toLowerCase();

                        if (forward) {
                            let searchFrom = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : 0;
                            const foundIndex = searchText.indexOf(queryLower, searchFrom);
                            if (foundIndex !== -1) {
                                match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                            }
                        } else {
                            let searchUntil = (currentEntryIndex === startEntryIndex && j === startSegmentIndex) ? startMatchIndex : text.length;
                            const foundIndex = searchText.lastIndexOf(queryLower, searchUntil);
                            if (foundIndex !== -1) {
                                match = { index: foundIndex, 0: text.substring(foundIndex, foundIndex + queryLower.length) };
                            }
                        }
                    }

                    if (match) {
                        findState.lastFound = {
                            entryIndex: currentEntryIndex,
                            segmentIndex: j,
                            matchStart: match.index,
                            matchEnd: match.index + match[0].length,
                        };
                        navigateToTranslation(currentEntryIndex, j);
                        const targetTextarea = document.getElementById(`msgstr-${currentEntryIndex}-${j}`);
                        if (targetTextarea) {
                            targetTextarea.setSelectionRange(findState.lastFound.matchStart, findState.lastFound.matchEnd);
                        }
                        found = true;
                        return;
                    }
                }
                if (found) break;

                currentEntryIndex = (currentEntryIndex + (forward ? 1 : -1) + totalEntries) % totalEntries;
                currentSegmentIndex = forward ? 0 : (poEntries[currentEntryIndex].sentenceSegments ? poEntries[currentEntryIndex].sentenceSegments.length - 1 : 0);
            }

            if (!found) {
                showMessage(translations[currentLanguage]['no_match_found']);
                findState.lastFound = null;
            }
        }


        function replaceCurrentMatch() {
            if (!findState.lastFound || !findState.query) {
                showMessage(translations[currentLanguage]['no_match_found']);
                return;
            }

            const { entryIndex, segmentIndex, matchStart, matchEnd } = findState.lastFound;
            const segment = poEntries[entryIndex].sentenceSegments[segmentIndex];
            let originalText = segment.translation;
            let replacedText;

            if (findState.useRegex) {
                 const regex = new RegExp(findState.query, findState.caseSensitive ? '' : 'i');
                 replacedText = originalText.substring(0, matchStart) +
                                originalText.substring(matchStart, matchEnd).replace(regex, findState.replace) +
                                originalText.substring(Math.min(matchEnd, originalText.length));

            } else {
                replacedText = originalText.substring(0, matchStart) +
                               findState.replace +
                               originalText.substring(Math.min(matchEnd, originalText.length));
            }

            segment.translation = replacedText;
            segment.wordCountTranslation = countWords(replacedText);
            segment.isTranslated = replacedText.trim() !== '';

            renderTranslations(poEntries);
            navigateToTranslation(entryIndex, segmentIndex);
            updateStatsDisplay();

            findState.lastFound = null;
        }

        function replaceAllMatches() {
            const query = findInput.value;
            const replaceWith = replaceInput.value;
            if (!query) {
                showMessage(translations[currentLanguage]['no_find_query']);
                return;
            }

            let replacedCount = 0;
            let regex;
            try {
                regex = new RegExp(query, (caseSensitiveCheckbox.checked ? '' : 'i') + 'g' + (regexCheckbox.checked ? '' : ''));
            } catch (e) {
                showMessage(`Regular expression error: ${e.message}`);
                return;
            }

            poEntries.forEach(entry => {
                if (entry.isHeader) {
                    return;
                }

                entry.sentenceSegments.forEach(segment => {
                    let originalTranslation = segment.translation;
                    let newTranslation;

                    if (regexCheckbox.checked) {
                        newTranslation = originalTranslation.replace(regex, replaceWith);
                    } else {
                        const searchStr = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const nonRegexRegex = new RegExp(searchStr, (caseSensitiveCheckbox.checked ? '' : 'i') + 'g');
                        newTranslation = originalTranslation.replace(nonRegexRegex, replaceWith);
                    }

                    if (originalTranslation !== newTranslation) {
                        segment.translation = newTranslation;
                        segment.wordCountTranslation = countWords(newTranslation);
                        segment.isTranslated = newTranslation.trim() !== '';
                        replacedCount++;
                    }
                });
            });

            renderTranslations(poEntries);
            showMessage(`${replacedCount} ${translations[currentLanguage]['replaced_all']}`);
            findState.lastFound = null;
            updateStatsDisplay();
        }


        function setLanguage(lang) {
            currentLanguage = lang;
            document.documentElement.lang = lang;
            
            const langEnBtn = document.getElementById('langEnBtn');
            const langEsBtn = document.getElementById('langEsBtn');
            
            langEnBtn.classList.remove('active-lang');
            langEsBtn.classList.remove('active-lang');
            langEnBtn.style.backgroundColor = 'var(--color-medium-gray)';
            langEnBtn.style.color = 'var(--color-dark)';
            langEsBtn.style.backgroundColor = 'var(--color-medium-gray)';
            langEsBtn.style.color = 'var(--color-dark)';


            if (lang === 'en') {
                langEnBtn.classList.add('active-lang');
                langEnBtn.style.backgroundColor = 'var(--color-dark)';
                langEnBtn.style.color = 'var(--color-white)';
            } else {
                langEsBtn.classList.add('active-lang');
                langEsBtn.style.backgroundColor = 'var(--color-dark)';
                langEsBtn.style.color = 'var(--color-white)';
            }

            updateTextContent();
            renderTranslations(poEntries);
            renderGlossary();
        }

        function updateTextContent() {
            const lang = translations[currentLanguage];

            // Selector mejorado: busca elementos por texto, placeholder o t√≠tulo
            document.querySelectorAll('[data-i18n], [data-i18n-placeholder], [data-i18n-title]').forEach(element => {
                // Obtenemos la clave del atributo que est√© presente
                const key = element.getAttribute('data-i18n') || element.getAttribute('data-i18n-placeholder') || element.getAttribute('data-i18n-title');
                
                if (lang[key]) {
                    if (element.hasAttribute('data-i18n-placeholder')) {
                        element.placeholder = lang[key];
                    } else if (element.hasAttribute('data-i18n-title')) {
                        element.title = lang[key];
                    } else {
                        element.textContent = lang[key];
                    }
                }
            });
            
            const displaySourceLanguageLabel = document.getElementById('displaySourceLanguageLabel');
            if (displaySourceLanguageLabel) displaySourceLanguageLabel.textContent = lang['source_language'];
            
            const displayTargetLanguageLabel = document.getElementById('displayTargetLanguageLabel');
            if (displayTargetLanguageLabel) displayTargetLanguageLabel.textContent = lang['target_language'];

            const displayTmSourceLanguageLabel = document.getElementById('displayTmSourceLanguageLabel');
            if (displayTmSourceLanguageLabel) displayTmSourceLanguageLabel.textContent = lang['source_language'];

            const displayTmTargetLanguageLabel = document.getElementById('displayTmTargetLanguageLabel');
            if (displayTmTargetLanguageLabel) displayTmTargetLanguageLabel.textContent = lang['target_language'];
            
            const findReplaceCloseBtnText = document.getElementById('findReplaceCloseBtnText');
            if(findReplaceCloseBtnText) findReplaceCloseBtnText.textContent = lang['close_btn'];
        }

        function updateMainContentOffset() {
            const isTerminologyOpen = terminologySidebar.classList.contains('show-sidebar');
            const isTranslationMemoryOpen = translationMemorySidebar.classList.contains('show-sidebar');
            
            if (centralColumn) {
                centralColumn.classList.remove('left-sidebar-active', 'right-sidebar-active');

                if (isTerminologyOpen) {
                    centralColumn.classList.add('left-sidebar-active');
                    document.documentElement.style.setProperty('--terminology-sidebar-width', terminologySidebar.offsetWidth + 'px');
                }
                if (isTranslationMemoryOpen || (aiSidebar && aiSidebar.classList.contains('show-sidebar'))) {
                    centralColumn.classList.add('right-sidebar-active');
                    // Prefer TM width if open, otherwise AI width
                    const width = isTranslationMemoryOpen ? translationMemorySidebar.offsetWidth : aiSidebar.offsetWidth;
                    document.documentElement.style.setProperty('--translation-memory-sidebar-width', width + 'px');
                }
            } else {
                console.warn("central-column element not found for offset update.");
            }
        }

        function updateUtilityButtonStates() {
            if (terminologySidebar.classList.contains('show-sidebar')) {
                terminologyBtn.classList.add('utility-btn-active');
            } else {
                terminologyBtn.classList.remove('utility-btn-active');
            }

            if (translationMemorySidebar.classList.contains('show-sidebar')) {
                tmBtn.classList.add('utility-btn-active');
            } else {
                tmBtn.classList.remove('utility-btn-active');
            }

            if (statsContainer.classList.contains('show')) {
                statsBtn.classList.add('utility-btn-active');
            } else {
                statsBtn.classList.remove('utility-btn-active');
            }
            if (aiSidebar && aiSidebar.classList.contains('show-sidebar')) {
                document.getElementById('aiBtn').classList.add('utility-btn-active');
            } else {
                document.getElementById('aiBtn')?.classList.remove('utility-btn-active');
            }
        }

        // --- Shortcut Customization Logic ---
        function formatShortcut(config) {
            let parts = [];
            if (config.ctrlKey) parts.push('Ctrl');
            if (config.altKey) parts.push('Alt');
            if (config.shiftKey) parts.push('Shift');
            
            let key = config.key;
            if (key === 'ArrowUp') key = '‚Üë';
            if (key === 'ArrowDown') key = '‚Üì';
            if (key === 'ArrowLeft') key = '‚Üê';
            if (key === 'ArrowRight') key = '‚Üí';

            parts.push(key);
            return parts.join(' + ');
        }

        function renderShortcutsUI() {
            shortcutsEditor.innerHTML = '';
            const lang = translations[currentLanguage];

            for (const action in tempShortcutConfig) {
                const config = tempShortcutConfig[action];
                
                let translationKey;
                if (action.startsWith('insertTMMatch')) {
                    translationKey = `shortcut_tm_insert_${action.slice(-1)}`;
                } else if (action.startsWith('insertGlossaryTerm')) {
                    translationKey = `shortcut_glossary_insert_${action.slice(-1)}`;
                } else {
                    // --- INICIO DE LA CORRECCI√ìN ---
                    // Hacemos una correspondencia manual para los casos que no coinciden
                    switch (action) {
                        case 'validateAndNext':
                            translationKey = 'shortcut_validate';
                            break;
                        case 'nextSegment':
                            translationKey = 'shortcut_next';
                            break;
                        case 'prevSegment':
                            translationKey = 'shortcut_prev';
                            break;
                        default:
                            // Un respaldo para futuros atajos que s√≠ coincidan
                            translationKey = `shortcut_${action}`;
                            break;
                    }
                    // --- FIN DE LA CORRECCI√ìN ---
                }
                const actionLabel = lang[translationKey] || action;
                
                const row = document.createElement('div');
                row.className = 'grid grid-cols-2 items-center gap-4';
                
                const label = document.createElement('label');
                label.className = 'text-on-light-contrast font-medium';
                label.textContent = actionLabel;
                row.appendChild(label);
                
                const input = document.createElement('input');
                input.type = 'text';
                input.readOnly = true;
                input.className = 'shortcut-input';
                input.value = formatShortcut(config);
                input.dataset.action = action;
                input.placeholder = lang['click_to_set_shortcut'];

                input.addEventListener('keydown', (e) => {
                    e.preventDefault();
                    
                    const tempConfig = {
                        ctrlKey: e.ctrlKey,
                        altKey: e.altKey,
                        shiftKey: e.shiftKey,
                        key: '...'
                    };
                    input.value = formatShortcut(tempConfig);

                    if (!['Control', 'Alt', 'Shift', 'Meta'].includes(e.key)) {
                        const newConfig = {
                            ctrlKey: e.ctrlKey,
                            altKey: e.altKey,
                            shiftKey: e.shiftKey,
                            key: (e.key.length === 1) ? e.key.toLowerCase() : e.key
                        };

                        tempShortcutConfig[action] = newConfig;
                        input.value = formatShortcut(newConfig);
                        input.blur();
                    }
                });

                input.addEventListener('blur', () => {
                    input.value = formatShortcut(tempShortcutConfig[action]);
                });
                
                row.appendChild(input);
                shortcutsEditor.appendChild(row);
            }
        }

        saveShortcutsBtn.addEventListener('click', () => {
            shortcutConfig = JSON.parse(JSON.stringify(tempShortcutConfig));
            localStorage.setItem('poandaShortcutConfig', JSON.stringify(shortcutConfig));
            showMessage(translations[currentLanguage]['shortcuts_saved']);
            shortcutsModal.classList.add('hidden');
        });
        
        resetShortcutsBtn.addEventListener('click', () => {
            tempShortcutConfig = JSON.parse(JSON.stringify(defaultShortcutConfig));
            renderShortcutsUI();
            showMessage(translations[currentLanguage]['shortcuts_reset']);
        });

        exportShortcutsBtn.addEventListener('click', () => {
            const jsonString = JSON.stringify(shortcutConfig, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'poanda_shortcuts.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        importShortcutsBtn.addEventListener('click', () => {
            importShortcutsInput.click();
        });

        importShortcutsInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedConfig = JSON.parse(e.target.result);
                    // Basic validation
                    if (typeof importedConfig === 'object' && importedConfig.validateAndNext) {
                        tempShortcutConfig = { ...defaultShortcutConfig, ...importedConfig };
                        renderShortcutsUI();
                        showMessage(translations[currentLanguage]['shortcuts_loaded']);
                    } else {
                        throw new Error("Invalid format");
                    }
                } catch (error) {
                    showMessage(translations[currentLanguage]['error_loading_shortcuts']);
                    console.error("Error importing shortcuts:", error);
                } finally {
                    importShortcutsInput.value = ''; // Reset file input
                }
            };
            reader.readAsText(file);
        });


        // --- Terminology Sidebar Logic ---
        terminologyBtn.addEventListener('click', () => {
            const isHidden = !terminologySidebar.classList.contains('show-sidebar');
            if (isHidden) {
                terminologySidebar.classList.add('show-sidebar');
            } else {
                terminologySidebar.classList.remove('show-sidebar');
            }
            updateMainContentOffset();
            updateUtilityButtonStates();
            if (isHidden) {
                if (!glossarySourceLanguage || !glossaryTargetLanguage) {
                    showLanguageConfigSection();
                } else {
                    showGlossaryEditorSection();
                }
            }
        });

        closeTerminologySidebarBtn.addEventListener('click', () => {
            terminologySidebar.classList.remove('show-sidebar');
            updateMainContentOffset();
            updateUtilityButtonStates();
        });

        function populateIsoLanguagesDatalist() {
            isoLanguagesDatalist.innerHTML = '';
            isoLanguagesData.forEach(lang => {
                const option = document.createElement('option');
                option.value = lang.code;
                option.textContent = lang.name;
                isoLanguagesDatalist.appendChild(option);
            });
        }

        function resetGlossary() {
            glossary = [];
            glossarySourceLanguage = '';
            glossaryTargetLanguage = '';
            if (configSrcLang) configSrcLang.value = 'en-US';
            if (configTgtLang) configTgtLang.value = 'es-ES';
            if (srcTermInput) srcTermInput.value = "";
            if (tgtTermInput) tgtTermInput.value = "";
            if (searchTermInput) searchTermInput.value = "";

            if (terminologyLanguageConfigSection && terminologyEditorSection) {
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }

            renderGlossary();
            renderTranslations(poEntries);
            updateStatsDisplay();
        }

        function showLanguageConfigSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection) {
                terminologyLanguageConfigSection.style.display = 'block';
                terminologyEditorSection.style.display = 'none';
            }
        }

        function showGlossaryEditorSection() {
            if (terminologyLanguageConfigSection && terminologyEditorSection && displaySrcLang && displayTgtLang) {
                terminologyLanguageConfigSection.style.display = 'none';
                terminologyEditorSection.style.display = 'block';
                displaySrcLang.value = glossarySourceLanguage;
                displayTgtLang.value = glossaryTargetLanguage;
                renderGlossary();
            }
        }

        function confirmGlossaryLanguages() {
            const srcLang = configSrcLang ? configSrcLang.value.trim() : '';
            const tgtLang = configTgtLang ? configTgtLang.value.trim() : '';

            if (!srcLang || !tgtLang) {
                showMessage(translations[currentLanguage]['lang_config_required']);
                return;
            }

            glossarySourceLanguage = srcLang;
            glossaryTargetLanguage = tgtLang;

            showGlossaryEditorSection();
            renderTranslations(poEntries);
        }

        function addTerm() {
            const srcTerm = srcTermInput ? srcTermInput.value.trim() : '';
            const tgtTerm = tgtTermInput ? tgtTermInput.value.trim() : '';

            if (!srcTerm || !tgtTerm) {
                showMessage(translations[currentLanguage]['both_terms_required']);
                return;
            }

            glossary.push({
                srcLang: glossarySourceLanguage,
                srcTerm: srcTerm,
                tgtLang: glossaryTargetLanguage,
                tgtTerm: tgtTerm
            });
            if (srcTermInput) srcTermInput.value = "";
            if (tgtTermInput) tgtTermInput.value = "";
            renderGlossary();
            renderTranslations(poEntries);
        }

        function deleteTerm(index) {
            glossary.splice(index, 1);
            renderGlossary();
            renderTranslations(poEntries);
        }

        function renderGlossary() {
            if (!glossaryTableBody) {
                console.warn("glossaryTableBody element not found. Cannot render glossary.");
                return;
            }
            const search = searchTermInput ? searchTermInput.value.toLowerCase() : '';
            glossaryTableBody.innerHTML = "";

            const filteredGlossary = glossary.filter(entry =>
                (entry.srcTerm && entry.srcTerm.toLowerCase().includes(search)) ||
                (entry.tgtTerm && entry.tgtTerm.toLowerCase().includes(search))
            );

            const highlightedTerms = [];
            const otherTerms = [];

            filteredGlossary.forEach(entry => {
                if (entry.srcTerm && termsFoundInActiveSegment.has(entry.srcTerm)) {
                    highlightedTerms.push(entry);
                } else {
                    otherTerms.push(entry);
                }
            });

            currentGlossaryLatestResults = [...highlightedTerms, ...otherTerms.sort((a, b) => a.srcTerm.localeCompare(b.srcTerm))];

            highlightedTerms.forEach((entry, i) => {
                const row = document.createElement("tr");
                row.classList.add('glossary-row-highlight');
                row.innerHTML = `
                    <td>${entry.srcTerm}</td>
                    <td>${entry.tgtTerm}</td>
                    <td><button class="glossary-delete-btn" onclick="deleteTerm(${glossary.indexOf(entry)})">${translations[currentLanguage]['delete_button']}</button></td>
                `;
                glossaryTableBody.appendChild(row);
            });

            otherTerms.forEach((entry, i) => {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td>${entry.srcTerm}</td>
                    <td>${entry.tgtTerm}</td>
                    <td><button class="glossary-delete-btn" onclick="deleteTerm(${glossary.indexOf(entry)})">${translations[currentLanguage]['delete_button']}</button></td>
                `;
                glossaryTableBody.appendChild(row);
            });
        }

        function generateTBX() {
            const xml = [`<?xml version="1.0" encoding="UTF-8"?>`,
                `<martif type="TBX" xml:lang="${glossarySourceLanguage}">`,
                `  <text>`,
                `    <body>`];

            glossary.forEach(entry => {
                xml.push(`      <termEntry>`);
                xml.push(`        <LangSet xml:lang="${entry.srcLang}">`);
                xml.push(`          <tig><term>${entry.srcTerm}</term></tig>`);
                xml.push(`        </LangSet>`);
                xml.push(`        <LangSet xml:lang="${entry.tgtLang}">`);
                xml.push(`          <tig><term>${entry.tgtTerm}</term></tig>`);
                xml.push(`        </LangSet>`);
                xml.push(`      </termEntry>`);
            });

            xml.push(`    </body>`, `  </text>`, `</martif>`);
            return xml.join("\n");
        }

        function downloadTBX() {
            if (glossary.length === 0 && (!glossarySourceLanguage || !glossaryTargetLanguage)) {
                showMessage(translations[currentLanguage]['cannot_download_empty_or_unconfigured_glossary']);
                return;
            }
            showLoadingOverlay(translations[currentLanguage]['saving_file']);
            try {
                const blob = new Blob([generateTBX()], { type: "application/xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "glossary.tbx";
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(url);
                showMessage(translations[currentLanguage]['tbx_saved_successfully']);
            } catch (error) {
                showMessage(`${translations[currentLanguage]['error_saving_file']} ${error.message}`);
                console.error("Error downloading TBX:", error);
            } finally {
                hideLoadingOverlay();
            }
        }

        function loadTBX() {
            if (!tbxFileInput) {
                console.warn("tbxFileInput element not found. Cannot load TBX.");
                return;
            }
            tbxFileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const content = await file.text();
                processTBXContent(content);
            };
            tbxFileInput.click();
        }

        function processTBXContent(content) {
            showLoadingOverlay(translations[currentLanguage]['loading_file']);
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, "application/xml");

                if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                    const errorText = xmlDoc.getElementsByTagName("parsererror")[0].textContent;
                    throw new Error("Invalid XML/TBX format: " + errorText);
                }

                if (xmlDoc.getElementsByTagName("tu").length > 0) {
                    showTMInternalMessage(translations[currentLanguage]['tbx_file_expected_tmx_found'], true);
                    throw new Error("Attempted to load TMX into Glossary.");
                }

                const entries = xmlDoc.getElementsByTagName("termEntry");
                glossary = [];
                let firstEntryLangs = { src: '', tgt: '' };

                if (entries.length > 0) {
                    const firstSets = entries[0].getElementsByTagName("LangSet");
                    if (firstSets.length >= 2) {
                        firstEntryLangs.src = firstSets[0].getAttribute("xml:lang");
                        firstEntryLangs.tgt = firstSets[1].getAttribute("xml:lang");
                    }
                }

                for (let entry of entries) {
                    const sets = entry.getElementsByTagName("LangSet");
                    if (sets.length >= 2) {
                        const lang1 = sets[0].getAttribute("xml:lang");
                        const term1 = sets[0].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                        const lang2 = sets[1].getAttribute("xml:lang");
                        const term2 = sets[1].getElementsByTagName("tig")[0]?.getElementsByTagName("term")[0]?.textContent || '';
                        glossary.push({ srcLang: lang1, srcTerm: term1, tgtLang: lang2, tgtTerm: term2 });
                    }
                }

                if (glossary.length > 0 && firstEntryLangs.src && firstEntryLangs.tgt) {
                    glossarySourceLanguage = firstEntryLangs.src;
                    glossaryTargetLanguage = firstEntryLangs.tgt;
                } else if (glossary.length === 0) {
                    showMessage(translations[currentLanguage]['error_loading_tbx_file']);
                }

                showGlossaryEditorSection();
                renderTranslations(poEntries);

            } catch (error) {
                console.error("Error loading TBX file:", error);
                if (!error.message.includes("Attempted to load TMX")) {
                     showMessage(translations[currentLanguage]['error_loading_tbx_file']);
                }
                resetGlossary();
            } finally {
                hideLoadingOverlay();
            }
        }


        // --- Translation Memory (TM) Logic ---

        function levenshteinDistance(a, b) {
            const an = a.length;
            const bn = b.length;
            if (an === 0) return bn;
            if (bn === 0) return an;

            const matrix = [];

            for (let i = 0; i <= bn; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= an; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= bn; i++) {
                for (let j = 1; j <= an; j++) {
                    const cost = (a[j - 1] === b[i - 1]) ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j - 1] + cost
                    );
                }
            }
            return matrix[bn][an];
        }

        function calculateSimilarity(s1, s2) {
            if (!s1 || !s2) return 0;
            const longerLength = Math.max(s1.length, s2.length);
            if (longerLength === 0) return 100;
            const distance = levenshteinDistance(s1, s2);
            return ((longerLength - distance) / longerLength) * 100;
        }


        tmBtn.addEventListener('click', () => {
            const isHidden = !translationMemorySidebar.classList.contains('show-sidebar');
            if (isHidden) {
                translationMemorySidebar.classList.add('show-sidebar');
            } else {
                translationMemorySidebar.classList.remove('show-sidebar');
            }
            updateMainContentOffset();
            updateUtilityButtonStates();
            if (isHidden) {
                if (!tmSourceLanguage || !tmTargetLanguage) {
                    showTMLanguageConfigSection();
                } else {
                    showTMEditorSection();
                    tmSearch();
                }
            }
        });

        closeTranslationMemorySidebarBtn.addEventListener('click', () => {
            translationMemorySidebar.classList.remove('show-sidebar');
            updateMainContentOffset();
            updateUtilityButtonStates();
        });

        tmFileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                 const content = await file.text();
                 processTMXContent(content);
            }
        });

        function showTMInternalMessage(msg, isError = false) {
            if (tmInternalMessage) {
                tmInternalMessage.textContent = msg;
                tmInternalMessage.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'border-red-500', 'bg-blue-100', 'text-blue-800', 'border-blue-500');
                if (isError) {
                    tmInternalMessage.classList.add('bg-red-100', 'text-red-800', 'border-red-500');
                } else {
                    tmInternalMessage.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-500');
                }
                tmInternalMessage.classList.remove('hidden');
            } else {
                console.warn("tmInternalMessage element not found.");
            }
        }

        function hideTMInternalMessage() {
            if (tmInternalMessage) {
                tmInternalMessage.classList.add('hidden');
                tmInternalMessage.textContent = '';
            }
        }

        function resetTM() {
            translationMemory = [];
            tmSourceLanguage = '';
            tmTargetLanguage = '';
            if (tmSearchInput) tmSearchInput.value = '';
            renderTMSearchResults([]);
            showTMLanguageConfigSection();
            showTMInternalMessage(translations[currentLanguage]['tm_initial_message']);
        }

        function showTMLanguageConfigSection() {
            if (tmLanguageConfigSection && tmEditorSection) {
                tmLanguageConfigSection.style.display = 'block';
                tmEditorSection.style.display = 'none';
                if (tmConfigSrcLang) tmConfigSrcLang.value = 'en-US';
                if (tmConfigTgtLang) tmConfigTgtLang.value = 'es-ES';
                hideTMInternalMessage();
            }
        }

        function showTMEditorSection() {
            if (tmLanguageConfigSection && tmEditorSection && displayTmSrcLang && displayTmTgtLang) {
                tmLanguageConfigSection.style.display = 'none';
                tmEditorSection.style.display = 'block';
                displayTmSrcLang.value = tmSourceLanguage;
                displayTmTgtLang.value = tmTargetLanguage;
                tmSearch();
                hideTMInternalMessage();
            }
        }

        function confirmTMLanguages() {
            const srcLang = tmConfigSrcLang ? tmConfigSrcLang.value.trim() : '';
            const tgtLang = tmConfigTgtLang ? tmConfigTgtLang.value.trim() : '';

            if (!srcLang || !tgtLang) {
                showTMInternalMessage(translations[currentLanguage]['lang_config_required'], true);
                return;
            }

            tmSourceLanguage = srcLang;
            tmTargetLanguage = tgtLang;

            showTMEditorSection();
        }

        function processTMXContent(content) {
            showLoadingOverlay(translations[currentLanguage]['loading_file']);
            hideTMInternalMessage();

            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, "application/xml");

                if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                    const errorText = xmlDoc.getElementsByTagName("parsererror")[0].textContent;
                    throw new Error("Invalid XML/TMX format: " + errorText);
                }

                if (xmlDoc.getElementsByTagName("termEntry").length > 0) {
                    showTMInternalMessage(translations[currentLanguage]['tmx_file_expected_tbx_found'], true);
                    throw new Error("Attempted to load TBX into Translation Memory.");
                }

                const tuElements = xmlDoc.getElementsByTagName("tu");
                let newTM = [];
                let detectedSrcLang = '';
                let detectedTgtLang = '';

                if (tuElements.length > 0) {
                    const tuvElements = tuElements[0].getElementsByTagName("tuv");
                    if (tuvElements.length >= 2) {
                        detectedSrcLang = tuvElements[0].getAttribute("xml:lang");
                        detectedTgtLang = tuvElements[1].getAttribute("xml:lang");
                    }
                }

                for (let tu of tuElements) {
                    const tuvElements = tu.getElementsByTagName("tuv");
                    if (tuvElements.length >= 2) {
                        const srcTuv = tuvElements[0];
                        const tgtTuv = tuvElements[1];
                        const srcLang = srcTuv.getAttribute("xml:lang");
                        const tgtLang = tgtTuv.getAttribute("xml:lang");
                        const srcSeg = srcTuv.getElementsByTagName("seg")[0]?.textContent || '';
                        const tgtSeg = tgtTuv.getElementsByTagName("seg")[0]?.textContent || '';

                        newTM.push({
                            srcLang: srcLang, srcText: srcSeg,
                            tgtLang: tgtLang, tgtText: tgtSeg,
                            srcWordCount: countWords(srcSeg), tgtWordCount: countWords(tgtSeg)
                        });
                    }
                }

                translationMemory = newTM;
                tmSourceLanguage = detectedSrcLang || (tmConfigSrcLang ? tmConfigSrcLang.value : 'en-US');
                tmTargetLanguage = detectedTgtLang || (tmConfigTgtLang ? tmConfigTgtLang.value : 'es-ES');

                showTMInternalMessage(`TMX loaded with ${translationMemory.length} translation units.`);
                showTMEditorSection();
                tmSearch();

            } catch (error) {
                console.error("Error loading TMX file:", error);
                if (!error.message.includes("Attempted to load TBX")) {
                     showTMInternalMessage(translations[currentLanguage]['error_loading_tmx_file'], true);
                }
                resetTM();
            } finally {
                hideLoadingOverlay();
            }
        }

        function generateTMX() {
            if (translationMemory.length === 0) {
                return null;
            }

            const header = `<?xml version="1.0" encoding="UTF-8"?>
<tmx version="1.4">
  <header creationtool="Poanda" creationtoolversion="1.0"
          datatype="unknown" segtype="sentence" changeid="PoandaUser"
          srclang="${tmSourceLanguage || 'en-US'}" o-tmf="Poanda"
          adminlang="en-US" `;

            const targetLangAttr = tmTargetLanguage ? `targetlang="${tmTargetLanguage}"` : '';

            const xml = [header + targetLangAttr + `>
  </header>
  <body>`];

            translationMemory.forEach(entry => {
                xml.push(`    <tu>
      <tuv xml:lang="${entry.srcLang}"><seg>${entry.srcText}</seg></tuv>
      <tuv xml:lang="${entry.tgtLang}"><seg>${entry.tgtText}</seg></tuv>
    </tu>`);
            });

            xml.push(`  </body>
</tmx>`);
            return xml.join("\n");
        }

        function downloadTMX() {
            const tmxContent = generateTMX();
            if (!tmxContent) {
                 showTMInternalMessage(translations[currentLanguage]['cannot_download_empty_tm'], true);
                 return;
            }

            showLoadingOverlay(translations[currentLanguage]['saving_file']);
            try {
                const blob = new Blob([tmxContent], { type: "application/xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "translation_memory.tmx";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showTMInternalMessage(translations[currentLanguage]['file_saved_successfully']);
            } catch (error) {
                showTMInternalMessage(`${translations[currentLanguage]['error_saving_file']} ${error.message}`, true);
                console.error("Error downloading TMX:", error);
            } finally {
                hideLoadingOverlay();
            }
        }

        function addOrUpdateTMEntry(original, translation) {
            if (!original || !translation) return;
            if (!tmSourceLanguage || !tmTargetLanguage) {
                console.warn("TM languages not configured. Skipping TM update.");
                return;
            }

            const existingIndex = translationMemory.findIndex(
                entry => entry.srcText === original && entry.srcLang === tmSourceLanguage && entry.tgtLang === tmTargetLanguage
            );

            if (existingIndex !== -1) {
                translationMemory[existingIndex].tgtText = translation;
                translationMemory[existingIndex].tgtWordCount = countWords(translation);
            } else {
                translationMemory.push({
                    srcLang: tmSourceLanguage,
                    srcText: original,
                    tgtLang: tmTargetLanguage,
                    tgtText: translation,
                    srcWordCount: countWords(original),
                    tgtWordCount: countWords(translation)
                });
            }
            tmSearch();
        }

        function findBestTMMatch(sourceSegmentText) {
            if (translationMemory.length === 0 || !sourceSegmentText.trim() || !tmSourceLanguage || !tmTargetLanguage) {
                return null;
            }

            let bestMatch = null;
            let highestScore = 0;
            const MIN_FUZZY_THRESHOLD = 70;

            translationMemory.forEach(entry => {
                if (entry.srcLang === tmSourceLanguage && entry.tgtLang === tmTargetLanguage && entry.srcText.trim()) {
                    const score = calculateSimilarity(sourceSegmentText, entry.srcText);
                    if (score >= MIN_FUZZY_THRESHOLD && score > highestScore) {
                        highestScore = score;
                        bestMatch = { ...entry, score: score.toFixed(0) };
                    }
                }
            });

            return bestMatch;
        }

        function tmSearch() {
            const query = tmSearchInput ? tmSearchInput.value.toLowerCase().trim() : '';
            let resultsToRender = [];

            const currentFocused = getCurrentFocusedIndex();
            let activeSegmentOriginalText = null;
            if (currentFocused && poEntries[currentFocused.entryIndex] && poEntries[currentFocused.entryIndex].sentenceSegments && poEntries[currentFocused.entryIndex].sentenceSegments[currentFocused.segmentIndex]) {
                activeSegmentOriginalText = poEntries[currentFocused.entryIndex].sentenceSegments[currentFocused.segmentIndex].original;
            }

            tmBestMatchForActiveSegment = null;
            if (activeSegmentOriginalText) {
                tmBestMatchForActiveSegment = findBestTMMatch(activeSegmentOriginalText);
            }

            if (tmBestMatchForActiveSegment && (query === '' || tmBestMatchForActiveSegment.srcText.toLowerCase().includes(query))) {
                resultsToRender.push({ ...tmBestMatchForActiveSegment, isBestMatch: true });
            }


            const filteredTM = translationMemory.filter(entry => {
                if (tmBestMatchForActiveSegment && entry.srcText === tmBestMatchForActiveSegment.srcText && entry.tgtText === tmBestMatchForActiveSegment.tgtText) {
                    return false;
                }
                if (query) {
                    return (entry.srcText && entry.srcText.toLowerCase().includes(query)) ||
                           (entry.tgtText && entry.tgtText.toLowerCase().includes(query));
                }
                return true;
            });

            filteredTM.forEach(entry => {
                let score = 0;
                if (query) {
                    score = calculateSimilarity(query, entry.srcText);
                } else if (activeSegmentOriginalText) {
                    score = calculateSimilarity(activeSegmentOriginalText, entry.srcText);
                }
                resultsToRender.push({ ...entry, score: score.toFixed(0) });
            });

            resultsToRender.sort((a, b) => {
                if (a.isBestMatch) return -1;
                if (b.isBestMatch) return 1;
                
                if (b.score !== a.score) {
                    return b.score - a.score;
                }
                return a.srcText.localeCompare(b.srcText);
            });

            currentTMLatestSearchResults = resultsToRender;
            renderTMSearchResults(resultsToRender, activeSegmentOriginalText);
        }


        function renderTMSearchResults(results, activeSegmentOriginalText) {
            if (!tmSearchResultsTableBody) {
                console.warn("tmSearchResultsTableBody element not found. Cannot render TM search results.");
                return;
            }
            tmSearchResultsTableBody.innerHTML = '';
            if (results.length === 0) {
                if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.remove('hidden');
                if (tmInternalMessage && tmInternalMessage.classList.contains('hidden')) {
                    if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.remove('hidden');
                }
                return;
            } else {
                if (tmNoMatchFoundMessage) tmNoMatchFoundMessage.classList.add('hidden');
            }
            hideTMInternalMessage();

            results.forEach(entry => {
                const row = document.createElement('tr');
                if (entry.isBestMatch) {
                    row.classList.add('tm-best-match-highlight');
                }

                let originalCellHtml = '';
                if (activeSegmentOriginalText) {
                    const differences = Diff.diffChars(entry.srcText, activeSegmentOriginalText);
                    originalCellHtml = differences.map(part => {
                        const className = part.added ? 'diff-added' :
                                        part.removed ? 'diff-removed' : 'diff-common';
                        return `<span class="${className}">${part.value}</span>`;
                    }).join('');
                } else {
                    originalCellHtml = entry.srcText;
                }

                row.innerHTML = `
                    <td>${entry.score}%</td>
                    <td><pre class="whitespace-pre-wrap">${originalCellHtml}</pre></td>
                    <td><pre class="whitespace-pre-wrap">${entry.tgtText}</pre></td>
                `;
                row.addEventListener('click', () => {
                    const currentFocused = getCurrentFocusedIndex();
                    if (currentFocused) {
                        const targetTextarea = document.getElementById(`msgstr-${currentFocused.entryIndex}-${currentFocused.segmentIndex}`);
                        if (targetTextarea && !targetTextarea.readOnly) {
                            targetTextarea.value = entry.tgtText;
                            const event = new Event('input', { bubbles: true });
                            targetTextarea.dispatchEvent(event);
                        }
                    }
                });
                tmSearchResultsTableBody.appendChild(row);
            });
        }


        function showLoadingOverlay(message) {
            if (loadingMessage && loadingOverlay) {
                loadingMessage.textContent = message;
                loadingOverlay.classList.remove('hidden');
            }
        }

        function hideLoadingOverlay() {
            if (loadingOverlay) {
                loadingOverlay.classList.add('hidden');
            }
        }

        if (dropArea) {
            dropArea.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.add('border-red-500');
            });

            dropArea.addEventListener('dragleave', (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-red-500');
            });

            dropArea.addEventListener('drop', async (event) => {
                event.preventDefault();
                event.stopPropagation();
                dropArea.classList.remove('border-red-500');

                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.name.toLowerCase().endsWith('.po')) {
                        await processFile(file);
                    } else if (file.name.toLowerCase().endsWith('.zip') || file.name.toLowerCase().endsWith('.poanda')) {
                        await openProject(file);
                    } else {
                        showMessage('Please drop a valid .po or .poanda project file.');
                    }
                }
            });
        }

        if (addTermHeader && addTermContent && addTermAccordionIcon) {
            addTermHeader.addEventListener('click', () => {
                const isCollapsed = addTermContent.classList.contains('collapsed');
                if (isCollapsed) {
                    addTermContent.classList.remove('collapsed');
                    addTermContent.classList.add('expanded');
                    addTermAccordionIcon.classList.remove('rotated');
                } else {
                    addTermContent.classList.remove('expanded');
                    addTermContent.classList.add('collapsed');
                    addTermAccordionIcon.classList.add('rotated');
                }
            });
        }

        function resetProjectState() {
            poEntries = [];
            currentFileName = 'translations.po';

            currentFileType = null;
        currentJsonSourceFileName = null;
        currentJsonTargetFileName = null;

            renderTranslations([]);
            updateStatsDisplay();

            resetGlossary();
            resetTM();

            terminologySidebar.classList.remove('show-sidebar');
            translationMemorySidebar.classList.remove('show-sidebar');
            statsContainer.classList.remove('show');
            updateMainContentOffset();
            updateUtilityButtonStates();
            updateSaveButtonsState();
        }

        function newProject() {
            if (confirm(translations[currentLanguage]['new_project_confirm'])) {
                resetProjectState();
                clearBackup();
            }
        }

        function showSaveProjectModal() {
            if (poEntries.length === 0) {
                showMessage(translations[currentLanguage]['no_project_to_save']);
                return;
            }
            projectFilenameInput.value = currentFileName.replace(/\.po$/i, '');
            saveProjectModal.classList.remove('hidden');
            projectFilenameInput.focus();
        }

        async function executeSaveProject() {
            const filename = projectFilenameInput.value.trim();
            if (!filename) {
                showMessage(translations[currentLanguage]['enter_filename']);
                return;
            }

            showLoadingOverlay(translations[currentLanguage]['saving_file']);
            try {
                const zip = new JSZip();

                const poContent = reconstructPo(poEntries);
                zip.file(currentFileName, poContent);

                const tmxContent = generateTMX();
                if (tmxContent) {
                    zip.file("memory.tmx", tmxContent);
                }

                if (glossary.length > 0) {
                    const tbxContent = generateTBX();
                    zip.file("glossary.tbx", tbxContent);
                }

                const zipBlob = await zip.generateAsync({ type: "blob" });
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `${filename}.poanda`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                saveProjectModal.classList.add('hidden');
                showMessage(translations[currentLanguage]['project_saved']);

            } catch (error) {
                showMessage(translations[currentLanguage]['error_saving_project'] + ': ' + error.message);
                console.error("Error saving project:", error);
            } finally {
                hideLoadingOverlay();
            }
        }

        async function openProject(file) {
            if (!file) return;

            showLoadingOverlay(translations[currentLanguage]['loading_project']);
            try {
                resetProjectState();

                const zip = await JSZip.loadAsync(file);
                let poFileFound = false;

                const promises = [];
                zip.forEach((relativePath, zipEntry) => {
                    const fileNameLower = zipEntry.name.toLowerCase();
                    if (fileNameLower.endsWith('.po')) {
                        poFileFound = true;
                        currentFileName = zipEntry.name;
                        promises.push(zipEntry.async("string").then(processPoContent));
                    } else if (fileNameLower.endsWith('.tmx')) {
                         promises.push(zipEntry.async("string").then(processTMXContent));
                    } else if (fileNameLower.endsWith('.tbx')) {
                         promises.push(zipEntry.async("string").then(processTBXContent));
                    }
                });

                await Promise.all(promises);

                if (!poFileFound) {
                    throw new Error(translations[currentLanguage]['invalid_project_file']);
                }
                showMessage(translations[currentLanguage]['project_loaded']);
                await clearBackup();

            } catch (error) {
                showMessage(translations[currentLanguage]['error_opening_project'] + ': ' + error.message);
                console.error("Error opening project:", error);
                resetProjectState();
            } finally {
                hideLoadingOverlay();
                projectFileInput.value = '';
            }
        }

        // --- Backup and Restore (IndexedDB) ---
        const DB_NAME = 'PoandaBackup';
        const DB_VERSION = 1;
        const STORE_NAME = 'session';
        let db;

        function openDb() {
            return new Promise((resolve, reject) => {
                if (db) {
                    resolve(db);
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject("Error opening IndexedDB.");
                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };
            });
        }

        async function saveBackup() {
            // 1. Comprobaci√≥n de seguridad: Si no hay base de datos o entradas, salimos.
            if (!db || typeof poEntries === 'undefined' || poEntries.length === 0) return;

            // 2. Preparar el HTML Crudo de forma segura
            // Nos aseguramos de que currentRawHtml exista, si no, guardamos cadena vac√≠a.
            let htmlToSave = "";
            if (typeof currentRawHtml !== 'undefined' && currentRawHtml) {
                htmlToSave = currentRawHtml;
            }

            const sessionData = {
                id: 'currentSession',
                poEntries: poEntries, // Tus traducciones
                currentFileType: (typeof currentFileType !== 'undefined') ? currentFileType : 'po',
                currentFileName: currentFileName,
                currentRawHtml: htmlToSave, // <--- AQU√ç GUARDAMOS EL HTML ORIGINAL
                glossary: glossary || [],
                glossarySourceLanguage: glossarySourceLanguage || '',
                glossaryTargetLanguage: glossaryTargetLanguage || '',
                translationMemory: translationMemory || [],
                tmSourceLanguage: tmSourceLanguage || '',
                tmTargetLanguage: tmTargetLanguage || '',
                timestamp: new Date()
            };

            // 3. Intentar guardar en la Base de Datos
            try {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(sessionData);
                
                request.onsuccess = () => {
                     updateBackupStatusUI();
                     // Si abres la consola (F12), ver√°s este mensaje cada 10s si funciona:
                     console.log("‚úÖ Backup guardado correctamente a las " + new Date().toLocaleTimeString());
                };
                
                request.onerror = (e) => {
                    console.error("‚ùå Error al escribir en IndexedDB:", e.target.error);
                };
            } catch (err) {
                console.error("‚ùå Error fatal dentro de saveBackup:", err);
            }
        }

        async function loadBackup() {
            if (!db) return null;
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get('currentSession');
                request.onerror = () => reject("Error loading backup from DB.");
                request.onsuccess = () => resolve(request.result);
            });
        }

        async function clearBackup() {
            if (!db) return;
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            store.clear();
            updateBackupStatusUI();
        }

        async function checkForBackup() {
            try {
                await openDb();
                const backup = await loadBackup();
                if (backup && backup.poEntries && backup.poEntries.length > 0) {
                    restoreBackupModal.classList.remove('hidden');
                }
                updateBackupStatusUI();
            } catch (error) {
                console.error("Backup check failed:", error);
            }
        }

        async function restoreSession(backupData = null) {
            showLoadingOverlay(translations[currentLanguage]['loading_project']);
            try {
                const backup = backupData || await loadBackup();
                if (backup) {
                    // 1. Restaurar variables b√°sicas
                    currentFileType = backup.currentFileType || 'po';
                    currentFileName = backup.currentFileName || 'translations.po';
                    currentRawHtml = backup.currentRawHtml || ""; // Recuperar el HTML crudo
                    
                    // 2. L√ìGICA ESPECIAL PARA HTML
                    if (currentFileType === 'html' && currentRawHtml) {
                        // Volvemos a parsear el HTML original para reconstruir htmlNodeMap y currentHtmlDoc
                        // Esto llena htmlNodeMap pero crea poEntries vac√≠os
                        parseHtmlProject(currentRawHtml);
                    }

                    // 3. Sobrescribir con las traducciones guardadas
                    // Al hacer esto, mantenemos el mapa creado en el paso 2, pero inyectamos los textos del backup
                    poEntries = backup.poEntries || [];

                    glossary = backup.glossary || [];
                    glossarySourceLanguage = backup.glossarySourceLanguage || '';
                    glossaryTargetLanguage = backup.glossaryTargetLanguage || '';
                    translationMemory = backup.translationMemory || [];
                    tmSourceLanguage = backup.tmSourceLanguage || '';
                    tmTargetLanguage = backup.tmTargetLanguage || '';

                    renderTranslations(poEntries);
                    
                    if (glossarySourceLanguage && glossaryTargetLanguage) {
                        showGlossaryEditorSection();
                    } else {
                        showLanguageConfigSection();
                    }

                    if (tmSourceLanguage && tmTargetLanguage) {
                        showTMEditorSection();
                    } else {
                        showTMLanguageConfigSection();
                    }
                    
                    updateSaveButtonsState();
                }
            } catch (error) {
                showMessage("Failed to restore session.");
                console.error(error);
            } finally {
                restoreBackupModal.classList.add('hidden');
                hideLoadingOverlay();
            }
        }

        async function updateBackupStatusUI() {
            try {
                const backup = await loadBackup();
                if (backup) {
                    backupIndicator.style.display = 'inline-block';
                    lastBackupTime.textContent = new Date(backup.timestamp).toLocaleString();
                    loadLocalBackupBtn.disabled = false;
                    saveBackupToDiskBtn.disabled = false;
                    deleteLocalBackupBtn.disabled = false;
                } else {
                    backupIndicator.style.display = 'none';
                    lastBackupTime.textContent = translations[currentLanguage]['no_backup_available'];
                    loadLocalBackupBtn.disabled = true;
                    saveBackupToDiskBtn.disabled = true;
                    deleteLocalBackupBtn.disabled = true;
                }
            } catch (error) {
                console.error("Error updating backup UI:", error);
            }
        }

        // --- PO to MO Converter Logic ---
        function parsePoForMo(poText) {
            const lines = poText.split('\n');
            const messages = [];
            let currentMsg = {};
            let state = '';

            const unescape = (str) => str.replace(/\\n/g, '\n').replace(/\\"/g, '"').replace(/\\\\/g, '\\');

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('#')) continue;

                if (trimmedLine.length === 0) {
                    if (currentMsg.msgid !== undefined) {
                        messages.push(currentMsg);
                    }
                    currentMsg = {};
                    state = '';
                    continue;
                }

                if (trimmedLine.startsWith('msgctxt')) {
                    state = 'msgctxt';
                    currentMsg.msgctxt = unescape(trimmedLine.substring(7).trim().slice(1, -1));
                } else if (trimmedLine.startsWith('msgid_plural')) {
                    state = 'msgid_plural';
                    currentMsg.msgid_plural = unescape(trimmedLine.substring(12).trim().slice(1, -1));
                } else if (trimmedLine.startsWith('msgid')) {
                    state = 'msgid';
                    currentMsg.msgid = unescape(trimmedLine.substring(5).trim().slice(1, -1));
                } else if (trimmedLine.startsWith('msgstr[')) {
                    const match = trimmedLine.match(/msgstr\[(\d+)\]/);
                    state = `msgstr[${match[1]}]`;
                    if (!currentMsg.msgstr) currentMsg.msgstr = [];
                    currentMsg.msgstr[parseInt(match[1], 10)] = unescape(trimmedLine.substring(match[0].length).trim().slice(1, -1));
                } else if (trimmedLine.startsWith('msgstr')) {
                    state = 'msgstr';
                    currentMsg.msgstr = [unescape(trimmedLine.substring(6).trim().slice(1, -1))];
                } else if (trimmedLine.startsWith('"')) {
                    const str = unescape(trimmedLine.slice(1, -1));
                    if (state === 'msgid') currentMsg.msgid += str;
                    else if (state === 'msgid_plural') currentMsg.msgid_plural += str;
                    else if (state === 'msgctxt') currentMsg.msgctxt += str;
                    else if (state === 'msgstr') currentMsg.msgstr[0] += str;
                    else if (state.startsWith('msgstr[')) {
                        const match = state.match(/msgstr\[(\d+)\]/);
                        const index = parseInt(match[1], 10);
                        if(!currentMsg.msgstr[index]) currentMsg.msgstr[index] = '';
                        currentMsg.msgstr[index] += str;
                    }
                }
            }
            if (currentMsg.msgid !== undefined) messages.push(currentMsg);
            return messages;
        }

        function compileMo(messages) {
            const textEncoder = new TextEncoder();
            const MAGIC = 0x950412de;
            const REVISION = 0;
            
            let header = messages.find(m => m.msgid === '');
            if (header && header.msgstr && header.msgstr[0]) {
                 if(!header.msgstr[0].includes('Content-Type')) {
                    header.msgstr[0] += '\nContent-Type: text/plain; charset=UTF-8\n';
                 }
            } else {
                 header = { msgid: "", msgstr: ["Content-Type: text/plain; charset=UTF-8\n"] };
            }

            const translations = messages.filter(m => m.msgid !== '');

            translations.sort((a, b) => {
                const keyA = (a.msgctxt || '') + '\u0004' + a.msgid;
                const keyB = (b.msgctxt || '') + '\u0004' + b.msgid;
                return keyA.localeCompare(keyB);
            });

            const stringCount = translations.length + 1;
            const headerSize = 28;
            const originalsTableOffset = headerSize;
            const translationsTableOffset = headerSize + (stringCount * 8);
            
            let stringData = [];
            let currentOffset = translationsTableOffset + (stringCount * 8);

            stringData.push({
                original: textEncoder.encode(""),
                translation: textEncoder.encode(header.msgstr[0]),
            });

            translations.forEach(msg => {
                let originalStr;
                if (msg.msgid_plural) {
                    originalStr = (msg.msgctxt ? msg.msgctxt + '\u0004' : '') + msg.msgid + '\u0000' + msg.msgid_plural;
                } else {
                    originalStr = (msg.msgctxt ? msg.msgctxt + '\u0004' : '') + msg.msgid;
                }
                const translationStr = (msg.msgstr || []).join('\u0000');
                stringData.push({
                    original: textEncoder.encode(originalStr),
                    translation: textEncoder.encode(translationStr),
                });
            });

            const originalsTable = [];
            const translationsTable = [];

            stringData.forEach(data => {
                originalsTable.push({ length: data.original.length, offset: currentOffset });
                currentOffset += data.original.length + 1;
            });
            stringData.forEach(data => {
                translationsTable.push({ length: data.translation.length, offset: currentOffset });
                currentOffset += data.translation.length + 1;
            });
            
            const buffer = new ArrayBuffer(currentOffset);
            const view = new DataView(buffer);
            let byteOffset = 0;

            view.setUint32(byteOffset, MAGIC, true); byteOffset += 4;
            view.setUint32(byteOffset, REVISION, true); byteOffset += 4;
            view.setUint32(byteOffset, stringCount, true); byteOffset += 4;
            view.setUint32(byteOffset, originalsTableOffset, true); byteOffset += 4;
            view.setUint32(byteOffset, translationsTableOffset, true); byteOffset += 4;
            view.setUint32(byteOffset, 0, true); byteOffset += 4;
            view.setUint32(byteOffset, 0, true); byteOffset += 4;
            
            originalsTable.forEach(entry => {
                view.setUint32(byteOffset, entry.length, true); byteOffset += 4;
                view.setUint32(byteOffset, entry.offset, true); byteOffset += 4;
            });
            translationsTable.forEach(entry => {
                view.setUint32(byteOffset, entry.length, true); byteOffset += 4;
                view.setUint32(byteOffset, entry.offset, true); byteOffset += 4;
            });

            stringData.forEach(data => {
                new Uint8Array(buffer, byteOffset).set(data.original);
                byteOffset += data.original.length + 1;
            });
            stringData.forEach(data => {
                new Uint8Array(buffer, byteOffset).set(data.translation);
                byteOffset += data.translation.length + 1;
            });

            return buffer;
        }

        function makeDraggableAndResizable(sidebar) {
            const header = sidebar.querySelector('.sidebar-header');
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

            if(header) {
                header.onmousedown = dragMouseDown;
            }

function makeModalDraggable(modalElement) {
    const handle = modalElement.querySelector('h2');
    const content = modalElement.querySelector('.modal-content');
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

    if (handle && content) {
        handle.style.cursor = 'move';
        handle.onmousedown = dragMouseDown;
    }

    function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
    }

    function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        content.style.top = (content.offsetTop - pos2) + "px";
        content.style.left = (content.offsetLeft - pos1) + "px";
    }

    function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
    }
}


            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
                sidebar.style.transform = 'none';
            }

            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                sidebar.style.top = (sidebar.offsetTop - pos2) + "px";
                sidebar.style.left = (sidebar.offsetLeft - pos1) + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
            
            const resizers = sidebar.querySelectorAll('.resizer');
            let currentResizer;

            for (let resizer of resizers) {
                resizer.addEventListener('mousedown', initResize, false);
            }

            function initResize(e) {
                e.stopPropagation(); // Stop the event from bubbling up to the header
                currentResizer = e.target;
                let startX = e.clientX;
                let startY = e.clientY;
                let startWidth = parseInt(document.defaultView.getComputedStyle(sidebar).width, 10);
                let startHeight = parseInt(document.defaultView.getComputedStyle(sidebar).height, 10);
                let startLeft = sidebar.offsetLeft;
                let startTop = sidebar.offsetTop;

                function doResize(e) {
                    const rect = sidebar.getBoundingClientRect();
                    if (currentResizer.classList.contains('resizer-r')) {
                        sidebar.style.width = (startWidth + e.clientX - startX) + 'px';
                    } else if (currentResizer.classList.contains('resizer-l')) {
                        sidebar.style.width = (startWidth - (e.clientX - startX)) + 'px';
                        sidebar.style.left = (startLeft + (e.clientX - startX)) + 'px';
                    } else if (currentResizer.classList.contains('resizer-b')) {
                        sidebar.style.height = (startHeight + e.clientY - startY) + 'px';
                    } else if (currentResizer.classList.contains('resizer-t')) {
                        sidebar.style.height = (startHeight - (e.clientY - startY)) + 'px';
                        sidebar.style.top = (startTop + (e.clientY - startY)) + 'px';
                    } else if (currentResizer.classList.contains('resizer-br')) {
                        sidebar.style.width = (startWidth + e.clientX - startX) + 'px';
                        sidebar.style.height = (startHeight + e.clientY - startY) + 'px';
                    } else if (currentResizer.classList.contains('resizer-bl')) {
                        sidebar.style.width = (startWidth - e.clientX + startX) + 'px';
                        sidebar.style.left = (startLeft + e.clientX - startX) + 'px';
                        sidebar.style.height = (startHeight + e.clientY - startY) + 'px';
                    } else if (currentResizer.classList.contains('resizer-tr')) {
                        sidebar.style.width = (startWidth + e.clientX - startX) + 'px';
                        sidebar.style.height = (startHeight - e.clientY + startY) + 'px';
                        sidebar.style.top = (startTop + e.clientY - startY) + 'px';
                    } else if (currentResizer.classList.contains('resizer-tl')) {
                        sidebar.style.width = (startWidth - e.clientX + startX) + 'px';
                        sidebar.style.left = (startLeft + e.clientX - startX) + 'px';
                        sidebar.style.height = (startHeight - e.clientY + startY) + 'px';
                        sidebar.style.top = (startTop + e.clientY - startY) + 'px';
                    }
                    updateMainContentOffset();
                }

                function stopResize() {
                    window.removeEventListener('mousemove', doResize, false);
                    window.removeEventListener('mouseup', stopResize, false);
                }

                window.addEventListener('mousemove', doResize, false);
                window.addEventListener('mouseup', stopResize, false);
            }
            
            const resetBtn = sidebar.querySelector('.reset-panel-btn');
            if(resetBtn) {
                resetBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    sidebar.style.removeProperty('top');
                    sidebar.style.removeProperty('left');
                    sidebar.style.removeProperty('right');
                    sidebar.style.removeProperty('bottom');
                    sidebar.style.removeProperty('width');
                    sidebar.style.removeProperty('height');
                    sidebar.style.removeProperty('transform');
                    
                    if (!sidebar.classList.contains('show-sidebar')) {
                         sidebar.classList.add('show-sidebar');
                    }
                    updateMainContentOffset();
                });
            }

            const resizeObserver = new ResizeObserver(() => {
                updateMainContentOffset();
            });
            resizeObserver.observe(sidebar);
        }

        // --- FUNCI√ìN QUE FALTABA ---
function makeModalDraggable(modalElement) {
    // Si el elemento no existe, salimos para evitar errores
    if (!modalElement) return;

    const handle = modalElement.querySelector('h2'); // Usamos el t√≠tulo H2 como "agarradera"
    const content = modalElement.querySelector('.modal-content');
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

    if (handle && content) {
        handle.style.cursor = 'move';
        handle.onmousedown = dragMouseDown;
    }

    function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
    }

    function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        content.style.top = (content.offsetTop - pos2) + "px";
        content.style.left = (content.offsetLeft - pos1) + "px";
    }

    function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
    }
}
// ---------------------------

        // --- Initialization on page load ---
        document.addEventListener('DOMContentLoaded', async () => {
            loadShortcuts(); // Load saved or default shortcuts
            populateIsoLanguagesDatalist();
            
            document.getElementById('langEnBtn').addEventListener('click', () => setLanguage('en'));
            document.getElementById('langEsBtn').addEventListener('click', () => setLanguage('es'));

            newProjectBtn.addEventListener('click', newProject);
            saveProjectBtn.addEventListener('click', showSaveProjectModal);
            openProjectBtn.addEventListener('click', () => projectFileInput.click());
            projectFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                openProject(file);
            });

            saveProjectConfirmBtn.addEventListener('click', executeSaveProject);
            saveProjectCancelBtn.addEventListener('click', () => {
                saveProjectModal.classList.add('hidden');
            });

            restoreBackupBtn.addEventListener('click', () => restoreSession());
            discardBackupBtn.addEventListener('click', () => {
                clearBackup();
                restoreBackupModal.classList.add('hidden');
            });
            
            backupBtn.addEventListener('click', () => {
                updateBackupStatusUI();
                backupModal.classList.remove('hidden');
            });

            backupCloseBtn.addEventListener('click', () => {
                backupModal.classList.add('hidden');
            });
            
            loadLocalBackupBtn.addEventListener('click', () => {
                restoreSession();
                backupModal.classList.add('hidden');
            });

            deleteLocalBackupBtn.addEventListener('click', async () => {
                if (confirm(translations[currentLanguage]['delete_local_backup_btn_confirm'])) {
                    await clearBackup();
                    showMessage(translations[currentLanguage]['backup_deleted']);
                }
            });

            saveBackupToDiskBtn.addEventListener('click', async () => {
                const backup = await loadBackup();
                if (backup) {
                    const jsonString = JSON.stringify(backup, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `poanda_backup_${new Date().toISOString().slice(0,10)}.poanda-backup`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            });
            
            loadBackupFromFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.id === 'currentSession' && data.poEntries) {
                            await restoreSession(data);
                            await saveBackup();
                            showMessage(translations[currentLanguage]['backup_loaded_from_file']);
                            backupModal.classList.add('hidden');
                        } else {
                            throw new Error("Invalid backup file format.");
                        }
                    } catch (error) {
                        showMessage(translations[currentLanguage]['error_loading_backup_file']);
                        console.error("Error processing backup file:", error);
                    } finally {
                        loadBackupFromFileInput.value = '';
                    }
                };
                reader.readAsText(file);
            });

            // ADD LISTENERS FOR NEW FILE MENU ITEMS
        const loadFilePoBtn = document.getElementById('loadFilePoBtn');
        const saveFilePoBtn = document.getElementById('saveFilePoBtn');
        const loadFileJsonBtn = document.getElementById('loadFileJsonBtn');
        const saveFileJsonBtn = document.getElementById('saveFileJsonBtn');
        const convertFileMoBtn = document.getElementById('convertFileMoBtn');
        const poFileInput = document.getElementById('poFile'); // Get reference

        if (loadFilePoBtn && poFileInput) {
            loadFilePoBtn.addEventListener('click', (e) => {
                e.preventDefault();
                poFileInput.click(); // Trigger the original PO file input
            });
        }
        if (saveFilePoBtn && savePoButton) {
             saveFilePoBtn.addEventListener('click', (e) => {
                 e.preventDefault();
                 if (!saveFilePoBtn.classList.contains('disabled-link')) {
                     savePoButton.click(); // Trigger the original PO save button
                 }
             });
        }
       if (loadFileJsonBtn) {
             loadFileJsonBtn.addEventListener('click', (e) => {
                 e.preventDefault();
                 loadSingleJsonFile(); // <-- Llama a la NUEVA funci√≥n
             });
        }
        if (saveFileJsonBtn) {
             saveFileJsonBtn.addEventListener('click', (e) => {
                 e.preventDefault();
                 if (!saveFileJsonBtn.classList.contains('disabled-link')) {
                     saveJsonFile(); // Call the new JSON saving function
                 }
             });
        }

        // HTML LISTENERS
        const loadFileHtmlBtn = document.getElementById('loadFileHtmlBtn');
        const saveFileHtmlBtn = document.getElementById('saveFileHtmlBtn');

        if (loadFileHtmlBtn) {
            loadFileHtmlBtn.addEventListener('click', (e) => {
                e.preventDefault();
                loadHtmlFile();
            });
        }
        if (saveFileHtmlBtn) {
            saveFileHtmlBtn.addEventListener('click', (e) => {
                e.preventDefault();
                if (!saveFileHtmlBtn.classList.contains('disabled-link')) {
                    saveHtmlFile();
                }
            });
        }

         if (convertFileMoBtn && convertToMoButton) {
             convertFileMoBtn.addEventListener('click', (e) => {
                 e.preventDefault();
                 if (!convertFileMoBtn.classList.contains('disabled-link')) {
                     convertToMoButton.click(); // Trigger the original MO conversion button
                 }
             });
        }
        // END ADD LISTENERS

            convertToMoButton.addEventListener('click', () => {
                if (poEntries.length > 0) {
                    convertToMoModal.classList.remove('hidden');
                } else {
                    showMessage(translations[currentLanguage]['no_file_to_convert']);
                }
            });

            moConverterCloseBtn.addEventListener('click', () => {
                convertToMoModal.classList.add('hidden');
            });

            moConverterActionBtn.addEventListener('click', () => {
                try {
                    const poContent = reconstructPo(poEntries);
                    const messages = parsePoForMo(poContent);
                    const moArrayBuffer = compileMo(messages);

                    const blob = new Blob([moArrayBuffer], { type: 'application/octet-stream' });
                    const outputFileName = currentFileName.replace(/\.po$/, '.mo');
                    const link = document.createElement('a');

                    link.href = URL.createObjectURL(blob);
                    link.download = outputFileName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);

                    showMessage(translations[currentLanguage]['mo_conversion_success']);
                } catch (error) {
                    showMessage(translations[currentLanguage]['mo_conversion_error']);
                    console.error("Error converting PO to MO:", error);
                } finally {
                    convertToMoModal.classList.add('hidden');
                }
            });

            makeDraggableAndResizable(document.getElementById('terminologySidebar'));
            makeDraggableAndResizable(document.getElementById('translationMemorySidebar'));
            makeDraggableAndResizable(document.getElementById('aiSidebar'));

            // Add event listeners for the new PO search bar
            poSearchInput.addEventListener('input', filterPOEntries);
            searchInOriginalCheckbox.addEventListener('change', filterPOEntries);
            searchInTranslationCheckbox.addEventListener('change', filterPOEntries);
            searchNextBtn.addEventListener('click', () => navigateToSearchResult(1));
            searchPrevBtn.addEventListener('click', () => navigateToSearchResult(-1));


            setLanguage(currentLanguage);

            resetGlossary();
            resetTM();
            
            statsBtn.addEventListener('click', () => {
                statsContainer.classList.toggle('show');
                updateUtilityButtonStates();
            });

            if (translationsContainer) {
                translationsContainer.innerHTML = `
                    <div data-i18n="no_translations" id="initialMessage" class="text-center text-on-light-contrast p-4 border border-gray-300 rounded-md">
                        ${translations[currentLanguage]['no_translations']}
                    </div>
                `;
            }
            if (savePoButton) savePoButton.disabled = true;
            if (convertToMoButton) convertToMoButton.disabled = true;
            if (poSearchContainer) poSearchContainer.classList.add('hidden');
            if (statsContainer) statsContainer.classList.remove('show');
            updateUtilityButtonStates();

            if (addTermContent && addTermAccordionIcon) {
                addTermContent.classList.add('collapsed');
                addTermContent.classList.remove('expanded');
                addTermAccordionIcon.classList.remove('rotated');
            }

            if (translationMemorySidebar) translationMemorySidebar.classList.remove('show-sidebar');

            updateMainContentOffset();
            updateSaveButtonsState();
            await checkForBackup();
            

 makeModalDraggable(document.getElementById('findReplaceModal'));

            // --- L√ìGICA MODO OSCURO ---
            const darkModeToggle = document.getElementById('darkModeToggle');
            // Cargar preferencia guardada
            const isDarkMode = localStorage.getItem('poandaDarkMode') === 'true';
            if (isDarkMode) {
                document.body.classList.add('dark-mode');
                if(darkModeToggle) darkModeToggle.textContent = '‚òÄÔ∏è';
            }
            
            if(darkModeToggle) {
                darkModeToggle.addEventListener('click', () => {
                    document.body.classList.toggle('dark-mode');
                    const enabled = document.body.classList.contains('dark-mode');
                    localStorage.setItem('poandaDarkMode', enabled);
                    darkModeToggle.textContent = enabled ? '‚òÄÔ∏è' : 'üåô';
                });
            }

            // Inicializar mensaje de bienvenida del chat en el idioma correcto
            const chatContainer = document.getElementById('aiChatContainer');
            if (chatContainer && chatContainer.children.length === 0) {
                const welcomeDiv = document.createElement('div');
                welcomeDiv.className = 'ai-message ai-message-bot';
                welcomeDiv.textContent = translations[currentLanguage]['ai_initial_message'];
                chatContainer.appendChild(welcomeDiv);
            }

            setInterval(saveBackup, 10000);
        });

        /* --- AI ASSISTANT LOGIC --- */
        const aiBtn = document.getElementById('aiBtn');
        const closeAiSidebarBtn = document.getElementById('closeAiSidebarBtn');
        const aiConfigToggleBtn = document.getElementById('aiConfigToggleBtn');
        const aiConfigPanel = document.getElementById('aiConfigPanel');
        const geminiApiKeyInput = document.getElementById('geminiApiKeyInput');
        const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
        const aiUserInput = document.getElementById('aiUserInput');
        const aiSendBtn = document.getElementById('aiSendBtn');

        // Toggle Sidebar
        // Toggle Sidebar con gesti√≥n inteligente de foco
        if(aiBtn) {
            aiBtn.addEventListener('click', () => {
                const isOpening = !aiSidebar.classList.contains('show-sidebar');
                
                if (isOpening) {
                    aiSidebar.classList.add('show-sidebar');
                    // Cerrar TM si est√° abierta
                    if (translationMemorySidebar) translationMemorySidebar.classList.remove('show-sidebar');
                    
                    // FOCO AL CHAT (Peque√±o retardo para dar tiempo a la animaci√≥n CSS)
                    setTimeout(() => {
                        if (aiUserInput) aiUserInput.focus();
                    }, 50);
                } else {
                    aiSidebar.classList.remove('show-sidebar');
                    
                    // FOCO DE VUELTA AL SEGMENTO
                    if (lastFocusedSegment) {
                        navigateToTranslation(lastFocusedSegment.entryIndex, lastFocusedSegment.segmentIndex);
                    }
                }
                updateMainContentOffset();
                updateUtilityButtonStates();
            });
        }

        if(closeAiSidebarBtn) {
            closeAiSidebarBtn.addEventListener('click', () => {
                aiSidebar.classList.remove('show-sidebar');
                updateMainContentOffset();
                updateUtilityButtonStates();
            });
        }

        // Config Panel
        if(aiConfigToggleBtn) {
            aiConfigToggleBtn.addEventListener('click', () => {
                aiConfigPanel.classList.toggle('hidden');
                geminiApiKeyInput.value = aiApiKey;
            });
        }

        if(saveApiKeyBtn) {
            saveApiKeyBtn.addEventListener('click', () => {
                aiApiKey = geminiApiKeyInput.value.trim();
                localStorage.setItem('poanda_gemini_key', aiApiKey);
                aiConfigPanel.classList.add('hidden');
                appendAiMessage('bot', 'API Key guardada correctamente. ‚úÖ');
            });
        }

       // L√≥gica del Chat (Versi√≥n REST API manual - Sin librer√≠as externas)
        async function callGeminiAI(prompt) {
            // Limpiamos la clave de posibles espacios en blanco al principio/final
            const cleanApiKey = aiApiKey ? aiApiKey.trim() : '';

            if (!cleanApiKey) {
                appendAiMessage('bot', translations[currentLanguage]['ai_no_api_key']);
                aiConfigPanel.classList.remove('hidden');
                return;
            }

            const loadingId = appendAiMessage('bot', translations[currentLanguage]['ai_thinking']);
            
            // Funci√≥n auxiliar para intentar conectar con un modelo espec√≠fico
            const tryFetch = async (modelName) => {
                const url = `https://generativelanguage.googleapis.com/v1/models/${modelName}:generateContent?key=${cleanApiKey}`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });
                return await response.json();
            };

            try {
    // INTENTO 1: Gemini 2.5 Flash (R√°pido, eficiente y soporta "thinking")
    // NOTA: Usamos solo el nombre final, sin 'models/' delante
    let data = await tryFetch('gemini-2.5-flash');

    // Si falla, probamos el Plan B
    if (data.error) {
        console.warn("Intento 1 fallido con 2.5 Flash, probando 2.5 Pro...", data.error);
        
        // INTENTO 2: Gemini 2.5 Pro (M√°s potente)
        data = await tryFetch('gemini-2.5-pro');
    }

                // Eliminamos mensaje de "pensando"
                const loadingMsg = document.getElementById(loadingId);
                if(loadingMsg) loadingMsg.remove();

                // Procesamos la respuesta final
                if (data.error) {
                    // Si fallan los dos, mostramos el error
                    let errorMsg = data.error.message;
                    if (errorMsg.includes('API key not valid')) errorMsg = 'La API Key es incorrecta. Revisa espacios en blanco.';
                    appendAiMessage('bot', `‚ùå Error: ${errorMsg}`);
                } else if (data.candidates && data.candidates.length > 0) {
                    const aiResponse = data.candidates[0].content.parts[0].text;
                    appendAiMessage('bot', aiResponse, true);
                } else {
                    appendAiMessage('bot', 'La IA no devolvi√≥ respuesta.');
                }

            } catch (error) {
                const loadingMsg = document.getElementById(loadingId);
                if(loadingMsg) loadingMsg.remove();
                console.error("Error de red:", error);
                appendAiMessage('bot', `‚ùå Error de conexi√≥n: ${error.message}`);
            }
        }
        function appendAiMessage(sender, text, allowInsert = false) {
            // 1. Guardar √∫ltima respuesta para el atajo
            if (sender === 'bot') lastAiResponseText = text;

            const msgDiv = document.createElement('div');
            const msgId = 'msg-' + Date.now();
            msgDiv.id = msgId;
            msgDiv.className = `ai-message ai-message-${sender}`;
            
            // 2. Renderizado con enlaces personalizados
            if (sender === 'bot' && typeof marked !== 'undefined') {
                // Configurar renderer para que los links sean botones
                const renderer = new marked.Renderer();
                renderer.link = ({href}) => {
                     // Obtenemos el texto "Source" o "Fuente" seg√∫n idioma actual
                     const label = translations[currentLanguage]['ai_link_source'] || 'Source';
                     // Devolvemos el HTML del bot√≥n, forzando nueva pesta√±a y title con la URL
                     return `<a href="${href}" target="_blank" title="${href}" class="ai-source-link">${label}</a>`;
                };
                
                // Parsear usando nuestro renderer
                msgDiv.innerHTML = marked.parse(text, { renderer: renderer });
            } else {
                msgDiv.textContent = text; 
            }

            // Add Insert Button if it's a bot translation/suggestion
            if (allowInsert && sender === 'bot') {
                const insertBtn = document.createElement('span');
                insertBtn.className = 'ai-insert-btn';
                insertBtn.textContent = 'üìã Insertar / Copiar';
                insertBtn.onclick = () => insertAiResponse(text);
                msgDiv.appendChild(insertBtn);
            }

            aiChatContainer.appendChild(msgDiv);
            aiChatContainer.scrollTop = aiChatContainer.scrollHeight;
            return msgId;
        }

        function insertAiResponse(text) {
            const focused = getCurrentFocusedIndex() || lastFocusedSegment;
            if (focused) {
                const textarea = document.getElementById(`msgstr-${focused.entryIndex}-${focused.segmentIndex}`);
                if (textarea && !textarea.readOnly) {
                    // Limpiar texto de markdown simple si la IA lo devolvi√≥
                    const cleanText = text.replace(/\*\*/g, '').replace(/```/g, '').trim();
                    textarea.value = cleanText;
                    textarea.dispatchEvent(new Event('input', { bubbles: true }));
                    textarea.focus();
                    
                    // Visual feedback on button
                    showMessage(translations[currentLanguage]['ai_inserted']);
                }
            } else {
                showMessage(translations[currentLanguage]['ai_no_segment']);
            }
        }

       function getContextPrompt(userQuery) {
            // 1. Obtener segmento activo
            const focused = getCurrentFocusedIndex() || lastFocusedSegment;
            if (!focused) return null;

            const entryIndex = focused.entryIndex;
            const segmentIndex = focused.segmentIndex;
            const entry = poEntries[entryIndex];
            const segment = entry.sentenceSegments[segmentIndex];
            
            // 2. Configuraci√≥n de idiomas
            const srcLang = (glossarySourceLanguage || configSrcLang?.value || 'Unknown');
            const tgtLang = (glossaryTargetLanguage || configTgtLang?.value || 'Unknown');

            // 3. RECUPERAR GLOSARIO (Contexto Terminol√≥gico)
            let glossaryContext = "No relevant glossary terms found.";
            if (termsFoundInActiveSegment && termsFoundInActiveSegment.size > 0) {
                const foundTermsList = [];
                termsFoundInActiveSegment.forEach(srcTerm => {
                    // Buscamos la traducci√≥n en el array global 'glossary'
                    const match = glossary.find(g => g.srcTerm === srcTerm);
                    if (match) {
                        foundTermsList.push(`"${match.srcTerm}" -> "${match.tgtTerm}"`);
                    }
                });
                if (foundTermsList.length > 0) {
                    glossaryContext = "STRICTLY USE these glossary terms:\n- " + foundTermsList.join("\n- ");
                }
            }

            // 4. RECUPERAR MEMORIA DE TRADUCCI√ìN (Contexto Hist√≥rico)
            let tmContext = "No TM match available.";
            // Usamos la variable global tmBestMatchForActiveSegment que ya calcula Poanda
            if (tmBestMatchForActiveSegment) {
                tmContext = `Found a similar translation in TM (${tmBestMatchForActiveSegment.score}% match):\n` +
                            `- Original: "${tmBestMatchForActiveSegment.srcText}"\n` +
                            `- Translation: "${tmBestMatchForActiveSegment.tgtText}"\n` +
                            `Use this as a reference style or base.`;
            }

            // 5. RECUPERAR CONTEXTO VECINO (Flujo del texto)
            // Intentamos coger el segmento anterior y el posterior para dar contexto
            let prevSegmentText = "N/A (Start of file)";
            let nextSegmentText = "N/A (End of file)";

            // L√≥gica simple para previo
            if (segmentIndex > 0) {
                prevSegmentText = entry.sentenceSegments[segmentIndex - 1].translation || "(Not translated yet)";
            } else if (entryIndex > 0) {
                // Si es el primer segmento de una entrada, miramos la entrada anterior (simplificado)
                const prevEntry = poEntries[entryIndex - 1];
                if (prevEntry && prevEntry.sentenceSegments.length > 0) {
                    const lastSeg = prevEntry.sentenceSegments[prevEntry.sentenceSegments.length - 1];
                    prevSegmentText = lastSeg.translation || "(Not translated yet)";
                }
            }

            // L√≥gica simple para siguiente
            if (segmentIndex < entry.sentenceSegments.length - 1) {
                nextSegmentText = entry.sentenceSegments[segmentIndex + 1].original;
            } else if (entryIndex < poEntries.length - 1) {
                const nextEntry = poEntries[entryIndex + 1];
                if (nextEntry && !nextEntry.isHeader && nextEntry.sentenceSegments.length > 0) {
                    nextSegmentText = nextEntry.sentenceSegments[0].original;
                }
            }

            // 6. CONSTRUCCI√ìN DEL PROMPT MAESTRO
            return `
                ACT AS: Professional Translator & Localization Expert (PandaBot).
                
                --- PROJECT CONTEXT ---
                Source Language: ${srcLang}
                Target Language: ${tgtLang}
                
                --- TERMINOLOGY & MEMORY (PRIORITY HIGH) ---
                ${glossaryContext}
                
                ${tmContext}
                
                --- TEXT FLOW CONTEXT ---
                Previous Sentence (Context): "...${prevSegmentText}"
                Current Sentence (TARGET): "${segment.original}"
                Next Sentence (Context): "${nextSegmentText}..."
                
                --- CURRENT STATUS ---
                Current Draft Translation: "${document.getElementById(`msgstr-${entryIndex}-${segmentIndex}`)?.value || ''}"
                Context ID (msgctxt): ${entry.msgctxt || 'N/A'}
                
                --- USER REQUEST ---
                ${userQuery}
                
                OUTPUT GUIDELINES:
                1. Be concise.
                2. If the user asks to translate, prioritize Glossary terms and TM style.
                3. Provide the result directly.
            `;
        }

        // Send Logic
        function handleAiSend() {
            const text = aiUserInput.value.trim();
            if (!text) return;
            
            const prompt = getContextPrompt(text);
            if (!prompt) {
                appendAiMessage('bot', translations[currentLanguage]['ai_no_segment']);
                return;
            }

            appendAiMessage('user', text);
            aiUserInput.value = '';
            callGeminiAI(prompt);
        }

        if(aiSendBtn) aiSendBtn.addEventListener('click', handleAiSend);
        if(aiUserInput) aiUserInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleAiSend();
            }
        });

        // Quick Actions Trigger
        window.triggerQuickAI = function(actionType) {
            let query = '';
            switch(actionType) {
                case 'translate': query = translations[currentLanguage]['ai_prompt_translate']; break;
                case 'improve': query = translations[currentLanguage]['ai_prompt_improve']; break;
                case 'explain': query = translations[currentLanguage]['ai_prompt_explain']; break;
                case 'fix': query = translations[currentLanguage]['ai_prompt_fix']; break;
            }
            
            if (query) {
                const prompt = getContextPrompt(query);
                if (!prompt) {
                    appendAiMessage('bot', translations[currentLanguage]['ai_no_segment']);
                    // Open sidebar if closed so user sees the error
                    if(!aiSidebar.classList.contains('show-sidebar')) aiSidebar.classList.add('show-sidebar');
                    return;
                }
                appendAiMessage('user', `‚ö° ${query}`);
                callGeminiAI(prompt);
            }
        };

    </script>
</body>
</html>
