<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title data-i18n="title">PandaTerm</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Brand Colors */
      --primary-color: #7DCEC7; /* Mint Green */
      --primary-hover-color: #6cbdb5;
      --text-color-dark: #373737; /* Dark Grey */
      --background-color-light: #f7f9fb;
      --card-background-light: #ffffff;
      --border-color-light: #e0e0e0;
      --header-text-light: #ffffff;

      /* Light mode theme */
      --background-color: var(--background-color-light);
      --text-color: var(--text-color-dark);
      --card-background: var(--card-background-light);
      --border-color: var(--border-color-light);
      --header-bg: var(--primary-color);
      --header-text: var(--header-text-light);
      --btn-primary-bg: var(--primary-color);
      --btn-primary-hover-bg: var(--primary-hover-color);
      --btn-primary-text-color: var(--header-text-light);
      --btn-secondary-bg: #e9eef2;
      --btn-secondary-hover-bg: #dbe1e6;
      --btn-secondary-text-color: var(--text-color-dark);
      --btn-danger-bg: #f44336;
      --btn-danger-hover-bg: #da190b;
      --input-border: #dce1e7;
      --info-box-bg: rgba(125, 206, 199, 0.1);
      --info-box-border: rgba(125, 206, 199, 0.3);
    }

    body.dark-mode {
      /* Dark mode theme */
      --background-color: #1a1a1a;
      --text-color: #e0e0e0;
      --card-background: #252525;
      --border-color: #3a3a3a;
      --header-bg: var(--text-color-dark);
      --header-text: var(--primary-color);
      --btn-primary-bg: var(--primary-color);
      --btn-primary-hover-bg: var(--primary-hover-color);
      --btn-primary-text-color: var(--text-color-dark);
      --btn-secondary-bg: #3a3a3a;
      --btn-secondary-hover-bg: #4a4a4a;
      --btn-secondary-text-color: #ffffff;
      --input-border: #4a4a4a;
      --info-box-bg: rgba(125, 206, 199, 0.1);
      --info-box-border: rgba(125, 206, 199, 0.2);
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes popIn {
        0% { transform: scale(0.9); opacity: 0; }
        70% { transform: scale(1.02); opacity: 1; }
        100% { transform: scale(1); opacity: 1; }
    }

    .row-pop-in {
        animation: popIn 0.3s ease-out forwards;
    }

    body {
      font-family: 'Montserrat', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--background-color);
      background-image: linear-gradient(180deg, rgba(255,255,255,0) 0%, var(--background-color) 300px);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      position: relative;
    }

    .lang-switcher-container {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }

    .logo-container {
      width: 100%;
      text-align: center;
      margin-top: 40px;
      margin-bottom: 10px;
      animation: fadeIn 0.5s ease-out forwards;
    }

    .logo {
      max-width: 220px; /* Increased logo size */
      height: auto;
      cursor: pointer;
      transition: transform 0.3s ease-out, filter 0.3s ease-out;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.05));
    }

    .logo:hover {
      transform: scale(1.05); /* Added hover effect */
    }

    body.dark-mode .logo {
      filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.6)); /* Sharper, more intense white halo */
    }

    body.dark-mode .logo:hover {
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.8)); /* Even brighter halo on hover */
    }

    .description {
        text-align: center;
        margin-bottom: 30px;
        color: var(--text-color);
        font-size: 1.1rem;
        opacity: 0;
        animation: fadeIn 0.5s ease-out 0.2s forwards;
    }

    .container {
      width: 90%;
      max-width: 900px;
      padding: 30px;
      background-color: var(--card-background);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.08);
      margin-bottom: 20px;
      opacity: 0;
      animation: fadeIn 0.5s ease-out 0.4s forwards;
    }

    .controls, .search-section, .lang-display {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 20px;
    }

    .controls {
        align-items: center;
    }

    /* Unified style for all input fields and textareas in add-term and general input groups */
    .controls button,
    .add-term button,
    .search-section input,
    .lang-display button,
    .lang-display input,
    select {
      padding: 12px 20px;
      border: 1px solid var(--input-border);
      border-radius: 8px;
      font-size: 1rem;
      color: var(--text-color);
      min-width: 150px;
      flex-grow: 1;
      box-sizing: border-box;
      transition: all 0.2s ease;
      font-family: 'Montserrat', sans-serif;
      background-color: var(--card-background); /* Ensure background matches */
    }

    .add-term input,
    .add-term textarea,
    .modal-content .input-group input,
    .modal-content .input-group textarea {
        padding: 12px 20px;
        border: 1px solid var(--input-border);
        border-radius: 8px;
        font-size: 1rem;
        color: var(--text-color);
        flex-grow: 1;
        box-sizing: border-box;
        transition: all 0.2s ease;
        font-family: 'Montserrat', sans-serif;
        background-color: var(--card-background);
        height: 50px; /* Fixed height for all input fields in add-term section */
    }

    /* Flex container for add-term section to keep fields in one row */
    .add-term {
        display: flex;
        flex-wrap: wrap; /* Allow wrapping if space is limited */
        gap: 12px;
        margin-bottom: 20px;
        align-items: flex-end; /* Align button to the bottom */
    }

    .add-term .input-group {
        flex: 1 1 calc(25% - 9px); /* Distribute 4 items per row, adjust gap */
        min-width: 180px; /* Minimum width for each input group */
    }

    /* Ensure textareas can be resized vertically */
    .add-term textarea,
    .modal-content .input-group textarea {
        resize: vertical;
        min-height: 50px; /* Minimum height for textareas, matching input height */
        height: auto; /* Allow height to adjust if user resizes */
    }

    input:focus, select:focus, textarea:focus { /* Added textarea to focus styles */
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(125, 206, 199, 0.3);
    }

    button {
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      font-weight: 600;
      transition: all 0.2s ease-out;
    }

    button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    button:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .btn-primary {
      background-color: var(--btn-primary-bg);
      color: var(--btn-primary-text-color);
    }
    .btn-primary:hover {
      background-color: var(--btn-primary-hover-bg);
    }

    .btn-secondary {
      background-color: var(--btn-secondary-bg);
      color: var(--btn-secondary-text-color);
    }
    .btn-secondary:hover {
      background-color: var(--btn-secondary-hover-bg);
    }

    .lang-btn {
        background-color: var(--card-background);
        border: 1px solid var(--border-color);
        color: var(--text-color);
        min-width: 50px;
        flex-grow: 0;
        padding: 8px 12px;
    }

    .lang-btn.active {
        background-color: var(--primary-color);
        color: var(--btn-primary-text-color);
        border-color: var(--primary-color);
    }

    .btn-danger {
      background-color: var(--btn-danger-bg);
      color: white;
    }
    .btn-danger:hover {
      background-color: var(--btn-danger-hover-bg);
    }

    .delete-btn {
      background-color: var(--btn-danger-bg);
      color: white;
    }
    .delete-btn:hover {
      background-color: var(--btn-danger-hover-bg);
    }

    button:disabled {
      background-color: #cccccc !important;
      cursor: not-allowed;
      color: #6c757d !important;
      transform: none;
      box-shadow: none;
    }

    input[type="file"] {
      display: none;
    }

    label {
      font-weight: 500;
      margin-right: 5px;
      white-space: nowrap;
      margin-bottom: 8px;
      display: block;
      font-size: 0.9rem;
      color: var(--text-color);
    }

    .input-group {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      min-width: 150px;
    }

    .lang-display {
        align-items: flex-end;
    }

    input:disabled {
      background-color: #e9ecef;
      color: #6c757d;
    }

    body.dark-mode input:disabled {
      background-color: #3a3a3a;
      color: #888;
    }

    .table-container {
      max-height: 400px;
      overflow-y: auto;
      border-radius: 8px;
      margin-top: 20px;
      border: 1px solid var(--border-color);
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background-color: var(--card-background);
    }

    th, td {
      border-bottom: 1px solid var(--border-color);
      padding: 14px 16px;
      text-align: left;
      vertical-align: top; /* Align content to the top for multi-line text */
    }

    td {
        color: var(--text-color);
    }

    th {
      background-color: var(--card-background);
      color: var(--text-color);
      font-weight: 600;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      position: sticky;
      top: 0;
      z-index: 10; /* Added z-index for opaque background when sticky */
    }

    body.dark-mode th {
        background-color: #303030;
    }

    tr:last-child td {
        border-bottom: none;
    }

    tr:hover {
      background-color: rgba(125, 206, 199, 0.07);
    }

    h2 {
        font-weight: 600;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--border-color);
        color: var(--text-color);
    }

    .message-box {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: var(--card-background);
      padding: 20px 30px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      z-index: 1000;
      text-align: center;
      max-width: 400px;
      color: var(--text-color);
      border-top: 4px solid var(--primary-color);
      animation: popIn 0.3s ease-out;
    }

    .message-box h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-weight: 600;
    }

    .message-box .dialog-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 20px;
    }

    .info-box {
      background-color: var(--info-box-bg);
      border: 1px solid var(--info-box-border);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      color: var(--text-color);
    }

    #languageConfigSection, #editorSection {
        transition: opacity 0.4s ease-out, transform 0.4s ease-out, max-height 0.4s ease-out;
        overflow: hidden;
        max-height: 1000px; /* Arbitrary large value */
    }

    .hidden-section {
        opacity: 0;
        transform: translateY(10px);
        max-height: 0 !important;
        margin-bottom: 0;
        pointer-events: none;
    }

    /* Styles for editable cells */
    td.editable {
        cursor: pointer;
        position: relative;
    }

    td.editable:hover {
        background-color: rgba(125, 206, 199, 0.15);
    }

    td.editable input[type="text"],
    td.editable textarea {
        width: calc(100% - 10px); /* Adjust for padding */
        padding: 5px;
        border: 1px solid var(--primary-color);
        border-radius: 4px;
        background-color: var(--card-background);
        color: var(--text-color);
        font-family: 'Montserrat', sans-serif;
        box-sizing: border-box;
        resize: vertical; /* Allow vertical resizing for textareas */
        min-height: 30px; /* Minimum height for textarea */
    }

    td.editable input[type="text"]:focus,
    td.editable textarea:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(125, 206, 199, 0.5);
    }

    .search-options {
        display: flex;
        gap: 15px;
        align-items: center;
        margin-top: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .search-options label {
        display: flex;
        align-items: center;
        gap: 5px;
        margin-bottom: 0; /* Override default label margin */
        font-size: 1rem;
        font-weight: 400;
    }

    .search-options input[type="radio"] {
        width: auto;
        min-width: unset;
        margin-right: 5px;
        cursor: pointer;
    }

    /* Modal styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1001;
        animation: fadeIn 0.3s ease-out;
    }

    .modal-content {
        background-color: var(--card-background);
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        max-width: 500px;
        width: 90%;
        animation: popIn 0.3s ease-out;
        position: relative;
    }

    .modal-content h3 {
        margin-top: 0;
        margin-bottom: 20px;
        font-weight: 600;
        color: var(--text-color);
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 10px;
    }

    .modal-content .input-group {
        margin-bottom: 15px;
    }

    .modal-content .input-group label {
        margin-bottom: 5px;
        font-weight: 500;
    }

    .modal-content .input-group input,
    .modal-content .input-group textarea {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--input-border);
        border-radius: 8px;
        background-color: var(--card-background);
        color: var(--text-color);
        font-family: 'Montserrat', sans-serif;
        box-sizing: border-box;
    }

    .modal-content .input-group textarea {
        min-height: 80px;
        resize: vertical;
    }

    .modal-content .dialog-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 25px;
    }

    .close-modal-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        background: none;
        border: none;
        font-size: 1.5rem;
        color: var(--text-color);
        cursor: pointer;
        padding: 5px;
        border-radius: 50%;
        transition: background-color 0.2s;
    }

    .close-modal-btn:hover {
        background-color: rgba(0,0,0,0.1);
    }

  </style>
</head>
<body>
  <div class="lang-switcher-container">
    <button id="langBtnEN" onclick="setUILanguage('en')" class="lang-btn">EN</button>
    <button id="langBtnES" onclick="setUILanguage('es')" class="lang-btn">ES</button>
  </div>
  <div class="logo-container">
    <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/pandaterm-logo.png" alt="PandaTerm Logo" class="logo" />
  </div>
  <p class="description" data-i18n="app_description"></p>


  <div class="container">
    <div class="controls">
      <button onclick="loadTBX()" data-i18n="import_tbx" class="btn-secondary">Importar TBX</button>
      <input type="file" id="tbxFileInput" accept=".xml,.tbx" />
      <button onclick="downloadTBX()" data-i18n="download_tbx" class="btn-secondary">Descargar TBX</button>
      <button onclick="resetGlossary()" data-i18n="new_glossary" class="btn-secondary">Nuevo glosario</button>
      <button onclick="toggleTheme()" id="themeToggleButton" data-i18n="toggle_theme" class="btn-secondary">Cambiar tema</button>
      <button onclick="undo()" id="undoButton" data-i18n="undo_button" class="btn-secondary" disabled>Deshacer</button>
    </div>

    <div id="languageConfigSection">
      <h2 data-i18n="config_lang_title">Configurar idiomas del glosario</h2>
      <div class="info-box">
        <p data-i18n="config_lang_info">
          Define los idiomas de origen y destino de tu glosario. Puedes introducir el código ISO directamente o seleccionarlo de las sugerencias. Es fundamental que el código ISO sea correcto para que funcione correctamente con tu herramienta TAO.
        </p>
      </div>
      <div class="lang-display">
        <div class="input-group">
          <label for="configSrcLang" data-i18n="source_language">Idioma de origen:</label>
          <input id="configSrcLang" list="isoLanguages" value="en-US" />
        </div>
        <div class="input-group">
          <label for="configTgtLang" data-i18n="target_language">Idioma de destino:</label>
          <input id="configTgtLang" list="isoLanguages" value="es-ES" />
        </div>
        <button onclick="confirmGlossaryLanguages()" data-i18n="confirm_languages" class="btn-primary">Confirmar idiomas</button>
      </div>
    </div>

    <div id="editorSection" class="hidden-section">
        <h2 data-i18n="current_lang_title">Idiomas actuales del glosario</h2>
        <div class="lang-display">
            <div class="input-group">
                <label data-i18n="source_language">Idioma de origen:</label>
                <input id="displaySrcLang" disabled />
            </div>
            <div class="input-group">
                <label data-i18n="target_language">Idioma de destino:</label>
                <input id="displayTgtLang" disabled />
            </div>
        </div>

        <h2 data-i18n="add_term_title">Añadir término</h2>
        <div class="add-term">
            <div class="input-group">
                <label for="srcTerm" data-i18n="term">Término:</label>
                <input id="srcTerm" />
            </div>
            <div class="input-group">
                <label for="tgtTerm" data-i18n="translation">Traducción:</label>
                <input id="tgtTerm" />
            </div>
            <div class="input-group">
                <label for="definition" data-i18n="definition">Definición:</label>
                <textarea id="definition"></textarea>
            </div>
            <div class="input-group">
                <label for="notes" data-i18n="notes">Notas:</label>
                <textarea id="notes"></textarea>
            </div>
            <button onclick="addTerm()" data-i18n="add_button" class="btn-primary">Añadir</button>
        </div>

        <h2 data-i18n="search_title">Buscar</h2>
        <div class="search-section">
            <input id="searchTerm" placeholder="Buscar término..." oninput="renderGlossary()" data-i18n-placeholder="search_placeholder" />
            <div class="search-options">
                <label>
                    <input type="radio" name="searchScope" value="all" checked onchange="renderGlossary()">
                    <span data-i18n="search_all">Todos</span>
                </label>
                <label>
                    <input type="radio" name="searchScope" value="source" onchange="renderGlossary()">
                    <span data-i18n="search_source">Solo origen</span>
                </label>
                <label>
                    <input type="radio" name="searchScope" value="target" onchange="renderGlossary()">
                    <span data-i18n="search_target">Solo destino</span>
                </label>
            </div>
        </div>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th data-i18n="source_term_col">Término de origen</th>
                        <th data-i18n="target_term_col">Término de destino</th>
                        <th data-i18n="definition_col">Definición</th>
                        <th data-i18n="notes_col">Notas</th>
                        <th data-i18n="actions_col">Acciones</th>
                    </tr>
                </thead>
                <tbody id="glossaryTable"></tbody>
            </table>
        </div>
    </div>

    <datalist id="isoLanguages">
      </datalist>
  </div>

  <script>
    // Global array to store glossary terms
    let glossary = [];
    // Action history for undo functionality
    let history = [];
    // Get current UI language from local storage, default to English
    let currentUILanguage = localStorage.getItem('language') || 'en';
    // Get current theme from local storage, default to light
    let currentTheme = localStorage.getItem('theme') || 'light';

    // Global variables to store the glossary's defined source and target languages
    let glossarySourceLanguage = '';
    let glossaryTargetLanguage = '';

    const translations = {
      en: {
        title: "PandaTerm",
        main_title: "PandaTerm",
        app_description: "A simple TBX glossary editor",
        import_tbx: "Import TBX",
        download_tbx: "Download TBX",
        new_glossary: "New glossary",
        toggle_theme: "Toggle theme",
        undo_button: "Undo",
        config_lang_title: "Configure glossary languages",
        config_lang_info: "Define the source and target languages for your glossary. You can type the ISO code directly or select from the suggestions. It is important that the ISO code is correct for it to work well in your CAT tool.",
        confirm_languages: "Confirm languages",
        current_lang_title: "Current glossary languages",
        add_term_title: "Add term",
        source_language: "Source language:",
        term: "Term:",
        target_language: "Target language:",
        translation: "Translation:",
        definition: "Definition:",
        notes: "Notes:",
        add_button: "Add",
        search_title: "Search",
        search_placeholder: "Search term...",
        search_all: "All",
        search_source: "Source only",
        search_target: "Target only",
        source_term_col: "Source term",
        target_term_col: "Target term",
        definition_col: "Definition",
        notes_col: "Notes",
        actions_col: "Actions",
        delete_button: "Delete",
        edit_button: "Edit",
        both_terms_required: "Both term and translation are required.",
        lang_config_required: "Please configure source and target languages for the glossary.",
        "Cannot download empty or unconfigured glossary.": "Cannot download empty or unconfigured glossary.",
        "No valid language pairs found in TBX. Defaulting to en-US/es-ES.": "No valid language pairs found in TBX. Defaulting to en-US/es-ES.",
        "Error loading TBX file. Please ensure it's a valid XML/TBX.": "Error loading TBX file. Please ensure it's a valid XML/TBX.",
        new_glossary_confirm_title: "Confirm New Glossary",
        new_glossary_confirm_text: "All current glossary data will be lost. If you don't want to lose it, click cancel and export it as a TBX file. Click confirm to create a new glossary from scratch.",
        confirm_button: "Confirm",
        cancel_button: "Cancel",
        download_dialog_title: "Enter filename",
        download_dialog_placeholder: "glossary",
        save_button: "Save",
        edit_term_title: "Edit Term",
        update_button: "Update"
      },
      es: {
        title: "PandaTerm",
        main_title: "PandaTerm",
        app_description: "Un sencillo editor de glosarios TBX",
        import_tbx: "Importar TBX",
        download_tbx: "Descargar TBX",
        new_glossary: "Nuevo glosario",
        toggle_theme: "Cambiar tema",
        undo_button: "Deshacer",
        config_lang_title: "Configurar idiomas del glosario",
        config_lang_info: "Define los idiomas de origen y destino de tu glosario. Puedes introducir el código ISO directamente o seleccionarlo de las sugerencias. Es fundamental que el código ISO sea correcto para que funcione correctamente con tu herramienta TAO.",
        confirm_languages: "Confirmar idiomas",
        current_lang_title: "Idiomas actuales del glosario",
        add_term_title: "Añadir término",
        source_language: "Idioma de origen:",
        term: "Término:",
        target_language: "Idioma de destino:",
        translation: "Traducción:",
        definition: "Definición:",
        notes: "Notas:",
        add_button: "Añadir",
        search_title: "Buscar",
        search_placeholder: "Buscar término...",
        search_all: "Todos",
        search_source: "Solo origen",
        search_target: "Solo destino",
        source_term_col: "Término de origen",
        target_term_col: "Término de destino",
        definition_col: "Definición",
        notes_col: "Notas",
        actions_col: "Acciones",
        delete_button: "Eliminar",
        edit_button: "Editar",
        both_terms_required: "El término y la traducción son obligatorios.",
        lang_config_required: "Por favor, configura los idiomas de origen y destino para el glosario.",
        "Cannot download empty or unconfigured glossary.": "No se puede descargar un glosario vacío o sin configurar.",
        "No valid language pairs found in TBX. Defaulting to en-US/es-ES.": "No se encontraron pares de idioma válidos en TBX. Se utiliza en-US/es-ES por defecto.",
        "Error loading TBX file. Please ensure it's a valid XML/TBX.": "Error al cargar el archivo TBX. Asegúrate de que sea un XML/TBX válido.",
        new_glossary_confirm_title: "Confirmar nuevo glosario",
        new_glossary_confirm_text: "Se perderá toda la información del glosario actual. Si no quieres perderlo, haz clic en cancelar y expórtalo como archivo TBX. Haz clic en confirmar para crear un glosario nuevo desde cero.",
        confirm_button: "Confirmar",
        cancel_button: "Cancelar",
        download_dialog_title: "Introducir nombre de archivo",
        download_dialog_placeholder: "glosario",
        save_button: "Guardar",
        edit_term_title: "Editar término",
        update_button: "Actualizar"
      }
    };

    const isoLanguagesData = [
      { code: "en", name: "English" }, { code: "en-US", name: "English (United States)" }, { code: "en-GB", name: "English (United Kingdom)" }, { code: "es", name: "Español" }, { code: "es-ES", name: "Español (España)" }, { code: "es-MX", name: "Español (México)" }, { code: "es-AR", name: "Español (Argentina)" }, { code: "fr", name: "Français" }, { code: "de", name: "Deutsch" }, { code: "it", name: "Italiano" }, { code: "pt", name: "Português" }, { code: "ja", name: "日本語 (Japanese)" }, { code: "zh", name: "中文 (Chinese)" }, { code: "ar", name: "العربية (Arabic)" }, { code: "ru", name: "Русский (Russian)" }, { code: "ko", name: "한국어 (Korean)" }, { code: "nl", name: "Nederlands" }, { code: "sv", name: "Svenska" }, { code: "da", name: "Dansk" }, { code: "no", name: "Norsk" }, { code: "fi", name: "Suomi" }, { code: "tr", name: "Türkçe" }, { code: "pl", "name": "Polski" }, { code: "ca", name: "Català" }, { code: "eu", name: "Euskara" }, { code: "gl", name: "Galego" }
    ];

    /**
     * Populates the datalist with ISO language codes and names.
     */
    function populateIsoLanguagesDatalist() {
      const datalist = document.getElementById('isoLanguages');
      datalist.innerHTML = '';
      isoLanguagesData.forEach(lang => {
        const option = document.createElement('option');
        option.value = lang.code;
        option.textContent = lang.name;
        datalist.appendChild(option);
      });
    }

    /**
     * Applies the selected theme (light or dark) to the body.
     * @param {string} theme - The theme to apply ('light' or 'dark').
     */
    function applyTheme(theme) {
      document.body.className = theme === 'dark' ? 'dark-mode' : '';
      currentTheme = theme;
      localStorage.setItem('theme', theme);
    }

    /**
     * Toggles between light and dark themes.
     */
    function toggleTheme() {
      applyTheme(currentTheme === 'light' ? 'dark' : 'light');
    }

    /**
     * Sets the UI language and updates all translatable text.
     * @param {string} lang - The language code ('en' or 'es').
     */
    function setUILanguage(lang) {
      currentUILanguage = lang;
      localStorage.setItem('language', lang);
      updateTextContent();
      updateLanguageButtons();
    }

    /**
     * Updates the active state of language switcher buttons.
     */
    function updateLanguageButtons() {
        document.getElementById('langBtnEN').classList.toggle('active', currentUILanguage === 'en');
        document.getElementById('langBtnES').classList.toggle('active', currentUILanguage === 'es');
    }

    /**
     * Updates all elements with `data-i18n` and `data-i18n-placeholder` attributes
     * to the current UI language.
     */
    function updateTextContent() {
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (translations[currentUILanguage][key]) {
          el.textContent = translations[currentUILanguage][key];
        }
      });

      document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if (translations[currentUILanguage][key]) {
          el.placeholder = translations[currentUILanguage][key];
        }
      });
      renderGlossary(); // Re-render glossary to update delete button text
    }

    /**
     * Shows a specific section of the application and hides others.
     * @param {string} sectionId - The ID of the section to show.
     */
    function showSection(sectionId) {
        const sectionToShow = document.getElementById(sectionId);
        const sectionToHide = sectionId === 'editorSection' ? document.getElementById('languageConfigSection') : document.getElementById('editorSection');

        sectionToHide.classList.add('hidden-section');
        sectionToShow.classList.remove('hidden-section');
    }

    /**
     * Updates the disabled state of the undo button based on history.
     */
    function updateUndoButtonState() {
      const undoButton = document.getElementById('undoButton');
      if(undoButton) {
        undoButton.disabled = history.length === 0;
      }
    }

    /**
     * Saves the current state of the glossary to the history for undo functionality.
     */
    function saveState() {
      // Save a deep copy of the current glossary state
      history.push(JSON.parse(JSON.stringify(glossary)));
      updateUndoButtonState();
    }

    /**
     * Undoes the last action by restoring the previous glossary state from history.
     */
    function undo() {
      if (history.length > 0) {
        glossary = history.pop();
        renderGlossary();
        updateUndoButtonState();
      }
    }

    /**
     * Performs the actual reset of the glossary after confirmation.
     */
    function performResetGlossary() {
      saveState();
      glossary = [];
      glossarySourceLanguage = '';
      glossaryTargetLanguage = '';
      document.getElementById('configSrcLang').value = 'en-US';
      document.getElementById('configTgtLang').value = 'es-ES';
      document.getElementById('srcTerm').value = '';
      document.getElementById('tgtTerm').value = '';
      document.getElementById('definition').value = ''; // Clear definition
      document.getElementById('notes').value = ''; // Clear notes
      document.getElementById('searchTerm').value = '';
      // Reset search scope to 'all'
      document.querySelector('input[name="searchScope"][value="all"]').checked = true;
      showSection('languageConfigSection');
      renderGlossary();
    }

    /**
     * Prompts the user for confirmation before resetting the glossary.
     */
    function resetGlossary() {
      const title = translations[currentUILanguage]['new_glossary_confirm_title'];
      const message = translations[currentUILanguage]['new_glossary_confirm_text'];
      showConfirmationDialog(title, message, performResetGlossary);
    }

    /**
     * Confirms and sets the glossary's source and target languages.
     */
    function confirmGlossaryLanguages() {
      const srcLang = document.getElementById('configSrcLang').value.trim();
      const tgtLang = document.getElementById('configTgtLang').value.trim();

      if (!srcLang || !tgtLang) {
        showMessageBox(translations[currentUILanguage]['lang_config_required']);
        return;
      }

      glossarySourceLanguage = srcLang;
      glossaryTargetLanguage = tgtLang;
      document.getElementById('displaySrcLang').value = glossarySourceLanguage;
      document.getElementById('displayTgtLang').value = glossaryTargetLanguage;
      showSection('editorSection');
      renderGlossary();

      // Clear history when starting a new glossary configuration
      history = [];
      updateUndoButtonState();
    }

    /**
     * Adds a new term to the glossary.
     */
    function addTerm() {
      const srcTermInput = document.getElementById("srcTerm");
      const tgtTermInput = document.getElementById("tgtTerm");
      const definitionInput = document.getElementById("definition"); // New
      const notesInput = document.getElementById("notes"); // New

      const srcTerm = srcTermInput.value.trim();
      const tgtTerm = tgtTermInput.value.trim();
      const definition = definitionInput.value.trim(); // New
      const notes = notesInput.value.trim(); // New

      if (!srcTerm || !tgtTerm) {
        showMessageBox(translations[currentUILanguage]['both_terms_required']);
        return;
      }

      saveState();

      glossary.push({
        srcLang: glossarySourceLanguage,
        srcTerm: srcTerm,
        tgtLang: glossaryTargetLanguage,
        tgtTerm: tgtTerm,
        definition: definition, // Add definition
        notes: notes // Add notes
      });
      srcTermInput.value = "";
      tgtTermInput.value = "";
      definitionInput.value = ""; // Clear definition input
      notesInput.value = ""; // Clear notes input
      srcTermInput.focus();
      renderGlossary(true); // Pass true to animate the last row
    }

    /**
     * Deletes a term from the glossary by its original index.
     * @param {number} originalIndex - The original index of the term in the glossary array.
     */
    function deleteTerm(originalIndex) {
      saveState();
      glossary.splice(originalIndex, 1);
      renderGlossary();
    }

    /**
     * Opens a modal to edit an existing term.
     * @param {number} index - The index of the term in the glossary array.
     */
    function editTerm(index) {
        const term = glossary[index];
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'modal-overlay';
        modalOverlay.id = 'editModal';

        modalOverlay.innerHTML = `
            <div class="modal-content">
                <button class="close-modal-btn" onclick="closeModal('editModal')">&times;</button>
                <h3 data-i18n="edit_term_title">${translations[currentUILanguage]['edit_term_title']}</h3>
                <div class="input-group">
                    <label for="editSrcTerm" data-i18n="term">${translations[currentUILanguage]['term']}</label>
                    <input id="editSrcTerm" type="text" value="${term.srcTerm}" />
                </div>
                <div class="input-group">
                    <label for="editTgtTerm" data-i18n="translation">${translations[currentUILanguage]['translation']}</label>
                    <input id="editTgtTerm" type="text" value="${term.tgtTerm}" />
                </div>
                <div class="input-group">
                    <label for="editDefinition" data-i18n="definition">${translations[currentUILanguage]['definition']}</label>
                    <textarea id="editDefinition">${term.definition || ''}</textarea>
                </div>
                <div class="input-group">
                    <label for="editNotes" data-i18n="notes">${translations[currentUILanguage]['notes']}</label>
                    <textarea id="editNotes">${term.notes || ''}</textarea>
                </div>
                <div class="dialog-buttons">
                    <button class="btn-secondary" onclick="closeModal('editModal')" data-i18n="cancel_button">${translations[currentUILanguage]['cancel_button']}</button>
                    <button class="btn-primary" onclick="saveEditedTerm(${index})" data-i18n="update_button">${translations[currentUILanguage]['update_button']}</button>
                </div>
            </div>
        `;
        document.body.appendChild(modalOverlay);
    }

    /**
     * Saves the changes made to a term in the edit modal.
     * @param {number} index - The index of the term in the glossary array.
     */
    function saveEditedTerm(index) {
        const srcTerm = document.getElementById('editSrcTerm').value.trim();
        const tgtTerm = document.getElementById('editTgtTerm').value.trim();
        const definition = document.getElementById('editDefinition').value.trim();
        const notes = document.getElementById('editNotes').value.trim();

        if (!srcTerm || !tgtTerm) {
            showMessageBox(translations[currentUILanguage]['both_terms_required']);
            return;
        }

        saveState(); // Save state before modification

        glossary[index].srcTerm = srcTerm;
        glossary[index].tgtTerm = tgtTerm;
        glossary[index].definition = definition;
        glossary[index].notes = notes;

        closeModal('editModal');
        renderGlossary();
    }

    /**
     * Closes a modal dialog.
     * @param {string} modalId - The ID of the modal overlay to close.
     */
    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.remove();
        }
    }

    /**
     * Renders the glossary table based on current search and filter criteria.
     * @param {boolean} animateLastRow - Whether to apply animation to the last added row.
     */
    function renderGlossary(animateLastRow = false) {
      const tbody = document.getElementById("glossaryTable");
      const search = document.getElementById("searchTerm").value.toLowerCase();
      const searchScope = document.querySelector('input[name="searchScope"]:checked').value;
      tbody.innerHTML = "";

      const filteredGlossary = glossary.filter(entry => {
        const srcMatch = entry.srcTerm.toLowerCase().includes(search);
        const tgtMatch = entry.tgtTerm.toLowerCase().includes(search);

        if (searchScope === 'source') {
          return srcMatch;
        } else if (searchScope === 'target') {
          return tgtMatch;
        } else { // 'all'
          return srcMatch || tgtMatch;
        }
      });

      filteredGlossary.forEach((entry, i) => {
          // Find original index to pass to deleteTerm and editTerm
          const originalIndex = glossary.findIndex(g => g === entry);
          const row = document.createElement("tr");
          row.innerHTML = `
            <td class="editable" onclick="editTerm(${originalIndex})">${entry.srcTerm}</td>
            <td class="editable" onclick="editTerm(${originalIndex})">${entry.tgtTerm}</td>
            <td class="editable" onclick="editTerm(${originalIndex})">${entry.definition || ''}</td>
            <td class="editable" onclick="editTerm(${originalIndex})">${entry.notes || ''}</td>
            <td><button class="delete-btn" onclick="deleteTerm(${originalIndex})">${translations[currentUILanguage]['delete_button']}</button></td>
          `;

          if (animateLastRow && i === filteredGlossary.length - 1) {
              row.classList.add('row-pop-in');
          }

          tbody.appendChild(row);
      });
    }

    /**
     * Generates the TBX XML string from the current glossary data.
     * It uses the <martif> structure for broader compatibility.
     * @returns {string} The TBX XML string.
     */
    function generateTBX() {
      const xml = [`<?xml version="1.0" encoding="UTF-8"?>`,
        `<martif type="TBX" xml:lang="${glossarySourceLanguage}">`, // Reverted to martif
        `  <text>`,
        `    <body>`];

      glossary.forEach(entry => {
        xml.push(`      <termEntry>`); // Reverted to termEntry
        xml.push(`        <LangSet xml:lang="${entry.srcLang}">`); // Reverted to LangSet
        xml.push(`          <tig><term>${entry.srcTerm}</term></tig>`); // Reverted to tig
        xml.push(`        </LangSet>`);
        xml.push(`        <LangSet xml:lang="${entry.tgtLang}">`); // Reverted to LangSet
        xml.push(`          <tig>`); // Reverted to tig
        xml.push(`            <term>${entry.tgtTerm}</term>`);
        // Add definition if present
        if (entry.definition) {
            xml.push(`            <descrip type="definition">${entry.definition}</descrip>`);
        }
        // Add notes if present
        if (entry.notes) {
            xml.push(`            <termNote type="comment">${entry.notes}</termNote>`);
        }
        xml.push(`          </tig>`);
        xml.push(`        </LangSet>`);
        xml.push(`      </termEntry>`);
      });

      xml.push(`    </body>`, `  </text>`, `</martif>`); // Reverted to martif
      return xml.join("\n");
    }

    /**
     * Initiates the download of the current glossary as a TBX file.
     */
    function downloadTBX() {
      if (glossary.length === 0 || !glossarySourceLanguage || !glossaryTargetLanguage) {
        showMessageBox(translations[currentUILanguage]["Cannot download empty or unconfigured glossary."]);
        return;
      }

      const title = translations[currentUILanguage]['download_dialog_title'];
      const placeholder = translations[currentUILanguage]['download_dialog_placeholder'];

      showInputDialog(title, '', placeholder, (filename) => {
        const blob = new Blob([generateTBX()], { type: "application/xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename.endsWith('.tbx') ? filename : `${filename}.tbx`;
        a.click();
        URL.revokeObjectURL(url);
      });
    }

    /**
     * Loads a TBX file selected by the user.
     * This function now handles both <martif> and <tbx> root structures.
     */
    function loadTBX() {
      console.log("Starting TBX import process...");
      document.getElementById("tbxFileInput").click();
      document.getElementById("tbxFileInput").onchange = (event) => {
        const file = event.target.files[0];
        if (!file) {
          console.log("No file selected.");
          return;
        }

        console.log(`Selected file: ${file.name}, type: ${file.type}, size: ${file.size} bytes`);

        const reader = new FileReader();
        reader.onload = () => {
          try {
            console.log("File read successfully. Attempting to parse XML...");
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(reader.result, "application/xml");

            // Check for parsing errors
            const parserError = xmlDoc.querySelector("parsererror");
            if (parserError) {
                const errorText = parserError.textContent || "Unknown XML parsing error.";
                console.error("XML Parsing Error:", errorText, xmlDoc);
                throw new Error(`Parsing error: The file is not a valid XML/TBX. Details: ${errorText.substring(0, 100)}...`);
            }
            console.log("Parsed XML document:", xmlDoc);

            let entryTagName, langSetTagName, termGroupTagName, rootElement;

            // Determine the TBX dialect based on the root element
            if (xmlDoc.getElementsByTagName("martif").length > 0) {
                rootElement = "martif";
                entryTagName = "termEntry";
                langSetTagName = "LangSet"; // Based on user's previous TBX and Subpanda's
                termGroupTagName = "tig";
                console.log("Detected TBX dialect: martif (older style)");
            } else if (xmlDoc.getElementsByTagName("tbx").length > 0) {
                rootElement = "tbx";
                entryTagName = "conceptEntry";
                langSetTagName = "langSec";
                termGroupTagName = "termSec";
                console.log("Detected TBX dialect: tbx (TBX 3.0 style)");
            } else {
                throw new Error("Unsupported TBX root element. Expected <martif> or <tbx>.");
            }

            const entries = xmlDoc.getElementsByTagName(entryTagName);
            console.log(`Found ${entries.length} <${entryTagName}> elements.`);

            const newGlossary = [];
            const langCounts = {}; // To determine most frequent source/target languages

            if (entries.length === 0) {
                console.warn(`No <${entryTagName}> elements found in the TBX file.`);
            }

            for (let i = 0; i < entries.length; i++) {
              const entry = entries[i];
              const langSets = entry.getElementsByTagName(langSetTagName);
              console.log(`Processing ${entryTagName} ${i+1}. Found ${langSets.length} <${langSetTagName}> elements.`);

              let conceptDefinition = '';
              let conceptNotes = '';

              // Try to get concept-level definition/notes for TBX 3.0 style
              if (rootElement === "tbx") {
                  const conceptDefinitionElement = entry.querySelector('descrip[type="definition"]');
                  const conceptNotesElement = entry.querySelector('note');
                  conceptDefinition = conceptDefinitionElement ? conceptDefinitionElement.textContent || '' : '';
                  conceptNotes = conceptNotesElement ? conceptNotesElement.textContent || '' : '';
              }


              if (langSets.length >= 2) {
                let srcLang = '';
                let srcTerm = '';
                let tgtLang = '';
                let tgtTerm = '';
                let entryDefinition = conceptDefinition; // Start with concept-level definition
                let entryNotes = conceptNotes; // Start with concept-level notes

                // Process first langSet (assumed source)
                const firstLangSet = langSets[0];
                srcLang = firstLangSet.getAttribute("xml:lang") || '';
                const firstTermGroup = firstLangSet.getElementsByTagName(termGroupTagName)[0];
                if (firstTermGroup) {
                    srcTerm = firstTermGroup.getElementsByTagName("term")[0]?.textContent || '';
                }

                // Process second langSet (assumed target)
                const secondLangSet = langSets[1];
                tgtLang = secondLangSet.getAttribute("xml:lang") || '';
                const secondTermGroup = secondLangSet.getElementsByTagName(termGroupTagName)[0];
                if (secondTermGroup) {
                    tgtTerm = secondTermGroup.getElementsByTagName("term")[0]?.textContent || '';

                    // Prioritize term-level definition/notes if available in target langSet/termGroup
                    const termGroupDefinitionElement = secondTermGroup.querySelector('descrip[type="definition"]');
                    const termGroupNotesElement = secondTermGroup.querySelector('termNote[type="comment"]');
                    const termGroupContextElement = secondTermGroup.querySelector('descrip[type="context"]'); // Often used as definition/notes

                    if (termGroupDefinitionElement) {
                        entryDefinition = termGroupDefinitionElement.textContent || '';
                    } else if (termGroupContextElement) { // If no explicit definition, context might serve as one
                        entryDefinition = termGroupContextElement.textContent || '';
                    }

                    if (termGroupNotesElement) {
                        entryNotes = termGroupNotesElement.textContent || '';
                    }
                }

                console.log(`  TermPair: ${srcLang}:${srcTerm} - ${tgtLang}:${tgtTerm}. Definition: "${entryDefinition}", Notes: "${entryNotes}"`);

                // Only add if at least one term is present.
                if (srcTerm || tgtTerm) {
                    newGlossary.push({ srcLang: srcLang, srcTerm: srcTerm, tgtLang: tgtLang, tgtTerm: tgtTerm, definition: entryDefinition, notes: entryNotes });

                    langCounts[srcLang] = (langCounts[srcLang] || 0) + 1;
                    langCounts[tgtLang] = (langCounts[tgtLang] || 0) + 1;
                } else {
                    console.warn(`  ${entryTagName} ${i+1} has two ${langSetTagName}s but no terms found. Skipping.`);
                }

              } else {
                console.warn(`  ${entryTagName} ${i+1} does not have at least two <${langSetTagName}> elements. Skipping.`);
              }
            }

            console.log("Language counts:", langCounts);
            const sortedLangs = Object.keys(langCounts).sort((a, b) => langCounts[b] - langCounts[a]);
            console.log("Sorted languages by frequency:", sortedLangs);

            let detectedSrcLang, detectedTgtLang;

            if (sortedLangs.length >= 2) {
                detectedSrcLang = sortedLangs[0];
                detectedTgtLang = sortedLangs[1];
                console.log(`Detected source language: ${detectedSrcLang}, Target language: ${detectedTgtLang}`);

                newGlossary.forEach(entry => {
                    // If the srcLang of an entry doesn't match the globally detected srcLang, swap them.
                    // This ensures consistency even if a TBX has entries with languages in different orders.
                    if (entry.srcLang !== detectedSrcLang && entry.tgtLang === detectedSrcLang) {
                        console.log(`Swapping language pair for entry: ${entry.srcTerm}`);
                        [entry.srcLang, entry.tgtLang] = [entry.tgtLang, entry.srcLang];
                        [entry.srcTerm, entry.tgtTerm] = [entry.tgtTerm, entry.srcTerm];
                    }
                });
            } else {
                // Fallback if not enough distinct languages are found in term entries
                // Try to get xml:lang from the root element itself
                const rootXmlLang = xmlDoc.documentElement.getAttribute("xml:lang");

                detectedSrcLang = rootXmlLang || 'en-US'; // Use root xml:lang or default
                detectedTgtLang = 'es-ES'; // Default target
                console.warn(`No valid language pairs found in TBX entries. Defaulting glossary languages to ${detectedSrcLang}/${detectedTgtLang}.`);
                if (newGlossary.length > 0) {
                     showMessageBox(translations[currentUILanguage]["No valid language pairs found in TBX. Defaulting to en-US/es-ES."]);
                }
            }

            saveState();
            glossary = newGlossary;
            glossarySourceLanguage = detectedSrcLang;
            glossaryTargetLanguage = detectedTgtLang;

            document.getElementById('configSrcLang').value = glossarySourceLanguage;
            document.getElementById('configTgtLang').value = glossaryTargetLanguage;
            document.getElementById('displaySrcLang').value = glossarySourceLanguage;
            document.getElementById('displayTgtLang').value = glossaryTargetLanguage;

            showSection('editorSection');
            renderGlossary();
            console.log("TBX import completed successfully.");

          } catch (error) {
            console.error("Error during TBX file processing:", error);
            showMessageBox(translations[currentUILanguage]["Error loading TBX file. Please ensure it's a valid XML/TBX."]);
          }
        };
        reader.readAsText(file);
        event.target.value = ''; // Clear the file input
      };
    }

    /**
     * Displays a simple message box to the user.
     * @param {string} message - The message to display.
     */
    function showMessageBox(message) {
      const existingMessageBox = document.querySelector('.message-box');
      if (existingMessageBox) {
        existingMessageBox.remove();
      }

      const messageBox = document.createElement('div');
      messageBox.className = 'message-box';

      const titleEl = document.createElement('h3');
      titleEl.textContent = title;

      const messageText = document.createElement('p');
      messageText.textContent = message;
      messageText.style.marginBottom = '20px';

      const closeButton = document.createElement('button');
      closeButton.textContent = 'OK';
      closeButton.className = 'btn-primary';
      closeButton.onclick = () => document.body.removeChild(messageBox);

      messageBox.appendChild(messageText);
      messageBox.appendChild(closeButton);
      document.body.appendChild(messageBox);
    }

    /**
     * Displays a confirmation dialog to the user.
     * @param {string} title - The title of the dialog.
     * @param {string} message - The message to display.
     * @param {function} onConfirm - Callback function to execute if confirmed.
     */
    function showConfirmationDialog(title, message, onConfirm) {
      const existingMessageBox = document.querySelector('.message-box');
      if (existingMessageBox) {
        existingMessageBox.remove();
      }

      const messageBox = document.createElement('div');
      messageBox.className = 'message-box';

      const titleEl = document.createElement('h3');
      titleEl.textContent = title;

      const messageText = document.createElement('p');
      messageText.textContent = message;

      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'dialog-buttons';

      const confirmButton = document.createElement('button');
      confirmButton.textContent = translations[currentUILanguage]['confirm_button'] || 'Confirm';
      confirmButton.className = 'btn-danger';
      confirmButton.onclick = () => {
        onConfirm();
        document.body.removeChild(messageBox);
      };

      const cancelButton = document.createElement('button');
      cancelButton.textContent = translations[currentUILanguage]['cancel_button'] || 'Cancel';
      cancelButton.className = 'btn-secondary';
      cancelButton.onclick = () => document.body.removeChild(messageBox);

      buttonContainer.appendChild(cancelButton);
      buttonContainer.appendChild(confirmButton);

      messageBox.appendChild(titleEl);
      messageBox.appendChild(messageText);
      messageBox.appendChild(buttonContainer);
      document.body.appendChild(messageBox);
    }

    /**
     * Displays an input dialog to the user.
     * @param {string} title - The title of the dialog.
     * @param {string} message - An optional message to display.
     * @param {string} placeholder - The placeholder text for the input field.
     * @param {function} onConfirm - Callback function with the input value if confirmed.
     */
    function showInputDialog(title, message, placeholder, onConfirm) {
      const existingMessageBox = document.querySelector('.message-box');
      if (existingMessageBox) {
        existingMessageBox.remove();
      }

      const messageBox = document.createElement('div');
      messageBox.className = 'message-box';

      const titleEl = document.createElement('h3');
      titleEl.textContent = title;

      const input = document.createElement('input');
      input.type = 'text';
      input.placeholder = placeholder;
      input.style.width = '100%';
      input.style.padding = '10px';
      input.style.boxSizing = 'border-box';
      input.style.marginTop = '10px';
      input.style.borderRadius = '8px';
      input.style.border = '1px solid var(--input-border)';
      input.style.backgroundColor = 'var(--card-background)';
      input.style.color = 'var(--text-color)';

      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'dialog-buttons';

      const confirmButton = document.createElement('button');
      confirmButton.textContent = translations[currentUILanguage]['save_button'] || 'Save';
      confirmButton.className = 'btn-primary';
      confirmButton.onclick = () => {
        const filename = input.value.trim();
        if (filename) {
          onConfirm(filename);
          document.body.removeChild(messageBox);
        }
      };

      const cancelButton = document.createElement('button');
      cancelButton.textContent = translations[currentUILanguage]['cancel_button'] || 'Cancel';
      cancelButton.className = 'btn-secondary';
      cancelButton.onclick = () => document.body.removeChild(messageBox);

      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          confirmButton.click();
        }
      });

      buttonContainer.appendChild(cancelButton);
      buttonContainer.appendChild(confirmButton);

      messageBox.appendChild(titleEl);
      if (message) {
          const messageText = document.createElement('p');
          messageText.textContent = message;
          messageBox.appendChild(messageText);
      }
      messageBox.appendChild(input);
      messageBox.appendChild(buttonContainer);
      document.body.appendChild(messageBox);
      input.focus();
    }

    document.addEventListener('DOMContentLoaded', () => {
      // Set initial language if not already set
      if (!localStorage.getItem('language')) {
        localStorage.setItem('language', 'en');
        currentUILanguage = 'en';
      }
      // Apply theme and language
      applyTheme(currentTheme);
      setUILanguage(currentUILanguage);
      // Populate language list for inputs
      populateIsoLanguagesDatalist();
      // Start with the initial configuration screen
      showSection('languageConfigSection');
      // Set initial state for undo button
      updateUndoButtonState();

      // Add key listeners for adding terms
      document.getElementById('srcTerm').addEventListener('keypress', (e) => { if (e.key === 'Enter') document.getElementById('tgtTerm').focus(); });
      document.getElementById('tgtTerm').addEventListener('keypress', (e) => { if (e.key === 'Enter') document.getElementById('definition').focus(); });
      document.getElementById('definition').addEventListener('keypress', (e) => { if (e.key === 'Enter') document.getElementById('notes').focus(); });
      document.getElementById('notes').addEventListener('keypress', (e) => { if (e.key === 'Enter') addTerm(); });

      // Add undo shortcut
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key.toLowerCase() === 'z') {
          e.preventDefault(); // Prevent browser's default undo action
          undo();
        }
      });
    });
  </script>
</body>
</html>
