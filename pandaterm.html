<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title data-i18n="title">PandaTerm</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Brand Colors */
      --primary-color: #7DCEC7; /* Mint Green */
      --primary-hover-color: #6cbdb5;
      --text-color-dark: #373737; /* Dark Grey */
      --background-color-light: #f7f9fb;
      --card-background-light: #ffffff;
      --border-color-light: #e0e0e0;
      --header-text-light: #ffffff;

      /* Light mode theme */
      --background-color: var(--background-color-light);
      --text-color: var(--text-color-dark);
      --card-background: var(--card-background-light);
      --border-color: var(--border-color-light);
      --header-bg: var(--primary-color);
      --header-text: var(--header-text-light);
      --btn-primary-bg: var(--primary-color);
      --btn-primary-hover-bg: var(--primary-hover-color);
      --btn-primary-text-color: var(--header-text-light);
      --btn-secondary-bg: #e9eef2;
      --btn-secondary-hover-bg: #dbe1e6;
      --btn-secondary-text-color: var(--text-color-dark);
      --btn-danger-bg: #f44336;
      --btn-danger-hover-bg: #da190b;
      --input-border: #dce1e7;
      --info-box-bg: rgba(125, 206, 199, 0.1);
      --info-box-border: rgba(125, 206, 199, 0.3);
    }

    body.dark-mode {
      /* Dark mode theme */
      --background-color: #1a1a1a;
      --text-color: #e0e0e0;
      --card-background: #252525;
      --border-color: #3a3a3a;
      --header-bg: var(--text-color-dark);
      --header-text: var(--primary-color);
      --btn-primary-bg: var(--primary-color);
      --btn-primary-hover-bg: var(--primary-hover-color);
      --btn-primary-text-color: var(--text-color-dark);
      --btn-secondary-bg: #3a3a3a;
      --btn-secondary-hover-bg: #4a4a4a;
      --btn-secondary-text-color: #ffffff;
      --input-border: #4a4a4a;
      --info-box-bg: rgba(125, 206, 199, 0.1);
      --info-box-border: rgba(125, 206, 199, 0.2);
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes popIn {
        0% { transform: scale(0.9); opacity: 0; }
        70% { transform: scale(1.02); opacity: 1; }
        100% { transform: scale(1); opacity: 1; }
    }

    .row-pop-in {
        animation: popIn 0.3s ease-out forwards;
    }

    body {
      font-family: 'Montserrat', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--background-color);
      background-image: linear-gradient(180deg, rgba(255,255,255,0) 0%, var(--background-color) 300px);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      position: relative;
    }

    .lang-switcher-container {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }

    .logo-container {
      width: 100%;
      text-align: center;
      margin-top: 40px;
      margin-bottom: 10px;
      animation: fadeIn 0.5s ease-out forwards;
    }

    .logo {
      max-width: 220px; 
      height: auto;
      cursor: pointer;
      transition: transform 0.3s ease-out, filter 0.3s ease-out;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.05));
    }

    .logo:hover {
      transform: scale(1.05); 
    }

    body.dark-mode .logo {
      filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.6)); 
    }

    body.dark-mode .logo:hover {
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.8)); 
    }

    .description {
        text-align: center;
        margin-bottom: 30px;
        color: var(--text-color);
        font-size: 1.1rem;
        opacity: 0;
        animation: fadeIn 0.5s ease-out 0.2s forwards;
    }

    .container {
      width: 90%;
      max-width: 1400px;
      padding: 30px;
      background-color: var(--card-background);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.08);
      margin-bottom: 20px;
      opacity: 0;
      animation: fadeIn 0.5s ease-out 0.4s forwards;
    }

    .controls, .search-section {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 20px;
    }

    .controls {
        align-items: center;
    }

    .controls button,
    .search-section input {
      padding: 12px 20px;
      border: 1px solid var(--input-border);
      border-radius: 8px;
      font-size: 1rem;
      color: var(--text-color);
      min-width: 150px;
      flex-grow: 1;
      box-sizing: border-box;
      transition: all 0.2s ease;
      font-family: 'Montserrat', sans-serif;
      background-color: var(--card-background);
    }

    .add-term input,
    .add-term textarea,
    .add-term select,
    .modal-content .input-group input,
    .modal-content .input-group textarea,
    .modal-content .input-group select {
        padding: 12px 20px;
        border: 1px solid var(--input-border);
        border-radius: 8px;
        font-size: 1rem;
        color: var(--text-color);
        flex-grow: 1;
        box-sizing: border-box;
        transition: all 0.2s ease;
        font-family: 'Montserrat', sans-serif;
        background-color: var(--card-background);
        height: 50px; 
    }

    .add-term {
        display: flex;
        flex-direction: column; 
        gap: 20px; 
        transition: max-height 0.4s ease-out, opacity 0.3s ease-out, margin 0.4s ease-out;
        max-height: 0;
        opacity: 0;
        overflow: hidden;
        margin-top: 0;
        margin-bottom: 0; 
    }
    .add-term.open {
        max-height: 1500px; 
        opacity: 1;
        margin-top: 20px;
        margin-bottom: 20px; 
    }

    .add-term-row {
        display: flex;
        flex-wrap: wrap; 
        gap: 20px; 
        align-items: flex-start; 
        width: 100%; 
        box-sizing: border-box;
    }

    .add-term-row .input-group {
        flex: 1 1 calc(50% - 10px); 
        min-width: 150px; 
        display: flex; 
        flex-direction: column; 
    }

    .add-term-row button {
        flex: 1 1 calc(50% - 10px); 
        min-width: 150px; 
        height: 50px; 
        align-self: flex-end; 
    }

    .add-term textarea,
    .modal-content .input-group textarea {
        resize: both; 
        min-height: 80px; 
        height: auto; 
        min-width: 100%; 
        width: 100%; 
    }

    .lang-display {
        display: flex;
        flex-wrap: wrap;
        gap: 15px; 
        align-items: flex-end; 
    }
    
    #currentLangContent {
        transition: max-height 0.4s ease-out, opacity 0.3s ease-out, margin 0.4s ease-out;
        max-height: 0;
        opacity: 0;
        overflow: hidden;
        margin-top: 0;
        margin-bottom: 0;
    }
    #currentLangContent.open {
         max-height: 1000px;
         opacity: 1;
         margin-top: 20px;
         margin-bottom: 20px;
    }

    .lang-display .input-group {
        flex: 1 1 calc(50% - 7.5px); 
        min-width: 150px; 
        display: flex; 
        flex-direction: column; 
    }

    .lang-display .input-group input {
        width: 100%;
        min-width: unset; 
        height: 50px; 
        padding: 12px 20px; 
        border: 1px solid var(--input-border); 
        border-radius: 8px; 
        background-color: var(--card-background); 
        color: var(--text-color); 
        box-sizing: border-box; 
    }

    .lang-display button {
        flex: 1 1 100%; 
        min-width: unset; 
        padding: 12px 20px; 
        font-size: 1rem; 
    }

    .lang-display .input-group label {
        display: block; 
        margin-bottom: 8px; 
        font-size: 0.9rem;
        color: var(--text-color);
    }

    input:focus, select:focus, textarea:focus { 
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(125, 206, 199, 0.3);
    }

    button {
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      font-weight: 600;
      transition: all 0.2s ease-out;
    }

    button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    button:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .btn-primary {
      background-color: var(--btn-primary-bg);
      color: var(--btn-primary-text-color);
    }
    .btn-primary:hover {
      background-color: var(--btn-primary-hover-bg);
    }

    .btn-secondary {
      background-color: var(--btn-secondary-bg);
      color: var(--btn-secondary-text-color);
    }
    .btn-secondary:hover {
      background-color: var(--btn-secondary-hover-bg);
    }

    .lang-btn {
        background-color: var(--card-background);
        border: 1px solid var(--border-color);
        color: var(--text-color);
        min-width: 50px;
        flex-grow: 0;
        padding: 8px 12px;
    }

    .lang-btn.active {
        background-color: var(--primary-color);
        color: var(--btn-primary-text-color);
        border-color: var(--primary-color);
    }

    .btn-danger {
      background-color: var(--btn-danger-bg);
      color: white;
    }
    .btn-danger:hover {
      background-color: var(--btn-danger-hover-bg);
    }

    .delete-btn {
      background-color: var(--btn-danger-bg);
      color: white;
    }
    .delete-btn:hover {
      background-color: var(--btn-danger-hover-bg);
    }

    button:disabled {
      background-color: #cccccc !important;
      cursor: not-allowed;
      color: #6c757d !important;
      transform: none;
      box-shadow: none;
    }

    input[type="file"] {
      display: none;
    }

    label {
      font-weight: 500;
      margin-right: 5px;
      white-space: nowrap;
      display: block; 
      font-size: 0.9rem;
      color: var(--text-color);
    }

    .required-asterisk {
        color: var(--btn-danger-bg); 
        margin-left: 4px;
        font-size: 1.1em;
        vertical-align: middle;
    }

    input:disabled {
      background-color: #e9ecef;
      color: #6c757d;
    }

    body.dark-mode input:disabled {
      background-color: #3a3a3a;
      color: #888;
    }

    .table-container {
      max-height: 80vh; 
      overflow-y: auto;
      overflow-x: auto; 
      border-radius: 8px;
      margin-top: 20px;
      border: 1px solid var(--border-color);
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    table {
      width: 100%;
      min-width: 900px; 
      border-collapse: collapse;
      background-color: var(--card-background);
    }

    th, td {
      border-bottom: 1px solid var(--border-color);
      padding: 14px 16px;
      text-align: left;
      vertical-align: top; 
    }

    th:nth-child(1), td:nth-child(1) { min-width: 150px; } 
    th:nth-child(2), td:nth-child(2) { min-width: 150px; } 
    th:nth-child(3), td:nth-child(3) { min-width: 250px; } 
    th:nth-child(4), td:nth-child(4) { min-width: 200px; } 
    th:nth-child(5), td:nth-child(5) { min-width: 120px; } 
    th:nth-child(6), td:nth-child(6) { width: 80px; } 

    td {
        color: var(--text-color);
    }

    th {
      background-color: var(--card-background);
      color: var(--text-color);
      font-weight: 600;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      position: sticky;
      top: 0;
      z-index: 10; 
    }

    body.dark-mode th {
        background-color: #303030;
    }

    tr:last-child td {
        border-bottom: none;
    }

    tr:hover {
      background-color: rgba(125, 206, 199, 0.07);
    }

    h2 {
        font-weight: 600;
        margin-bottom: 10px; 
        padding-bottom: 10px;
        border-bottom: 1px solid var(--border-color);
        color: var(--text-color);
    }
    
    .collapsible-header {
        cursor: pointer;
        position: relative;
        user-select: none;
        padding-right: 30px; 
        margin-bottom: 10px; 
    }
    .collapsible-header .arrow {
        position: absolute;
        right: 10px;
        top: calc(50% - 1px); 
        transform: translateY(-50%) rotate(0deg); 
        transition: transform 0.3s ease;
        font-size: 1.2rem;
        font-weight: 600;
    }
    .collapsible-header.open .arrow {
        transform: translateY(-50%) rotate(90deg); 
    }


    .message-box {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: var(--card-background);
      padding: 20px 30px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      z-index: 1000;
      text-align: center;
      max-width: 400px;
      color: var(--text-color);
      border-top: 4px solid var(--primary-color);
      animation: popIn 0.3s ease-out;
    }

    .message-box h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-weight: 600;
    }

    .message-box .dialog-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 20px;
    }

    .info-box {
      background-color: var(--info-box-bg);
      border: 1px solid var(--info-box-border);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      color: var(--text-color);
    }

    #languageConfigSection, #editorSection {
        transition: opacity 0.4s ease-out, transform 0.4s ease-out, max-height 0.4s ease-out;
        overflow: hidden;
        max-height: 1000px; 
    }

    .hidden-section {
        opacity: 0;
        transform: translateY(10px);
        max-height: 0 !important;
        margin-bottom: 0;
        pointer-events: none;
    }

    td.editable {
        cursor: pointer;
        position: relative;
    }

    td.editable:hover {
        background-color: rgba(125, 206, 199, 0.15);
    }

    td.editable input[type="text"],
    td.editable textarea,
    td.editable select {
        width: calc(100% - 10px); 
        padding: 5px;
        border: 1px solid var(--primary-color);
        border-radius: 4px;
        background-color: var(--card-background);
        color: var(--text-color);
        font-family: 'Montserrat', sans-serif;
        box-sizing: border-box;
        resize: vertical; 
        min-height: 30px; 
    }

    td.editable input[type="text"]:focus,
    td.editable textarea:focus,
    td.editable select:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(125, 206, 199, 0.5);
    }

    .search-options {
        display: flex;
        gap: 15px;
        align-items: center;
        margin-top: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap; 
    }

    .search-options label {
        display: flex;
        align-items: center;
        gap: 5px;
        margin-bottom: 0; 
        font-size: 1rem;
        font-weight: 400;
    }

    .search-options input[type="radio"] {
        width: auto;
        min-width: unset;
        margin-right: 5px;
        cursor: pointer;
    }

    /* Modal styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1001;
        animation: fadeIn 0.3s ease-out;
    }

    .modal-content {
        background-color: var(--card-background);
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        max-width: 500px;
        width: 90%;
        animation: popIn 0.3s ease-out;
        position: relative;
    }

    .modal-content.large-modal {
        max-width: 800px;
    }

    .modal-content h3 {
        margin-top: 0;
        margin-bottom: 20px;
        font-weight: 600;
        color: var(--text-color);
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 10px;
    }

    .modal-content .input-group {
        margin-bottom: 15px;
    }

    .modal-content .input-group label {
        margin-bottom: 5px;
        font-weight: 500;
    }

    .modal-content .input-group input,
    .modal-content .input-group textarea,
    .modal-content .input-group select {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--input-border);
        border-radius: 8px;
        background-color: var(--card-background);
        color: var(--text-color);
        font-family: 'Montserrat', sans-serif;
        box-sizing: border-box;
    }

    /* Code editor specific styles */
    .code-editor {
        font-family: 'Consolas', 'Monaco', monospace !important;
        font-size: 0.9rem !important;
        line-height: 1.4;
        white-space: pre;
        min-height: 300px !important;
        background-color: var(--background-color-light);
    }
    
    body.dark-mode .code-editor {
        background-color: #303030;
    }

    .validation-status {
        margin-top: 5px;
        font-size: 0.9rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 5px;
        height: 24px;
    }
    
    .status-valid {
        color: #4CAF50;
    }
    
    .status-invalid {
        color: #f44336;
    }

    .modal-content .input-group textarea {
        min-height: 80px;
        resize: vertical;
    }

    .modal-content .dialog-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 25px;
    }

    .modal-content .dialog-buttons button { 
        height: 50px; 
        padding: 12px 20px; 
        font-size: 1rem; 
        border-radius: 8px; 
    }

    .close-modal-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        background: none;
        border: none;
        font-size: 1.5rem;
        color: var(--text-color);
        cursor: pointer;
        padding: 5px;
        border-radius: 50%;
        transition: background-color 0.2s;
    }

    .close-modal-btn:hover {
        background-color: rgba(0,0,0,0.1);
    }

    td a {
        color: var(--primary-color);
        text-decoration: underline;
    }

    td a:hover {
        text-decoration: none;
    }

    .column-visibility-menu {
        display: none; 
    }

    #toastContainer { 
        position: fixed;
        bottom: 20px;
        left: 20px;
        z-index: 2000;
        display: flex;
        flex-direction: column; 
        gap: 10px;
        max-width: 350px;
    }

    .toast-notification {
      position: relative; 
      width: 100%;
      box-sizing: border-box;
      transform: translateX(-120%); 
      background-color: var(--text-color-dark);
      color: var(--background-color-light);
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-weight: 500;
      opacity: 0;
      transition: opacity 0.4s ease-out, transform 0.4s ease-out;
    }

    .toast-notification.show {
      transform: translateX(0); 
      opacity: 1;
    }

    body.dark-mode .toast-notification {
       background-color: var(--background-color-light);
       color: var(--text-color-dark);
    }

  </style>
</head>
<body>
  <div class="lang-switcher-container">
    <button id="langBtnEN" onclick="setUILanguage('en')" class="lang-btn">EN</button>
    <button id="langBtnES" onclick="setUILanguage('es')" class="lang-btn">ES</button>
  </div>
  <div class="logo-container">
    <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/pandaterm-logo.png" alt="PandaTerm Logo" class="logo" />
  </div>
  <p class="description" data-i18n="app_description"></p>


  <div class="container">
    <div class="controls">
      <button onclick="resetGlossary()" data-i18n="new_glossary" class="btn-secondary">Nuevo glosario</button>
      
      <button onclick="document.getElementById('fileInput').click()" data-i18n="import_button" class="btn-secondary">Importar</button>
      <input type="file" id="fileInput" accept=".xml,.tbx,.csv" />

      <button onclick="showImportCodeDialog()" data-i18n="import_code_button" class="btn-secondary">Importar código</button>
      
      <button onclick="showExportDialog()" data-i18n="export_button" class="btn-secondary">Exportar</button>
      
      <button onclick="toggleTheme()" id="themeToggleButton" data-i18n="toggle_theme" class="btn-secondary">Cambiar tema</button>
      <button onclick="undo()" id="undoButton" data-i18n="undo_button" class="btn-secondary" disabled>Deshacer</button>
    </div>
    <div id="languageConfigSection">
      <h2 data-i18n="config_lang_title">Configurar idiomas del glosario</h2>
      <div class="info-box">
        <p data-i18n="config_lang_info">
          Define los idiomas de origen y destino de tu glosario. Puedes introducir el código ISO directamente o seleccionarlo de las sugerencias. Es fundamental que el código ISO sea correcto para que funcione correctamente con tu herramienta TAO.
        </p>
      </div>
      <div class="lang-display">
        <div class="input-group">
          <label for="configSrcLang" data-i18n="source_language">Idioma de origen:</label>
          <input id="configSrcLang" list="isoLanguages" value="en-US" />
        </div>
        <div class="input-group">
          <label for="configTgtLang" data-i18n="target_language">Idioma de destino:</label>
          <input id="configTgtLang" list="isoLanguages" value="es-ES" />
        </div>
        <button onclick="confirmGlossaryLanguages()" data-i18n="confirm_languages" class="btn-primary">Confirmar idiomas</button>
      </div>
    </div>

    <div id="editorSection" class="hidden-section">
        <h2 data-i18n="current_lang_title" class="collapsible-header" onclick="toggleCollapse('currentLangContent')">Idiomas actuales del glosario<span class="arrow">►</span></h2>
        <div class="lang-display" id="currentLangContent">
            <div class="input-group">
                <label data-i18n="source_language">Idioma de origen:</label>
                <input id="displaySrcLang" disabled />
            </div>
            <div class="input-group">
                <label data-i18n="target_language">Idioma de destino:</label>
                <input id="displayTgtLang" disabled />
            </div>
        </div>
        <h2 data-i18n="add_term_title" class="collapsible-header" onclick="toggleCollapse('addTermContent')">Añadir término<span class="arrow">►</span></h2>
        <div class="add-term" id="addTermContent">
            <div class="add-term-row">
                <div class="input-group">
                    <label for="srcTerm" data-i18n="term">Término:<span class="required-asterisk">*</span></label>
                    <input id="srcTerm" />
                </div>
                <div class="input-group">
                    <label for="tgtTerm" data-i18n="translation">Traducción:<span class="required-asterisk">*</span></label>
                    <input id="tgtTerm" />
                </div>
            </div>

            <div class="add-term-row">
                <div class="input-group" id="definitionInputGroup">
                    <label for="definition"><span data-i18n="definition">Definición:</span></label>
                    <textarea id="definition"></textarea>
                </div>
                <div class="input-group" id="notesInputGroup">
                    <label for="notes"><span data-i18n="notes">Notas:</span></label>
                    <textarea id="notes"></textarea>
                </div>
            </div>

            <div class="add-term-row">
                <div class="input-group" id="partOfSpeechInputGroup">
                    <label for="partOfSpeech"><span data-i18n="part_of_speech">Categoría gramatical:</span></label>
                    <select id="partOfSpeech">
                        <option value="" data-i18n="select_pos_placeholder">Seleccionar</option>
                        <option value="noun">noun</option>
                        <option value="verb">verb</option>
                        <option value="adj">adj</option>
                        <option value="adv">adv</option>
                    </select>
                </div>
                <button onclick="addTerm()" data-i18n="add_button" class="btn-primary">Añadir</button>
            </div>
        </div>
        <h2 data-i18n="search_title">Buscar</h2>
        <div class="search-section">
            <input id="searchTerm" placeholder="Buscar término..." oninput="renderGlossary()" data-i18n-placeholder="search_placeholder" />
            <div class="search-options">
                <label>
                    <input type="radio" name="searchScope" value="all" checked onchange="renderGlossary()">
                    <span data-i18n="search_all">Todos</span>
                </label>
                <label>
                    <input type="radio" name="searchScope" value="source" onchange="renderGlossary()">
                    <span data-i18n="search_source">Solo origen</span>
                </label>
                <label>
                    <input type="radio" name="searchScope" value="target" onchange="renderGlossary()">
                    <span data-i18n="search_target">Solo destino</span>
                </label>
            </div>
        </div>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th data-i18n="source_term_col" data-column-id="source_term_col">Término de origen</th>
                        <th data-i18n="target_term_col" data-column-id="target_term_col">Término de destino</th>
                        <th data-i18n="definition_col" data-column-id="definition_col">Definición</th>
                        <th data-i18n="notes_col" data-column-id="notes_col">Notas</th>
                        <th data-i18n="part_of_speech_col" data-column-id="part_of_speech_col">Categoría gramatical</th>
                        <th data-i18n="actions_col" data-column-id="actions_col">Acciones</th>
                    </tr>
                </thead>
                <tbody id="glossaryTable"></tbody>
            </table>
        </div>
    </div>

    <datalist id="isoLanguages">
      </datalist>
  </div>
  
  <div id="toastContainer"></div>

  <script>
    // Global array to store glossary terms
    let glossary = [];
    // Action history for undo functionality
    let history = [];
    // Get current UI language from local storage, default to English
    let currentUILanguage = localStorage.getItem('language') || 'en';
    // Get current theme from local storage, default to light
    let currentTheme = localStorage.getItem('theme') || 'light';

    // Global variables to store the glossary's defined source and target languages
    let glossarySourceLanguage = '';
    let glossaryTargetLanguage = '';

    // Column visibility state - now always true as the toggle button is removed
    let columnVisibility = {
        'source_term_col': true,
        'target_term_col': true,
        'definition_col': true,
        'notes_col': true,
        'part_of_speech_col': true,
        'actions_col': true
    };

    const translations = {
      en: {
        title: "PandaTerm",
        main_title: "PandaTerm",
        app_description: "A simple TBX/CSV glossary editor",
        import_button: "Import File",
        import_code_button: "Import Code", 
        export_button: "Export", 
        new_glossary: "New glossary",
        toggle_theme: "Toggle theme",
        undo_button: "Undo",
        config_lang_title: "Configure glossary languages",
        config_lang_info: "Define the source and target languages for your glossary. You can type the ISO code directly or select from the suggestions. It is important that the ISO code is correct for it to work well in your CAT tool.",
        confirm_languages: "Confirm languages",
        current_lang_title: "Current glossary languages",
        add_term_title: "Add term",
        source_language: "Source language:",
        term: "Term:",
        target_language: "Translation:",
        translation: "Translation:",
        definition: "Definition:",
        notes: "Notes:",
        part_of_speech: "Part of Speech:",
        add_button: "Add",
        search_title: "Search",
        search_placeholder: "Search term...",
        search_all: "All",
        search_source: "Source only",
        search_target: "Target only",
        source_term_col: "Source term",
        target_term_col: "Target term",
        definition_col: "Definition",
        notes_col: "Notes",
        part_of_speech_col: "Part of Speech",
        actions_col: "Actions",
        delete_button: "Delete",
        edit_button: "Edit",
        both_terms_required: "Both term and translation are required.",
        lang_config_required: "Please configure source and target languages for the glossary.",
        "Cannot download empty or unconfigured glossary.": "Cannot download empty or unconfigured glossary.",
        "No valid language pairs found in TBX. Defaulting to en-US/es-ES.": "No valid language pairs found in TBX. Defaulting to en-US/es-ES.",
        "Error loading TBX file. Please ensure it's a valid XML/TBX.": "Error loading TBX file. Please ensure it's a valid XML/TBX.",
        new_glossary_confirm_title: "Confirm New Glossary",
        new_glossary_confirm_text: "All current glossary data will be lost. If you don't want to lose it, click cancel and export it as a TBX file. Click confirm to create a new glossary from scratch.",
        confirm_button: "Confirm",
        cancel_button: "Cancel",
        download_dialog_title: "Enter filename", 
        download_dialog_placeholder: "glossary", 
        save_button: "Save",
        edit_term_title: "Edit Term",
        update_button: "Update",
        select_pos_placeholder: "Select",
        show_more_fields: "Show more fields",
        hide_more_fields: "Hide fields",
        delete_term_confirm_title: "Confirm Delete",
        delete_term_confirm_text: "Are you sure you want to delete this term? This action cannot be undone.",
        "backup_restored": "Your previous work has been restored.",
        "backup_corrupt": "Could not restore backup. It may be corrupt. Starting new session.",
        "backup_confirm_title": "Restore Session?",
        "backup_confirm_text": "We found a previous session with {count} terms. Would you like to restore it?",
        "backup_confirm_button": "Restore",
        "backup_discard_button": "Discard",
        "export_dialog_title": "Export Glossary",
        "export_filename": "Filename:",
        "export_format": "Format:",
        "export_action_button": "Export",
        "csv_import_success": "Imported {count} new terms.",
        "csv_import_no_terms": "No new terms found to import.",
        "csv_import_error": "Error loading CSV file. Please ensure it's a valid file.",
        "csv_header_error": "The CSV must have headers like \"Source Term\" and \"Target Term\", or \"{srcLang}\" and \"{tgtLang}\".",
        "csv_empty_error": "The CSV is empty or has no headers.",
        "unsupported_file_error": "Unsupported file type. Please select a .tbx, .xml, or .csv file.",
        "tbx_import_success": "Imported {count} new terms from TBX.",
        // Import code translations
        "import_code_title": "Import TBX Code",
        "paste_code_here": "Paste your XML/TBX code here...",
        "import_action_button": "Import Code",
        "valid_xml": "✓ Valid XML Structure",
        "invalid_xml": "⚠ Invalid XML"
      },
      es: {
        title: "PandaTerm",
        main_title: "PandaTerm",
        app_description: "Un sencillo editor de glosarios TBX/CSV",
        import_button: "Importar archivo", 
        import_code_button: "Importar código",
        export_button: "Exportar", 
        new_glossary: "Nuevo glosario",
        toggle_theme: "Cambiar tema",
        undo_button: "Deshacer",
        config_lang_title: "Configurar idiomas del glosario",
        config_lang_info: "Define los idiomas de origen y destino de tu glosario. Puedes introducir el código ISO directamente o seleccionarlo de las sugerencias. Es fundamental que el código ISO sea correcto para que funcione correctamente con tu herramienta TAO.",
        confirm_languages: "Confirmar idiomas",
        current_lang_title: "Idiomas actuales del glosario",
        add_term_title: "Añadir término",
        source_language: "Idioma de origen:",
        term: "Término:",
        target_language: "Idioma de destino:",
        translation: "Traducción:",
        definition: "Definición:",
        notes: "Notas:",
        part_of_speech: "Categoría gramatical:",
        add_button: "Añadir",
        search_title: "Buscar",
        search_placeholder: "Buscar término...",
        search_all: "Todos",
        search_source: "Solo origen",
        search_target: "Solo destino",
        source_term_col: "Término de origen",
        target_term_col: "Término de destino",
        definition_col: "Definición",
        notes_col: "Notas",
        part_of_speech_col: "Categoría gramatical",
        actions_col: "Acciones",
        delete_button: "Eliminar",
        edit_button: "Editar",
        both_terms_required: "El término y la traducción son obligatorios.",
        lang_config_required: "Por favor, configura los idiomas de origen y destino para el glosario.",
        "Cannot download empty or unconfigured glossary.": "No se puede descargar un glosario vacío o sin configurar.",
        "No valid language pairs found in TBX. Defaulting to en-US/es-ES.": "No se encontraron pares de idioma válidos en TBX. Se utiliza en-US/es-ES por defecto.",
        "Error loading TBX file. Please ensure it's a valid XML/TBX.": "Error al cargar el archivo TBX. Asegúrate de que sea un XML/TBX válido.",
        new_glossary_confirm_title: "Confirmar nuevo glosario",
        new_glossary_confirm_text: "Se perderá toda la información del glosario actual. Si no quieres perderlo, haz clic en cancelar y expórtalo como archivo TBX. Haz clic en confirmar para crear un glosario nuevo desde cero.",
        confirm_button: "Confirmar",
        cancel_button: "Cancelar",
        download_dialog_title: "Introducir nombre de archivo", 
        download_dialog_placeholder: "glosario", 
        save_button: "Guardar",
        edit_term_title: "Editar término",
        update_button: "Actualizar",
        select_pos_placeholder: "Seleccionar",
        show_more_fields: "Mostrar más campos",
        hide_more_fields: "Ocultar campos",
        delete_term_confirm_title: "Confirmar eliminación",
        delete_term_confirm_text: "¿Estás seguro de que quieres eliminar este término? Esta acción no se puede deshacer.",
        "backup_restored": "Se ha restaurado tu trabajo anterior.",
        "backup_corrupt": "No se pudo restaurar la copia de seguridad. Puede que esté corrupta. Empezando una nueva sesión.",
        "backup_confirm_title": "¿Restaurar sesión?",
        "backup_confirm_text": "Encontramos una sesión anterior con {count} términos. ¿Quieres restaurarla?",
        "backup_confirm_button": "Restaurar",
        "backup_discard_button": "Descartar",
        "export_dialog_title": "Exportar Glosario",
        "export_filename": "Nombre de archivo:",
        "export_format": "Formato:",
        "export_action_button": "Exportar",
        "csv_import_success": "Se importaron {count} términos nuevos.",
        "csv_import_no_terms": "No se encontraron términos nuevos para importar.",
        "csv_import_error": "Error al cargar el archivo CSV. Asegúrate de que sea un archivo válido.",
        "csv_header_error": "El CSV debe tener cabeceras como \"Source Term\" y \"Target Term\", o \"{srcLang}\" y \"{tgtLang}\".",
        "csv_empty_error": "El CSV está vacío o no tiene cabeceras.",
        "unsupported_file_error": "Tipo de archivo no compatible. Por favor, selecciona un archivo .tbx, .xml, o .csv.",
        "tbx_import_success": "Se importaron {count} términos nuevos del TBX.",
        // Import code translations
        "import_code_title": "Importar código TBX",
        "paste_code_here": "Pega tu código XML/TBX aquí...",
        "import_action_button": "Importar código",
        "valid_xml": "✓ Estructura XML Válida",
        "invalid_xml": "⚠ XML Inválido"
      }
    };

    const isoLanguagesData = [
      { code: "en", name: "English" }, { code: "en-US", name: "English (United States)" }, { code: "en-GB", name: "English (United Kingdom)" }, { code: "es", name: "Español" }, { code: "es-ES", name: "Español (España)" }, { code: "es-MX", name: "Español (México)" }, { code: "es-AR", name: "Español (Argentina)" }, { code: "fr", name: "Français" }, { code: "de", name: "Deutsch" }, { code: "it", name: "Italiano" }, { code: "pt", name: "Português" }, { code: "ja", name: "日本語 (Japanese)" }, { code: "zh", name: "中文 (Chinese)" }, { code: "ar", name: "العربية (Arabic)" }, { code: "ru", name: "Русский (Russian)" }, { code: "ko", name: "한국어 (Korean)" }, { code: "nl", name: "Nederlands" }, { code: "sv", name: "Svenska" }, { code: "da", name: "Dansk" }, { code: "no", name: "Norsk" }, { code: "fi", name: "Suomi" }, { code: "tr", name: "Türkçe" }, { code: "pl", "name": "Polski" }, { code: "ca", name: "Català" }, { code: "eu", name: "Euskara" }, { code: "gl", name: "Galego" }
    ];

    /**
     * Populates the datalist with ISO language codes and names.
     */
    function populateIsoLanguagesDatalist() {
      const datalist = document.getElementById('isoLanguages');
      datalist.innerHTML = '';
      isoLanguagesData.forEach(lang => {
        const option = document.createElement('option');
        option.value = lang.code;
        option.textContent = lang.name;
        datalist.appendChild(option);
      });
    }

    /**
     * Applies the selected theme (light or dark) to the body.
     * @param {string} theme - The theme to apply ('light' or 'dark').
     */
    function applyTheme(theme) {
      document.body.className = theme === 'dark' ? 'dark-mode' : '';
      currentTheme = theme;
      localStorage.setItem('theme', theme);
    }

    /**
     * Toggles between light and dark themes.
     */
    function toggleTheme() {
      applyTheme(currentTheme === 'light' ? 'dark' : 'light');
    }

    /**
     * Sets the UI language and updates all translatable text.
     * @param {string} lang - The language code ('en' or 'es').
     */
    function setUILanguage(lang) {
      currentUILanguage = lang;
      localStorage.setItem('language', lang);
      updateTextContent();
      updateLanguageButtons();
    }

    /**
     * Updates the active state of language switcher buttons.
     */
    function updateLanguageButtons() {
        document.getElementById('langBtnEN').classList.toggle('active', currentUILanguage === 'en');
        document.getElementById('langBtnES').classList.toggle('active', currentUILanguage === 'es');
    }

    /**
     * Updates all elements with `data-i18n` and `data-i18n-placeholder` attributes
     * to the current UI language.
     */
    function updateTextContent() {
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (translations[currentUILanguage][key]) {
          // Si el elemento es un header colapsable, preserva la flecha
          if (el.classList.contains('collapsible-header')) {
            const arrow = el.querySelector('.arrow');
            el.textContent = translations[currentUILanguage][key];
            if (arrow) {
              el.appendChild(arrow);
            }
          } else {
            el.textContent = translations[currentUILanguage][key];
          }
        }
      });

      document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if (translations[currentUILanguage][key]) {
          el.placeholder = translations[currentUILanguage][key];
        }
      });
      // Update placeholder for partOfSpeech select
      const selectPosPlaceholder = document.querySelector('#partOfSpeech option[value=""]');
      if (selectPosPlaceholder) {
          selectPosPlaceholder.textContent = translations[currentUILanguage]['select_pos_placeholder'];
      }

      renderGlossary(); // Re-render glossary to update delete button text
    }

    /**
     * Shows a specific section of the application and hides others.
     * @param {string} sectionId - The ID of the section to show.
     */
    function showSection(sectionId) {
        const sectionToShow = document.getElementById(sectionId);
        const sectionToHide = sectionId === 'editorSection' ? document.getElementById('languageConfigSection') : document.getElementById('editorSection');

        sectionToHide.classList.add('hidden-section');
        sectionToShow.classList.remove('hidden-section');
    }

    /**
     * Updates the disabled state of the undo button based on history.
     */
    function updateUndoButtonState() {
      const undoButton = document.getElementById('undoButton');
      if(undoButton) {
        undoButton.disabled = history.length === 0;
      }
    }

    /**
     * Saves the current state of the glossary to the history for undo functionality.
     */
    function saveState() {
      // Save a deep copy of the current glossary state
      history.push(JSON.parse(JSON.stringify(glossary)));
      updateUndoButtonState();
    }

    /**
     * Undoes the last action by restoring the previous glossary state from history.
     */
    function undo() {
      if (history.length > 0) {
        glossary = history.pop();
        renderGlossary();
        updateUndoButtonState();
        saveBackupToLocalStorage(); 
      }
    }
    
    /**
     * Alterna la visibilidad de una sección colapsable.
     * @param {string} contentId - El ID del elemento de contenido a colapsar/expandir.
     */
    function toggleCollapse(contentId) {
        const content = document.getElementById(contentId);
        const header = content.previousElementSibling; // Obtiene el h2
        if (content.classList.contains('open')) {
            content.classList.remove('open');
            header.classList.remove('open');
        } else {
            content.classList.add('open');
            header.classList.add('open');
        }
    }

    /**
     * Performs the actual reset of the glossary after confirmation.
     */
    function performResetGlossary() {
      saveState();
      glossary = [];
      glossarySourceLanguage = '';
      glossaryTargetLanguage = '';
      document.getElementById('configSrcLang').value = 'en-US';
      document.getElementById('configTgtLang').value = 'es-ES';
      document.getElementById('srcTerm').value = '';
      document.getElementById('tgtTerm').value = '';
      document.getElementById('definition').value = ''; 
      document.getElementById('notes').value = ''; 
      document.getElementById('partOfSpeech').value = ''; 
      document.getElementById('searchTerm').value = '';
      // Reset search scope to 'all'
      document.querySelector('input[name="searchScope"][value="all"]').checked = true;
      
      // Cerrar secciones colapsables
      document.getElementById('currentLangContent').classList.remove('open');
      document.getElementById('currentLangContent').previousElementSibling.classList.remove('open');
      document.getElementById('addTermContent').classList.remove('open');
      document.getElementById('addTermContent').previousElementSibling.classList.remove('open');

      showSection('languageConfigSection');
      renderGlossary();
      saveBackupToLocalStorage(); 
    }

    /**
     * Prompts the user for confirmation before resetting the glossary.
     */
    function resetGlossary() {
      const title = translations[currentUILanguage]['new_glossary_confirm_title'];
      const message = translations[currentUILanguage]['new_glossary_confirm_text'];
      showConfirmationDialog(title, message, performResetGlossary, null, null, null, 'btn-danger');
    }

    /**
     * Confirms and sets the glossary's source and target languages.
     */
    function confirmGlossaryLanguages() {
      const srcLang = document.getElementById('configSrcLang').value.trim();
      const tgtLang = document.getElementById('configTgtLang').value.trim();

      if (!srcLang || !tgtLang) {
        showMessageBox(translations[currentUILanguage]['lang_config_required']);
        return;
      }

      glossarySourceLanguage = srcLang;
      glossaryTargetLanguage = tgtLang;
      document.getElementById('displaySrcLang').value = glossarySourceLanguage;
      document.getElementById('displayTgtLang').value = glossaryTargetLanguage;
      showSection('editorSection');
      renderGlossary();
      
      // Abrir la sección de añadir término por defecto al confirmar
      toggleCollapse('addTermContent');

      // Clear history when starting a new glossary configuration
      history = [];
      updateUndoButtonState();
      saveBackupToLocalStorage(); 
    }

    /**
     * Adds a new term to the glossary.
     */
    function addTerm() {
      const srcTermInput = document.getElementById("srcTerm");
      const tgtTermInput = document.getElementById("tgtTerm");
      const definitionInput = document.getElementById("definition");
      const notesInput = document.getElementById("notes");
      const partOfSpeechInput = document.getElementById("partOfSpeech");

      const srcTerm = srcTermInput.value.trim();
      const tgtTerm = tgtTermInput.value.trim();
      const definition = definitionInput.value.trim();
      const notes = notesInput.value.trim();
      const partOfSpeech = partOfSpeechInput.value.trim();

      if (!srcTerm || !tgtTerm) {
        showMessageBox(translations[currentUILanguage]['both_terms_required']);
        return;
      }

      saveState();

      glossary.push({
        srcLang: glossarySourceLanguage,
        srcTerm: srcTerm,
        tgtLang: glossaryTargetLanguage,
        tgtTerm: tgtTerm,
        definition: definition,
        notes: notes,
        srcPartOfSpeech: partOfSpeech
      });
      srcTermInput.value = "";
      tgtTermInput.value = "";
      definitionInput.value = "";
      notesInput.value = "";
      partOfSpeechInput.value = "";
      srcTermInput.focus();
      renderGlossary(true); // Pass true to animate the last row
      saveBackupToLocalStorage(); 
    }

    /**
     * Deletes a term from the glossary by its original index.
     * @param {number} originalIndex - The original index of the term in the glossary array.
     */
    function deleteTerm(originalIndex) {
        const title = translations[currentUILanguage]['delete_term_confirm_title'];
        const message = translations[currentUILanguage]['delete_term_confirm_text'];
        
        const performDelete = () => {
            saveState();
            glossary.splice(originalIndex, 1);
            renderGlossary();
            closeModal('editModal'); // Close modal if open after deleting
            saveBackupToLocalStorage(); 
        };
        
        showConfirmationDialog(title, message, performDelete, null, null, null, 'btn-danger');
    }

    /**
     * Opens a modal to edit an existing term.
     * @param {number} index - The index of the term in the glossary array.
     */
    function editTerm(index) {
        const term = glossary[index];
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'modal-overlay';
        modalOverlay.id = 'editModal';

        const posOptions = ['noun', 'verb', 'adj', 'adv'].map(pos =>
            `<option value="${pos}" ${term.srcPartOfSpeech === pos ? 'selected' : ''}>${pos}</option>`
        ).join('');

        modalOverlay.innerHTML = `
            <div class="modal-content">
                <button class="close-modal-btn" onclick="closeModal('editModal')">&times;</button>
                <h3 data-i18n="edit_term_title">${translations[currentUILanguage]['edit_term_title']}</h3>
                <div class="input-group">
                    <label for="editSrcTerm" data-i18n="term">${translations[currentUILanguage]['term']}<span class="required-asterisk">*</span></label>
                    <input id="editSrcTerm" type="text" value="${term.srcTerm}" />
                </div>
                <div class="input-group">
                    <label for="editTgtTerm" data-i18n="translation">${translations[currentUILanguage]['translation']}<span class="required-asterisk">*</span></label>
                    <input id="editTgtTerm" type="text" value="${term.tgtTerm}" />
                </div>
                <div class="input-group">
                    <label for="editDefinition" data-i18n="definition">${translations[currentUILanguage]['definition']}</label>
                    <textarea id="editDefinition">${term.definition || ''}</textarea>
                </div>
                <div class="input-group">
                    <label for="editNotes" data-i18n="notes">${translations[currentUILanguage]['notes']}</label>
                    <textarea id="editNotes">${term.notes || ''}</textarea>
                </div>
                <div class="input-group">
                    <label for="editPartOfSpeech" data-i18n="part_of_speech">${translations[currentUILanguage]['part_of_speech']}</label>
                    <select id="editPartOfSpeech">
                        <option value="" data-i18n="select_pos_placeholder">${translations[currentUILanguage]['select_pos_placeholder']}</option>
                        ${posOptions}
                    </select>
                </div>
                <div class="dialog-buttons">
                    <button class="btn-danger" onclick="deleteTerm(${index})" data-i18n="delete_button">${translations[currentUILanguage]['delete_button']}</button>
                    <button class="btn-secondary" onclick="closeModal('editModal')" data-i18n="cancel_button">${translations[currentUILanguage]['cancel_button']}</button>
                    <button class="btn-primary" onclick="saveEditedTerm(${index})" data-i18n="update_button">${translations[currentUILanguage]['update_button']}</button>
                </div>
            </div>
        `;
        document.body.appendChild(modalOverlay);
    }

    /**
     * Saves the changes made to a term in the edit modal.
     * @param {number} index - The index of the term in the glossary array.
     */
    function saveEditedTerm(index) {
        const srcTerm = document.getElementById('editSrcTerm').value.trim();
        const tgtTerm = document.getElementById('editTgtTerm').value.trim();
        const definition = document.getElementById('editDefinition').value.trim();
        const notes = document.getElementById('editNotes').value.trim();
        const partOfSpeech = document.getElementById('editPartOfSpeech').value.trim();

        if (!srcTerm || !tgtTerm) {
            showMessageBox(translations[currentUILanguage]['both_terms_required']);
            return;
        }

        saveState(); // Save state before modification

        glossary[index].srcTerm = srcTerm;
        glossary[index].tgtTerm = tgtTerm;
        glossary[index].definition = definition;
        glossary[index].notes = notes;
        glossary[index].srcPartOfSpeech = partOfSpeech;

        closeModal('editModal');
        renderGlossary();
        saveBackupToLocalStorage(); 
    }

    /**
     * Closes a modal dialog.
     * @param {string} modalId - The ID of the modal overlay to close.
     */
    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.remove();
        }
    }

    /**
     * Formats text to make URLs clickable.
     * @param {string} text - The input text.
     * @returns {string} The text with URLs replaced by clickable links.
     */
    function formatTextWithLinks(text) {
        if (!text) return '';
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        return text.replace(urlRegex, (url) => `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`);
    }

    /**
     * Applies the current column visibility settings to the table.
     */
    function applyColumnVisibility() {
        const table = document.querySelector('table');
        if (!table) return;

        const headers = Array.from(table.querySelectorAll('th'));
        const rows = Array.from(table.querySelectorAll('tbody tr'));

        headers.forEach((th, index) => {
            th.style.display = '';
            rows.forEach(row => {
                const cell = row.children[index];
                if (cell) {
                    cell.style.display = '';
                }
            });
        });
    }

    /**
     * Renders the glossary table based on current search and filter criteria.
     * @param {boolean} animateLastRow - Whether to apply animation to the last added row.
     */
    function renderGlossary(animateLastRow = false) {
      const tbody = document.getElementById("glossaryTable");
      const search = document.getElementById("searchTerm").value.toLowerCase();
      const searchScope = document.querySelector('input[name="searchScope"]:checked').value;
      tbody.innerHTML = "";

      const filteredGlossary = glossary.filter(entry => {
        const srcMatch = entry.srcTerm.toLowerCase().includes(search);
        const tgtMatch = entry.tgtTerm.toLowerCase().includes(search);
        const defMatch = (entry.definition || '').toLowerCase().includes(search);
        const notesMatch = (entry.notes || '').toLowerCase().includes(search);
        const posMatch = (entry.srcPartOfSpeech || '').toLowerCase().includes(search);

        if (searchScope === 'source') {
          return srcMatch;
        } else if (searchScope === 'target') {
          return tgtMatch;
        } else { // 'all'
          return srcMatch || tgtMatch || defMatch || notesMatch || posMatch;
        }
      });

      filteredGlossary.forEach((entry, i) => {
          const originalIndex = glossary.findIndex(g => g === entry);
          const row = document.createElement("tr");
          row.innerHTML = `
            <td class="editable" onclick="editTerm(${originalIndex})">${entry.srcTerm}</td>
            <td class="editable" onclick="editTerm(${originalIndex})">${entry.tgtTerm}</td>
            <td class="editable" onclick="editTerm(${originalIndex})">${formatTextWithLinks(entry.definition)}</td>
            <td class="editable" onclick="editTerm(${originalIndex})">${formatTextWithLinks(entry.notes)}</td>
            <td class="editable" onclick="editTerm(${originalIndex})">${entry.srcPartOfSpeech || ''}</td>
            <td><button class="delete-btn" onclick="deleteTerm(${originalIndex})">${translations[currentUILanguage]['delete_button']}</button></td>
          `;

          if (animateLastRow && i === filteredGlossary.length - 1) {
              row.classList.add('row-pop-in');
          }

          tbody.appendChild(row);
      });
      applyColumnVisibility(); // Apply visibility after rendering
    }

    // ===============================================
    // === LÓGICA DE EXPORTACIÓN (TBX Y CSV) =======
    // ===============================================

    function showExportDialog() {
      if (glossary.length === 0 || !glossarySourceLanguage || !glossaryTargetLanguage) {
        showMessageBox(translations[currentUILanguage]["Cannot download empty or unconfigured glossary."]);
        return;
      }

      const modalOverlay = document.createElement('div');
      modalOverlay.className = 'modal-overlay';
      modalOverlay.id = 'exportModal';

      modalOverlay.innerHTML = `
        <div class="modal-content">
          <button class="close-modal-btn" onclick="closeModal('exportModal')">&times;</button>
          <h3 data-i18n="export_dialog_title">${translations[currentUILanguage]['export_dialog_title']}</h3>
          
          <div class="input-group">
            <label for="exportFilename" data-i18n="export_filename">${translations[currentUILanguage]['export_filename']}</label>
            <input id="exportFilename" type="text" value="${translations[currentUILanguage]['download_dialog_placeholder']}" />
          </div>
          
          <div class="input-group">
            <label data-i18n="export_format">${translations[currentUILanguage]['export_format']}</label>
            <div class="search-options" style="margin-top: 5px; margin-bottom: 0; justify-content: flex-start; gap: 25px;">
              <label>
                <input type="radio" name="exportFormat" value="tbx" checked>
                <span>TBX</span>
              </label>
              <label>
                <input type="radio" name="exportFormat" value="csv">
                <span>CSV</span>
              </label>
            </div>
          </div>

          <div class="dialog-buttons">
            <button class="btn-secondary" onclick="closeModal('exportModal')" data-i18n="cancel_button">${translations[currentUILanguage]['cancel_button']}</button>
            <button class="btn-primary" onclick="performExport()" data-i18n="export_action_button">${translations[currentUILanguage]['export_action_button']}</button>
          </div>
        </div>
      `;
      document.body.appendChild(modalOverlay);
      
      const filenameInput = document.getElementById('exportFilename');
      filenameInput.focus();
      filenameInput.select(); 
    }

    function performExport() {
      const filename = document.getElementById('exportFilename').value.trim() || translations[currentUILanguage]['download_dialog_placeholder'];
      const format = document.querySelector('input[name="exportFormat"]:checked').value;

      if (format === 'tbx') {
        generateAndDownloadTBX(filename);
      } else if (format === 'csv') {
        generateAndDownloadCSV(filename);
      }

      closeModal('exportModal');
    }

    function generateTBX() {
      const xml = [`<?xml version="1.0" encoding="UTF-8"?>`,
        `<martif type="TBX" xml:lang="${glossarySourceLanguage}">`,
        `  <text>`,
        `    <body>`];

      glossary.forEach(entry => {
        xml.push(`      <termEntry>`);
        xml.push(`        <LangSet xml:lang="${entry.srcLang || glossarySourceLanguage}">`);
        xml.push(`          <tig>`);
        xml.push(`            <term>${entry.srcTerm}</term>`);
        if (entry.srcPartOfSpeech) {
            xml.push(`            <termNote type="partOfSpeech">${entry.srcPartOfSpeech}</termNote>`);
        }
        xml.push(`          </tig>`);
        xml.push(`        </LangSet>`);
        xml.push(`        <LangSet xml:lang="${entry.tgtLang || glossaryTargetLanguage}">`);
        xml.push(`          <tig>`);
        xml.push(`            <term>${entry.tgtTerm}</term>`);
        if (entry.definition) {
            xml.push(`            <descrip type="definition">${entry.definition}</descrip>`);
        }
        if (entry.notes) {
            xml.push(`            <termNote type="comment">${entry.notes}</termNote>`);
        }
        xml.push(`          </tig>`);
        xml.push(`        </LangSet>`);
        xml.push(`      </termEntry>`);
      });

      xml.push(`    </body>`, `  </text>`, `</martif>`);
      return xml.join("\n");
    }

    function generateAndDownloadTBX(filename) {
      const blob = new Blob([generateTBX()], { type: "application/xml" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename.endsWith('.tbx') ? filename : `${filename}.tbx`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function escapeCSV(field) {
      if (field === null || field === undefined) {
        return '""';
      }
      const str = String(field);
      const escaped = str.replace(/"/g, '""'); 
      if (str.includes('"') || str.includes(';') || str.includes('\n') || str.includes('\r')) {
        return `"${escaped}"`;
      }
      return escaped; 
    }

    function generateAndDownloadCSV(filename) {
      const headers = [
        "Source Language", "Source Term", "Target Language", "Target Term",
        "Definition", "Notes", "Part of Speech"
      ];
      let csvContent = headers.join(";") + "\n"; 

      glossary.forEach(entry => {
        const row = [
          entry.srcLang || glossarySourceLanguage,
          entry.srcTerm,
          entry.tgtLang || glossaryTargetLanguage,
          entry.tgtTerm,
          entry.definition || '',
          entry.notes || '',
          entry.srcPartOfSpeech || ''
        ];
        csvContent += row.map(escapeCSV).join(";") + "\n";
      });

      const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
      const blob = new Blob([bom, csvContent], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename.endsWith('.csv') ? filename : `${filename}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }

    // ===============================================
    // === LÓGICA DE IMPORTACIÓN (TBX Y CSV) =======
    // ===============================================

    /**
     * Shared logic to parse XML content and import into glossary
     * @param {string} xmlString - The raw XML content
     */
    function parseAndImportTBXString(xmlString) {
        try {
            console.log("Parsing TBX content...");
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");

            const parserError = xmlDoc.querySelector("parsererror");
            if (parserError) {
                const errorText = parserError.textContent || "Unknown XML parsing error.";
                throw new Error(`Parsing error: The content is not a valid XML/TBX. Details: ${errorText.substring(0, 100)}...`);
            }
            
            let entryTagName, langSetTagName, termGroupTagName, rootElement;

            if (xmlDoc.getElementsByTagName("martif").length > 0) {
                rootElement = "martif";
                entryTagName = "termEntry";
                langSetTagName = "LangSet";
                termGroupTagName = "tig";
            } else if (xmlDoc.getElementsByTagName("tbx").length > 0) {
                rootElement = "tbx";
                entryTagName = "conceptEntry";
                langSetTagName = "langSec";
                termGroupTagName = "termSec";
            } else {
                throw new Error("Unsupported TBX root element. Expected <martif> or <tbx>.");
            }

            const entries = xmlDoc.getElementsByTagName(entryTagName);
            const newGlossary = [];
            const langCounts = {}; 

            for (let i = 0; i < entries.length; i++) {
              const entry = entries[i];
              const langSets = entry.getElementsByTagName(langSetTagName);
              let conceptDefinition = '';
              let conceptNotes = '';

              if (rootElement === "tbx") {
                  const conceptDefinitionElement = entry.querySelector('descrip[type="definition"]');
                  const conceptNotesElement = entry.querySelector('note');
                  conceptDefinition = conceptDefinitionElement ? conceptDefinitionElement.textContent || '' : '';
                  conceptNotes = conceptNotesElement ? conceptNotesElement.textContent || '' : '';
              }

              if (langSets.length >= 2) {
                let srcLang = '', srcTerm = '', srcPartOfSpeech = '';
                let tgtLang = '', tgtTerm = '', tgtPartOfSpeech = '';
                let entryDefinition = conceptDefinition;
                let entryNotes = conceptNotes;

                const firstLangSet = langSets[0];
                srcLang = firstLangSet.getAttribute("xml:lang") || '';
                const firstTermGroup = firstLangSet.getElementsByTagName(termGroupTagName)[0];
                if (firstTermGroup) {
                    srcTerm = firstTermGroup.getElementsByTagName("term")[0]?.textContent || '';
                    let minPartOfSpeechElement = firstTermGroup.getElementsByTagNameNS("http://www.tbxinfo.net/ns/min", "partOfSpeech")[0];
                    if (minPartOfSpeechElement) {
                        srcPartOfSpeech = minPartOfSpeechElement.textContent || '';
                    } else {
                        srcPartOfSpeech = firstTermGroup.querySelector('termNote[type="partOfSpeech"]')?.textContent || '';
                    }
                }

                const secondLangSet = langSets[1];
                tgtLang = secondLangSet.getAttribute("xml:lang") || '';
                const secondTermGroup = secondLangSet.getElementsByTagName(termGroupTagName)[0];
                if (secondTermGroup) {
                    tgtTerm = secondTermGroup.getElementsByTagName("term")[0]?.textContent || '';
                    let minPartOfSpeechElement = secondTermGroup.getElementsByTagNameNS("http://www.tbxinfo.net/ns/min", "partOfSpeech")[0];
                    if (minPartOfSpeechElement) {
                        tgtPartOfSpeech = minPartOfSpeechElement.textContent || '';
                    } else {
                        tgtPartOfSpeech = secondTermGroup.querySelector('termNote[type="partOfSpeech"]')?.textContent || '';
                    }

                    const termGroupDefinitionElement = secondTermGroup.querySelector('descrip[type="definition"]');
                    const termGroupNotesElement = secondTermGroup.querySelector('termNote[type="comment"]');
                    const termGroupContextElement = secondTermGroup.querySelector('descrip[type="context"]');

                    if (termGroupDefinitionElement) {
                        entryDefinition = termGroupDefinitionElement.textContent || '';
                    } else if (termGroupContextElement) {
                        entryDefinition = termGroupContextElement.textContent || '';
                    }

                    if (termGroupNotesElement) {
                        entryNotes = termGroupNotesElement.textContent || '';
                    }
                }

                if (srcTerm || tgtTerm) {
                    newGlossary.push({
                        srcLang: srcLang, srcTerm: srcTerm, srcPartOfSpeech: srcPartOfSpeech,
                        tgtLang: tgtLang, tgtTerm: tgtTerm, tgtPartOfSpeech: tgtPartOfSpeech,
                        definition: entryDefinition, notes: entryNotes
                    });
                    langCounts[srcLang] = (langCounts[srcLang] || 0) + 1;
                    langCounts[tgtLang] = (langCounts[tgtLang] || 0) + 1;
                }
              }
            }

            const sortedLangs = Object.keys(langCounts).sort((a, b) => langCounts[b] - langCounts[a]);
            let detectedSrcLang, detectedTgtLang;

            if (sortedLangs.length >= 2) {
                detectedSrcLang = sortedLangs[0];
                detectedTgtLang = sortedLangs[1];
                newGlossary.forEach(entry => {
                    if (entry.srcLang !== detectedSrcLang && entry.tgtLang === detectedSrcLang) {
                        [entry.srcLang, entry.tgtLang] = [entry.tgtLang, entry.srcLang];
                        [entry.srcTerm, entry.tgtTerm] = [entry.tgtTerm, entry.srcTerm];
                        [entry.srcPartOfSpeech, entry.tgtPartOfSpeech] = [entry.tgtPartOfSpeech, entry.srcPartOfSpeech];
                    }
                });
            } else {
                const rootXmlLang = xmlDoc.documentElement.getAttribute("xml:lang");
                detectedSrcLang = rootXmlLang || 'en-US';
                detectedTgtLang = 'es-ES';
                if (newGlossary.length > 0) {
                     showMessageBox(translations[currentUILanguage]["No valid language pairs found in TBX. Defaulting to en-US/es-ES."]);
                }
            }

            saveState();
            glossary = newGlossary;
            glossarySourceLanguage = detectedSrcLang;
            glossaryTargetLanguage = detectedTgtLang;

            document.getElementById('configSrcLang').value = glossarySourceLanguage;
            document.getElementById('configTgtLang').value = glossaryTargetLanguage;
            document.getElementById('displaySrcLang').value = glossarySourceLanguage;
            document.getElementById('displayTgtLang').value = glossaryTargetLanguage;

            showSection('editorSection');
            renderGlossary();
            saveBackupToLocalStorage(); 
            
            let successMsg = translations[currentUILanguage]['tbx_import_success'] || "Imported {count} new terms from TBX.";
            showToast(successMsg.replace('{count}', newGlossary.length));
            console.log("TBX import completed successfully.");

          } catch (error) {
            console.error("Error during TBX file processing:", error);
            showMessageBox(translations[currentUILanguage]["Error loading TBX file. Please ensure it's a valid XML/TBX."] + " " + error.message);
          }
    }

    function readTBXFile(file) {
        const reader = new FileReader();
        reader.onload = () => {
            parseAndImportTBXString(reader.result);
        };
        reader.readAsText(file);
    }

    function readCSVFile(file) {
      const reader = new FileReader();
      reader.onload = () => {
        try {
          console.log("Cargando CSV...");
          parseCSV(reader.result);
        } catch (error) {
          console.error("Error durante el procesamiento del archivo CSV:", error);
          showMessageBox(error.message); 
        }
      };
      reader.readAsText(file, "UTF-8"); 
    }

    function parseCSVRow(row, delimiter) {
      const fields = [];
      let inQuote = false;
      let field = '';

      for (let i = 0; i < row.length; i++) {
        const char = row[i];
        
        if (char === '"') {
          if (inQuote && row[i+1] === '"') {
            field += '"';
            i++; 
          } else {
            inQuote = !inQuote;
          }
        } else if (char === delimiter && !inQuote) {
          fields.push(field);
          field = '';
        } else {
          field += char;
        }
      }
      
      fields.push(field); 
      
      return fields.map(f => {
          if (f.startsWith('"') && f.endsWith('"')) {
              return f.substring(1, f.length - 1).replace(/""/g, '"');
          }
          return f;
      });
    }

    function parseCSV(textContent) {
      const newGlossary = [];
      const lines = textContent.split(/\r?\n/);

      if (lines.length < 2 || !lines[0].trim()) {
        throw new Error(translations[currentUILanguage]['csv_empty_error']);
      }

      const delimiter = lines[0].includes(';') ? ';' : ',';
      
      const headers = parseCSVRow(lines[0], delimiter); 

      const map = {
        srcTerm: headers.indexOf("Source Term"),
        tgtTerm: headers.indexOf("Target Term"),
        definition: headers.indexOf("Definition"),
        notes: headers.indexOf("Notes"),
        partOfSpeech: headers.indexOf("Part of Speech")
      };

      if (map.srcTerm === -1 || map.tgtTerm === -1) {
          map.srcTerm = headers.indexOf(glossarySourceLanguage);
          map.tgtTerm = headers.indexOf(glossaryTargetLanguage);
          
          if (map.srcTerm === -1 || map.tgtTerm === -1) {
            let errorMsg = translations[currentUILanguage]['csv_header_error'];
            errorMsg = errorMsg.replace('{srcLang}', glossarySourceLanguage).replace('{tgtLang}', glossaryTargetLanguage);
            throw new Error(errorMsg);
          }
      }

      for (let i = 1; i < lines.length; i++) {
        if (!lines[i].trim()) continue; 

        const values = parseCSVRow(lines[i], delimiter);

        const srcTerm = values[map.srcTerm] || '';
        const tgtTerm = values[map.tgtTerm] || '';

        if (srcTerm && tgtTerm) {
          newGlossary.push({
            srcLang: glossarySourceLanguage,
            srcTerm: srcTerm,
            tgtLang: glossaryTargetLanguage,
            tgtTerm: tgtTerm,
            definition: (map.definition > -1 ? values[map.definition] : '') || '',
            notes: (map.notes > -1 ? values[map.notes] : '') || '',
            srcPartOfSpeech: (map.partOfSpeech > -1 ? values[map.partOfSpeech] : '') || ''
          });
        }
      }

      if (newGlossary.length > 0) {
        saveState(); 
        glossary = glossary.concat(newGlossary);
        renderGlossary();
        saveBackupToLocalStorage(); 
        let successMsg = translations[currentUILanguage]['csv_import_success'];
        showToast(successMsg.replace('{count}', newGlossary.length));
      } else {
        showToast(translations[currentUILanguage]['csv_import_no_terms']);
      }
    }

    // ===============================================
    // === LÓGICA DE DIÁLOGOS Y MENSAJES ===========
    // ===============================================

    function showMessageBox(message) {
      const existingMessageBox = document.querySelector('.message-box');
      if (existingMessageBox) {
        existingMessageBox.remove();
      }

      const messageBox = document.createElement('div');
      messageBox.className = 'message-box';

      const titleEl = document.createElement('h3');
      titleEl.textContent = translations[currentUILanguage]['title']; 

      const messageText = document.createElement('p');
      messageText.textContent = message;
      messageText.style.marginBottom = '20px';

      const closeButton = document.createElement('button');
      closeButton.textContent = 'OK';
      closeButton.className = 'btn-primary';
      closeButton.onclick = () => document.body.removeChild(messageBox);

      messageBox.appendChild(titleEl);
      messageBox.appendChild(messageText);
      messageBox.appendChild(closeButton);
      document.body.appendChild(messageBox);
    }

    function showConfirmationDialog(title, message, onConfirm, onCancelCallback = null, confirmText = null, cancelText = null, confirmClass = 'btn-danger') {
      const existingMessageBox = document.querySelector('.message-box');
      if (existingMessageBox) {
        existingMessageBox.remove();
      }

      const messageBox = document.createElement('div');
      messageBox.className = 'message-box';

      const titleEl = document.createElement('h3');
      titleEl.textContent = title;

      const messageText = document.createElement('p');
      messageText.textContent = message;

      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'dialog-buttons';

      const confirmButton = document.createElement('button');
      confirmButton.textContent = confirmText || translations[currentUILanguage]['confirm_button'] || 'Confirm';
      confirmButton.className = confirmClass; 
      confirmButton.onclick = () => {
        onConfirm();
        document.body.removeChild(messageBox);
      };

      const cancelButton = document.createElement('button');
      cancelButton.textContent = cancelText || translations[currentUILanguage]['cancel_button'] || 'Cancel';
      cancelButton.className = 'btn-secondary';
      cancelButton.onclick = () => {
        if (onCancelCallback) onCancelCallback(); 
        document.body.removeChild(messageBox);
      };

      buttonContainer.appendChild(cancelButton);
      buttonContainer.appendChild(confirmButton);

      messageBox.appendChild(titleEl);
      messageBox.appendChild(messageText);
      messageBox.appendChild(buttonContainer);
      document.body.appendChild(messageBox);
    }

    // ===============================================
    // === NUEVA LÓGICA DE IMPORTACIÓN DE CÓDIGO ===
    // ===============================================

    function showImportCodeDialog() {
        if (!glossarySourceLanguage || !glossaryTargetLanguage) {
            showMessageBox(translations[currentUILanguage]['lang_config_required']);
            showSection('languageConfigSection');
            return;
        }

        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'modal-overlay';
        modalOverlay.id = 'importCodeModal';

        modalOverlay.innerHTML = `
            <div class="modal-content large-modal">
                <button class="close-modal-btn" onclick="closeModal('importCodeModal')">&times;</button>
                <h3 data-i18n="import_code_title">${translations[currentUILanguage]['import_code_title']}</h3>
                <div class="input-group">
                    <label data-i18n="paste_code_here">${translations[currentUILanguage]['paste_code_here']}</label>
                    <textarea id="tbCodeInput" class="code-editor" spellcheck="false" placeholder="<martif..."></textarea>
                    <div id="codeValidationStatus" class="validation-status"></div>
                </div>
                <div class="dialog-buttons">
                    <button class="btn-secondary" onclick="closeModal('importCodeModal')" data-i18n="cancel_button">${translations[currentUILanguage]['cancel_button']}</button>
                    <button id="btnConfirmImportCode" class="btn-primary" onclick="importFromCode()" data-i18n="import_action_button" disabled>${translations[currentUILanguage]['import_action_button']}</button>
                </div>
            </div>
        `;
        document.body.appendChild(modalOverlay);

        const textarea = document.getElementById('tbCodeInput');
        textarea.focus();
        
        // Add real-time validation listener
        textarea.addEventListener('input', checkCodeValidity);
    }

    function checkCodeValidity() {
        const code = document.getElementById('tbCodeInput').value.trim();
        const statusDiv = document.getElementById('codeValidationStatus');
        const confirmBtn = document.getElementById('btnConfirmImportCode');

        if (!code) {
            statusDiv.innerHTML = '';
            confirmBtn.disabled = true;
            return;
        }

        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(code, "application/xml");
            const parserError = xmlDoc.querySelector("parsererror");

            if (parserError) {
                statusDiv.innerHTML = `<span class="status-invalid">${translations[currentUILanguage]['invalid_xml']}</span>`;
                confirmBtn.disabled = true;
            } else {
                // Check if it has TBX root elements
                if (xmlDoc.getElementsByTagName("martif").length > 0 || xmlDoc.getElementsByTagName("tbx").length > 0) {
                     statusDiv.innerHTML = `<span class="status-valid">${translations[currentUILanguage]['valid_xml']}</span>`;
                     confirmBtn.disabled = false;
                } else {
                     statusDiv.innerHTML = `<span class="status-invalid">XML valid but no Martif/TBX root found</span>`;
                     confirmBtn.disabled = true;
                }
            }
        } catch (e) {
            statusDiv.innerHTML = `<span class="status-invalid">${translations[currentUILanguage]['invalid_xml']}</span>`;
            confirmBtn.disabled = true;
        }
    }

    function importFromCode() {
        const code = document.getElementById('tbCodeInput').value;
        closeModal('importCodeModal');
        parseAndImportTBXString(code);
    }


    // ===============================================
    // === FUNCIONES DE BACKUP Y CARGA INICIAL =====
    // ===============================================

    function showToast(message) {
      const container = document.getElementById('toastContainer');
      if (!container) {
          console.error('Toast container not found!');
          return;
      }
      const toast = document.createElement('div');
      toast.className = 'toast-notification';
      toast.textContent = message;
      
      container.appendChild(toast); 
      
      setTimeout(() => { 
        toast.classList.add('show');
      }, 10); 

      setTimeout(() => { 
        toast.classList.remove('show');
        setTimeout(() => { 
          if (toast.parentNode === container) {
             container.removeChild(toast);
          }
        }, 500); 
      }, 4000); 
    }


    function saveBackupToLocalStorage() {
      try {
        const backupData = {
          glossary: glossary,
          sourceLang: glossarySourceLanguage,
          targetLang: glossaryTargetLanguage
        };
        localStorage.setItem('pandaTermBackup', JSON.stringify(backupData));
        console.log('Backup guardado en localStorage.');
      } catch (e) {
        console.error('Error al guardar el backup en localStorage:', e);
      }
    }

    function loadBackupFromLocalStorage() {
      try {
        const backupString = localStorage.getItem('pandaTermBackup');
        if (!backupString) {
          return { success: false, data: null, error: 'nobackup' };
        }
        const backupData = JSON.parse(backupString);
        if (backupData && backupData.glossary && backupData.sourceLang && backupData.targetLang) {
          console.log('Backup data found.');
          return { success: true, data: backupData, error: null };
        } else {
          console.warn('Backup en localStorage corrupto o incompleto.');
          return { success: false, data: null, error: 'corrupt' };
        }
      } catch (e) {
        console.error('Error al cargar o parsear el backup de localStorage:', e);
        return { success: false, data: null, error: 'corrupt' };
      }
    }

    // ===============================================
    // === INICIALIZACIÓN DE LA APLICACIÓN =========
    // ===============================================

    document.addEventListener('DOMContentLoaded', () => {
      // 1. Configurar idioma de la UI
      if (!localStorage.getItem('language')) {
        localStorage.setItem('language', 'en');
        currentUILanguage = 'en';
      }
      
      // 2. Aplicar tema e idioma (NECESARIO ANTES for a la lógica de backup)
      applyTheme(currentTheme);
      setUILanguage(currentUILanguage); 

      // 3. Intentar cargar backup (MODIFICADO)
      const backupResult = loadBackupFromLocalStorage();
      
      // 4. Poblar datalist de idiomas
      populateIsoLanguagesDatalist();

      // 5. Decidir qué pantalla mostrar (LÓGICA DE CONFIRMACIÓN DE BACKUP)
      if (backupResult.success) {
        // Backup encontrado, PREGUNTAR al usuario
        const backupData = backupResult.data;
        const termCount = backupData.glossary.length;
        
        const title = translations[currentUILanguage]['backup_confirm_title'];
        let message = translations[currentUILanguage]['backup_confirm_text'];
        message = message.replace('{count}', termCount);
        const confirmBtnText = translations[currentUILanguage]['backup_confirm_button'];
        const cancelBtnText = translations[currentUILanguage]['backup_discard_button'];
        
        const restoreAction = () => {
            // Usuario pulsa "Restaurar"
            glossary = backupData.glossary;
            glossarySourceLanguage = backupData.sourceLang;
            glossaryTargetLanguage = backupData.targetLang;
            
            document.getElementById('configSrcLang').value = glossarySourceLanguage;
            document.getElementById('configTgtLang').value = glossaryTargetLanguage;
            document.getElementById('displaySrcLang').value = glossarySourceLanguage;
            document.getElementById('displayTgtLang').value = glossaryTargetLanguage;
            showSection('editorSection'); 
            renderGlossary();
            showToast(translations[currentUILanguage]['backup_restored']);
        };
        
        const discardAction = () => {
            // Usuario pulsa "Descartar"
            localStorage.removeItem('pandaTermBackup');
            showSection('languageConfigSection');
        };
        
        showConfirmationDialog(title, message, restoreAction, discardAction, confirmBtnText, cancelBtnText, 'btn-primary');

      } else {
        // No hay backup o está corrupto
        if (backupResult.error === 'corrupt') {
            localStorage.removeItem('pandaTermBackup');
            console.warn('Se eliminó un backup corrupto de localStorage.');
            showToast(translations[currentUILanguage]['backup_corrupt']);
        }
        // Mostrar la configuración inicial de idioma
        showSection('languageConfigSection');
      }

      // 6. Configurar listeners
      updateUndoButtonState();

      // Listener para el input de archivo (centralizado)
      const fileInput = document.getElementById('fileInput');
      fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) {
          fileInput.value = ''; 
          return;
        }

        if (!glossarySourceLanguage || !glossaryTargetLanguage) {
            showMessageBox(translations[currentUILanguage]['lang_config_required']);
            showSection('languageConfigSection');
            fileInput.value = ''; 
            return;
        }

        const fileName = file.name.toLowerCase();
        if (fileName.endsWith('.tbx') || fileName.endsWith('.xml')) {
          console.log(`Importando TBX: ${file.name}`);
          readTBXFile(file);
        } else if (fileName.endsWith('.csv')) {
          console.log(`Importando CSV: ${file.name}`);
          readCSVFile(file);
        } else {
          console.warn(`Unsupported file type: ${fileName}`);
          showMessageBox(translations[currentUILanguage]['unsupported_file_error']);
        }
        
        fileInput.value = ''; 
      });

      // Listeners de teclado
      document.getElementById('srcTerm').addEventListener('keypress', (e) => { if (e.key === 'Enter') document.getElementById('tgtTerm').focus(); });
      document.getElementById('tgtTerm').addEventListener('keypress', (e) => { if (e.key === 'Enter') document.getElementById('definition').focus(); });
      document.getElementById('definition').addEventListener('keypress', (e) => { if (e.key === 'Enter') document.getElementById('notes').focus(); });
      document.getElementById('notes').addEventListener('keypress', (e) => { if (e.key === 'Enter') document.getElementById('partOfSpeech').focus(); });
      document.getElementById('partOfSpeech').addEventListener('keypress', (e) => { if (e.key === 'Enter') addTerm(); });

      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key.toLowerCase() === 'z') {
          e.preventDefault();
          undo();
        }
      });
      
      applyColumnVisibility();
    });
  </script>
</body>
</html>
