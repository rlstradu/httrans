<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title data-i18n="title">PandaTerm</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Brand Colors */
      --primary-color: #7DCEC7; /* Mint Green */
      --primary-hover-color: #6cbdb5;
      --text-color-dark: #373737; /* Dark Grey */
      --background-color-light: #f7f9fb;
      --card-background-light: #ffffff;
      --border-color-light: #e0e0e0;
      --header-text-light: #ffffff;

      /* Light mode theme */
      --background-color: var(--background-color-light);
      --text-color: var(--text-color-dark);
      --card-background: var(--card-background-light);
      --border-color: var(--border-color-light);
      --header-bg: var(--primary-color);
      --header-text: var(--header-text-light);
      --btn-primary-bg: var(--primary-color);
      --btn-primary-hover-bg: var(--primary-hover-color);
      --btn-primary-text-color: var(--header-text-light);
      --btn-secondary-bg: #e9eef2;
      --btn-secondary-hover-bg: #dbe1e6;
      --btn-secondary-text-color: var(--text-color-dark);
      --btn-danger-bg: #f44336;
      --btn-danger-hover-bg: #da190b;
      --input-border: #dce1e7;
      --info-box-bg: rgba(125, 206, 199, 0.1);
      --info-box-border: rgba(125, 206, 199, 0.3);
    }

    body.dark-mode {
      /* Dark mode theme */
      --background-color: #1a1a1a;
      --text-color: #e0e0e0;
      --card-background: #252525;
      --border-color: #3a3a3a;
      --header-bg: var(--text-color-dark);
      --header-text: var(--primary-color);
      --btn-primary-bg: var(--primary-color);
      --btn-primary-hover-bg: var(--primary-hover-color);
      --btn-primary-text-color: var(--text-color-dark);
      --btn-secondary-bg: #3a3a3a;
      --btn-secondary-hover-bg: #4a4a4a;
      --btn-secondary-text-color: #ffffff;
      --input-border: #4a4a4a;
      --info-box-bg: rgba(125, 206, 199, 0.1);
      --info-box-border: rgba(125, 206, 199, 0.2);
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes popIn {
        0% { transform: scale(0.9); opacity: 0; }
        70% { transform: scale(1.02); opacity: 1; }
        100% { transform: scale(1); opacity: 1; }
    }

    .row-pop-in {
        animation: popIn 0.3s ease-out forwards;
    }

    body {
      font-family: 'Montserrat', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--background-color);
      background-image: linear-gradient(180deg, rgba(255,255,255,0) 0%, var(--background-color) 300px);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      position: relative;
    }

    .lang-switcher-container {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }

    .logo-container {
      width: 100%;
      text-align: center;
      margin-top: 40px;
      margin-bottom: 10px;
      animation: fadeIn 0.5s ease-out forwards;
    }

    .logo {
      max-width: 220px; /* Increased logo size */
      height: auto;
      cursor: pointer;
      transition: transform 0.3s ease-out, filter 0.3s ease-out;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.05));
    }

    .logo:hover {
      transform: scale(1.05); /* Added hover effect */
    }

    body.dark-mode .logo {
      filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.6)); /* Sharper, more intense white halo */
    }

    body.dark-mode .logo:hover {
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.8)); /* Even brighter halo on hover */
    }

    .description {
        text-align: center;
        margin-bottom: 30px;
        color: var(--text-color);
        font-size: 1.1rem;
        opacity: 0;
        animation: fadeIn 0.5s ease-out 0.2s forwards;
    }

    .container {
      width: 90%;
      max-width: 1400px;
      padding: 30px;
      background-color: var(--card-background);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.08);
      margin-bottom: 20px;
      opacity: 0;
      animation: fadeIn 0.5s ease-out 0.4s forwards;
    }

    .controls, .search-section {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 20px;
    }

    .controls {
        align-items: center;
    }

    /* Unified style for all input fields and textareas in add-term and general input groups */
    .controls button,
    .search-section input {
      padding: 12px 20px;
      border: 1px solid var(--input-border);
      border-radius: 8px;
      font-size: 1rem;
      color: var(--text-color);
      min-width: 150px;
      flex-grow: 1;
      box-sizing: border-box;
      transition: all 0.2s ease;
      font-family: 'Montserrat', sans-serif;
      background-color: var(--card-background); /* Ensure background matches */
    }

    .add-term input,
    .add-term textarea,
    .add-term select,
    .modal-content .input-group input,
    .modal-content .input-group textarea,
    .modal-content .input-group select {
        padding: 12px 20px;
        border: 1px solid var(--input-border);
        border-radius: 8px;
        font-size: 1rem;
        color: var(--text-color);
        flex-grow: 1;
        box-sizing: border-box;
        transition: all 0.2s ease;
        font-family: 'Montserrat', sans-serif;
        background-color: var(--card-background);
        height: 50px; /* Fixed height for all input fields in add-term section */
    }

    /* Flex container for add-term section to keep fields in one column of rows */
    .add-term {
        display: flex;
        flex-direction: column; /* Stack rows vertically */
        gap: 20px; /* Increased gap between rows for better spacing */
        margin-bottom: 20px;
    }

    .add-term-row {
        display: flex;
        flex-wrap: wrap; /* Allow wrapping within rows */
        gap: 20px; /* Increased gap between items in a row */
        align-items: flex-start; /* Align items to the top to prevent label overlap */
        width: 100%; /* Ensure rows take full width */
        box-sizing: border-box;
    }

    /* All input groups and buttons within add-term-row should share space equally */
    .add-term-row .input-group {
        flex: 1 1 calc(50% - 10px); /* Each takes 50% of the row, accounting for 20px gap */
        min-width: 150px; /* Ensure a minimum width for responsiveness */
        display: flex; /* Make input-group a flex container */
        flex-direction: column; /* Stack label and input vertically */
    }

    .add-term-row button {
        flex: 1 1 calc(50% - 10px); /* Button takes 50% of the row */
        min-width: 150px; /* Ensure a minimum width for responsiveness */
        height: 50px; /* Ensure button also matches input height */
        align-self: flex-end; /* Align button to the bottom of its row */
    }

    /* Special handling for textareas to allow vertical resizing and proper min-height */
    .add-term textarea,
    .modal-content .input-group textarea {
        resize: both; /* Allow both vertical and horizontal resizing */
        min-height: 80px; /* Increased minimum height for textareas */
        height: auto; /* Allow height to adjust if user resizes */
        min-width: 100%; /* Ensure it doesn't shrink too much horizontally */
        width: 100%; /* Default to 100% width */
    }

    /* Language configuration and display sections */
    .lang-display {
        display: flex;
        flex-wrap: wrap;
        gap: 15px; /* Consistent gap */
        align-items: flex-end; /* Align labels/inputs */
    }

    .lang-display .input-group {
        flex: 1 1 calc(50% - 7.5px); /* Each input group takes half the width */
        min-width: 150px; /* Ensure responsiveness */
        display: flex; /* Make input-group a flex container */
        flex-direction: column; /* Stack label and input vertically */
    }

    /* Ensure inputs inside lang-display .input-group take full width of their parent */
    .lang-display .input-group input {
        width: 100%;
        min-width: unset; /* Override general min-width for these specific inputs */
        height: 50px; /* Consistent height for language inputs */
        padding: 12px 20px; /* Consistent padding */
        border: 1px solid var(--input-border); /* Consistent border */
        border-radius: 8px; /* Consistent border-radius */
        background-color: var(--card-background); /* Consistent background */
        color: var(--text-color); /* Consistent text color */
        box-sizing: border-box; /* Include padding and border in the element's total width and height */
    }

    .lang-display button {
        flex: 1 1 100%; /* Button takes full width on a new line */
        min-width: unset; /* Override general min-width */
        padding: 12px 20px; /* Standard button padding */
        font-size: 1rem; /* Standard font size */
    }

    /* Ensure labels in lang-display also behave well */
    .lang-display .input-group label {
        display: block; /* Ensure label is above input */
        margin-bottom: 8px; /* Increased margin-bottom for labels */
        font-size: 0.9rem;
        color: var(--text-color);
    }


    input:focus, select:focus, textarea:focus { /* Added textarea to focus styles */
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(125, 206, 199, 0.3);
    }

    button {
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      font-weight: 600;
      transition: all 0.2s ease-out;
    }

    button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    button:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    .btn-primary {
      background-color: var(--btn-primary-bg);
      color: var(--btn-primary-text-color);
    }
    .btn-primary:hover {
      background-color: var(--btn-primary-hover-bg);
    }

    .btn-secondary {
      background-color: var(--btn-secondary-bg);
      color: var(--btn-secondary-text-color);
    }
    .btn-secondary:hover {
      background-color: var(--btn-secondary-hover-bg);
    }

    .lang-btn {
        background-color: var(--card-background);
        border: 1px solid var(--border-color);
        color: var(--text-color);
        min-width: 50px;
        flex-grow: 0;
        padding: 8px 12px;
    }

    .lang-btn.active {
        background-color: var(--primary-color);
        color: var(--btn-primary-text-color);
        border-color: var(--primary-color);
    }

    .btn-danger {
      background-color: var(--btn-danger-bg);
      color: white;
    }
    .btn-danger:hover {
      background-color: var(--btn-danger-hover-bg);
    }

    .delete-btn {
      background-color: var(--btn-danger-bg);
      color: white;
    }
    .delete-btn:hover {
      background-color: var(--btn-danger-hover-bg);
    }

    button:disabled {
      background-color: #cccccc !important;
      cursor: not-allowed;
      color: #6c757d !important;
      transform: none;
      box-shadow: none;
    }

    input[type="file"] {
      display: none;
    }

    label {
      font-weight: 500;
      margin-right: 5px;
      white-space: nowrap;
      /* margin-bottom: 4px; Removed as input-group handles it */
      display: block; /* Revert to block for labels without checkboxes */
      font-size: 0.9rem;
      color: var(--text-color);
    }

    .required-asterisk {
        color: var(--btn-danger-bg); /* Red color for asterisk */
        margin-left: 4px;
        font-size: 1.1em;
        vertical-align: middle;
    }

    input:disabled {
      background-color: #e9ecef;
      color: #6c757d;
    }

    body.dark-mode input:disabled {
      background-color: #3a3a3a;
      color: #888;
    }

    .table-container {
      max-height: 80vh; /* Increased max-height for more visible rows */
      overflow-y: auto;
      overflow-x: auto; /* Added horizontal scroll for wide content */
      border-radius: 8px;
      margin-top: 20px;
      border: 1px solid var(--border-color);
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    table {
      width: 100%;
      min-width: 900px; /* Ensure table can expand horizontally, increased from 700px */
      border-collapse: collapse;
      background-color: var(--card-background);
    }

    th, td {
      border-bottom: 1px solid var(--border-color);
      padding: 14px 16px;
      text-align: left;
      vertical-align: top; /* Align content to the top for multi-line text */
    }

    /* Give specific columns a minimum width to ensure content pushes the table wider */
    th:nth-child(1), td:nth-child(1) { min-width: 150px; } /* Source Term */
    th:nth-child(2), td:nth-child(2) { min-width: 150px; } /* Target Term */
    th:nth-child(3), td:nth-child(3) { min-width: 250px; } /* Definition */
    th:nth-child(4), td:nth-child(4) { min-width: 200px; } /* Notes */
    th:nth-child(5), td:nth-child(5) { min-width: 120px; } /* Part of Speech */
    th:nth-child(6), td:nth-child(6) { width: 80px; } /* Actions */


    td {
        color: var(--text-color);
    }

    th {
      background-color: var(--card-background);
      color: var(--text-color);
      font-weight: 600;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      position: sticky;
      top: 0;
      z-index: 10; /* Added z-index for opaque background when sticky */
    }

    body.dark-mode th {
        background-color: #303030;
    }

    tr:last-child td {
        border-bottom: none;
    }

    tr:hover {
      background-color: rgba(125, 206, 199, 0.07);
    }

    h2 {
        font-weight: 600;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--border-color);
        color: var(--text-color);
    }

    .message-box {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: var(--card-background);
      padding: 20px 30px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      z-index: 1000;
      text-align: center;
      max-width: 400px;
      color: var(--text-color);
      border-top: 4px solid var(--primary-color);
      animation: popIn 0.3s ease-out;
    }

    .message-box h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-weight: 600;
    }

    .message-box .dialog-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 20px;
    }

    .info-box {
      background-color: var(--info-box-bg);
      border: 1px solid var(--info-box-border);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      color: var(--text-color);
    }

    #languageConfigSection, #editorSection {
        transition: opacity 0.4s ease-out, transform 0.4s ease-out, max-height 0.4s ease-out;
        overflow: hidden;
        max-height: 1000px; /* Arbitrary large value */
    }

    .hidden-section {
        opacity: 0;
        transform: translateY(10px);
        max-height: 0 !important;
        margin-bottom: 0;
        pointer-events: none;
    }

    /* Styles for editable cells */
    td.editable {
        cursor: pointer;
        position: relative;
    }

    td.editable:hover {
        background-color: rgba(125, 206, 199, 0.15);
    }

    td.editable input[type="text"],
    td.editable textarea,
    td.editable select {
        width: calc(100% - 10px); /* Adjust for padding */
        padding: 5px;
        border: 1px solid var(--primary-color);
        border-radius: 4px;
        background-color: var(--card-background);
        color: var(--text-color);
        font-family: 'Montserrat', sans-serif;
        box-sizing: border-box;
        resize: vertical; /* Allow vertical resizing for textareas */
        min-height: 30px; /* Minimum height for textarea */
    }

    td.editable input[type="text"]:focus,
    td.editable textarea:focus,
    td.editable select:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(125, 206, 199, 0.5);
    }

    .search-options {
        display: flex;
        gap: 15px;
        align-items: center;
        margin-top: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .search-options label {
        display: flex;
        align-items: center;
        gap: 5px;
        margin-bottom: 0; /* Override default label margin */
        font-size: 1rem;
        font-weight: 400;
    }

    .search-options input[type="radio"] {
        width: auto;
        min-width: unset;
        margin-right: 5px;
        cursor: pointer;
    }

    /* Modal styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1001;
        animation: fadeIn 0.3s ease-out;
    }

    .modal-content {
        background-color: var(--card-background);
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        max-width: 500px;
        width: 90%;
        animation: popIn 0.3s ease-out;
        position: relative;
    }

    .modal-content h3 {
        margin-top: 0;
        margin-bottom: 20px;
        font-weight: 600;
        color: var(--text-color);
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 10px;
    }

    .modal-content .input-group {
        margin-bottom: 15px;
    }

    .modal-content .input-group label {
        margin-bottom: 5px;
        font-weight: 500;
    }

    .modal-content .input-group input,
    .modal-content .input-group textarea,
    .modal-content .input-group select {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--input-border);
        border-radius: 8px;
        background-color: var(--card-background);
        color: var(--text-color);
        font-family: 'Montserrat', sans-serif;
        box-sizing: border-box;
    }

    .modal-content .input-group textarea {
        min-height: 80px;
        resize: vertical;
    }

    .modal-content .dialog-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 25px;
    }

    .modal-content .dialog-buttons button { /* Specific styling for modal buttons */
        height: 50px; /* Consistent height */
        padding: 12px 20px; /* Consistent padding */
        font-size: 1rem; /* Consistent font size */
        border-radius: 8px; /* Consistent border-radius */
    }

    .close-modal-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        background: none;
        border: none;
        font-size: 1.5rem;
        color: var(--text-color);
        cursor: pointer;
        padding: 5px;
        border-radius: 50%;
        transition: background-color 0.2s;
    }

    .close-modal-btn:hover {
        background-color: rgba(0,0,0,0.1);
    }

    /* Styles for clickable links in table cells */
    td a {
        color: var(--primary-color);
        text-decoration: underline;
    }

    td a:hover {
        text-decoration: none;
    }

    /* Column visibility menu (removed from functionality, but leaving styles just in case for now) */
    .column-visibility-menu {
        display: none; /* Always hidden */
    }

    /* === NUEVO ESTILO PARA NOTIFICACIÓN "TOAST" === */
    .toast-notification {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(100px); /* Start off-screen */
      background-color: var(--text-color-dark);
      color: var(--background-color-light);
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 2000;
      font-weight: 500;
      opacity: 0;
      transition: opacity 0.4s ease-out, transform 0.4s ease-out;
    }

    .toast-notification.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    body.dark-mode .toast-notification {
       background-color: var(--background-color-light);
       color: var(--text-color-dark);
    }
    /* === FIN DE ESTILOS "TOAST" === */

  </style>
</head>
<body>
  <div class="lang-switcher-container">
    <button id="langBtnEN" onclick="setUILanguage('en')" class="lang-btn">EN</button>
    <button id="langBtnES" onclick="setUILanguage('es')" class="lang-btn">ES</button>
  </div>
  <div class="logo-container">
    <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/pandaterm-logo.png" alt="PandaTerm Logo" class="logo" />
  </div>
  <p class="description" data-i18n="app_description"></p>


  <div class="container">
    <!-- === SECCIÓN DE CONTROLES MODIFICADA === -->
    <div class="controls">
      <!-- 1. Botón "New glossary" -->
      <button onclick="resetGlossary()" data-i18n="new_glossary" class="btn-secondary">Nuevo glosario</button>
      
      <!-- 2. Botón "Import" -->
      <button onclick="document.getElementById('fileInput').click()" data-i18n="import_button" class="btn-secondary">Importar</button>
      <!-- Input de archivo oculto, ahora con ID genérico y acepta .csv -->
      <input type="file" id="fileInput" accept=".xml,.tbx,.csv" />
      
      <!-- 3. Botón "Export" -->
      <button onclick="showExportDialog()" data-i18n="export_button" class="btn-secondary">Exportar</button>
      
      <!-- Botones restantes -->
      <button onclick="toggleTheme()" id="themeToggleButton" data-i18n="toggle_theme" class="btn-secondary">Cambiar tema</button>
      <button onclick="undo()" id="undoButton" data-i18n="undo_button" class="btn-secondary" disabled>Deshacer</button>
    </div>
    <!-- === FIN DE SECCIÓN DE CONTROLES MODIFICADA === -->


    <div id="languageConfigSection">
      <h2 data-i18n="config_lang_title">Configurar idiomas del glosario</h2>
      <div class="info-box">
        <p data-i18n="config_lang_info">
          Define los idiomas de origen y destino de tu glosario. Puedes introducir el código ISO directamente o seleccionarlo de las sugerencias. Es fundamental que el código ISO sea correcto para que funcione correctamente con tu herramienta TAO.
        </p>
      </div>
      <div class="lang-display">
        <div class="input-group">
          <label for="configSrcLang" data-i18n="source_language">Idioma de origen:</label>
          <input id="configSrcLang" list="isoLanguages" value="en-US" />
        </div>
        <div class="input-group">
          <label for="configTgtLang" data-i18n="target_language">Idioma de destino:</label>
          <input id="configTgtLang" list="isoLanguages" value="es-ES" />
        </div>
        <button onclick="confirmGlossaryLanguages()" data-i18n="confirm_languages" class="btn-primary">Confirmar idiomas</button>
      </div>
    </div>

    <div id="editorSection" class="hidden-section">
        <h2 data-i18n="current_lang_title">Idiomas actuales del glosario</h2>
        <div class="lang-display">
            <div class="input-group">
                <label data-i18n="source_language">Idioma de origen:</label>
                <input id="displaySrcLang" disabled />
            </div>
            <div class="input-group">
                <label data-i18n="target_language">Idioma de destino:</label>
                <input id="displayTgtLang" disabled />
            </div>
        </div>

        <h2 data-i18n="add_term_title">Añadir término</h2>
        <div class="add-term">
            <div class="add-term-row">
                <div class="input-group">
                    <label for="srcTerm" data-i18n="term">Término:<span class="required-asterisk">*</span></label>
                    <input id="srcTerm" />
                </div>
                <div class="input-group">
                    <label for="tgtTerm" data-i18n="translation">Traducción:<span class="required-asterisk">*</span></label>
                    <input id="tgtTerm" />
                </div>
            </div>

            <div class="add-term-row">
                <div class="input-group" id="definitionInputGroup">
                    <label for="definition"><span data-i18n="definition">Definición:</span></label>
                    <textarea id="definition"></textarea>
                </div>
                <div class="input-group" id="notesInputGroup">
                    <label for="notes"><span data-i18n="notes">Notas:</span></label>
                    <textarea id="notes"></textarea>
                </div>
            </div>

            <div class="add-term-row">
                <div class="input-group" id="partOfSpeechInputGroup">
                    <label for="partOfSpeech"><span data-i18n="part_of_speech">Categoría gramatical:</span></label>
                    <select id="partOfSpeech">
                        <option value="" data-i18n="select_pos_placeholder">Seleccionar</option>
                        <option value="noun">noun</option>
                        <option value="verb">verb</option>
                        <option value="adj">adj</option>
                        <option value="adv">adv</option>
                    </select>
                </div>
                <button onclick="addTerm()" data-i18n="add_button" class="btn-primary">Añadir</button>
            </div>
        </div>

        <h2 data-i18n="search_title">Buscar</h2>
        <div class="search-section">
            <input id="searchTerm" placeholder="Buscar término..." oninput="renderGlossary()" data-i18n-placeholder="search_placeholder" />
            <div class="search-options">
                <label>
                    <input type="radio" name="searchScope" value="all" checked onchange="renderGlossary()">
                    <span data-i18n="search_all">Todos</span>
                </label>
                <label>
                    <input type="radio" name="searchScope" value="source" onchange="renderGlossary()">
                    <span data-i18n="search_source">Solo origen</span>
                </label>
                <label>
                    <input type="radio" name="searchScope" value="target" onchange="renderGlossary()">
                    <span data-i18n="search_target">Solo destino</span>
                </label>
            </div>
        </div>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th data-i18n="source_term_col" data-column-id="source_term_col">Término de origen</th>
                        <th data-i18n="target_term_col" data-column-id="target_term_col">Término de destino</th>
                        <th data-i18n="definition_col" data-column-id="definition_col">Definición</th>
                        <th data-i18n="notes_col" data-column-id="notes_col">Notas</th>
                        <th data-i18n="part_of_speech_col" data-column-id="part_of_speech_col">Categoría gramatical</th>
                        <th data-i18n="actions_col" data-column-id="actions_col">Acciones</th>
                    </tr>
                </thead>
                <tbody id="glossaryTable"></tbody>
            </table>
        </div>
    </div>

    <datalist id="isoLanguages">
      </datalist>
  </div>

  <script>
    // Global array to store glossary terms
    let glossary = [];
    // Action history for undo functionality
    let history = [];
    // Get current UI language from local storage, default to English
    let currentUILanguage = localStorage.getItem('language') || 'en';
    // Get current theme from local storage, default to light
    let currentTheme = localStorage.getItem('theme') || 'light';

    // Global variables to store the glossary's defined source and target languages
    let glossarySourceLanguage = '';
    let glossaryTargetLanguage = '';

    // Column visibility state - now always true as the toggle button is removed
    let columnVisibility = {
        'source_term_col': true,
        'target_term_col': true,
        'definition_col': true,
        'notes_col': true,
        'part_of_speech_col': true,
        'actions_col': true
    };

    const translations = {
      en: {
        title: "PandaTerm",
        main_title: "PandaTerm",
        app_description: "A simple TBX/CSV glossary editor",
        // === TRADUCCIONES MODIFICADAS ===
        import_button: "Import", // Antes "import_tbx"
        export_button: "Export", // Antes "download_button"
        // === FIN DE MODIFICACIONES ===
        new_glossary: "New glossary",
        toggle_theme: "Toggle theme",
        undo_button: "Undo",
        config_lang_title: "Configure glossary languages",
        config_lang_info: "Define the source and target languages for your glossary. You can type the ISO code directly or select from the suggestions. It is important that the ISO code is correct for it to work well in your CAT tool.",
        confirm_languages: "Confirm languages",
        current_lang_title: "Current glossary languages",
        add_term_title: "Add term",
        source_language: "Source language:",
        term: "Term:",
        target_language: "Translation:",
        translation: "Translation:",
        definition: "Definition:",
        notes: "Notes:",
        part_of_speech: "Part of Speech:",
        add_button: "Add",
        search_title: "Search",
        search_placeholder: "Search term...",
        search_all: "All",
        search_source: "Source only",
        search_target: "Target only",
        source_term_col: "Source term",
        target_term_col: "Target term",
        definition_col: "Definition",
        notes_col: "Notes",
        part_of_speech_col: "Part of Speech",
        actions_col: "Actions",
        delete_button: "Delete",
        edit_button: "Edit",
        both_terms_required: "Both term and translation are required.",
        lang_config_required: "Please configure source and target languages for the glossary.",
        "Cannot download empty or unconfigured glossary.": "Cannot download empty or unconfigured glossary.",
        "No valid language pairs found in TBX. Defaulting to en-US/es-ES.": "No valid language pairs found in TBX. Defaulting to en-US/es-ES.",
        "Error loading TBX file. Please ensure it's a valid XML/TBX.": "Error loading TBX file. Please ensure it's a valid XML/TBX.",
        new_glossary_confirm_title: "Confirm New Glossary",
        new_glossary_confirm_text: "All current glossary data will be lost. If you don't want to lose it, click cancel and export it as a TBX file. Click confirm to create a new glossary from scratch.",
        confirm_button: "Confirm",
        cancel_button: "Cancel",
        download_dialog_title: "Enter filename", // Reutilizado por el modal de exportación
        download_dialog_placeholder: "glossary", // Reutilizado por el modal de exportación
        save_button: "Save",
        edit_term_title: "Edit Term",
        update_button: "Update",
        select_pos_placeholder: "Select",
        show_more_fields: "Show more fields",
        hide_more_fields: "Hide fields",
        delete_term_confirm_title: "Confirm Delete",
        delete_term_confirm_text: "Are you sure you want to delete this term? This action cannot be undone.",
        // --- TRADUCCIONES DE BACKUP ---
        "backup_restored": "Your previous work has been restored.",
        "backup_corrupt": "Could not restore backup. It may be corrupt. Starting new session.",
        // --- NUEVAS TRADUCCIONES (CSV Y EXPORT) ---
        "export_dialog_title": "Export Glossary",
        "export_filename": "Filename:",
        "export_format": "Format:",
        "export_action_button": "Export",
        "csv_import_success": "Imported {count} new terms.",
        "csv_import_no_terms": "No new terms found to import.",
        "csv_import_error": "Error loading CSV file. Please ensure it's a valid file.",
        "csv_header_error": "The CSV must have headers like \"Source Term\" and \"Target Term\", or \"{srcLang}\" and \"{tgtLang}\".",
        "csv_empty_error": "The CSV is empty or has no headers.",
        "unsupported_file_error": "Unsupported file type. Please select a .tbx, .xml, or .csv file."
      },
      es: {
        title: "PandaTerm",
        main_title: "PandaTerm",
        app_description: "Un sencillo editor de glosarios TBX/CSV",
        // === TRADUCCIONES MODIFICADAS ===
        import_button: "Importar", // Antes "import_tbx"
        export_button: "Exportar", // Antes "download_button"
        // === FIN DE MODIFICACIONES ===
        new_glossary: "Nuevo glosario",
        toggle_theme: "Cambiar tema",
        undo_button: "Deshacer",
        config_lang_title: "Configurar idiomas del glosario",
        config_lang_info: "Define los idiomas de origen y destino de tu glosario. Puedes introducir el código ISO directamente o seleccionarlo de las sugerencias. Es fundamental que el código ISO sea correcto para que funcione correctamente con tu herramienta TAO.",
        confirm_languages: "Confirmar idiomas",
        current_lang_title: "Idiomas actuales del glosario",
        add_term_title: "Añadir término",
        source_language: "Idioma de origen:",
        term: "Término:",
        target_language: "Idioma de destino:",
        translation: "Traducción:",
        definition: "Definición:",
        notes: "Notas:",
        part_of_speech: "Categoría gramatical:",
        add_button: "Añadir",
        search_title: "Buscar",
        search_placeholder: "Buscar término...",
        search_all: "Todos",
        search_source: "Solo origen",
        search_target: "Solo destino",
        source_term_col: "Término de origen",
        target_term_col: "Término de destino",
        definition_col: "Definición",
        notes_col: "Notas",
        part_of_speech_col: "Categoría gramatical",
        actions_col: "Acciones",
        delete_button: "Eliminar",
        edit_button: "Editar",
        both_terms_required: "El término y la traducción son obligatorios.",
        lang_config_required: "Por favor, configura los idiomas de origen y destino para el glosario.",
        "Cannot download empty or unconfigured glossary.": "No se puede descargar un glosario vacío o sin configurar.",
        "No valid language pairs found in TBX. Defaulting to en-US/es-ES.": "No se encontraron pares de idioma válidos en TBX. Se utiliza en-US/es-ES por defecto.",
        "Error loading TBX file. Please ensure it's a valid XML/TBX.": "Error al cargar el archivo TBX. Asegúrate de que sea un XML/TBX válido.",
        new_glossary_confirm_title: "Confirmar nuevo glosario",
        new_glossary_confirm_text: "Se perderá toda la información del glosario actual. Si no quieres perderlo, haz clic en cancelar y expórtalo como archivo TBX. Haz clic en confirmar para crear un glosario nuevo desde cero.",
        confirm_button: "Confirmar",
        cancel_button: "Cancelar",
        download_dialog_title: "Introducir nombre de archivo", // Reutilizado
        download_dialog_placeholder: "glosario", // Reutilizado
        save_button: "Guardar",
        edit_term_title: "Editar término",
        update_button: "Actualizar",
        select_pos_placeholder: "Seleccionar",
        show_more_fields: "Mostrar más campos",
        hide_more_fields: "Ocultar campos",
        delete_term_confirm_title: "Confirmar eliminación",
        delete_term_confirm_text: "¿Estás seguro de que quieres eliminar este término? Esta acción no se puede deshacer.",
        // --- TRADUCCIONES DE BACKUP ---
        "backup_restored": "Se ha restaurado tu trabajo anterior.",
        "backup_corrupt": "No se pudo restaurar la copia de seguridad. Puede que esté corrupta. Empezando una nueva sesión.",
        // --- NUEVAS TRADUCCIONES (CSV Y EXPORT) ---
        "export_dialog_title": "Exportar Glosario",
        "export_filename": "Nombre de archivo:",
        "export_format": "Formato:",
        "export_action_button": "Exportar",
        "csv_import_success": "Se importaron {count} términos nuevos.",
        "csv_import_no_terms": "No se encontraron términos nuevos para importar.",
        "csv_import_error": "Error al cargar el archivo CSV. Asegúrate de que sea un archivo válido.",
        "csv_header_error": "El CSV debe tener cabeceras como \"Source Term\" y \"Target Term\", o \"{srcLang}\" y \"{tgtLang}\".",
        "csv_empty_error": "El CSV está vacío o no tiene cabeceras.",
        "unsupported_file_error": "Tipo de archivo no compatible. Por favor, selecciona un archivo .tbx, .xml, o .csv."
      }
    };

    const isoLanguagesData = [
      { code: "en", name: "English" }, { code: "en-US", name: "English (United States)" }, { code: "en-GB", name: "English (United Kingdom)" }, { code: "es", name: "Español" }, { code: "es-ES", name: "Español (España)" }, { code: "es-MX", name: "Español (México)" }, { code: "es-AR", name: "Español (Argentina)" }, { code: "fr", name: "Français" }, { code: "de", name: "Deutsch" }, { code: "it", name: "Italiano" }, { code: "pt", name: "Português" }, { code: "ja", name: "日本語 (Japanese)" }, { code: "zh", name: "中文 (Chinese)" }, { code: "ar", name: "العربية (Arabic)" }, { code: "ru", name: "Русский (Russian)" }, { code: "ko", name: "한국어 (Korean)" }, { code: "nl", name: "Nederlands" }, { code: "sv", name: "Svenska" }, { code: "da", name: "Dansk" }, { code: "no", name: "Norsk" }, { code: "fi", name: "Suomi" }, { code: "tr", name: "Türkçe" }, { code: "pl", "name": "Polski" }, { code: "ca", name: "Català" }, { code: "eu", name: "Euskara" }, { code: "gl", name: "Galego" }
    ];

    /**
     * Populates the datalist with ISO language codes and names.
     */
    function populateIsoLanguagesDatalist() {
      const datalist = document.getElementById('isoLanguages');
      datalist.innerHTML = '';
      isoLanguagesData.forEach(lang => {
        const option = document.createElement('option');
        option.value = lang.code;
        option.textContent = lang.name;
        datalist.appendChild(option);
      });
    }

    /**
     * Applies the selected theme (light or dark) to the body.
     * @param {string} theme - The theme to apply ('light' or 'dark').
     */
    function applyTheme(theme) {
      document.body.className = theme === 'dark' ? 'dark-mode' : '';
      currentTheme = theme;
      localStorage.setItem('theme', theme);
    }

    /**
     * Toggles between light and dark themes.
     */
    function toggleTheme() {
      applyTheme(currentTheme === 'light' ? 'dark' : 'light');
    }

    /**
     * Sets the UI language and updates all translatable text.
     * @param {string} lang - The language code ('en' or 'es').
     */
    function setUILanguage(lang) {
      currentUILanguage = lang;
      localStorage.setItem('language', lang);
      updateTextContent();
      updateLanguageButtons();
    }

    /**
     * Updates the active state of language switcher buttons.
     */
    function updateLanguageButtons() {
        document.getElementById('langBtnEN').classList.toggle('active', currentUILanguage === 'en');
        document.getElementById('langBtnES').classList.toggle('active', currentUILanguage === 'es');
    }

    /**
     * Updates all elements with `data-i18n` and `data-i18n-placeholder` attributes
     * to the current UI language.
     */
    function updateTextContent() {
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (translations[currentUILanguage][key]) {
          el.textContent = translations[currentUILanguage][key];
        }
      });

      document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if (translations[currentUILanguage][key]) {
          el.placeholder = translations[currentUILanguage][key];
        }
      });
      // Update placeholder for partOfSpeech select
      const selectPosPlaceholder = document.querySelector('#partOfSpeech option[value=""]');
      if (selectPosPlaceholder) {
          selectPosPlaceholder.textContent = translations[currentUILanguage]['select_pos_placeholder'];
      }

      renderGlossary(); // Re-render glossary to update delete button text
    }

    /**
     * Shows a specific section of the application and hides others.
     * @param {string} sectionId - The ID of the section to show.
     */
    function showSection(sectionId) {
        const sectionToShow = document.getElementById(sectionId);
        const sectionToHide = sectionId === 'editorSection' ? document.getElementById('languageConfigSection') : document.getElementById('editorSection');

        sectionToHide.classList.add('hidden-section');
        sectionToShow.classList.remove('hidden-section');
    }

    /**
     * Updates the disabled state of the undo button based on history.
     */
    function updateUndoButtonState() {
      const undoButton = document.getElementById('undoButton');
      if(undoButton) {
        undoButton.disabled = history.length === 0;
      }
    }

    /**
     * Saves the current state of the glossary to the history for undo functionality.
     */
    function saveState() {
      // Save a deep copy of the current glossary state
      history.push(JSON.parse(JSON.stringify(glossary)));
      updateUndoButtonState();
    }

    /**
     * Undoes the last action by restoring the previous glossary state from history.
     */
    function undo() {
      if (history.length > 0) {
        glossary = history.pop();
        renderGlossary();
        updateUndoButtonState();
        saveBackupToLocalStorage(); // <-- GUARDAR BACKUP
      }
    }

    /**
     * Performs the actual reset of the glossary after confirmation.
     */
    function performResetGlossary() {
      saveState();
      glossary = [];
      glossarySourceLanguage = '';
      glossaryTargetLanguage = '';
      document.getElementById('configSrcLang').value = 'en-US';
      document.getElementById('configTgtLang').value = 'es-ES';
      document.getElementById('srcTerm').value = '';
      document.getElementById('tgtTerm').value = '';
      document.getElementById('definition').value = ''; // Clear definition
      document.getElementById('notes').value = ''; // Clear notes
      document.getElementById('partOfSpeech').value = ''; // Clear part of speech
      document.getElementById('searchTerm').value = '';
      // Reset search scope to 'all'
      document.querySelector('input[name="searchScope"][value="all"]').checked = true;

      showSection('languageConfigSection');
      renderGlossary();
      saveBackupToLocalStorage(); // <-- GUARDAR BACKUP
    }

    /**
     * Prompts the user for confirmation before resetting the glossary.
     */
    function resetGlossary() {
      const title = translations[currentUILanguage]['new_glossary_confirm_title'];
      const message = translations[currentUILanguage]['new_glossary_confirm_text'];
      showConfirmationDialog(title, message, performResetGlossary);
    }

    /**
     * Confirms and sets the glossary's source and target languages.
     */
    function confirmGlossaryLanguages() {
      const srcLang = document.getElementById('configSrcLang').value.trim();
      const tgtLang = document.getElementById('configTgtLang').value.trim();

      if (!srcLang || !tgtLang) {
        showMessageBox(translations[currentUILanguage]['lang_config_required']);
        return;
      }

      glossarySourceLanguage = srcLang;
      glossaryTargetLanguage = tgtLang;
      document.getElementById('displaySrcLang').value = glossarySourceLanguage;
      document.getElementById('displayTgtLang').value = glossaryTargetLanguage;
      showSection('editorSection');
      renderGlossary();

      // Clear history when starting a new glossary configuration
      history = [];
      updateUndoButtonState();
      saveBackupToLocalStorage(); // <-- GUARDAR BACKUP
    }

    /**
     * Adds a new term to the glossary.
     */
    function addTerm() {
      const srcTermInput = document.getElementById("srcTerm");
      const tgtTermInput = document.getElementById("tgtTerm");
      const definitionInput = document.getElementById("definition");
      const notesInput = document.getElementById("notes");
      const partOfSpeechInput = document.getElementById("partOfSpeech");

      const srcTerm = srcTermInput.value.trim();
      const tgtTerm = tgtTermInput.value.trim();
      const definition = definitionInput.value.trim();
      const notes = notesInput.value.trim();
      const partOfSpeech = partOfSpeechInput.value.trim();

      if (!srcTerm || !tgtTerm) {
        showMessageBox(translations[currentUILanguage]['both_terms_required']);
        return;
      }

      saveState();

      glossary.push({
        srcLang: glossarySourceLanguage,
        srcTerm: srcTerm,
        tgtLang: glossaryTargetLanguage,
        tgtTerm: tgtTerm,
        definition: definition,
        notes: notes,
        srcPartOfSpeech: partOfSpeech
      });
      srcTermInput.value = "";
      tgtTermInput.value = "";
      definitionInput.value = "";
      notesInput.value = "";
      partOfSpeechInput.value = "";
      srcTermInput.focus();
      renderGlossary(true); // Pass true to animate the last row
      saveBackupToLocalStorage(); // <-- GUARDAR BACKUP
    }

    /**
     * Deletes a term from the glossary by its original index.
     * @param {number} originalIndex - The original index of the term in the glossary array.
     */
    function deleteTerm(originalIndex) {
        const title = translations[currentUILanguage]['delete_term_confirm_title'];
        const message = translations[currentUILanguage]['delete_term_confirm_text'];
        showConfirmationDialog(title, message, () => {
            saveState();
            glossary.splice(originalIndex, 1);
            renderGlossary();
            closeModal('editModal'); // Close modal if open after deleting
            saveBackupToLocalStorage(); // <-- GUARDAR BACKUP
        });
    }

    /**
     * Opens a modal to edit an existing term.
     * @param {number} index - The index of the term in the glossary array.
     */
    function editTerm(index) {
        const term = glossary[index];
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'modal-overlay';
        modalOverlay.id = 'editModal';

        const posOptions = ['noun', 'verb', 'adj', 'adv'].map(pos =>
            `<option value="${pos}" ${term.srcPartOfSpeech === pos ? 'selected' : ''}>${pos}</option>`
        ).join('');

        modalOverlay.innerHTML = `
            <div class="modal-content">
                <button class="close-modal-btn" onclick="closeModal('editModal')">&times;</button>
                <h3 data-i18n="edit_term_title">${translations[currentUILanguage]['edit_term_title']}</h3>
                <div class="input-group">
                    <label for="editSrcTerm" data-i18n="term">${translations[currentUILanguage]['term']}<span class="required-asterisk">*</span></label>
                    <input id="editSrcTerm" type="text" value="${term.srcTerm}" />
                </div>
                <div class="input-group">
                    <label for="editTgtTerm" data-i18n="translation">${translations[currentUILanguage]['translation']}<span class="required-asterisk">*</span></label>
                    <input id="editTgtTerm" type="text" value="${term.tgtTerm}" />
                </div>
                <div class="input-group">
                    <label for="editDefinition" data-i18n="definition">${translations[currentUILanguage]['definition']}</label>
                    <textarea id="editDefinition">${term.definition || ''}</textarea>
                </div>
                <div class="input-group">
                    <label for="editNotes" data-i18n="notes">${translations[currentUILanguage]['notes']}</label>
                    <textarea id="editNotes">${term.notes || ''}</textarea>
                </div>
                <div class="input-group">
                    <label for="editPartOfSpeech" data-i18n="part_of_speech">${translations[currentUILanguage]['part_of_speech']}</label>
                    <select id="editPartOfSpeech">
                        <option value="" data-i18n="select_pos_placeholder">${translations[currentUILanguage]['select_pos_placeholder']}</option>
                        ${posOptions}
                    </select>
                </div>
                <div class="dialog-buttons">
                    <button class="btn-danger" onclick="deleteTerm(${index})" data-i18n="delete_button">${translations[currentUILanguage]['delete_button']}</button>
                    <button class="btn-secondary" onclick="closeModal('editModal')" data-i18n="cancel_button">${translations[currentUILanguage]['cancel_button']}</button>
                    <button class="btn-primary" onclick="saveEditedTerm(${index})" data-i18n="update_button">${translations[currentUILanguage]['update_button']}</button>
                </div>
            </div>
        `;
        document.body.appendChild(modalOverlay);
    }

    /**
     * Saves the changes made to a term in the edit modal.
     * @param {number} index - The index of the term in the glossary array.
     */
    function saveEditedTerm(index) {
        const srcTerm = document.getElementById('editSrcTerm').value.trim();
        const tgtTerm = document.getElementById('editTgtTerm').value.trim();
        const definition = document.getElementById('editDefinition').value.trim();
        const notes = document.getElementById('editNotes').value.trim();
        const partOfSpeech = document.getElementById('editPartOfSpeech').value.trim();

        if (!srcTerm || !tgtTerm) {
            showMessageBox(translations[currentUILanguage]['both_terms_required']);
            return;
        }

        saveState(); // Save state before modification

        glossary[index].srcTerm = srcTerm;
        glossary[index].tgtTerm = tgtTerm;
        glossary[index].definition = definition;
        glossary[index].notes = notes;
        glossary[index].srcPartOfSpeech = partOfSpeech;

        closeModal('editModal');
        renderGlossary();
        saveBackupToLocalStorage(); // <-- GUARDAR BACKUP
    }

    /**
     * Closes a modal dialog.
     * @param {string} modalId - The ID of the modal overlay to close.
     */
    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.remove();
        }
    }

    /**
     * Formats text to make URLs clickable.
     * @param {string} text - The input text.
     * @returns {string} The text with URLs replaced by clickable links.
     */
    function formatTextWithLinks(text) {
        if (!text) return '';
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        return text.replace(urlRegex, (url) => `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`);
    }

    /**
     * Applies the current column visibility settings to the table.
     */
    function applyColumnVisibility() {
        const table = document.querySelector('table');
        if (!table) return;

        const headers = Array.from(table.querySelectorAll('th'));
        const rows = Array.from(table.querySelectorAll('tbody tr'));

        headers.forEach((th, index) => {
            th.style.display = '';
            rows.forEach(row => {
                const cell = row.children[index];
                if (cell) {
                    cell.style.display = '';
                }
            });
        });
    }

    /**
     * Renders the glossary table based on current search and filter criteria.
     * @param {boolean} animateLastRow - Whether to apply animation to the last added row.
     */
    function renderGlossary(animateLastRow = false) {
      const tbody = document.getElementById("glossaryTable");
      const search = document.getElementById("searchTerm").value.toLowerCase();
      const searchScope = document.querySelector('input[name="searchScope"]:checked').value;
      tbody.innerHTML = "";

      const filteredGlossary = glossary.filter(entry => {
        const srcMatch = entry.srcTerm.toLowerCase().includes(search);
        const tgtMatch = entry.tgtTerm.toLowerCase().includes(search);
        const defMatch = (entry.definition || '').toLowerCase().includes(search);
        const notesMatch = (entry.notes || '').toLowerCase().includes(search);
        const posMatch = (entry.srcPartOfSpeech || '').toLowerCase().includes(search);

        if (searchScope === 'source') {
          return srcMatch;
        } else if (searchScope === 'target') {
          return tgtMatch;
        } else { // 'all'
          return srcMatch || tgtMatch || defMatch || notesMatch || posMatch;
        }
      });

      filteredGlossary.forEach((entry, i) => {
          const originalIndex = glossary.findIndex(g => g === entry);
          const row = document.createElement("tr");
          row.innerHTML = `
            <td class="editable" onclick="editTerm(${originalIndex})">${entry.srcTerm}</td>
            <td class="editable" onclick="editTerm(${originalIndex})">${entry.tgtTerm}</td>
            <td class="editable" onclick="editTerm(${originalIndex})">${formatTextWithLinks(entry.definition)}</td>
            <td class="editable" onclick="editTerm(${originalIndex})">${formatTextWithLinks(entry.notes)}</td>
            <td class="editable" onclick="editTerm(${originalIndex})">${entry.srcPartOfSpeech || ''}</td>
            <td><button class="delete-btn" onclick="deleteTerm(${originalIndex})">${translations[currentUILanguage]['delete_button']}</button></td>
          `;

          if (animateLastRow && i === filteredGlossary.length - 1) {
              row.classList.add('row-pop-in');
          }

          tbody.appendChild(row);
      });
      applyColumnVisibility(); // Apply visibility after rendering
    }

    // ===============================================
    // === LÓGICA DE EXPORTACIÓN (TBX Y CSV) =======
    // ===============================================

    /**
     * Muestra el modal de exportación para elegir formato y nombre.
     */
    function showExportDialog() {
      if (glossary.length === 0 || !glossarySourceLanguage || !glossaryTargetLanguage) {
        showMessageBox(translations[currentUILanguage]["Cannot download empty or unconfigured glossary."]);
        return;
      }

      const modalOverlay = document.createElement('div');
      modalOverlay.className = 'modal-overlay';
      modalOverlay.id = 'exportModal';

      // Usamos las traducciones para el modal
      modalOverlay.innerHTML = `
        <div class="modal-content">
          <button class="close-modal-btn" onclick="closeModal('exportModal')">&times;</button>
          <h3 data-i18n="export_dialog_title">${translations[currentUILanguage]['export_dialog_title']}</h3>
          
          <div class="input-group">
            <label for="exportFilename" data-i18n="export_filename">${translations[currentUILanguage]['export_filename']}</label>
            <input id="exportFilename" type="text" value="${translations[currentUILanguage]['download_dialog_placeholder']}" />
          </div>
          
          <div class="input-group">
            <label data-i18n="export_format">${translations[currentUILanguage]['export_format']}</label>
            <!-- Reutilizamos el estilo de .search-options para los radio buttons -->
            <div class="search-options" style="margin-top: 5px; margin-bottom: 0; justify-content: flex-start; gap: 25px;">
              <label>
                <input type="radio" name="exportFormat" value="tbx" checked>
                <span>TBX</span>
              </label>
              <label>
                <input type="radio" name="exportFormat" value="csv">
                <span>CSV</span>
              </label>
            </div>
          </div>

          <div class="dialog-buttons">
            <button class="btn-secondary" onclick="closeModal('exportModal')" data-i18n="cancel_button">${translations[currentUILanguage]['cancel_button']}</button>
            <button class="btn-primary" onclick="performExport()" data-i18n="export_action_button">${translations[currentUILanguage]['export_action_button']}</button>
          </div>
        </div>
      `;
      document.body.appendChild(modalOverlay);
      
      const filenameInput = document.getElementById('exportFilename');
      filenameInput.focus();
      filenameInput.select(); // Seleccionar el texto por defecto
    }

    /**
     * Se llama desde el modal de exportación. Obtiene los valores y llama a la función de descarga correspondiente.
     */
    function performExport() {
      const filename = document.getElementById('exportFilename').value.trim() || translations[currentUILanguage]['download_dialog_placeholder'];
      const format = document.querySelector('input[name="exportFormat"]:checked').value;

      if (format === 'tbx') {
        generateAndDownloadTBX(filename);
      } else if (format === 'csv') {
        generateAndDownloadCSV(filename);
      }

      closeModal('exportModal');
    }

    /**
     * Genera el contenido del string TBX.
     * @returns {string} El contenido del archivo TBX como string.
     */
    function generateTBX() {
      const xml = [`<?xml version="1.0" encoding="UTF-8"?>`,
        `<martif type="TBX" xml:lang="${glossarySourceLanguage}">`,
        `  <text>`,
        `    <body>`];

      glossary.forEach(entry => {
        xml.push(`      <termEntry>`);
        xml.push(`        <LangSet xml:lang="${entry.srcLang || glossarySourceLanguage}">`);
        xml.push(`          <tig>`);
        xml.push(`            <term>${entry.srcTerm}</term>`);
        if (entry.srcPartOfSpeech) {
            xml.push(`            <termNote type="partOfSpeech">${entry.srcPartOfSpeech}</termNote>`);
        }
        xml.push(`          </tig>`);
        xml.push(`        </LangSet>`);
        xml.push(`        <LangSet xml:lang="${entry.tgtLang || glossaryTargetLanguage}">`);
        xml.push(`          <tig>`);
        xml.push(`            <term>${entry.tgtTerm}</term>`);
        if (entry.definition) {
            xml.push(`            <descrip type="definition">${entry.definition}</descrip>`);
        }
        if (entry.notes) {
            xml.push(`            <termNote type="comment">${entry.notes}</termNote>`);
        }
        xml.push(`          </tig>`);
        xml.push(`        </LangSet>`);
        xml.push(`      </termEntry>`);
      });

      xml.push(`    </body>`, `  </text>`, `</martif>`);
      return xml.join("\n");
    }

     /**
     * Genera y descarga el glosario actual como un archivo TBX.
     * @param {string} filename - El nombre de archivo (sin extensión).
     */
    function generateAndDownloadTBX(filename) {
      const blob = new Blob([generateTBX()], { type: "application/xml" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename.endsWith('.tbx') ? filename : `${filename}.tbx`;
      a.click();
      URL.revokeObjectURL(url);
    }

    /**
     * Escapa un campo de texto para su uso en CSV.
     * @param {string} field - El contenido del campo.
     * @returns {string} El campo formateado para CSV.
     */
    function escapeCSV(field) {
      if (field === null || field === undefined) {
        return '""';
      }
      const str = String(field);
      const escaped = str.replace(/"/g, '""'); // Duplica las comillas dobles
      // Si el campo contiene comillas, punto y coma, o saltos de línea, se entrecomilla
      if (str.includes('"') || str.includes(';') || str.includes('\n') || str.includes('\r')) {
        return `"${escaped}"`;
      }
      return escaped; // Devolver sin comillas si no es necesario
    }

    /**
     * Genera y descarga el glosario actual como un archivo CSV compatible.
     * @param {string} filename - El nombre de archivo (sin extensión).
     */
    function generateAndDownloadCSV(filename) {
      const headers = [
        "Source Language", "Source Term", "Target Language", "Target Term",
        "Definition", "Notes", "Part of Speech"
      ];
      // Usamos punto y coma para mejor compatibilidad con Excel
      let csvContent = headers.join(";") + "\n"; 

      glossary.forEach(entry => {
        const row = [
          entry.srcLang || glossarySourceLanguage,
          entry.srcTerm,
          entry.tgtLang || glossaryTargetLanguage,
          entry.tgtTerm,
          entry.definition || '',
          entry.notes || '',
          entry.srcPartOfSpeech || ''
        ];
        csvContent += row.map(escapeCSV).join(";") + "\n";
      });

      // Aseguramos UTF-8 con BOM para que Excel abra los acentos correctamente
      const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
      const blob = new Blob([bom, csvContent], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename.endsWith('.csv') ? filename : `${filename}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }

    // ===============================================
    // === LÓGICA DE IMPORTACIÓN (TBX Y CSV) =======
    // ===============================================

    /**
     * Lee y procesa el contenido de un archivo TBX.
     * @param {File} file - El archivo TBX/XML a leer.
     */
    function readTBXFile(file) {
        const reader = new FileReader();
        reader.onload = () => {
          try {
            console.log("File read successfully. Attempting to parse XML...");
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(reader.result, "application/xml");

            const parserError = xmlDoc.querySelector("parsererror");
            if (parserError) {
                const errorText = parserError.textContent || "Unknown XML parsing error.";
                console.error("XML Parsing Error:", errorText, xmlDoc);
                throw new Error(`Parsing error: The file is not a valid XML/TBX. Details: ${errorText.substring(0, 100)}...`);
            }
            
            let entryTagName, langSetTagName, termGroupTagName, rootElement;

            if (xmlDoc.getElementsByTagName("martif").length > 0) {
                rootElement = "martif";
                entryTagName = "termEntry";
                langSetTagName = "LangSet";
                termGroupTagName = "tig";
            } else if (xmlDoc.getElementsByTagName("tbx").length > 0) {
                rootElement = "tbx";
                entryTagName = "conceptEntry";
                langSetTagName = "langSec";
                termGroupTagName = "termSec";
            } else {
                throw new Error("Unsupported TBX root element. Expected <martif> or <tbx>.");
            }

            const entries = xmlDoc.getElementsByTagName(entryTagName);
            const newGlossary = [];
            const langCounts = {}; 

            for (let i = 0; i < entries.length; i++) {
              const entry = entries[i];
              const langSets = entry.getElementsByTagName(langSetTagName);
              let conceptDefinition = '';
              let conceptNotes = '';

              if (rootElement === "tbx") {
                  const conceptDefinitionElement = entry.querySelector('descrip[type="definition"]');
                  const conceptNotesElement = entry.querySelector('note');
                  conceptDefinition = conceptDefinitionElement ? conceptDefinitionElement.textContent || '' : '';
                  conceptNotes = conceptNotesElement ? conceptNotesElement.textContent || '' : '';
              }

              if (langSets.length >= 2) {
                let srcLang = '', srcTerm = '', srcPartOfSpeech = '';
                let tgtLang = '', tgtTerm = '', tgtPartOfSpeech = '';
                let entryDefinition = conceptDefinition;
                let entryNotes = conceptNotes;

                const firstLangSet = langSets[0];
                srcLang = firstLangSet.getAttribute("xml:lang") || '';
                const firstTermGroup = firstLangSet.getElementsByTagName(termGroupTagName)[0];
                if (firstTermGroup) {
                    srcTerm = firstTermGroup.getElementsByTagName("term")[0]?.textContent || '';
                    let minPartOfSpeechElement = firstTermGroup.getElementsByTagNameNS("http://www.tbxinfo.net/ns/min", "partOfSpeech")[0];
                    if (minPartOfSpeechElement) {
                        srcPartOfSpeech = minPartOfSpeechElement.textContent || '';
                    } else {
                        srcPartOfSpeech = firstTermGroup.querySelector('termNote[type="partOfSpeech"]')?.textContent || '';
                    }
                }

                const secondLangSet = langSets[1];
                tgtLang = secondLangSet.getAttribute("xml:lang") || '';
                const secondTermGroup = secondLangSet.getElementsByTagName(termGroupTagName)[0];
                if (secondTermGroup) {
                    tgtTerm = secondTermGroup.getElementsByTagName("term")[0]?.textContent || '';
                    let minPartOfSpeechElement = secondTermGroup.getElementsByTagNameNS("http://www.tbxinfo.net/ns/min", "partOfSpeech")[0];
                    if (minPartOfSpeechElement) {
                        tgtPartOfSpeech = minPartOfSpeechElement.textContent || '';
                    } else {
                        tgtPartOfSpeech = secondTermGroup.querySelector('termNote[type="partOfSpeech"]')?.textContent || '';
                    }

                    const termGroupDefinitionElement = secondTermGroup.querySelector('descrip[type="definition"]');
                    const termGroupNotesElement = secondTermGroup.querySelector('termNote[type="comment"]');
                    const termGroupContextElement = secondTermGroup.querySelector('descrip[type="context"]');

                    if (termGroupDefinitionElement) {
                        entryDefinition = termGroupDefinitionElement.textContent || '';
                    } else if (termGroupContextElement) {
                        entryDefinition = termGroupContextElement.textContent || '';
                    }

                    if (termGroupNotesElement) {
                        entryNotes = termGroupNotesElement.textContent || '';
                    }
                }

                if (srcTerm || tgtTerm) {
                    newGlossary.push({
                        srcLang: srcLang, srcTerm: srcTerm, srcPartOfSpeech: srcPartOfSpeech,
                        tgtLang: tgtLang, tgtTerm: tgtTerm, tgtPartOfSpeech: tgtPartOfSpeech,
                        definition: entryDefinition, notes: entryNotes
                    });
                    langCounts[srcLang] = (langCounts[srcLang] || 0) + 1;
                    langCounts[tgtLang] = (langCounts[tgtLang] || 0) + 1;
                }
              }
            }

            const sortedLangs = Object.keys(langCounts).sort((a, b) => langCounts[b] - langCounts[a]);
            let detectedSrcLang, detectedTgtLang;

            if (sortedLangs.length >= 2) {
                detectedSrcLang = sortedLangs[0];
                detectedTgtLang = sortedLangs[1];
                newGlossary.forEach(entry => {
                    if (entry.srcLang !== detectedSrcLang && entry.tgtLang === detectedSrcLang) {
                        [entry.srcLang, entry.tgtLang] = [entry.tgtLang, entry.srcLang];
                        [entry.srcTerm, entry.tgtTerm] = [entry.tgtTerm, entry.srcTerm];
                        [entry.srcPartOfSpeech, entry.tgtPartOfSpeech] = [entry.tgtPartOfSpeech, entry.srcPartOfSpeech];
                    }
                });
            } else {
                const rootXmlLang = xmlDoc.documentElement.getAttribute("xml:lang");
                detectedSrcLang = rootXmlLang || 'en-US';
                detectedTgtLang = 'es-ES';
                if (newGlossary.length > 0) {
                     showMessageBox(translations[currentUILanguage]["No valid language pairs found in TBX. Defaulting to en-US/es-ES."]);
                }
            }

            saveState();
            glossary = newGlossary;
            glossarySourceLanguage = detectedSrcLang;
            glossaryTargetLanguage = detectedTgtLang;

            document.getElementById('configSrcLang').value = glossarySourceLanguage;
            document.getElementById('configTgtLang').value = glossaryTargetLanguage;
            document.getElementById('displaySrcLang').value = glossarySourceLanguage;
            document.getElementById('displayTgtLang').value = glossaryTargetLanguage;

            showSection('editorSection');
            renderGlossary();
            saveBackupToLocalStorage(); // <-- GUARDAR BACKUP
            console.log("TBX import completed successfully.");

          } catch (error) {
            console.error("Error during TBX file processing:", error);
            showMessageBox(translations[currentUILanguage]["Error loading TBX file. Please ensure it's a valid XML/TBX."] + " " + error.message);
          }
        };
        reader.readAsText(file);
    }

    /**
     * Lee y procesa el contenido de un archivo CSV.
     * @param {File} file - El archivo CSV a leer.
     */
    function readCSVFile(file) {
      const reader = new FileReader();
      reader.onload = () => {
        try {
          console.log("Cargando CSV...");
          parseCSV(reader.result);
        } catch (error) {
          console.error("Error durante el procesamiento del archivo CSV:", error);
          showMessageBox(error.message); // Mostrar el mensaje de error específico
        }
      };
      reader.readAsText(file, "UTF-8"); // Forzamos la lectura como UTF-8
    }

    /**
     * Parsea una sola línea de CSV, respetando las comillas dobles.
     * @param {string} row - La línea de texto CSV.
     * @param {string} delimiter - El delimitador (ej. ';').
     * @returns {string[]} Un array de los campos.
     */
    function parseCSVRow(row, delimiter) {
      const fields = [];
      let inQuote = false;
      let field = '';

      for (let i = 0; i < row.length; i++) {
        const char = row[i];
        
        if (char === '"') {
          if (inQuote && row[i+1] === '"') {
            // Es una comilla doble escapada ("")
            field += '"';
            i++; // Saltamos la siguiente comilla
          } else {
            // Es el inicio o fin de un campo entrecomillado
            inQuote = !inQuote;
          }
        } else if (char === delimiter && !inQuote) {
          // Fin de un campo
          fields.push(field);
          field = '';
        } else {
          // Carácter normal (incluyendo los que no son el delimitador)
          field += char;
        }
      }
      
      fields.push(field); // Añadimos el último campo
      
      // Limpiamos las comillas de encapsulamiento (ej. "hola" -> hola)
      // Solo si el campo empieza Y termina con comillas
      return fields.map(f => {
          if (f.startsWith('"') && f.endsWith('"')) {
              return f.substring(1, f.length - 1).replace(/""/g, '"');
          }
          return f;
      });
    }

    /**
     * Parsea el contenido de un string CSV y lo añade al glosario.
     * @param {string} textContent - El contenido completo del archivo CSV.
     */
    function parseCSV(textContent) {
      const newGlossary = [];
      // Dividimos en líneas, manejando \n y \r\n
      const lines = textContent.split(/\r?\n/);

      if (lines.length < 2 || !lines[0].trim()) {
        throw new Error(translations[currentUILanguage]['csv_empty_error']);
      }

      // Detectamos el delimitador (coma o punto y coma) por la cabecera
      const delimiter = lines[0].includes(';') ? ';' : ',';
      
      // 1. Extraer Cabeceras y Mapear
const headers = parseCSVRow(lines[0], delimiter); // ¡Usa tu propio parser!

      // Creamos un mapa de índices
      const map = {
        srcTerm: headers.indexOf("Source Term"),
        tgtTerm: headers.indexOf("Target Term"),
        definition: headers.indexOf("Definition"),
        notes: headers.indexOf("Notes"),
        partOfSpeech: headers.indexOf("Part of Speech")
      };

      // Verificación mínima: ¿encontramos los términos?
      if (map.srcTerm === -1 || map.tgtTerm === -1) {
          // Intentamos una segunda vez con los códigos de idioma (ej. "en-US")
          map.srcTerm = headers.indexOf(glossarySourceLanguage);
          map.tgtTerm = headers.indexOf(glossaryTargetLanguage);
          
          if (map.srcTerm === -1 || map.tgtTerm === -1) {
            let errorMsg = translations[currentUILanguage]['csv_header_error'];
            errorMsg = errorMsg.replace('{srcLang}', glossarySourceLanguage).replace('{tgtLang}', glossaryTargetLanguage);
            throw new Error(errorMsg);
          }
      }

      // 2. Procesar las filas
      for (let i = 1; i < lines.length; i++) {
        if (!lines[i].trim()) continue; // Ignorar líneas vacías

        const values = parseCSVRow(lines[i], delimiter);

        const srcTerm = values[map.srcTerm] || '';
        const tgtTerm = values[map.tgtTerm] || '';

        // Solo añadimos si tenemos los términos obligatorios
        if (srcTerm && tgtTerm) {
          newGlossary.push({
            srcLang: glossarySourceLanguage,
            srcTerm: srcTerm,
            tgtLang: glossaryTargetLanguage,
            tgtTerm: tgtTerm,
            definition: (map.definition > -1 ? values[map.definition] : '') || '',
            notes: (map.notes > -1 ? values[map.notes] : '') || '',
            srcPartOfSpeech: (map.partOfSpeech > -1 ? values[map.partOfSpeech] : '') || ''
          });
        }
      }

      // 3. Añadir al glosario
      if (newGlossary.length > 0) {
        saveState(); // Guardamos el estado actual antes de añadir los nuevos
        glossary = glossary.concat(newGlossary);
        renderGlossary();
        saveBackupToLocalStorage(); // <-- GUARDAR BACKUP
        let successMsg = translations[currentUILanguage]['csv_import_success'];
        showMessageBox(successMsg.replace('{count}', newGlossary.length));
      } else {
        showMessageBox(translations[currentUILanguage]['csv_import_no_terms']);
      }
    }

    // ===============================================
    // === LÓGICA DE DIÁLOGOS Y MENSAJES ===========
    // ===============================================

    /**
     * Displays a simple message box to the user.
     * @param {string} message - The message to display.
     */
    function showMessageBox(message) {
      const existingMessageBox = document.querySelector('.message-box');
      if (existingMessageBox) {
        existingMessageBox.remove();
      }

      const messageBox = document.createElement('div');
      messageBox.className = 'message-box';

      const titleEl = document.createElement('h3');
      titleEl.textContent = translations[currentUILanguage]['title']; 

      const messageText = document.createElement('p');
      messageText.textContent = message;
      messageText.style.marginBottom = '20px';

      const closeButton = document.createElement('button');
      closeButton.textContent = 'OK';
      closeButton.className = 'btn-primary';
      closeButton.onclick = () => document.body.removeChild(messageBox);

      messageBox.appendChild(titleEl);
      messageBox.appendChild(messageText);
      messageBox.appendChild(closeButton);
      document.body.appendChild(messageBox);
    }

    /**
     * Displays a confirmation dialog to the user.
     * @param {string} title - The title of the dialog.
     * @param {string} message - The message to display.
     * @param {function} onConfirm - Callback function to execute if confirmed.
     */
    function showConfirmationDialog(title, message, onConfirm) {
      const existingMessageBox = document.querySelector('.message-box');
      if (existingMessageBox) {
        existingMessageBox.remove();
      }

      const messageBox = document.createElement('div');
      messageBox.className = 'message-box';

      const titleEl = document.createElement('h3');
      titleEl.textContent = title;

      const messageText = document.createElement('p');
      messageText.textContent = message;

      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'dialog-buttons';

      const confirmButton = document.createElement('button');
      confirmButton.textContent = translations[currentUILanguage]['confirm_button'] || 'Confirm';
      confirmButton.className = 'btn-danger';
      confirmButton.onclick = () => {
        onConfirm();
        document.body.removeChild(messageBox);
      };

      const cancelButton = document.createElement('button');
      cancelButton.textContent = translations[currentUILanguage]['cancel_button'] || 'Cancel';
      cancelButton.className = 'btn-secondary';
      cancelButton.onclick = () => document.body.removeChild(messageBox);

      buttonContainer.appendChild(cancelButton);
      buttonContainer.appendChild(confirmButton);

      messageBox.appendChild(titleEl);
      messageBox.appendChild(messageText);
      messageBox.appendChild(buttonContainer);
      document.body.appendChild(messageBox);
    }

    /**
     * Displays an input dialog (LEGADO - AHORA USADO SOLO POR EXPORT)
     */
    function showInputDialog(title, message, placeholder, onConfirm) {
      const existingMessageBox = document.querySelector('.message-box');
      if (existingMessageBox) {
        existingMessageBox.remove();
      }

      const messageBox = document.createElement('div');
      messageBox.className = 'message-box';

      const titleEl = document.createElement('h3');
      titleEl.textContent = title;

      const input = document.createElement('input');
      input.type = 'text';
      input.placeholder = placeholder;
      input.style.width = '100%';
      input.style.padding = '10px';
      input.style.boxSizing = 'border-box';
      input.style.marginTop = '10px';
      input.style.borderRadius = '8px';
      input.style.border = '1px solid var(--input-border)';
      input.style.backgroundColor = 'var(--card-background)';
      input.style.color = 'var(--text-color)';

      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'dialog-buttons';

      const confirmButton = document.createElement('button');
      confirmButton.textContent = translations[currentUILanguage]['save_button'] || 'Save';
      confirmButton.className = 'btn-primary';
      confirmButton.onclick = () => {
        const filename = input.value.trim();
        if (filename) {
          onConfirm(filename);
          document.body.removeChild(messageBox);
        }
      };

      const cancelButton = document.createElement('button');
      cancelButton.textContent = translations[currentUILanguage]['cancel_button'] || 'Cancel';
      cancelButton.className = 'btn-secondary';
      cancelButton.onclick = () => document.body.removeChild(messageBox);

      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          confirmButton.click();
        }
      });

      buttonContainer.appendChild(cancelButton);
      buttonContainer.appendChild(confirmButton);

      messageBox.appendChild(titleEl);
      if (message) {
          const messageText = document.createElement('p');
          messageText.textContent = message;
          messageBox.appendChild(messageText);
      }
      messageBox.appendChild(input);
      messageBox.appendChild(buttonContainer);
      document.body.appendChild(messageBox);
      input.focus();
    }


    // ===============================================
    // === FUNCIONES DE BACKUP Y CARGA INICIAL =====
    // ===============================================

    /**
     * Muestra una notificación "toast" temporal.
     * @param {string} message - El mensaje a mostrar.
     */
    function showToast(message) {
      const toast = document.createElement('div');
      toast.className = 'toast-notification';
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.classList.add('show');
      }, 100); 

      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
          if (toast.parentNode === document.body) {
             document.body.removeChild(toast);
          }
        }, 500);
      }, 3000); 
    }


    /**
     * Guarda el estado actual del glosario en localStorage.
     */
    function saveBackupToLocalStorage() {
      try {
        const backupData = {
          glossary: glossary,
          sourceLang: glossarySourceLanguage,
          targetLang: glossaryTargetLanguage
        };
        localStorage.setItem('pandaTermBackup', JSON.stringify(backupData));
        console.log('Backup guardado en localStorage.');
      } catch (e) {
        console.error('Error al guardar el backup en localStorage:', e);
      }
    }

    /**
     * Carga el estado del glosario desde localStorage.
     * @returns {boolean} - Devuelve true si se cargó un backup, false en caso contrario.
     */
    function loadBackupFromLocalStorage() {
      try {
        const backupString = localStorage.getItem('pandaTermBackup');
        if (!backupString) {
          return false;
        }
        const backupData = JSON.parse(backupString);
        if (backupData && backupData.glossary && backupData.sourceLang && backupData.targetLang) {
          glossary = backupData.glossary;
          glossarySourceLanguage = backupData.sourceLang;
          glossaryTargetLanguage = backupData.targetLang;
          console.log('Backup restaurado desde localStorage.');
          return true;
        } else {
          console.warn('Backup en localStorage corrupto o incompleto.');
          return false;
        }
      } catch (e) {
        console.error('Error al cargar o parsear el backup de localStorage:', e);
        return false;
      }
    }

    // ===============================================
    // === INICIALIZACIÓN DE LA APLICACIÓN =========
    // ===============================================

    document.addEventListener('DOMContentLoaded', () => {
      // 1. Configurar idioma de la UI
      if (!localStorage.getItem('language')) {
        localStorage.setItem('language', 'en');
        currentUILanguage = 'en';
      }

      // 2. Intentar cargar backup
      const backupLoaded = loadBackupFromLocalStorage();
      let backupWasCorrupt = false;
      if (!backupLoaded && localStorage.getItem('pandaTermBackup') !== null) {
          backupWasCorrupt = true;
          localStorage.removeItem('pandaTermBackup');
          console.warn('Se eliminó un backup corrupto de localStorage.');
      }
      
      // 3. Aplicar tema e idioma (Actualiza las traducciones)
      applyTheme(currentTheme);
      setUILanguage(currentUILanguage); 
      
      // 4. Poblar datalist de idiomas
      populateIsoLanguagesDatalist();

      // 5. Decidir qué pantalla mostrar
      if (backupLoaded) {
        document.getElementById('configSrcLang').value = glossarySourceLanguage;
        document.getElementById('configTgtLang').value = glossaryTargetLanguage;
        document.getElementById('displaySrcLang').value = glossarySourceLanguage;
        document.getElementById('displayTgtLang').value = glossaryTargetLanguage;
        showSection('editorSection'); 
        renderGlossary();
        showToast(translations[currentUILanguage]['backup_restored']);
      } else {
        showSection('languageConfigSection');
        if (backupWasCorrupt) {
            showToast(translations[currentUILanguage]['backup_corrupt']);
        }
      }

      // 6. Configurar listeners
      updateUndoButtonState();

      // Listener para el input de archivo (centralizado)
      const fileInput = document.getElementById('fileInput');
      fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) {
          fileInput.value = ''; // Limpiar por si acaso
          return;
        }

        if (!glossarySourceLanguage || !glossaryTargetLanguage) {
            showMessageBox(translations[currentUILanguage]['lang_config_required']);
            showSection('languageConfigSection');
            fileInput.value = ''; // Limpiar input
            return;
        }

        const fileName = file.name.toLowerCase();
        if (fileName.endsWith('.tbx') || fileName.endsWith('.xml')) {
          console.log(`Importando TBX: ${file.name}`);
          readTBXFile(file);
        } else if (fileName.endsWith('.csv')) {
          console.log(`Importando CSV: ${file.name}`);
          readCSVFile(file);
        } else {
          console.warn(`Unsupported file type: ${fileName}`);
          showMessageBox(translations[currentUILanguage]['unsupported_file_error']);
        }
        
        fileInput.value = ''; // Limpiar siempre el input
      });

      // Listeners de teclado
      document.getElementById('srcTerm').addEventListener('keypress', (e) => { if (e.key === 'Enter') document.getElementById('tgtTerm').focus(); });
      document.getElementById('tgtTerm').addEventListener('keypress', (e) => { if (e.key === 'Enter') document.getElementById('definition').focus(); });
      document.getElementById('definition').addEventListener('keypress', (e) => { if (e.key === 'Enter') document.getElementById('notes').focus(); });
      document.getElementById('notes').addEventListener('keypress', (e) => { if (e.key === 'Enter') document.getElementById('partOfSpeech').focus(); });
      document.getElementById('partOfSpeech').addEventListener('keypress', (e) => { if (e.key === 'Enter') addTerm(); });

      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key.toLowerCase() === 'z') {
          e.preventDefault();
          undo();
        }
      });
      
      applyColumnVisibility();
    });
  </script>
</body>
</html>
