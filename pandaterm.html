<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title data-i18n="title">PandaTerm</title>
  <style>
    :root {
      /* Light mode colors (White/Light Grey) */
      --background-color: #fcfcfc; /* Almost white */
      --text-color: #333333; /* Dark grey for text */
      --card-background: #ffffff; /* Pure white for card backgrounds */
      --border-color: #e0e0e0; /* Light grey for borders */

      --btn-primary-bg: #007bff; /* Blue for primary actions */
      --btn-primary-hover-bg: #0056b3;
      --btn-primary-text-color: white;

      --btn-secondary-bg: #e0e0e0; /* Light grey for secondary actions */
      --btn-secondary-hover-bg: #d0d0d0;
      --btn-secondary-text-color: #333333;

      --btn-danger-bg: #f44336; /* Red for delete */
      --btn-danger-hover-bg: #da190b;

      --input-border: #cccccc; /* Medium grey for input borders */
      --header-bg: #f0f0f0; /* Very light grey for header */
      --header-text: #333333; /* Dark text on light header */
      --info-box-bg: #f0f8ff; /* Very light blue for info box */
      --info-box-border: #d0e8f8; /* Light blue border */
    }

    body.dark-mode {
      /* Dark mode colors (Black/Dark Grey) */
      --background-color: #121212; /* Very dark grey, almost black */
      --text-color: #e0e0e0; /* Light grey for text */
      --card-background: #1e1e1e; /* Dark grey for card backgrounds */
      --border-color: #3a3a3a; /* Darker grey for borders */

      --btn-primary-bg: #0056b3; /* Darker blue for primary actions */
      --btn-primary-hover-bg: #003d80;
      --btn-primary-text-color: white;

      --btn-secondary-bg: #4a4a4a; /* Medium dark grey for secondary actions */
      --btn-secondary-hover-bg: #606060;
      --btn-secondary-text-color: #ffffff;

      --btn-danger-bg: #e74c3c; /* Red for delete */
      --btn-danger-hover-bg: #c0392b;

      --input-border: #5a5a5a; /* Darker grey for input borders */
      --header-bg: #0a0a0a; /* Even darker, almost black for header */
      --header-text: #ffffff; /* White text on dark header */
      --info-box-bg: #2a2a2a; /* Matching card background for info box */
      --info-box-border: #5a5a5a; /* Darker grey border */
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background-color: var(--background-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    h1 {
      color: var(--header-text);
      margin-top: 0;
      padding: 20px;
      width: 100%;
      text-align: center;
      background-color: var(--header-bg);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .logo-container {
      width: 100%;
      text-align: center;
      margin-bottom: 10px; /* Reduced margin to bring description closer */
    }

    .logo {
      max-width: 200px; /* Adjust as needed */
      height: auto;
    }

    .description {
        text-align: center;
        margin-bottom: 20px;
        color: var(--text-color);
    }

    .container {
      width: 90%;
      max-width: 900px;
      padding: 20px;
      background-color: var(--card-background);
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }

    .controls, .add-term, .search-section, .lang-display {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
      /* align-items: center; Removed for flex-end alignment */
    }

    /* General styles for inputs, selects, and buttons */
    .controls button,
    .add-term button,
    .search-section input,
    .lang-display button, /* Specifically target button in lang-display */
    .add-term input,
    .lang-display input,
    select {
      padding: 10px 20px; /* Increased horizontal padding */
      border: 1px solid var(--input-border);
      border-radius: 5px;
      font-size: 1rem;
      color: var(--text-color);
      min-width: 150px; /* Increased min-width for better appearance */
      flex-grow: 1; /* Make them grow to fill space */
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
    }

    /* Buttons general styles - will be overridden by specific classes */
    button {
      cursor: pointer;
      transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
      border: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      background-color: transparent; /* Reset default background for buttons to be set by classes */
    }

    /* Input specific background */
    .add-term input,
    .search-section input,
    .lang-display input,
    select {
        background-color: var(--card-background);
    }

    /* Primary button styles */
    .btn-primary {
      background-color: var(--btn-primary-bg);
      color: var(--btn-primary-text-color);
    }
    .btn-primary:hover {
      background-color: var(--btn-primary-hover-bg);
    }

    /* Secondary button styles */
    .btn-secondary {
      background-color: var(--btn-secondary-bg);
      color: var(--btn-secondary-text-color);
    }
    .btn-secondary:hover {
      background-color: var(--btn-secondary-hover-bg);
    }

    /* Danger button styles (for delete) */
    .delete-btn {
      background-color: var(--btn-danger-bg);
      color: white; /* Always white text on danger buttons */
    }
    .delete-btn:hover {
      background-color: var(--btn-danger-hover-bg);
    }

    button:disabled {
      background-color: #cccccc !important; /* Override with !important to ensure disabled state */
      cursor: not-allowed;
      color: #6c757d !important;
    }

    input[type="file"] {
      display: none;
    }

    label {
      font-weight: bold;
      margin-right: 5px;
      white-space: nowrap;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      min-width: 150px;
    }

    /* Align items to the bottom within lang-display */
    .lang-display {
        align-items: flex-end;
    }
    /* Align items to the bottom within add-term, for consistency with lang-display */
    .add-term {
        align-items: flex-end;
    }

    input:disabled {
      background-color: #e9ecef;
      color: #6c757d;
      cursor: not-allowed;
    }

    body.dark-mode input:disabled {
      background-color: #4a4a4a; /* Darker disabled input in dark mode */
      color: #bbcfdc;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      background-color: var(--card-background);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    th, td {
      border: 1px solid var(--border-color);
      padding: 12px 15px;
      text-align: left;
    }

    th {
      background-color: var(--header-bg);
      color: var(--header-text);
      font-weight: normal;
    }

    tr:nth-child(even) {
      background-color: rgba(0,0,0,0.02);
    }

    tr:hover {
      background-color: rgba(0,0,0,0.05);
    }

    .message-box {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: var(--card-background);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      z-index: 1000;
      text-align: center;
      max-width: 300px;
      color: var(--text-color);
    }

    .info-box {
      background-color: var(--info-box-bg);
      border: 1px solid var(--info-box-border);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      color: var(--text-color);
    }
  </style>
</head>
<body>
  <h1 data-i18n="main_title">PandaTerm</h1>
  <div class="logo-container">
    <img src="https://raw.githubusercontent.com/rlstradu/httrans/refs/heads/main/pandaterm-logo.png" alt="PandaTerm Logo" class="logo" />
  </div>
  <p class="description" data-i18n="app_description"></p>


  <div class="container">
    <div class="controls">
      <button onclick="loadTBX()" data-i18n="import_tbx" class="btn-secondary">Importar TBX</button>
      <input type="file" id="tbxFileInput" accept=".xml,.tbx" />
      <button onclick="downloadTBX()" data-i18n="download_tbx" class="btn-secondary">Descargar TBX</button>
      <button onclick="resetGlossary()" data-i18n="new_glossary" class="btn-secondary">Nuevo glosario</button>
      <button onclick="toggleTheme()" id="themeToggleButton" data-i18n="toggle_theme" class="btn-secondary">Cambiar tema</button>
      <select id="languageSelector" onchange="setUILanguage(this.value)">
        <option value="en">English</option>
        <option value="es">Español</option>
      </select>
    </div>

    <div id="languageConfigSection">
      <h2 data-i18n="config_lang_title">Configurar idiomas del glosario</h2>
      <div class="info-box">
        <p data-i18n="config_lang_info">
          Define los idiomas de origen y destino de tu glosario. Puedes introducir el código ISO directamente o seleccionarlo de las sugerencias. Es fundamental que el código ISO sea correcto para que funcione correctamente con tu herramienta TAO.
        </p>
      </div>
      <div class="lang-display">
        <div class="input-group">
          <label for="configSrcLang" data-i18n="source_language">Idioma de origen:</label>
          <input id="configSrcLang" list="isoLanguages" value="en-US" />
        </div>
        <div class="input-group">
          <label for="configTgtLang" data-i18n="target_language">Idioma de destino:</label>
          <input id="configTgtLang" list="isoLanguages" value="es-ES" />
        </div>
        <button onclick="confirmGlossaryLanguages()" data-i18n="confirm_languages" class="btn-secondary">Confirmar idiomas</button>
      </div>
    </div>

    <div id="editorSection" style="display:none;"> <!-- Initially hidden -->
        <h2 data-i18n="current_lang_title">Idiomas actuales del glosario</h2>
        <div class="lang-display">
            <div class="input-group">
                <label data-i18n="source_language">Idioma de origen:</label>
                <input id="displaySrcLang" disabled />
            </div>
            <div class="input-group">
                <label data-i18n="target_language">Idioma de destino:</label>
                <input id="displayTgtLang" disabled />
            </div>
        </div>

        <h2 data-i18n="add_term_title">Añadir término</h2>
        <div class="add-term">
            <div class="input-group">
                <label for="srcTerm" data-i18n="term">Término:</label>
                <input id="srcTerm" />
            </div>
            <div class="input-group">
                <label for="tgtTerm" data-i18n="translation">Traducción:</label>
                <input id="tgtTerm" />
            </div>
            <button onclick="addTerm()" data-i18n="add_button" class="btn-secondary">Añadir</button>
        </div>

        <h2 data-i18n="search_title">Buscar</h2>
        <div class="search-section">
            <input id="searchTerm" placeholder="Buscar término..." oninput="renderGlossary()" data-i18n-placeholder="search_placeholder" />
        </div>

        <table>
            <thead>
                <tr>
                    <th data-i18n="source_term_col">Término de origen</th>
                    <th data-i18n="target_term_col">Término de destino</th>
                    <th data-i18n="actions_col">Acciones</th>
                </tr>
            </thead>
            <tbody id="glossaryTable"></tbody>
        </table>
    </div>

    <datalist id="isoLanguages">
      <!-- Options will be dynamically populated by JavaScript -->
    </datalist>
  </div>

  <script>
    // Global array to store glossary terms
    let glossary = [];
    // Get current UI language from local storage, default to English
    let currentUILanguage = localStorage.getItem('language') || 'en'; // Default to English
    // Get current theme from local storage, default to light
    let currentTheme = localStorage.getItem('theme') || 'light';

    // Global variables to store the glossary's defined source and target languages
    let glossarySourceLanguage = '';
    let glossaryTargetLanguage = '';

    // Object containing all UI translations for English and Spanish
    const translations = {
      en: {
        title: "PandaTerm", // Updated title
        main_title: "PandaTerm", // Updated main title
        app_description: "A simple TBX glossary editor", // New description
        import_tbx: "Import TBX",
        download_tbx: "Download TBX",
        new_glossary: "New glossary",
        toggle_theme: "Toggle theme",
        config_lang_title: "Configure glossary languages",
        config_lang_info: "Define the source and target languages for your glossary. You can type directly the ISO code or select from the suggestions. It is important that the ISO code is correct for it to work well in your CAT tool.",
        confirm_languages: "Confirm languages",
        current_lang_title: "Current glossary languages",
        add_term_title: "Add term",
        source_language: "Source language:",
        term: "Term:",
        target_language: "Target language:",
        translation: "Translation:",
        add_button: "Add",
        search_title: "Search",
        search_placeholder: "Search term...",
        source_term_col: "Source term",
        target_term_col: "Target term",
        actions_col: "Actions",
        delete_button: "Delete",
        both_terms_required: "Both terms are required.",
        lang_config_required: "Please configure source and target languages for the glossary.",
        "Cannot download empty or unconfigured glossary.": "Cannot download empty or unconfigured glossary.",
        "No valid language pairs found in TBX. Defaulting to en-US/es-ES.": "No valid language pairs found in TBX. Defaulting to en-US/es-ES.",
        "Error loading TBX file. Please ensure it's a valid XML/TBX.": "Error loading TBX file. Please ensure it's a valid XML/TBX."
      },
      es: {
        title: "PandaTerm", // Updated title
        main_title: "PandaTerm", // Updated main title
        app_description: "Un sencillo editor de glosarios TBX", // New description
        import_tbx: "Importar TBX",
        download_tbx: "Descargar TBX",
        new_glossary: "Nuevo glosario",
        toggle_theme: "Cambiar tema",
        config_lang_title: "Configurar idiomas del glosario",
        config_lang_info: "Define los idiomas de origen y destino de tu glosario. Puedes introducir el código ISO directamente o seleccionarlo de las sugerencias. Es fundamental que el código ISO sea correcto para que funcione correctamente con tu herramienta TAO.",
        confirm_languages: "Confirmar idiomas",
        current_lang_title: "Idiomas actuales del glosario",
        add_term_title: "Añadir término",
        source_language: "Idioma de origen:",
        term: "Término:",
        target_language: "Idioma de destino:",
        translation: "Traducción:",
        add_button: "Añadir",
        search_title: "Buscar",
        search_placeholder: "Buscar término...",
        source_term_col: "Término de origen",
        target_term_col: "Término de destino",
        actions_col: "Acciones",
        delete_button: "Eliminar",
        both_terms_required: "Ambos términos son requeridos.",
        lang_config_required: "Por favor, configura los idiomas de origen y destino para el glosario.",
        "Cannot download empty or unconfigured glossary.": "No se puede descargar un glosario vacío o sin configurar.",
        "No valid language pairs found in TBX. Defaulting to en-US/es-ES.": "No se encontraron pares de idioma válidos en TBX. Se utiliza en-US/es-ES por defecto.",
        "Error loading TBX file. Please ensure it's a valid XML/TBX.": "Error al cargar el archivo TBX. Asegúrate de que sea un XML/TBX válido."
      }
    };

    // List of common ISO 639-1 language codes for the datalist
    const isoLanguagesData = [
      { code: "en", name: "English" },
      { code: "en-US", name: "English (United States)" },
      { code: "en-GB", name: "English (United Kingdom)" },
      { code: "es", name: "Español" },
      { code: "es-ES", name: "Español (España)" },
      { code: "es-MX", name: "Español (México)" },
      { code: "fr", name: "Français" },
      { code: "de", name: "Deutsch" },
      { code: "it", name: "Italiano" },
      { code: "pt", name: "Português" },
      { code: "ja", name: "日本語 (Japanese)" },
      { code: "zh", name: "中文 (Chinese)" },
      { code: "ar", name: "العربية (Arabic)" },
      { code: "ru", name: "Русский (Russian)" },
      { code: "ko", name: "한국어 (Korean)" },
      { code: "nl", name: "Nederlands" },
      { code: "sv", name: "Svenska" },
      { code: "da", name: "Dansk" },
      { code: "no", name: "Norsk" },
      { code: "fi", name: "Suomi" },
      { code: "tr", name: "Türkçe" },
      { code: "pl", name: "Polski" },
      { code: "cs", name: "Čeština" },
      { code: "hu", name: "Magyar" },
      { code: "el", name: "Ελληνικά (Greek)" },
      { code: "he", name: "עברית (Hebrew)" },
      { code: "th", name: "ไทย (Thai)" },
      { code: "vi", name: "Tiếng Việt (Vietnamese)" },
      { code: "id", name: "Bahasa Indonesia" },
      { code: "ms", name: "Bahasa Melayu" },
      { code: "ca", name: "Català" },
      { code: "eu", name: "Euskara" },
      { code: "gl", name: "Galego" },
      { code: "ro", name: "Română" },
      { code: "uk", name: "Українська (Ukrainian)" },
      { code: "bg", name: "Български (Bulgarian)" },
      { code: "hr", name: "Hrvatski" },
      { code: "sr", name: "Srpski" },
      { code: "sk", name: "Slovenčina" },
      { code: "sl", name: "Slovenščina" },
      { code: "lt", name: "Lietuvių" },
      { code: "lv", name: "Latviešu" },
      { code: "et", name: "Eesti" },
      { code: "is", name: "Íslenska" },
      { code: "ga", name: "Gaeilge" },
      { code: "mt", name: "Malti" },
      // Add more as needed
    ];

    /**
     * Populates the datalist with ISO language codes.
     */
    function populateIsoLanguagesDatalist() {
      const datalist = document.getElementById('isoLanguages');
      datalist.innerHTML = ''; // Clear existing options
      isoLanguagesData.forEach(lang => {
        const option = document.createElement('option');
        option.value = lang.code;
        option.textContent = lang.name; // Display full name
        datalist.appendChild(option);
      });
    }

    /**
     * Applies the selected theme (light or dark) to the body element
     * and saves the preference to local storage.
     * @param {string} theme - The theme to apply ('light' or 'dark').
     */
    function applyTheme(theme) {
      document.body.className = theme === 'dark' ? 'dark-mode' : '';
      currentTheme = theme;
      localStorage.setItem('theme', theme);
    }

    /**
     * Toggles the current theme between light and dark.
     */
    function toggleTheme() {
      applyTheme(currentTheme === 'light' ? 'dark' : 'light');
    }

    /**
     * Sets the UI language and updates all text content.
     * @param {string} lang - The language code ('en' or 'es').
     */
    function setUILanguage(lang) {
      currentUILanguage = lang;
      localStorage.setItem('language', lang);
      updateTextContent();
    }

    /**
     * Updates the text content of all elements with data-i18n attributes
     * based on the current UI language.
     */
    function updateTextContent() {
      const elements = document.querySelectorAll('[data-i18n]');
      elements.forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (translations[currentUILanguage][key]) {
          el.textContent = translations[currentUILanguage][key];
        }
      });

      const placeholders = document.querySelectorAll('[data-i18n-placeholder]');
      placeholders.forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if (translations[currentUILanguage][key]) {
          el.placeholder = translations[currentUILanguage][key];
        }
      });

      // Update the language selector to reflect the current language
      document.getElementById('languageSelector').value = currentUILanguage;
      // Re-render glossary to update delete button text
      renderGlossary();
    }

    /**
     * Resets the glossary and UI to the initial "New Glossary" state.
     */
    function resetGlossary() {
      glossary = [];
      glossarySourceLanguage = '';
      glossaryTargetLanguage = '';
      document.getElementById('configSrcLang').value = 'en-US';
      document.getElementById('configTgtLang').value = 'es-ES';

      document.getElementById('languageConfigSection').style.display = 'block';
      document.getElementById('editorSection').style.display = 'none';

      renderGlossary(); // Clear table
    }

    /**
     * Confirms the glossary's source and target languages from user input.
     * Enables the main editor section if languages are valid.
     */
    function confirmGlossaryLanguages() {
      const srcLang = document.getElementById('configSrcLang').value.trim();
      const tgtLang = document.getElementById('configTgtLang').value.trim();

      if (!srcLang || !tgtLang) {
        showMessageBox(translations[currentUILanguage]['lang_config_required']);
        return;
      }

      glossarySourceLanguage = srcLang;
      glossaryTargetLanguage = tgtLang;

      // Update display inputs
      document.getElementById('displaySrcLang').value = glossarySourceLanguage;
      document.getElementById('displayTgtLang').value = glossaryTargetLanguage;

      document.getElementById('languageConfigSection').style.display = 'none';
      document.getElementById('editorSection').style.display = 'block';
      renderGlossary();
    }

    /**
     * Adds a new term to the glossary. Uses the globally configured languages.
     */
    function addTerm() {
      const srcTerm = document.getElementById("srcTerm").value.trim();
      const tgtTerm = document.getElementById("tgtTerm").value.trim();

      if (!srcTerm || !tgtTerm) {
        showMessageBox(translations[currentUILanguage]['both_terms_required']);
        return;
      }

      glossary.push({
        srcLang: glossarySourceLanguage,
        srcTerm: srcTerm,
        tgtLang: glossaryTargetLanguage,
        tgtTerm: tgtTerm
      });
      document.getElementById("srcTerm").value = "";
      document.getElementById("tgtTerm").value = "";
      renderGlossary();
    }

    /**
     * Deletes a term from the glossary at the specified index.
     * @param {number} index - The index of the term to delete.
     */
    function deleteTerm(index) {
      glossary.splice(index, 1);
      renderGlossary();
    }

    /**
     * Renders the glossary table, filtering terms based on the search input.
     */
    function renderGlossary() {
      const tbody = document.getElementById("glossaryTable");
      const search = document.getElementById("searchTerm").value.toLowerCase();
      tbody.innerHTML = ""; // Clear existing rows

      glossary.forEach((entry, i) => {
        // Filter based on search term in source or target term
        if (
          entry.srcTerm.toLowerCase().includes(search) ||
          entry.tgtTerm.toLowerCase().includes(search)
        ) {
          const row = document.createElement("tr");
          row.innerHTML = `
            <td>${entry.srcTerm}</td>
            <td>${entry.tgtTerm}</td>
            <td><button class="delete-btn" onclick="deleteTerm(${i})">${translations[currentUILanguage]['delete_button']}</button></td>
          `;
          tbody.appendChild(row);
        }
      });
    }

    /**
     * Generates a TBX XML string from the current glossary data.
     * @returns {string} The TBX XML content.
     */
    function generateTBX() {
      const xml = [`<?xml version="1.0" encoding="UTF-8"?>`,
        `<martif type="TBX" xml:lang="${glossarySourceLanguage}">`, // Use main glossary source language for martif
        `  <text>`,
        `    <body>`];

      glossary.forEach(entry => {
        xml.push(`      <termEntry>`);
        xml.push(`        <LangSet xml:lang="${entry.srcLang}">`);
        xml.push(`          <tig><term>${entry.srcTerm}</term></tig>`);
        xml.push(`        </LangSet>`);
        xml.push(`        <LangSet xml:lang="${entry.tgtLang}">`);
        xml.push(`          <tig><term>${entry.tgtTerm}</term></tig>`);
        xml.push(`        </LangSet>`);
        xml.push(`      </termEntry>`);
      });

      xml.push(`    </body>`, `  </text>`, `</martif>`);
      return xml.join("\n");
    }

    /**
     * Triggers a download of the generated TBX XML file.
     */
    function downloadTBX() {
      if (glossary.length === 0 && (!glossarySourceLanguage || !glossaryTargetLanguage)) {
        showMessageBox(translations[currentUILanguage]["Cannot download empty or unconfigured glossary."]);
        return;
      }
      const blob = new Blob([generateTBX()], { type: "application/xml" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "glossary.tbx";
      a.click();
      URL.revokeObjectURL(url); // Clean up the URL object
    }

    /**
     * Loads TBX data from a user-selected XML/TBX file.
     * Parses the XML and updates the glossary array and sets glossary languages.
     */
    function loadTBX() {
      document.getElementById("tbxFileInput").click(); // Trigger file input click
      document.getElementById("tbxFileInput").onchange = (event) => {
        const file = event.target.files[0];
        if (!file) return; // No file selected

        const reader = new FileReader();
        reader.onload = () => {
          try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(reader.result, "application/xml");
            const entries = xmlDoc.getElementsByTagName("termEntry");

            glossary = []; // Clear current glossary
            let firstEntryLangs = { src: '', tgt: '' };

            if (entries.length > 0) {
              const firstSets = entries[0].getElementsByTagName("LangSet");
              if (firstSets.length >= 2) {
                firstEntryLangs.src = firstSets[0].getAttribute("xml:lang");
                firstEntryLangs.tgt = firstSets[1].getAttribute("xml:lang");
              }
            }

            for (let entry of entries) {
              const sets = entry.getElementsByTagName("LangSet");
              if (sets.length === 2) { // Expecting two language sets for source and target
                const lang1 = sets[0].getAttribute("xml:lang");
                const term1 = sets[0].getElementsByTagName("term")[0].textContent;
                const lang2 = sets[1].getAttribute("xml:lang");
                const term2 = sets[1].getElementsByTagName("term")[0].textContent;
                glossary.push({ srcLang: lang1, srcTerm: term1, tgtLang: lang2, tgtTerm: term2 });
              }
            }

            if (glossary.length > 0 && firstEntryLangs.src && firstEntryLangs.tgt) {
                glossarySourceLanguage = firstEntryLangs.src;
                glossaryTargetLanguage = firstEntryLangs.tgt;
            } else {
                // Fallback if no valid entries to extract languages from
                glossarySourceLanguage = 'en-US';
                glossaryTargetLanguage = 'es-ES';
                showMessageBox(translations[currentUILanguage]["No valid language pairs found in TBX. Defaulting to en-US/es-ES."]);
            }


            // Update display inputs
            document.getElementById('displaySrcLang').value = glossarySourceLanguage;
            document.getElementById('displayTgtLang').value = glossaryTargetLanguage;

            // Hide config section, show editor section
            document.getElementById('languageConfigSection').style.display = 'none';
            document.getElementById('editorSection').style.display = 'block';

            renderGlossary(); // Re-render the glossary with loaded data
          } catch (error) {
            console.error("Error loading TBX file:", error);
            showMessageBox(translations[currentUILanguage]["Error loading TBX file. Please ensure it's a valid XML/TBX."]);
            resetGlossary(); // Reset to configuration state on error
          }
        };
        reader.readAsText(file); // Read file content as text
      };
    }

    /**
     * Displays a custom message box instead of native alert().
     * @param {string} message - The message to display.
     */
    function showMessageBox(message) {
      // Remove any existing message box to prevent duplicates
      const existingMessageBox = document.querySelector('.message-box');
      if (existingMessageBox) {
        existingMessageBox.remove();
      }

      // Create message box elements
      const messageBox = document.createElement('div');
      messageBox.className = 'message-box'; // Apply CSS class

      const messageText = document.createElement('p');
      messageText.textContent = message;
      messageText.style.marginBottom = '20px';

      const closeButton = document.createElement('button');
      closeButton.textContent = 'OK';
      closeButton.style.cssText = `
        padding: 8px 15px;
        background-color: var(--btn-primary-bg);
        color: var(--btn-primary-text-color);
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1rem;
      `;
      closeButton.onclick = () => document.body.removeChild(messageBox);

      messageBox.appendChild(messageText);
      messageBox.appendChild(closeButton);
      document.body.appendChild(messageBox);
    }

    // Initialize theme, UI language, populate datalist, and set initial UI state on load
    document.addEventListener('DOMContentLoaded', () => {
      // Set currentUILanguage to 'en' by default if not already set in local storage
      if (!localStorage.getItem('language')) {
        currentUILanguage = 'en';
        localStorage.setItem('language', 'en');
      }
      applyTheme(currentTheme); // Apply theme from local storage
      setUILanguage(currentUILanguage); // Apply UI language from local storage
      populateIsoLanguagesDatalist(); // Populate the datalist
      resetGlossary(); // Start in the new glossary configuration mode
    });
  </script>
</body>
</html>
